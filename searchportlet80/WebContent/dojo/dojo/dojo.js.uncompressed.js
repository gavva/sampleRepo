/*
	Copyright (c) 2004-2009, The Dojo Foundation All Rights Reserved.
	Available via Academic Free License >= 2.1 OR the modified BSD license.
	see: http://dojotoolkit.org/license for details
*/

/*
	This is a compiled version of Dojo, built for deployment and not for
	development. To get an editable version, please visit:

		http://dojotoolkit.org

	for documentation and information on getting the source.
*/

;(function(){

	/*
	dojo, dijit, and dojox must always be the first three, and in that order.
	djConfig.scopeMap = [
		["dojo", "fojo"],
		["dijit", "fijit"],
		["dojox", "fojox"]
	
	]
	*/

	/**Build will replace this comment with a scoped djConfig **/

	//The null below can be relaced by a build-time value used instead of djConfig.scopeMap.
	var sMap = [['dojo','dojo13'],['dijit','dijit13'],['dojox','dojox13']];

	//See if new scopes need to be defined.
	if((sMap || (typeof djConfig != "undefined" && djConfig.scopeMap)) && (typeof window != "undefined")){
		var scopeDef = "", scopePrefix = "", scopeSuffix = "", scopeMap = {}, scopeMapRev = {};
		sMap = sMap || djConfig.scopeMap;
		for(var i = 0; i < sMap.length; i++){
			//Make local variables, then global variables that use the locals.
			var newScope = sMap[i];
			scopeDef += "var " + newScope[0] + " = {}; " + newScope[1] + " = " + newScope[0] + ";" + newScope[1] + "._scopeName = '" + newScope[1] + "';";
			scopePrefix += (i == 0 ? "" : ",") + newScope[0];
			scopeSuffix += (i == 0 ? "" : ",") + newScope[1];
			scopeMap[newScope[0]] = newScope[1];
			scopeMapRev[newScope[1]] = newScope[0];
		}

		eval(scopeDef + "dojo._scopeArgs = [" + scopeSuffix + "];");

		dojo._scopePrefixArgs = scopePrefix;
		dojo._scopePrefix = "(function(" + scopePrefix + "){";
		dojo._scopeSuffix = "})(" + scopeSuffix + ")";
		dojo._scopeMap = scopeMap;
		dojo._scopeMapRev = scopeMapRev;
	}

/*=====
// note:
//		'djConfig' does not exist under 'dojo.*' so that it can be set before the
//		'dojo' variable exists.
// note:
//		Setting any of these variables *after* the library has loaded does
//		nothing at all.

djConfig = {
	// summary:
	//		Application code can set the global 'djConfig' prior to loading
	//		the library to override certain global settings for how dojo works.
	//
	// isDebug: Boolean
	//		Defaults to `false`. If set to `true`, ensures that Dojo provides
	//		extended debugging feedback via Firebug. If Firebug is not available
	//		on your platform, setting `isDebug` to `true` will force Dojo to
	//		pull in (and display) the version of Firebug Lite which is
	//		integrated into the Dojo distribution, thereby always providing a
	//		debugging/logging console when `isDebug` is enabled. Note that
	//		Firebug's `console.*` methods are ALWAYS defined by Dojo. If
	//		`isDebug` is false and you are on a platform without Firebug, these
	//		methods will be defined as no-ops.
	isDebug: false,
	// debugAtAllCosts: Boolean
	//		Defaults to `false`. If set to `true`, this triggers an alternate
	//		mode of the package system in which dependencies are detected and
	//		only then are resources evaluated in dependency order via
	//		`<script>` tag inclusion. This may double-request resources and
	//		cause problems with scripts which expect `dojo.require()` to
	//		preform synchronously. `debugAtAllCosts` can be an invaluable
	//		debugging aid, but when using it, ensure that all code which
	//		depends on Dojo modules is wrapped in `dojo.addOnLoad()` handlers.
	//		Due to the somewhat unpredictable side-effects of using
	//		`debugAtAllCosts`, it is strongly recommended that you enable this
	//		flag as a last resort. `debugAtAllCosts` has no effect when loading
	//		resources across domains. For usage information, see the
	//		[Dojo Book](http://dojotoolkit.org/book/book-dojo/part-4-meta-dojo-making-your-dojo-code-run-faster-and-better/debugging-facilities/deb)
	debugAtAllCosts: false,
	// locale: String
	//		The locale to assume for loading localized resources in this page,
	//		specified according to [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt).
	//		Must be specified entirely in lowercase, e.g. `en-us` and `zh-cn`.
	//		See the documentation for `dojo.i18n` and `dojo.requireLocalization`
	//		for details on loading localized resources. If no locale is specified,
	//		Dojo assumes the locale of the user agent, according to `navigator.userLanguage`
	//		or `navigator.language` properties.
	locale: undefined,
	// extraLocale: Array
	//		No default value. Specifies additional locales whose
	//		resources should also be loaded alongside the default locale when
	//		calls to `dojo.requireLocalization()` are processed.
	extraLocale: undefined,
	// baseUrl: String
	//		The directory in which `dojo.js` is located. Under normal
	//		conditions, Dojo auto-detects the correct location from which it
	//		was loaded. You may need to manually configure `baseUrl` in cases
	//		where you have renamed `dojo.js` or in which `<base>` tags confuse
	//		some browsers (e.g. IE 6). The variable `dojo.baseUrl` is assigned
	//		either the value of `djConfig.baseUrl` if one is provided or the
	//		auto-detected root if not. Other modules are located relative to
	//		this path. The path should end in a slash.
	baseUrl: undefined,
	// modulePaths: Object
	//		A map of module names to paths relative to `dojo.baseUrl`. The
	//		key/value pairs correspond directly to the arguments which
	//		`dojo.registerModulePath` accepts. Specifiying
	//		`djConfig.modulePaths = { "foo": "../../bar" }` is the equivalent
	//		of calling `dojo.registerModulePath("foo", "../../bar");`. Multiple
	//		modules may be configured via `djConfig.modulePaths`.
	modulePaths: {},
	// afterOnLoad: Boolean 
	//		Indicates Dojo was added to the page after the page load. In this case
	//		Dojo will not wait for the page DOMContentLoad/load events and fire
	//		its dojo.addOnLoad callbacks after making sure all outstanding
	//		dojo.required modules have loaded.
	afterOnLoad: false,
	// addOnLoad: Function or Array
	//		Adds a callback via dojo.addOnLoad. Useful when Dojo is added after
	//		the page loads and djConfig.afterOnLoad is true. Supports the same
	//		arguments as dojo.addOnLoad. When using a function reference, use
	//		`djConfig.addOnLoad = function(){};`. For object with function name use
	//		`djConfig.addOnLoad = [myObject, "functionName"];` and for object with
	//		function reference use
	//		`djConfig.addOnLoad = [myObject, function(){}];`
	addOnLoad: null,
	// require: Array
	//		An array of module names to be loaded immediately after dojo.js has been included
	//		in a page. 
	require: [],
	// defaultDuration: Array
	//		Default duration, in milliseconds, for wipe and fade animations within dijits.
	//		Assigned to dijit.defaultDuration.
	defaultDuration: 200,
	// dojoBlankHtmlUrl: String
	//		Used by some modules to configure an empty iframe. Used by dojo.io.iframe and
	//		dojo.back, and dijit popup support in IE where an iframe is needed to make sure native
	//		controls do not bleed through the popups. Normally this configuration variable 
	//		does not need to be set, except when using cross-domain/CDN Dojo builds.
	//		Save dojo/resources/blank.html to your domain and set `djConfig.dojoBlankHtmlUrl` 
	//		to the path on your domain your copy of blank.html.
	dojoBlankHtmlUrl: undefined
}
=====*/

(function(){
	// firebug stubs

	if(typeof this["loadFirebugConsole"] == "function"){
		// for Firebug 1.2
		this["loadFirebugConsole"]();
	}else{
		//Work-around for Safari console problem.
		if(this["navigator"]){
			if(/3[\.0-9]+.*Safari/i.test(navigator.appVersion) && this["console"]){
				this.console = {
					_c: this.console,
					log: function(s){this._c.log(s);},
					info: function(s){this._c.info(s);},
					error: function(s){this._c.error(s);},
					warn: function(s){this._c.warn(s);}
				};
			}
		}
		this.console = this.console || {};

		//	Be careful to leave 'log' always at the end
		var cn = [
			"assert", "count", "debug", "dir", "dirxml", "error", "group",
			"groupEnd", "info", "profile", "profileEnd", "time", "timeEnd",
			"trace", "warn", "log" 
		];
		var i=0, tn;
		while((tn=cn[i++])){
			if(!console[tn]){
				(function(){
					var tcn = tn+"";
					console[tcn] = ('log' in console) ? function(){ 
						var a = Array.apply({}, arguments);
						a.unshift(tcn+":");
						console["log"](a.join(" "));
					} : function(){}
				})();
			}
		}
	}

	//TODOC:  HOW TO DOC THIS?
	// dojo is the root variable of (almost all) our public symbols -- make sure it is defined.
	if(typeof dojo == "undefined"){
		this.dojo = {
			_scopeName: "dojo",
			_scopePrefix: "",
			_scopePrefixArgs: "",
			_scopeSuffix: "",
			_scopeMap: {},
			_scopeMapRev: {}
		};
	}

	var d = dojo;

	//Need placeholders for dijit and dojox for scoping code.
	if(typeof dijit == "undefined"){
		this.dijit = {_scopeName: "dijit"};
	}
	if(typeof dojox == "undefined"){
		this.dojox = {_scopeName: "dojox"};
	}
	
	if(!d._scopeArgs){
		d._scopeArgs = [dojo, dijit, dojox];
	}

/*=====
dojo.global = {
	//	summary:
	//		Alias for the global scope
	//		(e.g. the window object in a browser).
	//	description:
	//		Refer to 'dojo.global' rather than referring to window to ensure your
	//		code runs correctly in contexts other than web browsers (e.g. Rhino on a server).
}
=====*/
	d.global = this;

	d.config =/*===== djConfig = =====*/{
		isDebug: false,
		debugAtAllCosts: false
	};

	if(typeof djConfig != "undefined"){
		for(var opt in djConfig){
			d.config[opt] = djConfig[opt];
		}
	}

/*=====
	// Override locale setting, if specified
	dojo.locale = {
		// summary: the locale as defined by Dojo (read-only)
	};
=====*/
	dojo.locale = d.config.locale;

	var rev = "$Rev: 18832 $".match(/\d+/); 

	dojo.version = {
		// summary: 
		//		version number of dojo
		//	major: Integer
		//		Major version. If total version is "1.2.0beta1", will be 1
		//	minor: Integer
		//		Minor version. If total version is "1.2.0beta1", will be 2
		//	patch: Integer
		//		Patch version. If total version is "1.2.0beta1", will be 0
		//	flag: String
		//		Descriptor flag. If total version is "1.2.0beta1", will be "beta1"
		//	revision: Number
		//		The SVN rev from which dojo was pulled
		major: 0, minor: 0, patch: 0, flag: "dev",
		revision: rev ? +rev[0] : NaN,
		toString: function(){
			with(d.version){
				return major + "." + minor + "." + patch + flag + " (" + revision + ")";	// String
			}
		}
	}

		// Register with the OpenAjax hub
	if(typeof OpenAjax != "undefined"){
		OpenAjax.hub.registerLibrary(dojo._scopeName, "http://dojotoolkit.org", d.version.toString());
	}
	
	var tobj = {};
	dojo._mixin = function(/*Object*/ obj, /*Object*/ props){
		// summary:
		//		Adds all properties and methods of props to obj. This addition
		//		is "prototype extension safe", so that instances of objects
		//		will not pass along prototype defaults.
		for(var x in props){
			// the "tobj" condition avoid copying properties in "props"
			// inherited from Object.prototype.  For example, if obj has a custom
			// toString() method, don't overwrite it with the toString() method
			// that props inherited from Object.prototype
			if(tobj[x] === undefined || tobj[x] != props[x]){
				obj[x] = props[x];
			}
		}
				// IE doesn't recognize custom toStrings in for..in
		if(d.isIE && props){
			var p = props.toString;
			if(typeof p == "function" && p != obj.toString && p != tobj.toString &&
				p != "\nfunction toString() {\n    [native code]\n}\n"){
					obj.toString = props.toString;
			}
		}
				return obj; // Object
	}

	dojo.mixin = function(/*Object*/obj, /*Object...*/props){
		// summary:	
		//		Adds all properties and methods of props to obj and returns the
		//		(now modified) obj.
		//	description:
		//		`dojo.mixin` can mix multiple source objects into a
		//		destionation object which is then returned. Unlike regular
		//		`for...in` iteration, `dojo.mixin` is also smart about avoiding
		//		extensions which other toolkits may unwisely add to the root
		//		object prototype
		//	obj:
		//		The object to mix properties into. Also the return value.
		//	props:
		//		One or more objects whose values are successively copied into
		//		obj. If more than one of these objects contain the same value,
		//		the one specified last in the function call will "win".
		//	example:
		//		make a shallow copy of an object
		//	|	var copy = dojo.mixin({}, source);
		//	example:
		//		many class constructors often take an object which specifies
		//		values to be configured on the object. In this case, it is
		//		often simplest to call `dojo.mixin` on the `this` object:
		//	|	dojo.declare("acme.Base", null, {
		//	|		constructor: function(properties){
		//	|			// property configuration:
		//	|			dojo.mixin(this, properties);
		//	|	
		//	|			console.log(this.quip);
		//	|			//  ...
		//	|		},
		//	|		quip: "I wasn't born yesterday, you know - I've seen movies.",
		//	|		// ...
		//	|	});
		//	|
		//	|	// create an instance of the class and configure it
		//	|	var b = new acme.Base({quip: "That's what it does!" });
		//	example:
		//		copy in properties from multiple objects
		//	|	var flattened = dojo.mixin(
		//	|		{
		//	|			name: "Frylock",
		//	|			braces: true
		//	|		},
		//	|		{
		//	|			name: "Carl Brutanananadilewski"
		//	|		}
		//	|	);
		//	|	
		//	|	// will print "Carl Brutanananadilewski"
		//	|	console.log(flattened.name);
		//	|	// will print "true"
		//	|	console.log(flattened.braces);
		if(!obj){ obj = {}; }
		for(var i=1, l=arguments.length; i<l; i++){
			d._mixin(obj, arguments[i]);
		}
		return obj; // Object
	}

	dojo._getProp = function(/*Array*/parts, /*Boolean*/create, /*Object*/context){
		var obj=context || d.global;
		for(var i=0, p; obj && (p=parts[i]); i++){
			if(i == 0 && this._scopeMap[p]){
				p = this._scopeMap[p];
			}
			obj = (p in obj ? obj[p] : (create ? obj[p]={} : undefined));
		}
		return obj; // mixed
	}

	dojo.setObject = function(/*String*/name, /*Object*/value, /*Object?*/context){
		// summary: 
		//		Set a property from a dot-separated string, such as "A.B.C"
		//	description: 
		//		Useful for longer api chains where you have to test each object in
		//		the chain, or when you have an object reference in string format.
		//		Objects are created as needed along `path`. Returns the passed
		//		value if setting is successful or `undefined` if not.
		//	name: 	
		//		Path to a property, in the form "A.B.C".
		//	context:
		//		Optional. Object to use as root of path. Defaults to
		//		`dojo.global`.
		//	example:
		//		set the value of `foo.bar.baz`, regardless of whether
		//		intermediate objects already exist:
		//	|	dojo.setObject("foo.bar.baz", value);
		//	example:
		//		without `dojo.setObject`, we often see code like this:
		//	|	// ensure that intermediate objects are available
		//	|	if(!obj["parent"]){ obj.parent = {}; }
		//	|	if(!obj.parent["child"]){ obj.parent.child= {}; }
		//	|	// now we can safely set the property
		//	|	obj.parent.child.prop = "some value";
		//		wheras with `dojo.setObject`, we can shorten that to:
		//	|	dojo.setObject("parent.child.prop", "some value", obj);
		var parts=name.split("."), p=parts.pop(), obj=d._getProp(parts, true, context);
		return obj && p ? (obj[p]=value) : undefined; // Object
	}

	dojo.getObject = function(/*String*/name, /*Boolean?*/create, /*Object?*/context){
		// summary: 
		//		Get a property from a dot-separated string, such as "A.B.C"
		//	description: 
		//		Useful for longer api chains where you have to test each object in
		//		the chain, or when you have an object reference in string format.
		//	name: 	
		//		Path to an property, in the form "A.B.C".
		//	create: 
		//		Optional. Defaults to `false`. If `true`, Objects will be
		//		created at any point along the 'path' that is undefined.
		//	context:
		//		Optional. Object to use as root of path. Defaults to
		//		'dojo.global'. Null may be passed.
		return d._getProp(name.split("."), create, context); // Object
	}

	dojo.exists = function(/*String*/name, /*Object?*/obj){
		//	summary: 
		//		determine if an object supports a given method
		//	description: 
		//		useful for longer api chains where you have to test each object in
		//		the chain
		//	name: 	
		//		Path to an object, in the form "A.B.C".
		//	obj:
		//		Object to use as root of path. Defaults to
		//		'dojo.global'. Null may be passed.
		//	example:
		//	|	// define an object
		//	|	var foo = {
		//	|		bar: { }
		//	|	};
		//	|
		//	|	// search the global scope
		//	|	dojo.exists("foo.bar"); // true
		//	|	dojo.exists("foo.bar.baz"); // false
		//	|
		//	|	// search from a particular scope
		//	|	dojo.exists("bar", foo); // true
		//	|	dojo.exists("bar.baz", foo); // false
		return !!d.getObject(name, false, obj); // Boolean
	}


	dojo["eval"] = function(/*String*/ scriptFragment){
		//	summary: 
		//		Perform an evaluation in the global scope. Use this rather than
		//		calling 'eval()' directly.
		//	description: 
		//		Placed in a separate function to minimize size of trapped
		//		exceptions. Calling eval() directly from some other scope may
		//		complicate tracebacks on some platforms.
		//	returns:
		//		The result of the evaluation. Often `undefined`


		// note:
		//	 - JSC eval() takes an optional second argument which can be 'unsafe'.
		//	 - Mozilla/SpiderMonkey eval() takes an optional second argument which is the
		//  	 scope object for new symbols.

		// FIXME: investigate Joseph Smarr's technique for IE:
		//		http://josephsmarr.com/2007/01/31/fixing-eval-to-use-global-scope-in-ie/
		//	see also:
		// 		http://trac.dojotoolkit.org/ticket/744
		return d.global.eval ? d.global.eval(scriptFragment) : eval(scriptFragment); 	// Object
	}

	/*=====
		dojo.deprecated = function(behaviour, extra, removal){
			//	summary: 
			//		Log a debug message to indicate that a behavior has been
			//		deprecated.
			//	behaviour: String
			//		The API or behavior being deprecated. Usually in the form
			//		of "myApp.someFunction()".
			//	extra: String?
			//		Text to append to the message. Often provides advice on a
			//		new function or facility to achieve the same goal during
			//		the deprecation period.
			//	removal: String?
			//		Text to indicate when in the future the behavior will be
			//		removed. Usually a version number.
			//	example:
			//	|	dojo.deprecated("myApp.getTemp()", "use myApp.getLocaleTemp() instead", "1.0");
		}

		dojo.experimental = function(moduleName, extra){
			//	summary: Marks code as experimental.
			//	description: 
			//	 	This can be used to mark a function, file, or module as
			//	 	experimental.  Experimental code is not ready to be used, and the
			//	 	APIs are subject to change without notice.  Experimental code may be
			//	 	completed deleted without going through the normal deprecation
			//	 	process.
			//	moduleName: String
			//	 	The name of a module, or the name of a module file or a specific
			//	 	function
			//	extra: String?
			//	 	some additional message for the user
			//	example:
			//	|	dojo.experimental("dojo.data.Result");
			//	example:
			//	|	dojo.experimental("dojo.weather.toKelvin()", "PENDING approval from NOAA");
		}
	=====*/

	//Real functions declared in dojo._firebug.firebug.
	d.deprecated = d.experimental = function(){};

})();
// vim:ai:ts=4:noet

/*
 * loader.js - A bootstrap module.  Runs before the hostenv_*.js file. Contains
 * all of the package loading methods.
 */

(function(){
	var d = dojo;

	d.mixin(d, {
		_loadedModules: {},
		_inFlightCount: 0,
		_hasResource: {},

		_modulePrefixes: {
			dojo: 	{	name: "dojo", value: "." },
			// dojox: 	{	name: "dojox", value: "../dojox" },
			// dijit: 	{	name: "dijit", value: "../dijit" },
			doh: 	{	name: "doh", value: "../util/doh" },
			tests: 	{	name: "tests", value: "tests" }
		},

		_moduleHasPrefix: function(/*String*/module){
			// summary: checks to see if module has been established
			var mp = this._modulePrefixes;
			return !!(mp[module] && mp[module].value); // Boolean
		},

		_getModulePrefix: function(/*String*/module){
			// summary: gets the prefix associated with module
			var mp = this._modulePrefixes;
			if(this._moduleHasPrefix(module)){
				return mp[module].value; // String
			}
			return module; // String
		},

		_loadedUrls: [],

		//WARNING: 
		//		This variable is referenced by packages outside of bootstrap:
		//		FloatingPane.js and undo/browser.js
		_postLoad: false,
		
		//Egad! Lots of test files push on this directly instead of using dojo.addOnLoad.
		_loaders: [],
		_unloaders: [],
		_loadNotifying: false
	});


		dojo._loadPath = function(/*String*/relpath, /*String?*/module, /*Function?*/cb){
		// 	summary:
		//		Load a Javascript module given a relative path
		//
		//	description:
		//		Loads and interprets the script located at relpath, which is
		//		relative to the script root directory.  If the script is found but
		//		its interpretation causes a runtime exception, that exception is
		//		not caught by us, so the caller will see it.  We return a true
		//		value if and only if the script is found.
		//
		// relpath: 
		//		A relative path to a script (no leading '/', and typically ending
		//		in '.js').
		// module: 
		//		A module whose existance to check for after loading a path.  Can be
		//		used to determine success or failure of the load.
		// cb: 
		//		a callback function to pass the result of evaluating the script

		var uri = ((relpath.charAt(0) == '/' || relpath.match(/^\w+:/)) ? "" : this.baseUrl) + relpath;
		try{
			return !module ? this._loadUri(uri, cb) : this._loadUriAndCheck(uri, module, cb); // Boolean
		}catch(e){
			console.error(e);
			return false; // Boolean
		}
	}

	dojo._loadUri = function(/*String*/uri, /*Function?*/cb){
		//	summary:
		//		Loads JavaScript from a URI
		//	description:
		//		Reads the contents of the URI, and evaluates the contents.  This is
		//		used to load modules as well as resource bundles. Returns true if
		//		it succeeded. Returns false if the URI reading failed.  Throws if
		//		the evaluation throws.
		//	uri: a uri which points at the script to be loaded
		//	cb: 
		//		a callback function to process the result of evaluating the script
		//		as an expression, typically used by the resource bundle loader to
		//		load JSON-style resources

		if(d._loadedUrls[uri]){
			return true; // Boolean
		}
		d._inFlightCount++; // block addOnLoad calls that arrive while we're busy downloading
		var contents = d._getText(uri, true);
		if(contents){ // not 404, et al
			d._loadedUrls[uri] = true;
			d._loadedUrls.push(uri);
			if(cb){
				contents = '('+contents+')';
			}else{
				//Only do the scoping if no callback. If a callback is specified,
				//it is most likely the i18n bundle stuff.
				contents = d._scopePrefix + contents + d._scopeSuffix;
			}
			if(d.isMoz){ contents += "\r\n//@ sourceURL=" + uri; } // debugging assist for Firebug
			var value = d["eval"](contents);
			if(cb){ cb(value); }
		}
		// Check to see if we need to call _callLoaded() due to an addOnLoad() that arrived while we were busy downloading
		if(--d._inFlightCount == 0 && d._postLoad && d._loaders.length){
			// We shouldn't be allowed to get here but Firefox allows an event 
			// (mouse, keybd, async xhrGet) to interrupt a synchronous xhrGet. 
			// If the current script block contains multiple require() statements, then after each
			// require() returns, inFlightCount == 0, but we want to hold the _callLoaded() until
			// all require()s are done since the out-of-sequence addOnLoad() presumably needs them all.
			// setTimeout allows the next require() to start (if needed), and then we check this again.
			setTimeout(function(){ 
				// If inFlightCount > 0, then multiple require()s are running sequentially and 
				// the next require() started after setTimeout() was executed but before we got here.
				if(d._inFlightCount == 0){ 
					d._callLoaded();
				}
			}, 0);
		}
		return !!contents; // Boolean: contents? true : false
	}
	
	// FIXME: probably need to add logging to this method
	dojo._loadUriAndCheck = function(/*String*/uri, /*String*/moduleName, /*Function?*/cb){
		// summary: calls loadUri then findModule and returns true if both succeed
		var ok = false;
		try{
			ok = this._loadUri(uri, cb);
		}catch(e){
			console.error("failed loading " + uri + " with error: " + e);
		}
		return !!(ok && this._loadedModules[moduleName]); // Boolean
	}

	dojo.loaded = function(){
		// summary:
		//		signal fired when initial environment and package loading is
		//		complete. You should use dojo.addOnLoad() instead of doing a 
		//		direct dojo.connect() to this method in order to handle
		//		initialization tasks that require the environment to be
		//		initialized. In a browser host,	declarative widgets will 
		//		be constructed when this function	finishes runing.
		this._loadNotifying = true;
		this._postLoad = true;
		var mll = d._loaders;

		//Clear listeners so new ones can be added
		//For other xdomain package loads after the initial load.
		this._loaders = [];

		for(var x = 0; x < mll.length; x++){
			mll[x]();
		}

		this._loadNotifying = false;
		
		//Make sure nothing else got added to the onload queue
		//after this first run. If something did, and we are not waiting for any
		//more inflight resources, run again.
		if(d._postLoad && d._inFlightCount == 0 && mll.length){
			d._callLoaded();
		}
	}

	dojo.unloaded = function(){
		// summary:
		//		signal fired by impending environment destruction. You should use
		//		dojo.addOnUnload() instead of doing a direct dojo.connect() to this 
		//		method to perform page/application cleanup methods. See 
		//		dojo.addOnUnload for more info.
		var mll = d._unloaders;
		while(mll.length){
			(mll.pop())();
		}
	}

	d._onto = function(arr, obj, fn){
		if(!fn){
			arr.push(obj);
		}else if(fn){
			var func = (typeof fn == "string") ? obj[fn] : fn;
			arr.push(function(){ func.call(obj); });
		}
	}

	dojo.addOnLoad = function(/*Object?*/obj, /*String|Function*/functionName){
		// summary:
		//		Registers a function to be triggered after the DOM has finished
		//		loading and widgets declared in markup have been instantiated.
		//		Images and CSS files may or may not have finished downloading when
		//		the specified function is called.  (Note that widgets' CSS and HTML
		//		code is guaranteed to be downloaded before said widgets are
		//		instantiated.)
		// example:
		//	|	dojo.addOnLoad(functionPointer);
		//	|	dojo.addOnLoad(object, "functionName");
		//	|	dojo.addOnLoad(object, function(){ /* ... */});

		d._onto(d._loaders, obj, functionName);

		//Added for xdomain loading. dojo.addOnLoad is used to
		//indicate callbacks after doing some dojo.require() statements.
		//In the xdomain case, if all the requires are loaded (after initial
		//page load), then immediately call any listeners.
		if(d._postLoad && d._inFlightCount == 0 && !d._loadNotifying){
			d._callLoaded();
		}
	}

	//Support calling dojo.addOnLoad via djConfig.addOnLoad. Support all the
	//call permutations of dojo.addOnLoad. Mainly useful when dojo is added
	//to the page after the page has loaded.
	var dca = d.config.addOnLoad;
	if(dca){
		d.addOnLoad[(dca instanceof Array ? "apply" : "call")](d, dca);
	}

	dojo._modulesLoaded = function(){
		if(d._postLoad){ return; }
		if(d._inFlightCount > 0){ 
			console.warn("files still in flight!");
			return;
		}
		d._callLoaded();
	}

	dojo._callLoaded = function(){

		// The "object" check is for IE, and the other opera check fixes an
		// issue in Opera where it could not find the body element in some
		// widget test cases.  For 0.9, maybe route all browsers through the
		// setTimeout (need protection still for non-browser environments
		// though). This might also help the issue with FF 2.0 and freezing
		// issues where we try to do sync xhr while background css images are
		// being loaded (trac #2572)? Consider for 0.9.
		if(typeof setTimeout == "object" || (dojo.config.useXDomain && d.isOpera)){
			if(dojo.isAIR){
				setTimeout(function(){dojo.loaded();}, 0);
			}else{
				setTimeout(dojo._scopeName + ".loaded();", 0);
			}
		}else{
			d.loaded();
		}
	}

	dojo._getModuleSymbols = function(/*String*/modulename){
		// summary:
		//		Converts a module name in dotted JS notation to an array
		//		representing the path in the source tree
		var syms = modulename.split(".");
		for(var i = syms.length; i>0; i--){
			var parentModule = syms.slice(0, i).join(".");
			if((i==1) && !this._moduleHasPrefix(parentModule)){		
				// Support default module directory (sibling of dojo) for top-level modules 
				syms[0] = "../" + syms[0];
			}else{
				var parentModulePath = this._getModulePrefix(parentModule);
				if(parentModulePath != parentModule){
					syms.splice(0, i, parentModulePath);
					break;
				}
			}
		}
		return syms; // Array
	}

	dojo._global_omit_module_check = false;

	dojo.loadInit = function(/*Function*/init){
		//	summary:
		//		Executes a function that needs to be executed for the loader's dojo.requireIf
		//		resolutions to work. This is needed mostly for the xdomain loader case where
		//		a function needs to be executed to set up the possible values for a dojo.requireIf
		//		call.
		//	init:
		//		a function reference. Executed immediately.
		//	description: This function is mainly a marker for the xdomain loader to know parts of
		//		code that needs be executed outside the function wrappper that is placed around modules.
		//		The init function could be executed more than once, and it should make no assumptions
		//		on what is loaded, or what modules are available. Only the functionality in Dojo Base
		//		is allowed to be used. Avoid using this method. For a valid use case,
		//		see the source for dojox.gfx.
		init();
	}

	dojo._loadModule = dojo.require = function(/*String*/moduleName, /*Boolean?*/omitModuleCheck){
		//	summary:
		//		loads a Javascript module from the appropriate URI
		//	moduleName:
		//		module name to load, using periods for separators,
		//		 e.g. "dojo.date.locale".  Module paths are de-referenced by dojo's
		//		internal mapping of locations to names and are disambiguated by
		//		longest prefix. See `dojo.registerModulePath()` for details on
		//		registering new modules.
		//	omitModuleCheck:
		//		if `true`, omitModuleCheck skips the step of ensuring that the
		//		loaded file actually defines the symbol it is referenced by.
		//		For example if it called as `dojo.require("a.b.c")` and the
		//		file located at `a/b/c.js` does not define an object `a.b.c`,
		//		and exception will be throws whereas no exception is raised
		//		when called as `dojo.require("a.b.c", true)`
		//	description:
		//		`dojo.require("A.B")` first checks to see if symbol A.B is
		//		defined. If it is, it is simply returned (nothing to do).
		//	
		//		If it is not defined, it will look for `A/B.js` in the script root
		//		directory.
		//	
		//		`dojo.require` throws an excpetion if it cannot find a file
		//		to load, or if the symbol `A.B` is not defined after loading.
		//	
		//		It returns the object `A.B`.
		//	
		//		`dojo.require()` does nothing about importing symbols into
		//		the current namespace.  It is presumed that the caller will
		//		take care of that. For example, to import all symbols into a
		//		local block, you might write:
		//	
		//		|	with (dojo.require("A.B")) {
		//		|		...
		//		|	}
		//	
		//		And to import just the leaf symbol to a local variable:
		//	
		//		|	var B = dojo.require("A.B");
		//	   	|	...
		//	returns: the required namespace object
		omitModuleCheck = this._global_omit_module_check || omitModuleCheck;

		//Check if it is already loaded.
		var module = this._loadedModules[moduleName];
		if(module){
			return module;
		}

		// convert periods to slashes
		var relpath = this._getModuleSymbols(moduleName).join("/") + '.js';

		var modArg = (!omitModuleCheck) ? moduleName : null;
		var ok = this._loadPath(relpath, modArg);

		if(!ok && !omitModuleCheck){
			throw new Error("Could not load '" + moduleName + "'; last tried '" + relpath + "'");
		}

		// check that the symbol was defined
		// Don't bother if we're doing xdomain (asynchronous) loading.
		if(!omitModuleCheck && !this._isXDomain){
			// pass in false so we can give better error
			module = this._loadedModules[moduleName];
			if(!module){
				throw new Error("symbol '" + moduleName + "' is not defined after loading '" + relpath + "'"); 
			}
		}

		return module;
	}

	dojo.provide = function(/*String*/ resourceName){
		//	summary:
		//		Each javascript source file must have at least one
		//		`dojo.provide()` call at the top of the file, corresponding to
		//		the file name.  For example, `js/dojo/foo.js` must have
		//		`dojo.provide("dojo.foo");` before any calls to
		//		`dojo.require()` are made.
		//	description:
		//		Each javascript source file is called a resource.  When a
		//		resource is loaded by the browser, `dojo.provide()` registers
		//		that it has been loaded.
		//	
		//		For backwards compatibility reasons, in addition to registering
		//		the resource, `dojo.provide()` also ensures that the javascript
		//		object for the module exists.  For example,
		//		`dojo.provide("dojox.data.FlickrStore")`, in addition to
		//		registering that `FlickrStore.js` is a resource for the
		//		`dojox.data` module, will ensure that the `dojox.data`
		//		javascript object exists, so that calls like 
		//		`dojo.data.foo = function(){ ... }` don't fail.
		//
		//		In the case of a build where multiple javascript source files
		//		are combined into one bigger file (similar to a .lib or .jar
		//		file), that file may contain multiple dojo.provide() calls, to
		//		note that it includes multiple resources.

		//Make sure we have a string.
		resourceName = resourceName + "";
		return (d._loadedModules[resourceName] = d.getObject(resourceName, true)); // Object
	}

	//Start of old bootstrap2:

	dojo.platformRequire = function(/*Object*/modMap){
		//	summary:
		//		require one or more modules based on which host environment
		//		Dojo is currently operating in
		//	description:
		//		This method takes a "map" of arrays which one can use to
		//		optionally load dojo modules. The map is indexed by the
		//		possible dojo.name_ values, with two additional values:
		//		"default" and "common". The items in the "default" array will
		//		be loaded if none of the other items have been choosen based on
		//		dojo.name_, set by your host environment. The items in the
		//		"common" array will *always* be loaded, regardless of which
		//		list is chosen.
		//	example:
		//		|	dojo.platformRequire({
		//		|		browser: [
		//		|			"foo.sample", // simple module
		//		|			"foo.test",
		//		|			["foo.bar.baz", true] // skip object check in _loadModule (dojo.require)
		//		|		],
		//		|		default: [ "foo.sample._base" ],
		//		|		common: [ "important.module.common" ]
		//		|	});

		var common = modMap.common || [];
		var result = common.concat(modMap[d._name] || modMap["default"] || []);

		for(var x=0; x<result.length; x++){
			var curr = result[x];
			if(curr.constructor == Array){
				d._loadModule.apply(d, curr);
			}else{
				d._loadModule(curr);
			}
		}
	}

	dojo.requireIf = function(/*Boolean*/ condition, /*String*/ resourceName){
		// summary:
		//		If the condition is true then call dojo.require() for the specified
		//		resource
		if(condition === true){
			// FIXME: why do we support chained require()'s here? does the build system?
			var args = [];
			for(var i = 1; i < arguments.length; i++){ 
				args.push(arguments[i]);
			}
			d.require.apply(d, args);
		}
	}

	dojo.requireAfterIf = d.requireIf;

	dojo.registerModulePath = function(/*String*/module, /*String*/prefix){
		//	summary: 
		//		maps a module name to a path
		//	description: 
		//		An unregistered module is given the default path of ../[module],
		//		relative to Dojo root. For example, module acme is mapped to
		//		../acme.  If you want to use a different module name, use
		//		dojo.registerModulePath. 
		//	example:
		//		If your dojo.js is located at this location in the web root:
		//	|	/myapp/js/dojo/dojo/dojo.js
		//		and your modules are located at:
		//	|	/myapp/js/foo/bar.js
		//	|	/myapp/js/foo/baz.js
		//	|	/myapp/js/foo/thud/xyzzy.js
		//		Your application can tell Dojo to locate the "foo" namespace by calling:
		//	|	dojo.registerModulePath("foo", "../../foo");
		//		At which point you can then use dojo.require() to load the
		//		modules (assuming they provide() the same things which are
		//		required). The full code might be:
		//	|	<script type="text/javascript" 
		//	|		src="/myapp/js/dojo/dojo/dojo.js"></script>
		//	|	<script type="text/javascript">
		//	|		dojo.registerModulePath("foo", "../../foo");
		//	|		dojo.require("foo.bar");
		//	|		dojo.require("foo.baz");
		//	|		dojo.require("foo.thud.xyzzy");
		//	|	</script>
		d._modulePrefixes[module] = { name: module, value: prefix };
	}

	dojo.requireLocalization = function(/*String*/moduleName, /*String*/bundleName, /*String?*/locale, /*String?*/availableFlatLocales){
		// summary:
		//		Declares translated resources and loads them if necessary, in the
		//		same style as dojo.require.  Contents of the resource bundle are
		//		typically strings, but may be any name/value pair, represented in
		//		JSON format.  See also `dojo.i18n.getLocalization`.
		//
		// description:
		//		Load translated resource bundles provided underneath the "nls"
		//		directory within a package.  Translated resources may be located in
		//		different packages throughout the source tree.  
		//
		//		Each directory is named for a locale as specified by RFC 3066,
		//		(http://www.ietf.org/rfc/rfc3066.txt), normalized in lowercase.
		//		Note that the two bundles in the example do not define all the
		//		same variants.  For a given locale, bundles will be loaded for
		//		that locale and all more general locales above it, including a
		//		fallback at the root directory.  For example, a declaration for
		//		the "de-at" locale will first load `nls/de-at/bundleone.js`,
		//		then `nls/de/bundleone.js` and finally `nls/bundleone.js`.  The
		//		data will be flattened into a single Object so that lookups
		//		will follow this cascading pattern.  An optional build step can
		//		preload the bundles to avoid data redundancy and the multiple
		//		network hits normally required to load these resources.
		//
		// moduleName: 
		//		name of the package containing the "nls" directory in which the
		//		bundle is found
		//
		// bundleName: 
		//		bundle name, i.e. the filename without the '.js' suffix
		//
		// locale: 
		//		the locale to load (optional)  By default, the browser's user
		//		locale as defined by dojo.locale
		//
		// availableFlatLocales: 
		//		A comma-separated list of the available, flattened locales for this
		//		bundle. This argument should only be set by the build process.
		//
		//	example:
		//		A particular widget may define one or more resource bundles,
		//		structured in a program as follows, where moduleName is
		//		mycode.mywidget and bundleNames available include bundleone and
		//		bundletwo:
		//	|		...
		//	|	mycode/
		//	|		mywidget/
		//	|			nls/
		//	|				bundleone.js (the fallback translation, English in this example)
		//	|				bundletwo.js (also a fallback translation)
		//	|				de/
		//	|					bundleone.js
		//	|					bundletwo.js
		//	|				de-at/
		//	|					bundleone.js
		//	|				en/
		//	|					(empty; use the fallback translation)
		//	|				en-us/
		//	|					bundleone.js
		//	|				en-gb/
		//	|					bundleone.js
		//	|				es/
		//	|					bundleone.js
		//	|					bundletwo.js
		//	|				  ...etc
		//	|				...
		//

		d.require("dojo.i18n");
		d.i18n._requireLocalization.apply(d.hostenv, arguments);
	};


	var ore = new RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$");
	var ire = new RegExp("^((([^\\[:]+):)?([^@]+)@)?(\\[([^\\]]+)\\]|([^\\[:]*))(:([0-9]+))?$");

	dojo._Url = function(/*dojo._Url||String...*/){
		// summary: 
		//		Constructor to create an object representing a URL.
		//		It is marked as private, since we might consider removing
		//		or simplifying it.
		// description: 
		//		Each argument is evaluated in order relative to the next until
		//		a canonical uri is produced. To get an absolute Uri relative to
		//		the current document use:
		//      	new dojo._Url(document.baseURI, url)

		var n = null;

		var _a = arguments;
		var uri = [_a[0]];
		// resolve uri components relative to each other
		for(var i = 1; i<_a.length; i++){
			if(!_a[i]){ continue; }

			// Safari doesn't support this.constructor so we have to be explicit
			// FIXME: Tracked (and fixed) in Webkit bug 3537.
			//		http://bugs.webkit.org/show_bug.cgi?id=3537
			var relobj = new d._Url(_a[i]+"");
			var uriobj = new d._Url(uri[0]+"");

			if(
				relobj.path == "" &&
				!relobj.scheme &&
				!relobj.authority &&
				!relobj.query
			){
				if(relobj.fragment != n){
					uriobj.fragment = relobj.fragment;
				}
				relobj = uriobj;
			}else if(!relobj.scheme){
				relobj.scheme = uriobj.scheme;

				if(!relobj.authority){
					relobj.authority = uriobj.authority;

					if(relobj.path.charAt(0) != "/"){
						var path = uriobj.path.substring(0,
							uriobj.path.lastIndexOf("/") + 1) + relobj.path;

						var segs = path.split("/");
						for(var j = 0; j < segs.length; j++){
							if(segs[j] == "."){
								// flatten "./" references
								if(j == segs.length - 1){
									segs[j] = "";
								}else{
									segs.splice(j, 1);
									j--;
								}
							}else if(j > 0 && !(j == 1 && segs[0] == "") &&
								segs[j] == ".." && segs[j-1] != ".."){
								// flatten "../" references
								if(j == (segs.length - 1)){
									segs.splice(j, 1);
									segs[j - 1] = "";
								}else{
									segs.splice(j - 1, 2);
									j -= 2;
								}
							}
						}
						relobj.path = segs.join("/");
					}
				}
			}

			uri = [];
			if(relobj.scheme){ 
				uri.push(relobj.scheme, ":");
			}
			if(relobj.authority){
				uri.push("//", relobj.authority);
			}
			uri.push(relobj.path);
			if(relobj.query){
				uri.push("?", relobj.query);
			}
			if(relobj.fragment){
				uri.push("#", relobj.fragment);
			}
		}

		this.uri = uri.join("");

		// break the uri into its main components
		var r = this.uri.match(ore);

		this.scheme = r[2] || (r[1] ? "" : n);
		this.authority = r[4] || (r[3] ? "" : n);
		this.path = r[5]; // can never be undefined
		this.query = r[7] || (r[6] ? "" : n);
		this.fragment  = r[9] || (r[8] ? "" : n);

		if(this.authority != n){
			// server based naming authority
			r = this.authority.match(ire);

			this.user = r[3] || n;
			this.password = r[4] || n;
			this.host = r[6] || r[7]; // ipv6 || ipv4
			this.port = r[9] || n;
		}
	}

	dojo._Url.prototype.toString = function(){ return this.uri; };

	dojo.moduleUrl = function(/*String*/module, /*dojo._Url||String*/url){
		//	summary: 
		//		Returns a `dojo._Url` object relative to a module.
		//	example:
		//	|	var pngPath = dojo.moduleUrl("acme","images/small.png");
		//	|	console.dir(pngPath); // list the object properties
		//	|	// create an image and set it's source to pngPath's value:
		//	|	var img = document.createElement("img");
		// 	|	// NOTE: we assign the string representation of the url object
		//	|	img.src = pngPath.toString(); 
		//	|	// add our image to the document
		//	|	dojo.body().appendChild(img);
		//	example: 
		//		you may de-reference as far as you like down the package
		//		hierarchy.  This is sometimes handy to avoid lenghty relative
		//		urls or for building portable sub-packages. In this example,
		//		the `acme.widget` and `acme.util` directories may be located
		//		under different roots (see `dojo.registerModulePath`) but the
		//		the modules which reference them can be unaware of their
		//		relative locations on the filesystem:
		//	|	// somewhere in a configuration block
		//	|	dojo.registerModulePath("acme.widget", "../../acme/widget");
		//	|	dojo.registerModulePath("acme.util", "../../util");
		//	|	
		//	|	// ...
		//	|	
		//	|	// code in a module using acme resources
		//	|	var tmpltPath = dojo.moduleUrl("acme.widget","templates/template.html");
		//	|	var dataPath = dojo.moduleUrl("acme.util","resources/data.json");

		var loc = d._getModuleSymbols(module).join('/');
		if(!loc){ return null; }
		if(loc.lastIndexOf("/") != loc.length-1){
			loc += "/";
		}
		
		//If the path is an absolute path (starts with a / or is on another
		//domain/xdomain) then don't add the baseUrl.
		var colonIndex = loc.indexOf(":");
		if(loc.charAt(0) != "/" && (colonIndex == -1 || colonIndex > loc.indexOf("/"))){
			loc = d.baseUrl + loc;
		}

		return new d._Url(loc, url); // String
	}
})();

/*=====
dojo.isBrowser = {
	//	example:
	//	|	if(dojo.isBrowser){ ... }
};

dojo.isFF = {
	//	example:
	//	|	if(dojo.isFF > 1){ ... }
};

dojo.isIE = {
	// example:
	//	|	if(dojo.isIE > 6){
	//	|		// we are IE7
	// 	|	}
};

dojo.isSafari = {
	//	example:
	//	|	if(dojo.isSafari){ ... }
	//	example: 
	//		Detect iPhone:
	//	|	if(dojo.isSafari && navigator.userAgent.indexOf("iPhone") != -1){ 
	//	|		// we are iPhone. Note, iPod touch reports "iPod" above and fails this test.
	//	|	}
};

dojo = {
	// isBrowser: Boolean
	//		True if the client is a web-browser
	isBrowser: true,
	//	isFF: Number | undefined
	//		Version as a Number if client is FireFox. undefined otherwise. Corresponds to
	//		major detected FireFox version (1.5, 2, 3, etc.)
	isFF: 2,
	//	isIE: Number | undefined
	//		Version as a Number if client is MSIE(PC). undefined otherwise. Corresponds to
	//		major detected IE version (6, 7, 8, etc.)
	isIE: 6,
	//	isKhtml: Number | undefined
	//		Version as a Number if client is a KHTML browser. undefined otherwise. Corresponds to major
	//		detected version.
	isKhtml: 0,
	//	isWebKit: Number | undefined
	//		Version as a Number if client is a WebKit-derived browser (Konqueror,
	//		Safari, Chrome, etc.). undefined otherwise.
	isWebKit: 0,
	//	isMozilla: Number | undefined
	//		Version as a Number if client is a Mozilla-based browser (Firefox,
	//		SeaMonkey). undefined otherwise. Corresponds to major detected version.
	isMozilla: 0,
	//	isOpera: Number | undefined
	//		Version as a Number if client is Opera. undefined otherwise. Corresponds to
	//		major detected version.
	isOpera: 0,
	//	isSafari: Number | undefined
	//		Version as a Number if client is Safari or iPhone. undefined otherwise.
	isSafari: 0
	//	isChrome: Number | undefined
	//		Version as a Number if client is Chrome browser. undefined otherwise.
	isChrome: 0
}
=====*/

if(typeof window != 'undefined'){
	dojo.isBrowser = true;
	dojo._name = "browser";


	// attempt to figure out the path to dojo if it isn't set in the config
	(function(){
		var d = dojo;

		// this is a scope protection closure. We set browser versions and grab
		// the URL we were loaded from here.

		// grab the node we were loaded from
		if(document && document.getElementsByTagName){
			var scripts = document.getElementsByTagName("script");
			var rePkg = /dojo(\.xd)?\.js(\W|$)/i;
			for(var i = 0; i < scripts.length; i++){
				var src = scripts[i].getAttribute("src");
				if(!src){ continue; }
				var m = src.match(rePkg);
				if(m){
					// find out where we came from
					if(!d.config.baseUrl){
						d.config.baseUrl = src.substring(0, m.index);
					}
					// and find out if we need to modify our behavior
					var cfg = scripts[i].getAttribute("djConfig");
					if(cfg){
						var cfgo = eval("({ "+cfg+" })");
						for(var x in cfgo){
							dojo.config[x] = cfgo[x];
						}
					}
					break; // "first Dojo wins"
				}
			}
		}
		d.baseUrl = d.config.baseUrl;

		// fill in the rendering support information in dojo.render.*
		var n = navigator;
		var dua = n.userAgent,
			dav = n.appVersion,
			tv = parseFloat(dav);

		if(dua.indexOf("Opera") >= 0){ d.isOpera = tv; }
		if(dua.indexOf("AdobeAIR") >= 0){ d.isAIR = 1; }
		d.isKhtml = (dav.indexOf("Konqueror") >= 0) ? tv : 0;
		d.isWebKit = parseFloat(dua.split("WebKit/")[1]) || undefined;
		d.isChrome = parseFloat(dua.split("Chrome/")[1]) || undefined;

		// safari detection derived from:
		//		http://developer.apple.com/internet/safari/faq.html#anchor2
		//		http://developer.apple.com/internet/safari/uamatrix.html
		var index = Math.max(dav.indexOf("WebKit"), dav.indexOf("Safari"), 0);
		if(index && !dojo.isChrome){
			// try to grab the explicit Safari version first. If we don't get
			// one, look for less than 419.3 as the indication that we're on something
			// "Safari 2-ish".
			d.isSafari = parseFloat(dav.split("Version/")[1]);
			if(!d.isSafari || parseFloat(dav.substr(index + 7)) <= 419.3){
				d.isSafari = 2;
			}
		}

				if(dua.indexOf("Gecko") >= 0 && !d.isKhtml && !d.isWebKit){ d.isMozilla = d.isMoz = tv; }
		if(d.isMoz){
			//We really need to get away from this. Consider a sane isGecko approach for the future.
			d.isFF = parseFloat(dua.split("Firefox/")[1] || dua.split("Minefield/")[1] || dua.split("Shiretoko/")[1]) || undefined;
		}
		if(document.all && !d.isOpera){
			d.isIE = parseFloat(dav.split("MSIE ")[1]) || undefined;
			//In cases where the page has an HTTP header or META tag with
			//X-UA-Compatible, then it is in emulation mode, for a previous
			//version. Make sure isIE reflects the desired version.
			//document.documentMode of 5 means quirks mode.
			if(d.isIE >= 8 && document.documentMode != 5){
				d.isIE = document.documentMode;
			}
		}

		//Workaround to get local file loads of dojo to work on IE 7
		//by forcing to not use native xhr.
		if(dojo.isIE && window.location.protocol === "file:"){
			dojo.config.ieForceActiveXXhr=true;
		}
		
		var cm = document.compatMode;
		d.isQuirks = cm == "BackCompat" || cm == "QuirksMode" || d.isIE < 6;

		// TODO: is the HTML LANG attribute relevant?
		d.locale = dojo.config.locale || (d.isIE ? n.userLanguage : n.language).toLowerCase();

		// These are in order of decreasing likelihood; this will change in time.
				d._XMLHTTP_PROGIDS = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];
		
		d._xhrObj = function(){
			// summary: 
			//		does the work of portably generating a new XMLHTTPRequest object.
			var http, last_e;
						if(!dojo.isIE || !dojo.config.ieForceActiveXXhr){
							try{ http = new XMLHttpRequest(); }catch(e){}
						}
			if(!http){
				for(var i=0; i<3; ++i){
					var progid = d._XMLHTTP_PROGIDS[i];
					try{
						http = new ActiveXObject(progid);
					}catch(e){
						last_e = e;
					}

					if(http){
						d._XMLHTTP_PROGIDS = [progid];  // so faster next time
						break;
					}
				}
			}
			
			if(!http){
				throw new Error("XMLHTTP not available: "+last_e);
			}

			return http; // XMLHTTPRequest instance
		}

		d._isDocumentOk = function(http){
			var stat = http.status || 0;
			return (stat >= 200 && stat < 300) || 	// Boolean
				stat == 304 || 						// allow any 2XX response code
				stat == 1223 || 						// get it out of the cache
				(!stat && (location.protocol=="file:" || location.protocol=="chrome:") ); // Internet Explorer mangled the status code
		}

		//See if base tag is in use.
		//This is to fix http://trac.dojotoolkit.org/ticket/3973,
		//but really, we need to find out how to get rid of the dojo._Url reference
		//below and still have DOH work with the dojo.i18n test following some other
		//test that uses the test frame to load a document (trac #2757).
		//Opera still has problems, but perhaps a larger issue of base tag support
		//with XHR requests (hasBase is true, but the request is still made to document
		//path, not base path).
		var owloc = window.location+"";
		var base = document.getElementsByTagName("base");
		var hasBase = (base && base.length > 0);

		d._getText = function(/*URI*/ uri, /*Boolean*/ fail_ok){
			// summary: Read the contents of the specified uri and return those contents.
			// uri:
			//		A relative or absolute uri. If absolute, it still must be in
			//		the same "domain" as we are.
			// fail_ok:
			//		Default false. If fail_ok and loading fails, return null
			//		instead of throwing.
			// returns: The response text. null is returned when there is a
			//		failure and failure is okay (an exception otherwise)

			// NOTE: must be declared before scope switches ie. this._xhrObj()
			var http = this._xhrObj();

			if(!hasBase && dojo._Url){
				uri = (new dojo._Url(owloc, uri)).toString();
			}

			if(d.config.cacheBust){
				//Make sure we have a string before string methods are used on uri
				uri += "";
				uri += (uri.indexOf("?") == -1 ? "?" : "&") + String(d.config.cacheBust).replace(/\W+/g,"");
			}

			http.open('GET', uri, false);
			try{
				http.send(null);
				if(!d._isDocumentOk(http)){
					var err = Error("Unable to load "+uri+" status:"+ http.status);
					err.status = http.status;
					err.responseText = http.responseText;
					throw err;
				}
			}catch(e){
				if(fail_ok){ return null; } // null
				// rethrow the exception
				throw e;
			}
			return http.responseText; // String
		}
		

		var _w = window;
		var _handleNodeEvent = function(/*String*/evtName, /*Function*/fp){
			// summary:
			//		non-destructively adds the specified function to the node's
			//		evtName handler.
			// evtName: should be in the form "onclick" for "onclick" handlers.
			// Make sure you pass in the "on" part.
			var oldHandler = _w[evtName] || function(){};
			_w[evtName] = function(){
				fp.apply(_w, arguments);
				oldHandler.apply(_w, arguments);
			};
		};


		d._windowUnloaders = [];
		
		d.windowUnloaded = function(){
			// summary:
			//		signal fired by impending window destruction. You may use
			//		dojo.addOnWindowUnload() to register a listener for this
			//		event. NOTE: if you wish to dojo.connect() to this method
			//		to perform page/application cleanup, be aware that this
			//		event WILL NOT fire if no handler has been registered with
			//		dojo.addOnWindowUnload. This behavior started in Dojo 1.3.
			//		Previous versions always triggered dojo.windowUnloaded. See
			//		dojo.addOnWindowUnload for more info.
			var mll = d._windowUnloaders;
			while(mll.length){
				(mll.pop())();
			}
		};

		var _onWindowUnloadAttached = 0;
		d.addOnWindowUnload = function(/*Object?|Function?*/obj, /*String|Function?*/functionName){
			// summary:
			//		registers a function to be triggered when window.onunload
			//		fires. 
			//	description:
			//		The first time that addOnWindowUnload is called Dojo
			//		will register a page listener to trigger your unload
			//		handler with. Note that registering these handlers may
			//		destory "fastback" page caching in browsers that support
			//		it. Be careful trying to modify the DOM or access
			//		JavaScript properties during this phase of page unloading:
			//		they may not always be available. Consider
			//		dojo.addOnUnload() if you need to modify the DOM or do
			//		heavy JavaScript work since it fires at the eqivalent of
			//		the page's "onbeforeunload" event.
			// example:
			//	|	dojo.addOnWindowUnload(functionPointer)
			//	|	dojo.addOnWindowUnload(object, "functionName");
			//	|	dojo.addOnWindowUnload(object, function(){ /* ... */});

			d._onto(d._windowUnloaders, obj, functionName);
			if(!_onWindowUnloadAttached){
				_onWindowUnloadAttached = 1;
				_handleNodeEvent("onunload", d.windowUnloaded);
			}
		};

		var _onUnloadAttached = 0;
		d.addOnUnload = function(/*Object?|Function?*/obj, /*String|Function?*/functionName){
			// summary:
			//		registers a function to be triggered when the page unloads.
			//	description:
			//		The first time that addOnUnload is called Dojo will
			//		register a page listener to trigger your unload handler
			//		with. 
			//
			//		In a browser enviroment, the functions will be triggered
			//		during the window.onbeforeunload event. Be careful of doing
			//		too much work in an unload handler. onbeforeunload can be
			//		triggered if a link to download a file is clicked, or if
			//		the link is a javascript: link. In these cases, the
			//		onbeforeunload event fires, but the document is not
			//		actually destroyed. So be careful about doing destructive
			//		operations in a dojo.addOnUnload callback.
			//
			//		Further note that calling dojo.addOnUnload will prevent
			//		browsers from using a "fast back" cache to make page
			//		loading via back button instantaneous. 
			// example:
			//	|	dojo.addOnUnload(functionPointer)
			//	|	dojo.addOnUnload(object, "functionName")
			//	|	dojo.addOnUnload(object, function(){ /* ... */});

			d._onto(d._unloaders, obj, functionName);
			if(!_onUnloadAttached){
				_onUnloadAttached = 1;
				_handleNodeEvent("onbeforeunload", dojo.unloaded);
			}
		};

	})();

	dojo._initFired = false;
	//	BEGIN DOMContentLoaded, from Dean Edwards (http://dean.edwards.name/weblog/2006/06/again/)
	dojo._loadInit = function(e){
		dojo._initFired = true;
		// allow multiple calls, only first one will take effect
		// A bug in khtml calls events callbacks for document for event which isnt supported
		// for example a created contextmenu event calls DOMContentLoaded, workaround
		var type = e && e.type ? e.type.toLowerCase() : "load";
		if(arguments.callee.initialized || (type != "domcontentloaded" && type != "load")){ return; }
		arguments.callee.initialized = true;
		if("_khtmlTimer" in dojo){
			clearInterval(dojo._khtmlTimer);
			delete dojo._khtmlTimer;
		}

		if(dojo._inFlightCount == 0){
			dojo._modulesLoaded();
		}
	}

	if(!dojo.config.afterOnLoad){
		//	START DOMContentLoaded
		// Mozilla and Opera 9 expose the event we could use
				if(document.addEventListener){
			// NOTE: 
			//		due to a threading issue in Firefox 2.0, we can't enable
			//		DOMContentLoaded on that platform. For more information, see:
			//		http://trac.dojotoolkit.org/ticket/1704
			if(dojo.isWebKit > 525 || dojo.isOpera || dojo.isFF >= 3 || (dojo.isMoz && dojo.config.enableMozDomContentLoaded === true)){
						document.addEventListener("DOMContentLoaded", dojo._loadInit, null);
					}
	
			//	mainly for Opera 8.5, won't be fired if DOMContentLoaded fired already.
			//  also used for Mozilla because of trac #1640
			window.addEventListener("load", dojo._loadInit, null);
		}
			
				if(dojo.isAIR){
			window.addEventListener("load", dojo._loadInit, null);
		}else if((dojo.isWebKit < 525) || dojo.isKhtml){
			dojo._khtmlTimer = setInterval(function(){
				if(/loaded|complete/.test(document.readyState)){
					dojo._loadInit(); // call the onload handler
				}
			}, 10);
		}
				//	END DOMContentLoaded
	}

		if(dojo.isIE){
		// 	for Internet Explorer. readyState will not be achieved on init
		// 	call, but dojo doesn't need it however, we'll include it
		// 	because we don't know if there are other functions added that
		// 	might.  Note that this has changed because the build process
		// 	strips all comments -- including conditional ones.
		if(!dojo.config.afterOnLoad){
			document.write('<scr'+'ipt defer src="//:" '
				+ 'onreadystatechange="if(this.readyState==\'complete\'){' + dojo._scopeName + '._loadInit();}">'
				+ '</scr'+'ipt>'
			);
		}

		try{
			document.namespaces.add("v","urn:schemas-microsoft-com:vml");
			document.createStyleSheet().addRule("v\\:*", "behavior:url(#default#VML);  display:inline-block");
		}catch(e){}
	}
	

	/*
	OpenAjax.subscribe("OpenAjax", "onload", function(){
		if(dojo._inFlightCount == 0){
			dojo._modulesLoaded();
		}
	});

	OpenAjax.subscribe("OpenAjax", "onunload", function(){
		dojo.unloaded();
	});
	*/
} //if (typeof window != 'undefined')

//Register any module paths set up in djConfig. Need to do this
//in the hostenvs since hostenv_browser can read djConfig from a
//script tag's attribute.
(function(){
	var mp = dojo.config["modulePaths"];
	if(mp){
		for(var param in mp){
			dojo.registerModulePath(param, mp[param]);
		}
	}
})();

//Load debug code if necessary.
if(dojo.config.isDebug){
	dojo.require("dojo._firebug.firebug");
}

if(dojo.config.debugAtAllCosts){
	dojo.config.useXDomain = true;
	dojo.require("dojo._base._loader.loader_xd");
	dojo.require("dojo._base._loader.loader_debug");
	
}

if(!dojo._hasResource["dojo._base.lang"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo._base.lang"] = true;
dojo.provide("dojo._base.lang");

// Crockford (ish) functions

dojo.isString = function(/*anything*/ it){
	//	summary:
	//		Return true if it is a String
	return !!arguments.length && it != null && (typeof it == "string" || it instanceof String); // Boolean
}

dojo.isArray = function(/*anything*/ it){
	//	summary:
	//		Return true if it is an Array
	return it && (it instanceof Array || typeof it == "array"); // Boolean
}

/*=====
dojo.isFunction = function(it){
	// summary: Return true if it is a Function
	// it: anything
	return; // Boolean
}
=====*/

dojo.isFunction = (function(){
	var _isFunction = function(/*anything*/ it){
		var t = typeof it; // must evaluate separately due to bizarre Opera bug. See #8937 
		return it && (t == "function" || it instanceof Function); // Boolean
	};

	return dojo.isSafari ?
		// only slow this down w/ gratuitious casting in Safari (not WebKit)
		function(/*anything*/ it){
			if(typeof it == "function" && it == "[object NodeList]"){ return false; }
			return _isFunction(it); // Boolean
		} : _isFunction;
})();

dojo.isObject = function(/*anything*/ it){
	// summary: 
	//		Returns true if it is a JavaScript object (or an Array, a Function
	//		or null)
	return it !== undefined &&
		(it === null || typeof it == "object" || dojo.isArray(it) || dojo.isFunction(it)); // Boolean
}

dojo.isArrayLike = function(/*anything*/ it){
	//	summary:
	//		similar to dojo.isArray() but more permissive
	//	description:
	//		Doesn't strongly test for "arrayness".  Instead, settles for "isn't
	//		a string or number and has a length property". Arguments objects
	//		and DOM collections will return true when passed to
	//		dojo.isArrayLike(), but will return false when passed to
	//		dojo.isArray().
	//	returns:
	//		If it walks like a duck and quacks like a duck, return `true`
	var d = dojo;
	return it && it !== undefined && // Boolean
		// keep out built-in constructors (Number, String, ...) which have length
		// properties
		!d.isString(it) && !d.isFunction(it) &&
		!(it.tagName && it.tagName.toLowerCase() == 'form') &&
		(d.isArray(it) || isFinite(it.length));
}

dojo.isAlien = function(/*anything*/ it){
	// summary: 
	//		Returns true if it is a built-in function or some other kind of
	//		oddball that *should* report as a function but doesn't
	return it && !dojo.isFunction(it) && /\{\s*\[native code\]\s*\}/.test(String(it)); // Boolean
}

dojo.extend = function(/*Object*/ constructor, /*Object...*/ props){
	// summary:
	//		Adds all properties and methods of props to constructor's
	//		prototype, making them available to all instances created with
	//		constructor.
	for(var i=1, l=arguments.length; i<l; i++){
		dojo._mixin(constructor.prototype, arguments[i]);
	}
	return constructor; // Object
}

dojo._hitchArgs = function(scope, method /*,...*/){
	var pre = dojo._toArray(arguments, 2);
	var named = dojo.isString(method);
	return function(){
		// arrayify arguments
		var args = dojo._toArray(arguments);
		// locate our method
		var f = named ? (scope||dojo.global)[method] : method;
		// invoke with collected args
		return f && f.apply(scope || this, pre.concat(args)); // mixed
 	} // Function
}

dojo.hitch = function(/*Object*/scope, /*Function|String*/method /*,...*/){
	//	summary: 
	//		Returns a function that will only ever execute in the a given scope. 
	//		This allows for easy use of object member functions
	//		in callbacks and other places in which the "this" keyword may
	//		otherwise not reference the expected scope. 
	//		Any number of default positional arguments may be passed as parameters 
	//		beyond "method".
	//		Each of these values will be used to "placehold" (similar to curry)
	//		for the hitched function. 
	//	scope: 
	//		The scope to use when method executes. If method is a string, 
	//		scope is also the object containing method.
	//	method:
	//		A function to be hitched to scope, or the name of the method in
	//		scope to be hitched.
	//	example:
	//	|	dojo.hitch(foo, "bar")(); 
	//		runs foo.bar() in the scope of foo
	//	example:
	//	|	dojo.hitch(foo, myFunction);
	//		returns a function that runs myFunction in the scope of foo
	if(arguments.length > 2){
		return dojo._hitchArgs.apply(dojo, arguments); // Function
	}
	if(!method){
		method = scope;
		scope = null;
	}
	if(dojo.isString(method)){
		scope = scope || dojo.global;
		if(!scope[method]){ throw(['dojo.hitch: scope["', method, '"] is null (scope="', scope, '")'].join('')); }
		return function(){ return scope[method].apply(scope, arguments || []); }; // Function
	}
	return !scope ? method : function(){ return method.apply(scope, arguments || []); }; // Function
}

/*=====
dojo.delegate = function(obj, props){
	//	summary:
	//		Returns a new object which "looks" to obj for properties which it
	//		does not have a value for. Optionally takes a bag of properties to
	//		seed the returned object with initially. 
	//	description:
	//		This is a small implementaton of the Boodman/Crockford delegation
	//		pattern in JavaScript. An intermediate object constructor mediates
	//		the prototype chain for the returned object, using it to delegate
	//		down to obj for property lookup when object-local lookup fails.
	//		This can be thought of similarly to ES4's "wrap", save that it does
	//		not act on types but rather on pure objects.
	//	obj:
	//		The object to delegate to for properties not found directly on the
	//		return object or in props.
	//	props:
	//		an object containing properties to assign to the returned object
	//	returns:
	//		an Object of anonymous type
	//	example:
	//	|	var foo = { bar: "baz" };
	//	|	var thinger = dojo.delegate(foo, { thud: "xyzzy"});
	//	|	thinger.bar == "baz"; // delegated to foo
	//	|	foo.thud == undefined; // by definition
	//	|	thinger.thud == "xyzzy"; // mixed in from props
	//	|	foo.bar = "thonk";
	//	|	thinger.bar == "thonk"; // still delegated to foo's bar
}
=====*/

dojo.delegate = dojo._delegate = (function(){
	// boodman/crockford delegation w/ cornford optimization
	function TMP(){}
	return function(obj, props){
		TMP.prototype = obj;
		var tmp = new TMP();
		if(props){
			dojo._mixin(tmp, props);
		}
		return tmp; // Object
	}
})();

/*=====
dojo._toArray = function(obj, offset, startWith){
	//	summary:
	//		Converts an array-like object (i.e. arguments, DOMCollection) to an
	//		array. Returns a new Array with the elements of obj.
	//	obj: Object
	//		the object to "arrayify". We expect the object to have, at a
	//		minimum, a length property which corresponds to integer-indexed
	//		properties.
	//	offset: Number?
	//		the location in obj to start iterating from. Defaults to 0.
	//		Optional.
	//	startWith: Array?
	//		An array to pack with the properties of obj. If provided,
	//		properties in obj are appended at the end of startWith and
	//		startWith is the returned array.
}
=====*/

(function(){
	var efficient = function(obj, offset, startWith){
		return (startWith||[]).concat(Array.prototype.slice.call(obj, offset||0));
	};

		var slow = function(obj, offset, startWith){
		var arr = startWith||[]; 
		for(var x = offset || 0; x < obj.length; x++){ 
			arr.push(obj[x]); 
		} 
		return arr;
	};
	
	dojo._toArray = 
				dojo.isIE ?  function(obj){
			return ((obj.item) ? slow : efficient).apply(this, arguments);
		} : 
				efficient;

})();

dojo.partial = function(/*Function|String*/method /*, ...*/){
	//	summary:
	//		similar to hitch() except that the scope object is left to be
	//		whatever the execution context eventually becomes.
	//	description:
	//		Calling dojo.partial is the functional equivalent of calling:
	//		|	dojo.hitch(null, funcName, ...);
	var arr = [ null ];
	return dojo.hitch.apply(dojo, arr.concat(dojo._toArray(arguments))); // Function
}

dojo.clone = function(/*anything*/ o){
	// summary:
	//		Clones objects (including DOM nodes) and all children.
	//		Warning: do not clone cyclic structures.
	if(!o){ return o; }
	if(dojo.isArray(o)){
		var r = [];
		for(var i = 0; i < o.length; ++i){
			r.push(dojo.clone(o[i]));
		}
		return r; // Array
	}
	if(!dojo.isObject(o)){
		return o;	/*anything*/
	}
	if(o.nodeType && o.cloneNode){ // isNode
		return o.cloneNode(true); // Node
	}
	if(o instanceof Date){
		return new Date(o.getTime());	// Date
	}
	// Generic objects
	r = new o.constructor(); // specific to dojo.declare()'d classes!
	for(i in o){
		if(!(i in r) || r[i] != o[i]){
			r[i] = dojo.clone(o[i]);
		}
	}
	return r; // Object
}

/*=====
dojo.trim = function(str){
	//	summary:
	//		Trims whitespace from both sides of the string
	//	str: String
	//		String to be trimmed
	//	returns: String
	//		Returns the trimmed string
	//	description:
	//		This version of trim() was selected for inclusion into the base due
	//		to its compact size and relatively good performance
	//		(see [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript)
	//		Uses String.prototype.trim instead, if available.
	//		The fastest but longest version of this function is located at
	//		dojo.string.trim()
	return "";	// String
}
=====*/

dojo.trim = String.prototype.trim ?
	function(str){ return str.trim(); } :
	function(str){ return str.replace(/^\s\s*/, '').replace(/\s\s*$/, ''); };

}

if(!dojo._hasResource["dojo._base.declare"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo._base.declare"] = true;
dojo.provide("dojo._base.declare");


// this file courtesy of the TurboAjax Group, licensed under a Dojo CLA

dojo.declare = function(/*String*/ className, /*Function|Function[]*/ superclass, /*Object*/ props){
	//	summary: 
	//		Create a feature-rich constructor from compact notation
	//	className:
	//		The name of the constructor (loosely, a "class")
	//		stored in the "declaredClass" property in the created prototype
	//	superclass:
	//		May be null, a Function, or an Array of Functions. If an array, 
	//		the first element is used as the prototypical ancestor and
	//		any following Functions become mixin ancestors.
	//	props:
	//		An object whose properties are copied to the
	//		created prototype.
	//		Add an instance-initialization function by making it a property 
	//		named "constructor".
	//	description:
	//		Create a constructor using a compact notation for inheritance and
	//		prototype extension. 
	//
	//		All superclasses (including mixins) must be Functions (not simple Objects).
	//
	//		Mixin ancestors provide a type of multiple inheritance. Prototypes of mixin 
	//		ancestors are copied to the new class: changes to mixin prototypes will
	//		not affect classes to which they have been mixed in.
	//
	//		"className" is cached in "declaredClass" property of the new class.
	//
	//	example:
	//	|	dojo.declare("my.classes.bar", my.classes.foo, {
	//	|		// properties to be added to the class prototype
	//	|		someValue: 2,
	//	|		// initialization function
	//	|		constructor: function(){
	//	|			this.myComplicatedObject = new ReallyComplicatedObject(); 
	//	|		},
	//	|		// other functions
	//	|		someMethod: function(){ 
	//	|			doStuff(); 
	//	|		}
	//	|	);

	// process superclass argument
	var dd = arguments.callee, mixins;
	if(dojo.isArray(superclass)){
		mixins = superclass;
		superclass = mixins.shift();
	}
	// construct intermediate classes for mixins
	if(mixins){
		dojo.forEach(mixins, function(m, i){
			if(!m){ throw(className + ": mixin #" + i + " is null"); } // It's likely a required module is not loaded
			superclass = dd._delegate(superclass, m);
		});
	}
	// create constructor
	var ctor = dd._delegate(superclass);
	// extend with "props"
	props = props || {};
	ctor.extend(props);
	// more prototype decoration
	dojo.extend(ctor, {declaredClass: className, _constructor: props.constructor/*, preamble: null*/});
	// special help for IE
	ctor.prototype.constructor = ctor;
	// create named reference
	return dojo.setObject(className, ctor); // Function
};

dojo.mixin(dojo.declare, {
	_delegate: function(base, mixin){
		var bp = (base||0).prototype, mp = (mixin||0).prototype, dd=dojo.declare;
		// fresh constructor, fresh prototype
		var ctor = dd._makeCtor();
		// cache ancestry
		dojo.mixin(ctor, {superclass: bp, mixin: mp, extend: dd._extend});
		// chain prototypes
		if(base){ctor.prototype = dojo._delegate(bp);}
		// add mixin and core
		dojo.extend(ctor, dd._core, mp||0, {_constructor: null, preamble: null});
		// special help for IE
		ctor.prototype.constructor = ctor;
		// name this class for debugging
		ctor.prototype.declaredClass = (bp||0).declaredClass + '_' + (mp||0).declaredClass;
		return ctor;
	},
	_extend: function(props){
		var i, fn;
		for(i in props){ if(dojo.isFunction(fn=props[i]) && !0[i]){fn.nom=i;fn.ctor=this;} }
		dojo.extend(this, props);
	},
	_makeCtor: function(){
		// we have to make a function, but don't want to close over anything
		return function(){ this._construct(arguments); };
	},
	_core: { 
		_construct: function(args){
			var c=args.callee, s=c.superclass, ct=s&&s.constructor, m=c.mixin, mct=m&&m.constructor, a=args, ii, fn;
			// side-effect of = used on purpose here, lint may complain, don't try this at home
			if(a[0]){ 
				// FIXME: preambles for each mixin should be allowed
				// FIXME: 
				//		should we allow the preamble here NOT to modify the
				//		default args, but instead to act on each mixin
				//		independently of the class instance being constructed
				//		(for impedence matching)?

				// allow any first argument w/ a "preamble" property to act as a
				// class preamble (not exclusive of the prototype preamble)
				if(/*dojo.isFunction*/((fn = a[0].preamble))){ 
					a = fn.apply(this, a) || a; 
				}
			} 
			// prototype preamble
			if((fn = c.prototype.preamble)){a = fn.apply(this, a) || a;}
			// FIXME: 
			//		need to provide an optional prototype-settable
			//		"_explicitSuper" property which disables this
			// initialize superclass
			if(ct&&ct.apply){ct.apply(this, a);}
			// initialize mixin
			if(mct&&mct.apply){mct.apply(this, a);}
			// initialize self
			if((ii=c.prototype._constructor)){ii.apply(this, args);}
			// post construction
			if(this.constructor.prototype==c.prototype && (ct=this.postscript)){ ct.apply(this, args); }
		},
		_findMixin: function(mixin){
			var c = this.constructor, p, m;
			while(c){
				p = c.superclass;
				m = c.mixin;
				if(m==mixin || (m instanceof mixin.constructor)){return p;}
				if(m && m._findMixin && (m=m._findMixin(mixin))){return m;}
				c = p && p.constructor;
			}
		},
		_findMethod: function(name, method, ptype, has){
			// consciously trading readability for bytes and speed in this low-level method
			var p=ptype, c, m, f;
			do{
				c = p.constructor;
				m = c.mixin;
				// find method by name in our mixin ancestor
				if(m && (m=this._findMethod(name, method, m, has))){return m;}
				// if we found a named method that either exactly-is or exactly-is-not 'method'
				if((f=p[name])&&(has==(f==method))){return p;}
				// ascend chain
				p = c.superclass;
			}while(p);
			// if we couldn't find an ancestor in our primary chain, try a mixin chain
			return !has && (p=this._findMixin(ptype)) && this._findMethod(name, method, p, has);
		},
		inherited: function(name, args, newArgs){
			// optionalize name argument
			var a = arguments;
			if(!dojo.isString(a[0])){newArgs=args; args=name; name=args.callee.nom;}
			a = newArgs||args;
			var c = args.callee, p = this.constructor.prototype, fn, mp;
			// if not an instance override
			if(this[name] != c || p[name] == c){
				// start from memoized prototype, or
				// find a prototype that has property 'name' == 'c'
				mp = (c.ctor||0).superclass || this._findMethod(name, c, p, true);
				if(!mp){throw(this.declaredClass + ': inherited method "' + name + '" mismatch');}
				// find a prototype that has property 'name' != 'c'
				p = this._findMethod(name, c, mp, false);
			}
			// we expect 'name' to be in prototype 'p'
			fn = p && p[name];
			if(!fn){throw(mp.declaredClass + ': inherited method "' + name + '" not found');}
			// if the function exists, invoke it in our scope
			return fn.apply(this, a);
		}
	}
});

}

if(!dojo._hasResource["dojo._base.connect"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo._base.connect"] = true;
dojo.provide("dojo._base.connect");


// this file courtesy of the TurboAjax Group, licensed under a Dojo CLA

// low-level delegation machinery
dojo._listener = {
	// create a dispatcher function
	getDispatcher: function(){
		// following comments pulled out-of-line to prevent cloning them 
		// in the returned function.
		// - indices (i) that are really in the array of listeners (ls) will 
		//   not be in Array.prototype. This is the 'sparse array' trick
		//   that keeps us safe from libs that take liberties with built-in 
		//   objects
		// - listener is invoked with current scope (this)
		return function(){
			var ap=Array.prototype, c=arguments.callee, ls=c._listeners, t=c.target;
			// return value comes from original target function
			var r = t && t.apply(this, arguments);
			// make local copy of listener array so it is immutable during processing
			var lls;
											lls = [].concat(ls);
							
			// invoke listeners after target function
			for(var i in lls){
				if(!(i in ap)){
					lls[i].apply(this, arguments);
				}
			}
			// return value comes from original target function
			return r;
		}
	},
	// add a listener to an object
	add: function(/*Object*/ source, /*String*/ method, /*Function*/ listener){
		// Whenever 'method' is invoked, 'listener' will have the same scope.
		// Trying to supporting a context object for the listener led to 
		// complexity. 
		// Non trivial to provide 'once' functionality here
		// because listener could be the result of a dojo.hitch call,
		// in which case two references to the same hitch target would not
		// be equivalent. 
		source = source || dojo.global;
		// The source method is either null, a dispatcher, or some other function
		var f = source[method];
		// Ensure a dispatcher
		if(!f||!f._listeners){
			var d = dojo._listener.getDispatcher();
			// original target function is special
			d.target = f;
			// dispatcher holds a list of listeners
			d._listeners = []; 
			// redirect source to dispatcher
			f = source[method] = d;
		}
		// The contract is that a handle is returned that can 
		// identify this listener for disconnect. 
		//
		// The type of the handle is private. Here is it implemented as Integer. 
		// DOM event code has this same contract but handle is Function 
		// in non-IE browsers.
		//
		// We could have separate lists of before and after listeners.
		return f._listeners.push(listener) ; /*Handle*/
	},
	// remove a listener from an object
	remove: function(/*Object*/ source, /*String*/ method, /*Handle*/ handle){
		var f = (source||dojo.global)[method];
		// remember that handle is the index+1 (0 is not a valid handle)
		if(f && f._listeners && handle--){
			delete f._listeners[handle];
		}
	}
};

// Multiple delegation for arbitrary methods.

// This unit knows nothing about DOM, 
// but we include DOM aware 
// documentation and dontFix
// argument here to help the autodocs.
// Actual DOM aware code is in event.js.

dojo.connect = function(/*Object|null*/ obj, 
						/*String*/ event, 
						/*Object|null*/ context, 
						/*String|Function*/ method,
						/*Boolean*/ dontFix){
	// summary:
	//		Create a link that calls one function when another executes. 
	//
	// description:
	//		Connects method to event, so that after event fires, method
	//		does too. All connected functions are passed the same arguments as
	//		the event function was initially called with. You may connect as
	//		many methods to event as needed.
	//
	//		event must be a string. If obj is null, dojo.global is used.
	//
	//		null arguments may simply be omitted.
	//
	//		obj[event] can resolve to a function or undefined (null). 
	//		If obj[event] is null, it is assigned a function.
	//
	//		The return value is a handle that is needed to 
	//		remove this connection with dojo.disconnect.
	//
	// obj: 
	//		The source object for the event function. 
	//		Defaults to dojo.global if null.
	//		If obj is a DOM node, the connection is delegated 
	//		to the DOM event manager (unless dontFix is true).
	//
	// event:
	//		String name of the event function in obj. 
	//		I.e. identifies a property obj[event].
	//
	// context: 
	//		The object that method will receive as "this".
	//
	//		If context is null and method is a function, then method
	//		inherits the context of event.
	//	
	//		If method is a string then context must be the source 
	//		object object for method (context[method]). If context is null,
	//		dojo.global is used.
	//
	// method:
	//		A function reference, or name of a function in context. 
	//		The function identified by method fires after event does. 
	//		method receives the same arguments as the event.
	//		See context argument comments for information on method's scope.
	//
	// dontFix:
	//		If obj is a DOM node, set dontFix to true to prevent delegation 
	//		of this connection to the DOM event manager. 
	//
	// example:
	//		When obj.onchange(), do ui.update():
	//	|	dojo.connect(obj, "onchange", ui, "update");
	//	|	dojo.connect(obj, "onchange", ui, ui.update); // same
	//
	// example:
	//		Using return value for disconnect:
	//	|	var link = dojo.connect(obj, "onchange", ui, "update");
	//	|	...
	//	|	dojo.disconnect(link);
	//
	// example:
	//		When onglobalevent executes, watcher.handler is invoked:
	//	|	dojo.connect(null, "onglobalevent", watcher, "handler");
	//
	// example:
	//		When ob.onCustomEvent executes, customEventHandler is invoked:
	//	|	dojo.connect(ob, "onCustomEvent", null, "customEventHandler");
	//	|	dojo.connect(ob, "onCustomEvent", "customEventHandler"); // same
	//
	// example:
	//		When ob.onCustomEvent executes, customEventHandler is invoked
	//		with the same scope (this):
	//	|	dojo.connect(ob, "onCustomEvent", null, customEventHandler);
	//	|	dojo.connect(ob, "onCustomEvent", customEventHandler); // same
	//
	// example:
	//		When globalEvent executes, globalHandler is invoked
	//		with the same scope (this):
	//	|	dojo.connect(null, "globalEvent", null, globalHandler);
	//	|	dojo.connect("globalEvent", globalHandler); // same

	// normalize arguments
	var a=arguments, args=[], i=0;
	// if a[0] is a String, obj was ommited
	args.push(dojo.isString(a[0]) ? null : a[i++], a[i++]);
	// if the arg-after-next is a String or Function, context was NOT omitted
	var a1 = a[i+1];
	args.push(dojo.isString(a1)||dojo.isFunction(a1) ? a[i++] : null, a[i++]);
	// absorb any additional arguments
	for(var l=a.length; i<l; i++){	args.push(a[i]); }
	// do the actual work
	return dojo._connect.apply(this, args); /*Handle*/
}

// used by non-browser hostenvs. always overriden by event.js
dojo._connect = function(obj, event, context, method){
	var l=dojo._listener, h=l.add(obj, event, dojo.hitch(context, method)); 
	return [obj, event, h, l]; // Handle
}

dojo.disconnect = function(/*Handle*/ handle){
	// summary:
	//		Remove a link created by dojo.connect.
	// description:
	//		Removes the connection between event and the method referenced by handle.
	// handle:
	//		the return value of the dojo.connect call that created the connection.
	if(handle && handle[0] !== undefined){
		dojo._disconnect.apply(this, handle);
		// let's not keep this reference
		delete handle[0];
	}
}

dojo._disconnect = function(obj, event, handle, listener){
	listener.remove(obj, event, handle);
}

// topic publish/subscribe

dojo._topics = {};

dojo.subscribe = function(/*String*/ topic, /*Object|null*/ context, /*String|Function*/ method){
	//	summary:
	//		Attach a listener to a named topic. The listener function is invoked whenever the
	//		named topic is published (see: dojo.publish).
	//		Returns a handle which is needed to unsubscribe this listener.
	//	context:
	//		Scope in which method will be invoked, or null for default scope.
	//	method:
	//		The name of a function in context, or a function reference. This is the function that
	//		is invoked when topic is published.
	//	example:
	//	|	dojo.subscribe("alerts", null, function(caption, message){ alert(caption + "\n" + message); });
	//	|	dojo.publish("alerts", [ "read this", "hello world" ]);																	

	// support for 2 argument invocation (omitting context) depends on hitch
	return [topic, dojo._listener.add(dojo._topics, topic, dojo.hitch(context, method))]; /*Handle*/
}

dojo.unsubscribe = function(/*Handle*/ handle){
	//	summary:
	//	 	Remove a topic listener. 
	//	handle:
	//	 	The handle returned from a call to subscribe.
	//	example:
	//	|	var alerter = dojo.subscribe("alerts", null, function(caption, message){ alert(caption + "\n" + message); };
	//	|	...
	//	|	dojo.unsubscribe(alerter);
	if(handle){
		dojo._listener.remove(dojo._topics, handle[0], handle[1]);
	}
}

dojo.publish = function(/*String*/ topic, /*Array*/ args){
	//	summary:
	//	 	Invoke all listener method subscribed to topic.
	//	topic:
	//	 	The name of the topic to publish.
	//	args:
	//	 	An array of arguments. The arguments will be applied 
	//	 	to each topic subscriber (as first class parameters, via apply).
	//	example:
	//	|	dojo.subscribe("alerts", null, function(caption, message){ alert(caption + "\n" + message); };
	//	|	dojo.publish("alerts", [ "read this", "hello world" ]);	

	// Note that args is an array, which is more efficient vs variable length
	// argument list.  Ideally, var args would be implemented via Array
	// throughout the APIs.
	var f = dojo._topics[topic];
	if(f){
		f.apply(this, args||[]);
	}
}

dojo.connectPublisher = function(	/*String*/ topic, 
									/*Object|null*/ obj, 
									/*String*/ event){
	//	summary:
	//	 	Ensure that everytime obj.event() is called, a message is published
	//	 	on the topic. Returns a handle which can be passed to
	//	 	dojo.disconnect() to disable subsequent automatic publication on
	//	 	the topic.
	//	topic:
	//	 	The name of the topic to publish.
	//	obj: 
	//	 	The source object for the event function. Defaults to dojo.global
	//	 	if null.
	//	event:
	//	 	The name of the event function in obj. 
	//	 	I.e. identifies a property obj[event].
	//	example:
	//	|	dojo.connectPublisher("/ajax/start", dojo, "xhrGet");
	var pf = function(){ dojo.publish(topic, arguments); }
	return (event) ? dojo.connect(obj, event, pf) : dojo.connect(obj, pf); //Handle
};

}

if(!dojo._hasResource["dojo._base.Deferred"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo._base.Deferred"] = true;
dojo.provide("dojo._base.Deferred");


dojo.Deferred = function(/*Function?*/ canceller){
	// summary:
	//		Encapsulates a sequence of callbacks in response to a value that
	//		may not yet be available.  This is modeled after the Deferred class
	//		from Twisted <http://twistedmatrix.com>.
	// description:
	//		JavaScript has no threads, and even if it did, threads are hard.
	//		Deferreds are a way of abstracting non-blocking events, such as the
	//		final response to an XMLHttpRequest. Deferreds create a promise to
	//		return a response a some point in the future and an easy way to
	//		register your interest in receiving that response.
	//
	//		The most important methods for Deffered users are:
	//
	//			* addCallback(handler)
	//			* addErrback(handler)
	//			* callback(result)
	//			* errback(result)
	//
	//		In general, when a function returns a Deferred, users then "fill
	//		in" the second half of the contract by registering callbacks and
	//		error handlers. You may register as many callback and errback
	//		handlers as you like and they will be executed in the order
	//		registered when a result is provided. Usually this result is
	//		provided as the result of an asynchronous operation. The code
	//		"managing" the Deferred (the code that made the promise to provide
	//		an answer later) will use the callback() and errback() methods to
	//		communicate with registered listeners about the result of the
	//		operation. At this time, all registered result handlers are called
	//		*with the most recent result value*.
	//
	//		Deferred callback handlers are treated as a chain, and each item in
	//		the chain is required to return a value that will be fed into
	//		successive handlers. The most minimal callback may be registered
	//		like this:
	//
	//		|	var d = new dojo.Deferred();
	//		|	d.addCallback(function(result){ return result; });
	//
	//		Perhaps the most common mistake when first using Deferreds is to
	//		forget to return a value (in most cases, the value you were
	//		passed).
	//
	//		The sequence of callbacks is internally represented as a list of
	//		2-tuples containing the callback/errback pair.  For example, the
	//		following call sequence:
	//		
	//		|	var d = new dojo.Deferred();
	//		|	d.addCallback(myCallback);
	//		|	d.addErrback(myErrback);
	//		|	d.addBoth(myBoth);
	//		|	d.addCallbacks(myCallback, myErrback);
	//
	//		is translated into a Deferred with the following internal
	//		representation:
	//
	//		|	[
	//		|		[myCallback, null],
	//		|		[null, myErrback],
	//		|		[myBoth, myBoth],
	//		|		[myCallback, myErrback]
	//		|	]
	//
	//		The Deferred also keeps track of its current status (fired).  Its
	//		status may be one of three things:
	//
	//			* -1: no value yet (initial condition)
	//			* 0: success
	//			* 1: error
	//	
	//		A Deferred will be in the error state if one of the following three
	//		conditions are met:
	//
	//			1. The result given to callback or errback is "instanceof" Error
	//			2. The previous callback or errback raised an exception while
	//			   executing
	//			3. The previous callback or errback returned a value
	//			   "instanceof" Error
	//
	//		Otherwise, the Deferred will be in the success state. The state of
	//		the Deferred determines the next element in the callback sequence
	//		to run.
	//
	//		When a callback or errback occurs with the example deferred chain,
	//		something equivalent to the following will happen (imagine
	//		that exceptions are caught and returned):
	//
	//		|	// d.callback(result) or d.errback(result)
	//		|	if(!(result instanceof Error)){
	//		|		result = myCallback(result);
	//		|	}
	//		|	if(result instanceof Error){
	//		|		result = myErrback(result);
	//		|	}
	//		|	result = myBoth(result);
	//		|	if(result instanceof Error){
	//		|		result = myErrback(result);
	//		|	}else{
	//		|		result = myCallback(result);
	//		|	}
	//
	//		The result is then stored away in case another step is added to the
	//		callback sequence.	Since the Deferred already has a value
	//		available, any new callbacks added will be called immediately.
	//
	//		There are two other "advanced" details about this implementation
	//		that are useful:
	//
	//		Callbacks are allowed to return Deferred instances themselves, so
	//		you can build complicated sequences of events with ease.
	//
	//		The creator of the Deferred may specify a canceller.  The canceller
	//		is a function that will be called if Deferred.cancel is called
	//		before the Deferred fires. You can use this to implement clean
	//		aborting of an XMLHttpRequest, etc. Note that cancel will fire the
	//		deferred with a CancelledError (unless your canceller returns
	//		another kind of error), so the errbacks should be prepared to
	//		handle that error for cancellable Deferreds.
	// example:
	//	|	var deferred = new dojo.Deferred();
	//	|	setTimeout(function(){ deferred.callback({success: true}); }, 1000);
	//	|	return deferred;
	// example:
	//		Deferred objects are often used when making code asynchronous. It
	//		may be easiest to write functions in a synchronous manner and then
	//		split code using a deferred to trigger a response to a long-lived
	//		operation. For example, instead of register a callback function to
	//		denote when a rendering operation completes, the function can
	//		simply return a deferred:
	//
	//		|	// callback style:
	//		|	function renderLotsOfData(data, callback){
	//		|		var success = false
	//		|		try{
	//		|			for(var x in data){
	//		|				renderDataitem(data[x]);
	//		|			}
	//		|			success = true;
	//		|		}catch(e){ }
	//		|		if(callback){
	//		|			callback(success);
	//		|		}
	//		|	}
	//
	//		|	// using callback style
	//		|	renderLotsOfData(someDataObj, function(success){
	//		|		// handles success or failure
	//		|		if(!success){
	//		|			promptUserToRecover();
	//		|		}
	//		|	});
	//		|	// NOTE: no way to add another callback here!!
	// example:
	//		Using a Deferred doesn't simplify the sending code any, but it
	//		provides a standard interface for callers and senders alike,
	//		providing both with a simple way to service multiple callbacks for
	//		an operation and freeing both sides from worrying about details
	//		such as "did this get called already?". With Deferreds, new
	//		callbacks can be added at any time.
	//
	//		|	// Deferred style:
	//		|	function renderLotsOfData(data){
	//		|		var d = new dojo.Deferred();
	//		|		try{
	//		|			for(var x in data){
	//		|				renderDataitem(data[x]);
	//		|			}
	//		|			d.callback(true);
	//		|		}catch(e){ 
	//		|			d.errback(new Error("rendering failed"));
	//		|		}
	//		|		return d;
	//		|	}
	//
	//		|	// using Deferred style
	//		|	renderLotsOfData(someDataObj).addErrback(function(){
	//		|		promptUserToRecover();
	//		|	});
	//		|	// NOTE: addErrback and addCallback both return the Deferred
	//		|	// again, so we could chain adding callbacks or save the
	//		|	// deferred for later should we need to be notified again.
	// example:
	//		In this example, renderLotsOfData is syncrhonous and so both
	//		versions are pretty artificial. Putting the data display on a
	//		timeout helps show why Deferreds rock:
	//
	//		|	// Deferred style and async func
	//		|	function renderLotsOfData(data){
	//		|		var d = new dojo.Deferred();
	//		|		setTimeout(function(){
	//		|			try{
	//		|				for(var x in data){
	//		|					renderDataitem(data[x]);
	//		|				}
	//		|				d.callback(true);
	//		|			}catch(e){ 
	//		|				d.errback(new Error("rendering failed"));
	//		|			}
	//		|		}, 100);
	//		|		return d;
	//		|	}
	//
	//		|	// using Deferred style
	//		|	renderLotsOfData(someDataObj).addErrback(function(){
	//		|		promptUserToRecover();
	//		|	});
	//
	//		Note that the caller doesn't have to change his code at all to
	//		handle the asynchronous case.

	this.chain = [];
	this.id = this._nextId();
	this.fired = -1;
	this.paused = 0;
	this.results = [null, null];
	this.canceller = canceller;
	this.silentlyCancelled = false;
};

dojo.extend(dojo.Deferred, {
	/*
	makeCalled: function(){
		// summary:
		//		returns a new, empty deferred, which is already in the called
		//		state. Calling callback() or errback() on this deferred will
		//		yeild an error and adding new handlers to it will result in
		//		them being called immediately.
		var deferred = new dojo.Deferred();
		deferred.callback();
		return deferred;
	},

	toString: function(){
		var state;
		if(this.fired == -1){
			state = 'unfired';
		}else{
			state = this.fired ? 'success' : 'error';
		}
		return 'Deferred(' + this.id + ', ' + state + ')';
	},
	*/

	_nextId: (function(){
		var n = 1;
		return function(){ return n++; };
	})(),

	cancel: function(){
		// summary:	
		//		Cancels a Deferred that has not yet received a value, or is
		//		waiting on another Deferred as its value.
		// description:
		//		If a canceller is defined, the canceller is called. If the
		//		canceller did not return an error, or there was no canceller,
		//		then the errback chain is started.
		var err;
		if(this.fired == -1){
			if(this.canceller){
				err = this.canceller(this);
			}else{
				this.silentlyCancelled = true;
			}
			if(this.fired == -1){
				if(!(err instanceof Error)){
					var res = err;
					var msg = "Deferred Cancelled";
					if(err && err.toString){
						msg += ": " + err.toString();
					}
					err = new Error(msg);
					err.dojoType = "cancel";
					err.cancelResult = res;
				}
				this.errback(err);
			}
		}else if(	(this.fired == 0) &&
					(this.results[0] instanceof dojo.Deferred)
		){
			this.results[0].cancel();
		}
	},
			

	_resback: function(res){
		// summary:
		//		The private primitive that means either callback or errback
		this.fired = ((res instanceof Error) ? 1 : 0);
		this.results[this.fired] = res;
		this._fire();
	},

	_check: function(){
		if(this.fired != -1){
			if(!this.silentlyCancelled){
				throw new Error("already called!");
			}
			this.silentlyCancelled = false;
			return;
		}
	},

	callback: function(res){
		//	summary:	
		//		Begin the callback sequence with a non-error value.
		
		/*
		callback or errback should only be called once on a given
		Deferred.
		*/
		this._check();
		this._resback(res);
	},

	errback: function(/*Error*/res){
		//	summary: 
		//		Begin the callback sequence with an error result.
		this._check();
		if(!(res instanceof Error)){
			res = new Error(res);
		}
		this._resback(res);
	},

	addBoth: function(/*Function|Object*/cb, /*String?*/cbfn){
		//	summary:
		//		Add the same function as both a callback and an errback as the
		//		next element on the callback sequence.This is useful for code
		//		that you want to guarantee to run, e.g. a finalizer.
		var enclosed = dojo.hitch.apply(dojo, arguments);
		return this.addCallbacks(enclosed, enclosed); // dojo.Deferred
	},

	addCallback: function(/*Function|Object*/cb, /*String?*/cbfn /*...*/){
		//	summary: 
		//		Add a single callback to the end of the callback sequence.
		return this.addCallbacks(dojo.hitch.apply(dojo, arguments)); // dojo.Deferred
	},

	addErrback: function(cb, cbfn){
		//	summary: 
		//		Add a single callback to the end of the callback sequence.
		return this.addCallbacks(null, dojo.hitch.apply(dojo, arguments)); // dojo.Deferred
	},

	addCallbacks: function(cb, eb){
		// summary: 
		//		Add separate callback and errback to the end of the callback
		//		sequence.
		this.chain.push([cb, eb])
		if(this.fired >= 0){
			this._fire();
		}
		return this; // dojo.Deferred
	},

	_fire: function(){
		// summary: 
		//		Used internally to exhaust the callback sequence when a result
		//		is available.
		var chain = this.chain;
		var fired = this.fired;
		var res = this.results[fired];
		var self = this;
		var cb = null;
		while(
			(chain.length > 0) &&
			(this.paused == 0)
		){
			// Array
			var f = chain.shift()[fired];
			if(!f){ continue; }
			var func = function(){
				var ret = f(res);
				//If no response, then use previous response.
				if(typeof ret != "undefined"){
					res = ret;
				}
				fired = ((res instanceof Error) ? 1 : 0);
				if(res instanceof dojo.Deferred){
					cb = function(res){
						self._resback(res);
						// inlined from _pause()
						self.paused--;
						if(
							(self.paused == 0) && 
							(self.fired >= 0)
						){
							self._fire();
						}
					}
					// inlined from _unpause
					this.paused++;
				}
			};
			if(dojo.config.debugAtAllCosts){
				func.call(this);
			}else{
				try{
					func.call(this);
				}catch(err){
					fired = 1;
					res = err;
				}
			}
		}
		this.fired = fired;
		this.results[fired] = res;
		if((cb)&&(this.paused)){
			// this is for "tail recursion" in case the dependent
			// deferred is already fired
			res.addBoth(cb);
		}
	}
});

}

if(!dojo._hasResource["dojo._base.json"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo._base.json"] = true;
dojo.provide("dojo._base.json");

dojo.fromJson = function(/*String*/ json){
	// summary:
	// 		Parses a [JSON](http://json.org) string to return a JavaScript object.  Throws for invalid JSON strings.
	// json: 
	//		a string literal of a JSON item, for instance:
	//			`'{ "foo": [ "bar", 1, { "baz": "thud" } ] }'`

	return eval("(" + json + ")"); // Object
}

dojo._escapeString = function(/*String*/str){
	//summary:
	//		Adds escape sequences for non-visual characters, double quote and
	//		backslash and surrounds with double quotes to form a valid string
	//		literal.
	return ('"' + str.replace(/(["\\])/g, '\\$1') + '"').
		replace(/[\f]/g, "\\f").replace(/[\b]/g, "\\b").replace(/[\n]/g, "\\n").
		replace(/[\t]/g, "\\t").replace(/[\r]/g, "\\r"); // string
}

dojo.toJsonIndentStr = "\t";
dojo.toJson = function(/*Object*/ it, /*Boolean?*/ prettyPrint, /*String?*/ _indentStr){
	// summary:
	//		Returns a [JSON](http://json.org) serialization of an object.
	//
	// description:
	//		Returns a [JSON](http://json.org) serialization of an object.
	//		Note that this doesn't check for infinite recursion, so don't do that!
	//
	// it:
	//		an object to be serialized. Objects may define their own
	//		serialization via a special "__json__" or "json" function
	//		property. If a specialized serializer has been defined, it will
	//		be used as a fallback.
	//
	// prettyPrint:
	//		if true, we indent objects and arrays to make the output prettier.
	//		The variable dojo.toJsonIndentStr is used as the indent string 
	//		-- to use something other than the default (tab), 
	//		change that variable before calling dojo.toJson().
	//
	// _indentStr:
	//		private variable for recursive calls when pretty printing, do not use.

	if(it === undefined){
		return "undefined";
	}
	var objtype = typeof it;
	if(objtype == "number" || objtype == "boolean"){
		return it + "";
	}
	if(it === null){
		return "null";
	}
	if(dojo.isString(it)){ 
		return dojo._escapeString(it); 
	}
	// recurse
	var recurse = arguments.callee;
	// short-circuit for objects that support "json" serialization
	// if they return "self" then just pass-through...
	var newObj;
	_indentStr = _indentStr || "";
	var nextIndent = prettyPrint ? _indentStr + dojo.toJsonIndentStr : "";
	var tf = it.__json__||it.json;
	if(dojo.isFunction(tf)){
		newObj = tf.call(it);
		if(it !== newObj){
			return recurse(newObj, prettyPrint, nextIndent);
		}
	}
	if(it.nodeType && it.cloneNode){ // isNode
		// we can't seriailize DOM nodes as regular objects because they have cycles
		// DOM nodes could be serialized with something like outerHTML, but
		// that can be provided by users in the form of .json or .__json__ function.
		throw new Error("Can't serialize DOM nodes");
	}

	var sep = prettyPrint ? " " : "";
	var newLine = prettyPrint ? "\n" : "";

	// array
	if(dojo.isArray(it)){
		var res = dojo.map(it, function(obj){
			var val = recurse(obj, prettyPrint, nextIndent);
			if(typeof val != "string"){
				val = "undefined";
			}
			return newLine + nextIndent + val;
		});
		return "[" + res.join("," + sep) + newLine + _indentStr + "]";
	}
	/*
	// look in the registry
	try {
		window.o = it;
		newObj = dojo.json.jsonRegistry.match(it);
		return recurse(newObj, prettyPrint, nextIndent);
	}catch(e){
		// console.log(e);
	}
	// it's a function with no adapter, skip it
	*/
	if(objtype == "function"){
		return null; // null
	}
	// generic object code path
	var output = [], key;
	for(key in it){
		var keyStr, val;
		if(typeof key == "number"){
			keyStr = '"' + key + '"';
		}else if(typeof key == "string"){
			keyStr = dojo._escapeString(key);
		}else{
			// skip non-string or number keys
			continue;
		}
		val = recurse(it[key], prettyPrint, nextIndent);
		if(typeof val != "string"){
			// skip non-serializable values
			continue;
		}
		// FIXME: use += on Moz!!
		//	 MOW NOTE: using += is a pain because you have to account for the dangling comma...
		output.push(newLine + nextIndent + keyStr + ":" + sep + val);
	}
	return "{" + output.join("," + sep) + newLine + _indentStr + "}"; // String
}

}

if(!dojo._hasResource["dojo._base.array"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo._base.array"] = true;

dojo.provide("dojo._base.array");

(function(){
	var _getParts = function(arr, obj, cb){
		return [ 
			dojo.isString(arr) ? arr.split("") : arr, 
			obj || dojo.global,
			// FIXME: cache the anonymous functions we create here?
			dojo.isString(cb) ? new Function("item", "index", "array", cb) : cb
		];
	};

	dojo.mixin(dojo, {
		indexOf: function(	/*Array*/		array, 
							/*Object*/		value,
							/*Integer?*/	fromIndex,
							/*Boolean?*/	findLast){
			// summary:
			//		locates the first index of the provided value in the
			//		passed array. If the value is not found, -1 is returned.
			// description:
			//		For details on this method, see:
			// 			http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:indexOf

			var step = 1, end = array.length || 0, i = 0;
			if(findLast){
				i = end - 1;
				step = end = -1;
			}
			if(fromIndex != undefined){ i = fromIndex; }
			if((findLast && i > end) || i < end){
				for(; i != end; i += step){
					if(array[i] == value){ return i; }
				}
			}
			return -1;	// Number
		},

		lastIndexOf: function(/*Array*/array, /*Object*/value, /*Integer?*/fromIndex){
			// summary:
			//		locates the last index of the provided value in the passed
			//		array. If the value is not found, -1 is returned.
			// description:
			//		For details on this method, see:
			// 			http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:lastIndexOf
			return dojo.indexOf(array, value, fromIndex, true); // Number
		},

		forEach: function(/*Array|String*/arr, /*Function|String*/callback, /*Object?*/thisObject){
			//	summary:
			//		for every item in arr, callback is invoked. Return values are ignored.
			//	arr:
			//		the array to iterate over. If a string, operates on individual characters.
			//	callback:
			//		a function is invoked with three arguments: item, index, and array
			//	thisObject:
			//		may be used to scope the call to callback
			//	description:
			//		This function corresponds to the JavaScript 1.6
			//		Array.forEach() method. For more details, see:
			//			http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:forEach
			//	example:
			//	|	// log out all members of the array:
			//	|	dojo.forEach(
			//	|		[ "thinger", "blah", "howdy", 10 ],
			//	|		function(item){
			//	|			console.log(item);
			//	|		}
			//	|	);
			//	example:
			//	|	// log out the members and their indexes
			//	|	dojo.forEach(
			//	|		[ "thinger", "blah", "howdy", 10 ],
			//	|		function(item, idx, arr){
			//	|			console.log(item, "at index:", idx);
			//	|		}
			//	|	);
			//	example:
			//	|	// use a scoped object member as the callback
			//	|	
			//	|	var obj = {
			//	|		prefix: "logged via obj.callback:", 
			//	|		callback: function(item){
			//	|			console.log(this.prefix, item);
			//	|		}
			//	|	};
			//	|	
			//	|	// specifying the scope function executes the callback in that scope
			//	|	dojo.forEach(
			//	|		[ "thinger", "blah", "howdy", 10 ],
			//	|		obj.callback,
			//	|		obj
			//	|	);
			//	|	
			//	|	// alternately, we can accomplish the same thing with dojo.hitch()
			//	|	dojo.forEach(
			//	|		[ "thinger", "blah", "howdy", 10 ],
			//	|		dojo.hitch(obj, "callback")
			//	|	);

			// match the behavior of the built-in forEach WRT empty arrs
			if(!arr || !arr.length){ return; }

			// FIXME: there are several ways of handilng thisObject. Is
			// dojo.global always the default context?
			var _p = _getParts(arr, thisObject, callback); arr = _p[0];
			for(var i=0,l=arr.length; i<l; ++i){ 
				_p[2].call(_p[1], arr[i], i, arr);
			}
		},

		_everyOrSome: function(/*Boolean*/every, /*Array|String*/arr, /*Function|String*/callback, /*Object?*/thisObject){
			var _p = _getParts(arr, thisObject, callback); arr = _p[0];
			for(var i=0,l=arr.length; i<l; ++i){
				var result = !!_p[2].call(_p[1], arr[i], i, arr);
				if(every ^ result){
					return result; // Boolean
				}
			}
			return every; // Boolean
		},

		every: function(/*Array|String*/arr, /*Function|String*/callback, /*Object?*/thisObject){
			// summary:
			//		Determines whether or not every item in arr satisfies the
			//		condition implemented by callback.
			// arr:
			//		the array to iterate on. If a string, operates on individual characters.
			// callback:
			//		a function is invoked with three arguments: item, index,
			//		and array and returns true if the condition is met.
			// thisObject:
			//		may be used to scope the call to callback
			// description:
			//		This function corresponds to the JavaScript 1.6
			//		Array.every() method. For more details, see:
			//			http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:every
			// example:
			//	|	// returns false
			//	|	dojo.every([1, 2, 3, 4], function(item){ return item>1; });
			// example:
			//	|	// returns true 
			//	|	dojo.every([1, 2, 3, 4], function(item){ return item>0; });
			return dojo._everyOrSome(true, arr, callback, thisObject); // Boolean
		},

		some: function(/*Array|String*/arr, /*Function|String*/callback, /*Object?*/thisObject){
			// summary:
			//		Determines whether or not any item in arr satisfies the
			//		condition implemented by callback.
			// arr:
			//		the array to iterate over. If a string, operates on individual characters.
			// callback:
			//		a function is invoked with three arguments: item, index,
			//		and array and returns true if the condition is met.
			// thisObject:
			//		may be used to scope the call to callback
			// description:
			//		This function corresponds to the JavaScript 1.6
			//		Array.some() method. For more details, see:
			//			http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:some
			// example:
			//	|	// is true
			//	|	dojo.some([1, 2, 3, 4], function(item){ return item>1; });
			// example:
			//	|	// is false
			//	|	dojo.some([1, 2, 3, 4], function(item){ return item<1; });
			return dojo._everyOrSome(false, arr, callback, thisObject); // Boolean
		},

		map: function(/*Array|String*/arr, /*Function|String*/callback, /*Function?*/thisObject){
			// summary:
			//		applies callback to each element of arr and returns
			//		an Array with the results
			// arr:
			//		the array to iterate on. If a string, operates on
			//		individual characters.
			// callback:
			//		a function is invoked with three arguments, (item, index,
			//		array),  and returns a value
			// thisObject:
			//		may be used to scope the call to callback
			// description:
			//		This function corresponds to the JavaScript 1.6 Array.map()
			//		method. For more details, see:
			//			http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:map
			// example:
			//	|	// returns [2, 3, 4, 5]
			//	|	dojo.map([1, 2, 3, 4], function(item){ return item+1 });

			var _p = _getParts(arr, thisObject, callback); arr = _p[0];
			var outArr = (arguments[3] ? (new arguments[3]()) : []);
			for(var i=0,l=arr.length; i<l; ++i){
				outArr.push(_p[2].call(_p[1], arr[i], i, arr));
			}
			return outArr; // Array
		},

		filter: function(/*Array*/arr, /*Function|String*/callback, /*Object?*/thisObject){
			// summary:
			//		Returns a new Array with those items from arr that match the
			//		condition implemented by callback.
			// arr:
			//		the array to iterate over.
			// callback:
			//		a function that is invoked with three arguments (item,
			//		index, array). The return of this function is expected to
			//		be a boolean which determines whether the passed-in item
			//		will be included in the returned array.
			// thisObject:
			//		may be used to scope the call to callback
			// description:
			//		This function corresponds to the JavaScript 1.6
			//		Array.filter() method. For more details, see:
			//			http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:filter
			// example:
			//	|	// returns [2, 3, 4]
			//	|	dojo.filter([1, 2, 3, 4], function(item){ return item>1; });

			var _p = _getParts(arr, thisObject, callback); arr = _p[0];
			var outArr = [];
			for(var i=0,l=arr.length; i<l; ++i){
				if(_p[2].call(_p[1], arr[i], i, arr)){
					outArr.push(arr[i]);
				}
			}
			return outArr; // Array
		}
	});
})();
/*
*/

}

if(!dojo._hasResource["dojo._base.Color"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo._base.Color"] = true;
dojo.provide("dojo._base.Color");



(function(){
	
	var d = dojo;
		
	dojo.Color = function(/*Array|String|Object*/ color){
		// summary:
		//		Takes a named string, hex string, array of rgb or rgba values,
		//		an object with r, g, b, and a properties, or another `dojo.Color` object
		//		and creates a new Color instance to work from.
		//
		// example:
		// 	Work with a Color instance:
		//	| var c = new dojo.Color(); 
		//	| c.setColor([0,0,0]); // black
		//	| var hex = c.toHex(); // #000000
		//
		// example:
		//	Work with a node's color:
		//	| var color = dojo.style("someNode", "backgroundColor");
		//	| var n = new dojo.Color(color);
		//	| // adjust the color some
		//	| n.r *= .5; 
		//  | console.log(n.toString()); // rgb(128, 255, 255);
		if(color){ this.setColor(color); }
	};

	// FIXME: there's got to be a more space-efficient way to encode or discover these!!  Use hex?
	dojo.Color.named = {
		black:      [0,0,0],
		silver:     [192,192,192],
		gray:       [128,128,128],
		white:      [255,255,255],
		maroon:		[128,0,0],
		red:        [255,0,0],
		purple:		[128,0,128],
		fuchsia:	[255,0,255],
		green:	    [0,128,0],
		lime:	    [0,255,0],
		olive:		[128,128,0],
		yellow:		[255,255,0],
		navy:       [0,0,128],
		blue:       [0,0,255],
		teal:		[0,128,128],
		aqua:		[0,255,255]
	};

	dojo.extend(dojo.Color, {
		r: 255, g: 255, b: 255, a: 1,
		_set: function(r, g, b, a){
			var t = this; t.r = r; t.g = g; t.b = b; t.a = a;
		},
		setColor: function(/*Array|String|Object*/ color){
			// summary:
			//		Takes a named string, hex string, array of rgb or rgba values,
			//		an object with r, g, b, and a properties, or another `dojo.Color` object
			//		and sets this color instance to that value. 
			// 
			// example:
			//	|	var c = new dojo.Color(); // no color
			//	|	c.setColor("#ededed"); // greyish
			if(d.isString(color)){
				d.colorFromString(color, this);
			}else if(d.isArray(color)){
				d.colorFromArray(color, this);
			}else{
				this._set(color.r, color.g, color.b, color.a);
				if(!(color instanceof d.Color)){ this.sanitize(); }
			}
			return this;	// dojo.Color
		},
		sanitize: function(){
			// summary:
			//		makes sure that the object has correct attributes
			// description: 
			//		the default implementation does nothing, include dojo.colors to
			//		augment it to real checks
			return this;	// dojo.Color
		},
		toRgb: function(){
			// summary: Returns 3 component array of rgb values
			//
			// example:
			//	| var c = new dojo.Color("#000000"); 
			//	| console.log(c.toRgb()); // [0,0,0] 
			var t = this;
			return [t.r, t.g, t.b];	// Array
		},
		toRgba: function(){
			// summary: Returns a 4 component array of rgba values
			var t = this;
			return [t.r, t.g, t.b, t.a];	// Array
		},
		toHex: function(){
			// summary: Returns a css color string in hexadecimal representation
			//
			// example: 
			// | 	console.log(new dojo.Color([0,0,0]).toHex()); // #000000
			var arr = d.map(["r", "g", "b"], function(x){
				var s = this[x].toString(16);
				return s.length < 2 ? "0" + s : s;
			}, this);
			return "#" + arr.join("");	// String
		},
		toCss: function(/*Boolean?*/ includeAlpha){
			// summary: Returns a css color string in rgb(a) representation
			//
			// example:
			// |	var c = new dojo.Color("#FFF").toCss();
			// |	console.log(c); // rgb('255','255','255')
			var t = this, rgb = t.r + ", " + t.g + ", " + t.b;
			return (includeAlpha ? "rgba(" + rgb + ", " + t.a : "rgb(" + rgb) + ")";	// String
		},
		toString: function(){
			// summary: Returns a visual representation of the color
			return this.toCss(true); // String
		}
	});

	dojo.blendColors = function(
		/*dojo.Color*/ start, 
		/*dojo.Color*/ end, 
		/*Number*/ weight,
		/*dojo.Color?*/ obj
	){
		// summary: 
		//		Blend colors end and start with weight from 0 to 1, 0.5 being a 50/50 blend,
		//		can reuse a previously allocated dojo.Color object for the result
		var t = obj || new d.Color();
		d.forEach(["r", "g", "b", "a"], function(x){
			t[x] = start[x] + (end[x] - start[x]) * weight;
			if(x != "a"){ t[x] = Math.round(t[x]); }
		});
		return t.sanitize();	// dojo.Color
	};

	dojo.colorFromRgb = function(/*String*/ color, /*dojo.Color?*/ obj){
		// summary: get rgb(a) array from css-style color declarations
		var m = color.toLowerCase().match(/^rgba?\(([\s\.,0-9]+)\)/);
		return m && dojo.colorFromArray(m[1].split(/\s*,\s*/), obj);	// dojo.Color
	};

	dojo.colorFromHex = function(/*String*/ color, /*dojo.Color?*/ obj){
		// summary: converts a hex string with a '#' prefix to a color object.
		//	Supports 12-bit #rgb shorthand.
		//
		// example:
		//	| var thing = dojo.colorFromHex("#ededed"); // grey, longhand
		//
		// example:
		//	| var thing = dojo.colorFromHex("#000"); // black, shorthand
		var t = obj || new d.Color(),
			bits = (color.length == 4) ? 4 : 8,
			mask = (1 << bits) - 1;
		color = Number("0x" + color.substr(1));
		if(isNaN(color)){
			return null; // dojo.Color
		}
		d.forEach(["b", "g", "r"], function(x){
			var c = color & mask;
			color >>= bits;
			t[x] = bits == 4 ? 17 * c : c;
		});
		t.a = 1;
		return t;	// dojo.Color
	};

	dojo.colorFromArray = function(/*Array*/ a, /*dojo.Color?*/ obj){
		// summary: builds a color from 1, 2, 3, or 4 element array
		var t = obj || new d.Color();
		t._set(Number(a[0]), Number(a[1]), Number(a[2]), Number(a[3]));
		if(isNaN(t.a)){ t.a = 1; }
		return t.sanitize();	// dojo.Color
	};

	dojo.colorFromString = function(/*String*/ str, /*dojo.Color?*/ obj){
		//	summary:
		//		parses str for a color value.
		//	description:
		//		Acceptable input values for str may include arrays of any form
		//		accepted by dojo.colorFromArray, hex strings such as "#aaaaaa", or
		//		rgb or rgba strings such as "rgb(133, 200, 16)" or "rgba(10, 10,
		//		10, 50)"
		//	returns:
		//		a dojo.Color object. If obj is passed, it will be the return value.
		var a = d.Color.named[str];
		return a && d.colorFromArray(a, obj) || d.colorFromRgb(str, obj) || d.colorFromHex(str, obj);
	};

})();

}

if(!dojo._hasResource["dojo._base"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo._base"] = true;
dojo.provide("dojo._base");









}

if(!dojo._hasResource["dojo._base.window"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo._base.window"] = true;
dojo.provide("dojo._base.window");

/*=====
dojo.doc = {
	// summary:
	//		Alias for the current document. 'dojo.doc' can be modified
	//		for temporary context shifting. Also see dojo.withDoc().
	// description:
	//    Refer to dojo.doc rather
	//    than referring to 'window.document' to ensure your code runs
	//    correctly in managed contexts.
	// example:
	// 	|	n.appendChild(dojo.doc.createElement('div'));
}
=====*/
dojo.doc = window["document"] || null;

dojo.body = function(){
	// summary:
	//		Return the body element of the document
	//		return the body object associated with dojo.doc
	// example:
	// 	|	dojo.body().appendChild(dojo.doc.createElement('div'));

	// Note: document.body is not defined for a strict xhtml document
	// Would like to memoize this, but dojo.doc can change vi dojo.withDoc().
	return dojo.doc.body || dojo.doc.getElementsByTagName("body")[0]; // Node
}

dojo.setContext = function(/*Object*/globalObject, /*DocumentElement*/globalDocument){
	// summary:
	//		changes the behavior of many core Dojo functions that deal with
	//		namespace and DOM lookup, changing them to work in a new global
	//		context (e.g., an iframe). The varibles dojo.global and dojo.doc
	//		are modified as a result of calling this function and the result of
	//		`dojo.body()` likewise differs.
	dojo.global = globalObject;
	dojo.doc = globalDocument;
};

dojo.withGlobal = function(	/*Object*/globalObject, 
							/*Function*/callback, 
							/*Object?*/thisObject, 
							/*Array?*/cbArguments){
	// summary:
	//		Invoke callback with globalObject as dojo.global and
	//		globalObject.document as dojo.doc.
	// description:
	//		Invoke callback with globalObject as dojo.global and
	//		globalObject.document as dojo.doc. If provided, globalObject
	//		will be executed in the context of object thisObject
	//		When callback() returns or throws an error, the dojo.global
	//		and dojo.doc will be restored to its previous state.

	var oldGlob = dojo.global;
	try{
		dojo.global = globalObject;
		return dojo.withDoc.call(null, globalObject.document, callback, thisObject, cbArguments);
	}finally{
		dojo.global = oldGlob;
	}
}

dojo.withDoc = function(	/*DocumentElement*/documentObject, 
							/*Function*/callback, 
							/*Object?*/thisObject, 
							/*Array?*/cbArguments){
	// summary:
	//		Invoke callback with documentObject as dojo.doc.
	// description:
	//		Invoke callback with documentObject as dojo.doc. If provided,
	//		callback will be executed in the context of object thisObject
	//		When callback() returns or throws an error, the dojo.doc will
	//		be restored to its previous state.

	var oldDoc = dojo.doc,
		oldLtr = dojo._bodyLtr;

	try{
		dojo.doc = documentObject;
		delete dojo._bodyLtr; // uncache

		if(thisObject && dojo.isString(callback)){
			callback = thisObject[callback];
		}

		return callback.apply(thisObject, cbArguments || []);
	}finally{
		dojo.doc = oldDoc;
		if(oldLtr !== undefined){ dojo._bodyLtr = oldLtr; }
	}
};
	

}

if(!dojo._hasResource["dojo._base.event"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo._base.event"] = true;
dojo.provide("dojo._base.event");


// this file courtesy of the TurboAjax Group, licensed under a Dojo CLA

(function(){
	// DOM event listener machinery
	var del = (dojo._event_listener = {
		add: function(/*DOMNode*/node, /*String*/name, /*Function*/fp){
			if(!node){return;} 
			name = del._normalizeEventName(name);
			fp = del._fixCallback(name, fp);
			var oname = name;
			if(
								!dojo.isIE && 
								(name == "mouseenter" || name == "mouseleave")
			){
				var ofp = fp;
				//oname = name;
				name = (name == "mouseenter") ? "mouseover" : "mouseout";
				fp = function(e){		
					if(dojo.isFF <= 2) {
						// check tagName to fix a FF2 bug with invalid nodes (hidden child DIV of INPUT)
						// which causes isDescendant to return false which causes
						// spurious, and more importantly, incorrect mouse events to fire.
						// TODO: remove tagName check when Firefox 2 is no longer supported
						try{ e.relatedTarget.tagName; }catch(e2){ return; }
					}
					if(!dojo.isDescendant(e.relatedTarget, node)){
						// e.type = oname; // FIXME: doesn't take? SJM: event.type is generally immutable.
						return ofp.call(this, e); 
					}
				}
			}
			node.addEventListener(name, fp, false);
			return fp; /*Handle*/
		},
		remove: function(/*DOMNode*/node, /*String*/event, /*Handle*/handle){
			// summary:
			//		clobbers the listener from the node
			// node:
			//		DOM node to attach the event to
			// event:
			//		the name of the handler to remove the function from
			// handle:
			//		the handle returned from add
			if(node){
				event = del._normalizeEventName(event);
				if(!dojo.isIE && (event == "mouseenter" || event == "mouseleave")){
					event = (event == "mouseenter") ? "mouseover" : "mouseout";
				}

				node.removeEventListener(event, handle, false);
			}
		},
		_normalizeEventName: function(/*String*/name){
			// Generally, name should be lower case, unless it is special
			// somehow (e.g. a Mozilla DOM event).
			// Remove 'on'.
			return name.slice(0,2) =="on" ? name.slice(2) : name;
		},
		_fixCallback: function(/*String*/name, fp){
			// By default, we only invoke _fixEvent for 'keypress'
			// If code is added to _fixEvent for other events, we have
			// to revisit this optimization.
			// This also applies to _fixEvent overrides for Safari and Opera
			// below.
			return name != "keypress" ? fp : function(e){ return fp.call(this, del._fixEvent(e, this)); };
		},
		_fixEvent: function(evt, sender){
			// _fixCallback only attaches us to keypress.
			// Switch on evt.type anyway because we might 
			// be called directly from dojo.fixEvent.
			switch(evt.type){
				case "keypress":
					del._setKeyChar(evt);
					break;
			}
			return evt;
		},
		_setKeyChar: function(evt){
			evt.keyChar = evt.charCode ? String.fromCharCode(evt.charCode) : '';
			evt.charOrCode = evt.keyChar || evt.keyCode;
		},
		// For IE and Safari: some ctrl-key combinations (mostly w/punctuation) do not emit a char code in IE
		// we map those virtual key codes to ascii here
		// not valid for all (non-US) keyboards, so maybe we shouldn't bother
		_punctMap: { 
			106:42, 
			111:47, 
			186:59, 
			187:43, 
			188:44, 
			189:45, 
			190:46, 
			191:47, 
			192:96, 
			219:91, 
			220:92, 
			221:93, 
			222:39 
		}
	});

	// DOM events
	
	dojo.fixEvent = function(/*Event*/evt, /*DOMNode*/sender){
		// summary:
		//		normalizes properties on the event object including event
		//		bubbling methods, keystroke normalization, and x/y positions
		// evt: Event
		//		native event object
		// sender: DOMNode
		//		node to treat as "currentTarget"
		return del._fixEvent(evt, sender);
	}

	dojo.stopEvent = function(/*Event*/evt){
		// summary:
		//		prevents propagation and clobbers the default action of the
		//		passed event
		// evt: Event
		//		The event object. If omitted, window.event is used on IE.
		evt.preventDefault();
		evt.stopPropagation();
		// NOTE: below, this method is overridden for IE
	}

	// the default listener to use on dontFix nodes, overriden for IE
	var node_listener = dojo._listener;
	
	// Unify connect and event listeners
	dojo._connect = function(obj, event, context, method, dontFix){
		// FIXME: need a more strict test
		var isNode = obj && (obj.nodeType||obj.attachEvent||obj.addEventListener);
		// choose one of three listener options: raw (connect.js), DOM event on a Node, custom event on a Node
		// we need the third option to provide leak prevention on broken browsers (IE)
		var lid = isNode ? (dontFix ? 2 : 1) : 0, l = [dojo._listener, del, node_listener][lid];
		// create a listener
		var h = l.add(obj, event, dojo.hitch(context, method));
		// formerly, the disconnect package contained "l" directly, but if client code
		// leaks the disconnect package (by connecting it to a node), referencing "l" 
		// compounds the problem.
		// instead we return a listener id, which requires custom _disconnect below.
		// return disconnect package
		return [ obj, event, h, lid ];
	}

	dojo._disconnect = function(obj, event, handle, listener){
		([dojo._listener, del, node_listener][listener]).remove(obj, event, handle);
	}

	// Constants

	// Public: client code should test
	// keyCode against these named constants, as the
	// actual codes can vary by browser.
	dojo.keys = {
		// summary: definitions for common key values
		BACKSPACE: 8,
		TAB: 9,
		CLEAR: 12,
		ENTER: 13,
		SHIFT: 16,
		CTRL: 17,
		ALT: 18,
		PAUSE: 19,
		CAPS_LOCK: 20,
		ESCAPE: 27,
		SPACE: 32,
		PAGE_UP: 33,
		PAGE_DOWN: 34,
		END: 35,
		HOME: 36,
		LEFT_ARROW: 37,
		UP_ARROW: 38,
		RIGHT_ARROW: 39,
		DOWN_ARROW: 40,
		INSERT: 45,
		DELETE: 46,
		HELP: 47,
		LEFT_WINDOW: 91,
		RIGHT_WINDOW: 92,
		SELECT: 93,
		NUMPAD_0: 96,
		NUMPAD_1: 97,
		NUMPAD_2: 98,
		NUMPAD_3: 99,
		NUMPAD_4: 100,
		NUMPAD_5: 101,
		NUMPAD_6: 102,
		NUMPAD_7: 103,
		NUMPAD_8: 104,
		NUMPAD_9: 105,
		NUMPAD_MULTIPLY: 106,
		NUMPAD_PLUS: 107,
		NUMPAD_ENTER: 108,
		NUMPAD_MINUS: 109,
		NUMPAD_PERIOD: 110,
		NUMPAD_DIVIDE: 111,
		F1: 112,
		F2: 113,
		F3: 114,
		F4: 115,
		F5: 116,
		F6: 117,
		F7: 118,
		F8: 119,
		F9: 120,
		F10: 121,
		F11: 122,
		F12: 123,
		F13: 124,
		F14: 125,
		F15: 126,
		NUM_LOCK: 144,
		SCROLL_LOCK: 145
	};
	
		// IE event normalization
	if(dojo.isIE){ 
		var _trySetKeyCode = function(e, code){
			try{
				// squelch errors when keyCode is read-only
				// (e.g. if keyCode is ctrl or shift)
				return (e.keyCode = code);
			}catch(e){
				return 0;
			}
		}

		// by default, use the standard listener
		var iel = dojo._listener;
		var listenersName = (dojo._ieListenersName = "_" + dojo._scopeName + "_listeners");
		// dispatcher tracking property
		if(!dojo.config._allow_leaks){
			// custom listener that handles leak protection for DOM events
			node_listener = iel = dojo._ie_listener = {
				// support handler indirection: event handler functions are 
				// referenced here. Event dispatchers hold only indices.
				handlers: [],
				// add a listener to an object
				add: function(/*Object*/ source, /*String*/ method, /*Function*/ listener){
					source = source || dojo.global;
					var f = source[method];
					if(!f||!f[listenersName]){
						var d = dojo._getIeDispatcher();
						// original target function is special
						d.target = f && (ieh.push(f) - 1);
						// dispatcher holds a list of indices into handlers table
						d[listenersName] = [];
						// redirect source to dispatcher
						f = source[method] = d;
					}
					return f[listenersName].push(ieh.push(listener) - 1) ; /*Handle*/
				},
				// remove a listener from an object
				remove: function(/*Object*/ source, /*String*/ method, /*Handle*/ handle){
					var f = (source||dojo.global)[method], l = f && f[listenersName];
					if(f && l && handle--){
						delete ieh[l[handle]];
						delete l[handle];
					}
				}
			};
			// alias used above
			var ieh = iel.handlers;
		}

		dojo.mixin(del, {
			add: function(/*DOMNode*/node, /*String*/event, /*Function*/fp){
				if(!node){return;} // undefined
				event = del._normalizeEventName(event);
				if(event=="onkeypress"){
					// we need to listen to onkeydown to synthesize
					// keypress events that otherwise won't fire
					// on IE
					var kd = node.onkeydown;
					if(!kd || !kd[listenersName] || !kd._stealthKeydownHandle){
						var h = del.add(node, "onkeydown", del._stealthKeyDown);
						kd = node.onkeydown;
						kd._stealthKeydownHandle = h;
						kd._stealthKeydownRefs = 1;
					}else{
						kd._stealthKeydownRefs++;
					}
				}
				return iel.add(node, event, del._fixCallback(fp));
			},
			remove: function(/*DOMNode*/node, /*String*/event, /*Handle*/handle){
				event = del._normalizeEventName(event);
				iel.remove(node, event, handle); 
				if(event=="onkeypress"){
					var kd = node.onkeydown;
					if(--kd._stealthKeydownRefs <= 0){
						iel.remove(node, "onkeydown", kd._stealthKeydownHandle);
						delete kd._stealthKeydownHandle;
					}
				}
			},
			_normalizeEventName: function(/*String*/eventName){
				// Generally, eventName should be lower case, unless it is
				// special somehow (e.g. a Mozilla event)
				// ensure 'on'
				return eventName.slice(0,2) != "on" ? "on" + eventName : eventName;
			},
			_nop: function(){},
			_fixEvent: function(/*Event*/evt, /*DOMNode*/sender){
				// summary:
				//		normalizes properties on the event object including event
				//		bubbling methods, keystroke normalization, and x/y positions
				// evt: native event object
				// sender: node to treat as "currentTarget"
				if(!evt){
					var w = sender && (sender.ownerDocument || sender.document || sender).parentWindow || window;
					evt = w.event; 
				}
				if(!evt){return(evt);}
				evt.target = evt.srcElement; 
				evt.currentTarget = (sender || evt.srcElement); 
				evt.layerX = evt.offsetX;
				evt.layerY = evt.offsetY;
				// FIXME: scroll position query is duped from dojo.html to
				// avoid dependency on that entire module. Now that HTML is in
				// Base, we should convert back to something similar there.
				var se = evt.srcElement, doc = (se && se.ownerDocument) || document;
				// DO NOT replace the following to use dojo.body(), in IE, document.documentElement should be used
				// here rather than document.body
				var docBody = ((dojo.isIE < 6) || (doc["compatMode"] == "BackCompat")) ? doc.body : doc.documentElement;
				var offset = dojo._getIeDocumentElementOffset();
				evt.pageX = evt.clientX + dojo._fixIeBiDiScrollLeft(docBody.scrollLeft || 0) - offset.x;
				evt.pageY = evt.clientY + (docBody.scrollTop || 0) - offset.y;
				if(evt.type == "mouseover"){ 
					evt.relatedTarget = evt.fromElement;
				}
				if(evt.type == "mouseout"){ 
					evt.relatedTarget = evt.toElement;
				}
				evt.stopPropagation = del._stopPropagation;
				evt.preventDefault = del._preventDefault;
				return del._fixKeys(evt);
			},
			_fixKeys: function(evt){
				switch(evt.type){
					case "keypress":
						var c = ("charCode" in evt ? evt.charCode : evt.keyCode);
						if (c==10){
							// CTRL-ENTER is CTRL-ASCII(10) on IE, but CTRL-ENTER on Mozilla
							c=0;
							evt.keyCode = 13;
						}else if(c==13||c==27){
							c=0; // Mozilla considers ENTER and ESC non-printable
						}else if(c==3){
							c=99; // Mozilla maps CTRL-BREAK to CTRL-c
						}
						// Mozilla sets keyCode to 0 when there is a charCode
						// but that stops the event on IE.
						evt.charCode = c;
						del._setKeyChar(evt);
						break;
				}
				return evt;
			},
			_stealthKeyDown: function(evt){
				// IE doesn't fire keypress for most non-printable characters.
				// other browsers do, we simulate it here.
				var kp = evt.currentTarget.onkeypress;
				// only works if kp exists and is a dispatcher
				if(!kp || !kp[listenersName]){ return; }
				// munge key/charCode
				var k=evt.keyCode;
				// These are Windows Virtual Key Codes
				// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/WinUI/WindowsUserInterface/UserInput/VirtualKeyCodes.asp
				var unprintable = k!=13 && k!=32 && k!=27 && (k<48||k>90) && (k<96||k>111) && (k<186||k>192) && (k<219||k>222);
				// synthesize keypress for most unprintables and CTRL-keys
				if(unprintable||evt.ctrlKey){
					var c = unprintable ? 0 : k;
					if(evt.ctrlKey){
						if(k==3 || k==13){
							return; // IE will post CTRL-BREAK, CTRL-ENTER as keypress natively 
						}else if(c>95 && c<106){ 
							c -= 48; // map CTRL-[numpad 0-9] to ASCII
						}else if((!evt.shiftKey)&&(c>=65&&c<=90)){ 
							c += 32; // map CTRL-[A-Z] to lowercase
						}else{ 
							c = del._punctMap[c] || c; // map other problematic CTRL combinations to ASCII
						}
					}
					// simulate a keypress event
					var faux = del._synthesizeEvent(evt, {type: 'keypress', faux: true, charCode: c});
					kp.call(evt.currentTarget, faux);
					evt.cancelBubble = faux.cancelBubble;
					evt.returnValue = faux.returnValue;
					_trySetKeyCode(evt, faux.keyCode);
				}
			},
			// Called in Event scope
			_stopPropagation: function(){
				this.cancelBubble = true; 
			},
			_preventDefault: function(){
				// Setting keyCode to 0 is the only way to prevent certain keypresses (namely
				// ctrl-combinations that correspond to menu accelerator keys).
				// Otoh, it prevents upstream listeners from getting this information
				// Try to split the difference here by clobbering keyCode only for ctrl 
				// combinations. If you still need to access the key upstream, bubbledKeyCode is
				// provided as a workaround.
				this.bubbledKeyCode = this.keyCode;
				if(this.ctrlKey){_trySetKeyCode(this, 0);}
				this.returnValue = false;
			}
		});
				
		// override stopEvent for IE
		dojo.stopEvent = function(evt){
			evt = evt || window.event;
			del._stopPropagation.call(evt);
			del._preventDefault.call(evt);
		}
	}
	
	del._synthesizeEvent = function(evt, props){
			var faux = dojo.mixin({}, evt, props);
			del._setKeyChar(faux);
			// FIXME: would prefer to use dojo.hitch: dojo.hitch(evt, evt.preventDefault); 
			// but it throws an error when preventDefault is invoked on Safari
			// does Event.preventDefault not support "apply" on Safari?
			faux.preventDefault = function(){ evt.preventDefault(); }; 
			faux.stopPropagation = function(){ evt.stopPropagation(); }; 
			return faux;
	}
	
		// Opera event normalization
	if(dojo.isOpera){
		dojo.mixin(del, {
			_fixEvent: function(evt, sender){
				switch(evt.type){
					case "keypress":
						var c = evt.which;
						if(c==3){
							c=99; // Mozilla maps CTRL-BREAK to CTRL-c
						}
						// can't trap some keys at all, like INSERT and DELETE
						// there is no differentiating info between DELETE and ".", or INSERT and "-"
						c = c<41 && !evt.shiftKey ? 0 : c;
						if(evt.ctrlKey && !evt.shiftKey && c>=65 && c<=90){
							// lowercase CTRL-[A-Z] keys
							c += 32;
						}
						return del._synthesizeEvent(evt, { charCode: c });
				}
				return evt;
			}
		});
	}
	
		// Webkit event normalization
	if(dojo.isWebKit){
				del._add = del.add;
		del._remove = del.remove;

		dojo.mixin(del, {
			add: function(/*DOMNode*/node, /*String*/event, /*Function*/fp){
				if(!node){return;} // undefined
				var handle = del._add(node, event, fp);
				if(del._normalizeEventName(event) == "keypress"){
					// we need to listen to onkeydown to synthesize
					// keypress events that otherwise won't fire
					// in Safari 3.1+: https://lists.webkit.org/pipermail/webkit-dev/2007-December/002992.html
					handle._stealthKeyDownHandle = del._add(node, "keydown", function(evt){
						//A variation on the IE _stealthKeydown function
						//Synthesize an onkeypress event, but only for unprintable characters.
						var k=evt.keyCode;
						// These are Windows Virtual Key Codes
						// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/WinUI/WindowsUserInterface/UserInput/VirtualKeyCodes.asp
						var unprintable = k!=13 && k!=32 && k!=27 && (k<48 || k>90) && (k<96 || k>111) && (k<186 || k>192) && (k<219 || k>222);
						// synthesize keypress for most unprintables and CTRL-keys
						if(unprintable || evt.ctrlKey){
							var c = unprintable ? 0 : k;
							if(evt.ctrlKey){
								if(k==3 || k==13){
									return; // IE will post CTRL-BREAK, CTRL-ENTER as keypress natively 
								}else if(c>95 && c<106){ 
									c -= 48; // map CTRL-[numpad 0-9] to ASCII
								}else if(!evt.shiftKey && c>=65 && c<=90){ 
									c += 32; // map CTRL-[A-Z] to lowercase
								}else{ 
									c = del._punctMap[c] || c; // map other problematic CTRL combinations to ASCII
								}
							}
							// simulate a keypress event
							var faux = del._synthesizeEvent(evt, {type: 'keypress', faux: true, charCode: c});
							fp.call(evt.currentTarget, faux);
						}
					});
				}
				return handle; /*Handle*/
			},

			remove: function(/*DOMNode*/node, /*String*/event, /*Handle*/handle){
				if(node){
					if(handle._stealthKeyDownHandle){
						del._remove(node, "keydown", handle._stealthKeyDownHandle);
					}
					del._remove(node, event, handle);
				}
			},
			_fixEvent: function(evt, sender){
				switch(evt.type){
					case "keypress":
						if(evt.faux){ return evt; }
						var c = evt.charCode;
						c = c>=32 ? c : 0;
						return del._synthesizeEvent(evt, {charCode: c, faux: true});
				}
				return evt;
			}
		});
		}
	})();

if(dojo.isIE){
	// keep this out of the closure
	// closing over 'iel' or 'ieh' b0rks leak prevention
	// ls[i] is an index into the master handler array
	dojo._ieDispatcher = function(args, sender){
		var ap=Array.prototype, h=dojo._ie_listener.handlers, c=args.callee, ls=c[dojo._ieListenersName], t=h[c.target];
		// return value comes from original target function
		var r = t && t.apply(sender, args);
		// make local copy of listener array so it's immutable during processing
		var lls = [].concat(ls);
		// invoke listeners after target function
		for(var i in lls){
			var f = h[lls[i]];
			if(!(i in ap) && f){
				f.apply(sender, args);
			}
		}
		return r;
	}
	dojo._getIeDispatcher = function(){
		// ensure the returned function closes over nothing ("new Function" apparently doesn't close)
		return new Function(dojo._scopeName + "._ieDispatcher(arguments, this)"); // function
	}
	// keep this out of the closure to reduce RAM allocation
	dojo._event_listener._fixCallback = function(fp){
		var f = dojo._event_listener._fixEvent;
		return function(e){ return fp.call(this, f(e, this)); };
	}
}

}

if(!dojo._hasResource["dojo._base.html"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo._base.html"] = true;

dojo.provide("dojo._base.html");

// FIXME: need to add unit tests for all the semi-public methods

try{
	document.execCommand("BackgroundImageCache", false, true);
}catch(e){
	// sane browsers don't have cache "issues"
}

// =============================
// DOM Functions
// =============================

/*=====
dojo.byId = function(id, doc){
	//	summary:
	//		Returns DOM node with matching `id` attribute or `null` 
	//		if not found, similar to "$" function in another library.
	//		If `id` is a DomNode, this function is a no-op.
	//
	//	id: String|DOMNode
	//	 	A string to match an HTML id attribute or a reference to a DOM Node
	//
	//	doc: Document?
	//		Document to work in. Defaults to the current value of
	//		dojo.doc.  Can be used to retrieve
	//		node references from other documents.
	// 
	//	example:
	//	Look up a node by ID:
	//	| var n = dojo.byId("foo");
	//
	//	example:
	//	Check if a node exists.
	//	|	if(dojo.byId("bar")){ ... }
	//
	//	example:
	//	Allow string or DomNode references to be passed to a custom function:
	//	| var foo = function(nodeOrId){ 
	//	|	nodeOrId = dojo.byId(nodeOrId); 
	//	|	// ... more stuff
	//	| }
=====*/

if(dojo.isIE || dojo.isOpera){
	dojo.byId = function(id, doc){
		if(dojo.isString(id)){
			var _d = doc || dojo.doc;
			var te = _d.getElementById(id);
			// attributes.id.value is better than just id in case the 
			// user has a name=id inside a form
			if(te && (te.attributes.id.value == id || te.id == id)){
				return te;
			}else{
				var eles = _d.all[id];
				if(!eles || eles.nodeName){
					eles = [eles];
				}
				// if more than 1, choose first with the correct id
				var i=0;
				while((te=eles[i++])){
					if((te.attributes && te.attributes.id && te.attributes.id.value == id)
						|| te.id == id){
						return te;
					}
				}
			}
		}else{
			return id; // DomNode
		}
	};
}else{
	dojo.byId = function(id, doc){
		return dojo.isString(id) ? (doc || dojo.doc).getElementById(id) : id; // DomNode
	};
}
/*=====
}
=====*/

(function(){
	var d = dojo;

	var _destroyContainer = null;
		d.addOnWindowUnload(function(){
		_destroyContainer = null; //prevent IE leak
	});
	
/*=====
	dojo._destroyElement = function(node){
		// summary: Existing alias for `dojo.destroy`. Deprecated, will be removed in 2.0
	}
=====*/
	dojo._destroyElement = dojo.destroy = function(/*String|DomNode*/node){
		//	summary:
		//		Removes a node from its parent, clobbering it and all of its
		//		children.
		//
		//	description:
		//		Removes a node from its parent, clobbering it and all of its
		//		children. Function only works with DomNodes, and returns nothing.
		//		
		//	node:
		//		A String ID or DomNode reference of the element to be destroyed
		//
		//	example:
		//	Destroy a node byId:
		//	| dojo.destroy("someId");
		//
		//	example:
		//	Destroy all nodes in a list by reference:
		//	| dojo.query(".someNode").forEach(dojo.destroy);
		
		node = d.byId(node);
		try{
			if(!_destroyContainer || _destroyContainer.ownerDocument != node.ownerDocument){
				_destroyContainer = node.ownerDocument.createElement("div");
			}
			_destroyContainer.appendChild(node.parentNode ? node.parentNode.removeChild(node) : node);
			// NOTE: see http://trac.dojotoolkit.org/ticket/2931. This may be a bug and not a feature
			_destroyContainer.innerHTML = ""; 
		}catch(e){
			/* squelch */
		}
	};

	dojo.isDescendant = function(/*DomNode|String*/node, /*DomNode|String*/ancestor){
		//	summary:
		//		Returns true if node is a descendant of ancestor
		//	node: string id or node reference to test
		//	ancestor: string id or node reference of potential parent to test against
		try{
			node = d.byId(node);
			ancestor = d.byId(ancestor);
			while(node){
				if(node === ancestor){
					return true; // Boolean
				}
				node = node.parentNode;
			}
		}catch(e){ /* squelch, return false */ }
		return false; // Boolean
	};

	dojo.setSelectable = function(/*DomNode|String*/node, /*Boolean*/selectable){
		//	summary: enable or disable selection on a node
		//	node:
		//		id or reference to node
		//	selectable:
		//		state to put the node in. false indicates unselectable, true 
		//		allows selection.
		node = d.byId(node);
				if(d.isMozilla){
			node.style.MozUserSelect = selectable ? "" : "none";
		}else if(d.isKhtml || d.isWebKit){
					node.style.KhtmlUserSelect = selectable ? "auto" : "none";
				}else if(d.isIE){
			var v = (node.unselectable = selectable ? "" : "on");
			d.query("*", node).forEach("item.unselectable = '"+v+"'");
		}
				//FIXME: else?  Opera?
	};

	var _insertBefore = function(/*DomNode*/node, /*DomNode*/ref){
		var parent = ref.parentNode;
		if(parent){
			parent.insertBefore(node, ref);
		}
	}

	var _insertAfter = function(/*DomNode*/node, /*DomNode*/ref){
		//	summary:
		//		Try to insert node after ref
		var parent = ref.parentNode;
		if(parent){
			if(parent.lastChild == ref){
				parent.appendChild(node);
			}else{
				parent.insertBefore(node, ref.nextSibling);
			}
		}
	}

	dojo.place = function(node, refNode, position){
		//	summary:
		//		Attempt to insert node into the DOM, choosing from various positioning options.
		//		Returns true if successful, false otherwise.
		//
		//	node: String|DomNode
		//		id or node reference, or HTML fragment starting with "<" to place relative to refNode
		//
		//	refNode: String|DomNode
		//		id or node reference to use as basis for placement
		//
		//	position: String|Number?
		//		string noting the position of node relative to refNode or a
		//		number indicating the location in the childNodes collection of refNode. 
		//		Accepted string values are:
		//	|	* before
		//	|	* after
		//	|	* replace
		//	|	* only
		//	|	* first
		//	|	* last
		//		"first" and "last" indicate positions as children of refNode, "replace" replaces refNode,
		//		"only" replaces all children.  position defaults to "last" if not specified
		//
		//	returns: DomNode
		//		Returned values is the first argument resolved to a DOM node.
		//
		//		.place() is also a method of `dojo.NodeList`, allowing `dojo.query` node lookups.
		// 
		// example:
		// Place a node by string id as the last child of another node by string id:
		// | 	dojo.place("someNode", "anotherNode");
		//
		// example:
		// Place a node by string id before another node by string id
		// | 	dojo.place("someNode", "anotherNode", "before");
		//
		// example:
		// Create a Node, and place it in the body element (last child):
		// | 	dojo.place(dojo.create('div'), dojo.body());
		//
		// example:
		// Put a new LI as the first child of a list by id:
		// | 	dojo.place(dojo.create('li'), "someUl", "first");

		refNode = d.byId(refNode);
		if(d.isString(node)){
			node = node.charAt(0) == "<" ? d._toDom(node, refNode.ownerDocument) : d.byId(node);
		}
		if(typeof position == "number"){
			var cn = refNode.childNodes;
			if(!cn.length || cn.length <= position){
				refNode.appendChild(node);
			}else{
				_insertBefore(node, cn[position < 0 ? 0 : position]);
			}
		}else{
			switch(position){
				case "before":
					_insertBefore(node, refNode);
					break;
				case "after":
					_insertAfter(node, refNode);
					break;
				case "replace":
					refNode.parentNode.replaceChild(node, refNode);
					break; 
				case "only":
					d.empty(refNode);
					refNode.appendChild(node);
					break;
				case "first":
					if(refNode.firstChild){
						_insertBefore(node, refNode.firstChild);
						break;
					}
					// else fallthrough...
				default: // aka: last
					refNode.appendChild(node);
			}
		}
		return node; // DomNode
	}

	// Box functions will assume this model.
	// On IE/Opera, BORDER_BOX will be set if the primary document is in quirks mode.
	// Can be set to change behavior of box setters.
	
	// can be either:
	//	"border-box"
	//	"content-box" (default)
	dojo.boxModel = "content-box";
	
	// We punt per-node box mode testing completely.
	// If anybody cares, we can provide an additional (optional) unit 
	// that overrides existing code to include per-node box sensitivity.

	// Opera documentation claims that Opera 9 uses border-box in BackCompat mode.
	// but experiments (Opera 9.10.8679 on Windows Vista) indicate that it actually continues to use content-box.
	// IIRC, earlier versions of Opera did in fact use border-box.
	// Opera guys, this is really confusing. Opera being broken in quirks mode is not our fault.

		if(d.isIE /*|| dojo.isOpera*/){
		var _dcm = document.compatMode;
		// client code may have to adjust if compatMode varies across iframes
		d.boxModel = _dcm == "BackCompat" || _dcm == "QuirksMode" || d.isIE < 6 ? "border-box" : "content-box"; // FIXME: remove IE < 6 support?
	}
	
	// =============================
	// Style Functions
	// =============================
	
	// getComputedStyle drives most of the style code.
	// Wherever possible, reuse the returned object.
	//
	// API functions below that need to access computed styles accept an 
	// optional computedStyle parameter.
	// If this parameter is omitted, the functions will call getComputedStyle themselves.
	// This way, calling code can access computedStyle once, and then pass the reference to 
	// multiple API functions. 

/*=====
	dojo.getComputedStyle = function(node){
		//	summary:
		//		Returns a "computed style" object.
		//
		//	description:
		//		Gets a "computed style" object which can be used to gather
		//		information about the current state of the rendered node. 
		//
		//		Note that this may behave differently on different browsers.
		//		Values may have different formats and value encodings across
		//		browsers.
		//
		//		Note also that this method is expensive.  Wherever possible,
		//		reuse the returned object.
		//
		//		Use the dojo.style() method for more consistent (pixelized)
		//		return values.
		//
		//	node: DOMNode
		//		A reference to a DOM node. Does NOT support taking an
		//		ID string for speed reasons.
		//	example:
		//	|	dojo.getComputedStyle(dojo.byId('foo')).borderWidth;
		//
		//	example:
		//	Reusing the returned object, avoiding multiple lookups:
		//	|	var cs = dojo.getComputedStyle(dojo.byId("someNode"));
		//	|	var w = cs.width, h = cs.height;
		return; // CSS2Properties
	}
=====*/

	// Although we normally eschew argument validation at this
	// level, here we test argument 'node' for (duck)type,
	// by testing nodeType, ecause 'document' is the 'parentNode' of 'body'
	// it is frequently sent to this function even 
	// though it is not Element.
	var gcs;
		if(d.isWebKit){
			gcs = function(/*DomNode*/node){
			var s;
			if(node.nodeType == 1){
				var dv = node.ownerDocument.defaultView;
				s = dv.getComputedStyle(node, null);
				if(!s && node.style){ 
					node.style.display = ""; 
					s = dv.getComputedStyle(node, null);
				}
			}
			return s || {};
		}; 
		}else if(d.isIE){
		gcs = function(node){
			// IE (as of 7) doesn't expose Element like sane browsers
			return node.nodeType == 1 /* ELEMENT_NODE*/ ? node.currentStyle : {};
		};
	}else{
		gcs = function(node){
			return node.nodeType == 1 ? 
				node.ownerDocument.defaultView.getComputedStyle(node, null) : {};
		};
	}
		dojo.getComputedStyle = gcs;

		if(!d.isIE){
			d._toPixelValue = function(element, value){
			// style values can be floats, client code may want
			// to round for integer pixels.
			return parseFloat(value) || 0; 
		};
		}else{
		d._toPixelValue = function(element, avalue){
			if(!avalue){ return 0; }
			// on IE7, medium is usually 4 pixels
			if(avalue == "medium"){ return 4; }
			// style values can be floats, client code may
			// want to round this value for integer pixels.
			if(avalue.slice && avalue.slice(-2) == 'px'){ return parseFloat(avalue); }
			with(element){
				var sLeft = style.left;
				var rsLeft = runtimeStyle.left;
				runtimeStyle.left = currentStyle.left;
				try{
					// 'avalue' may be incompatible with style.left, which can cause IE to throw
					// this has been observed for border widths using "thin", "medium", "thick" constants
					// those particular constants could be trapped by a lookup
					// but perhaps there are more
					style.left = avalue;
					avalue = style.pixelLeft;
				}catch(e){
					avalue = 0;
				}
				style.left = sLeft;
				runtimeStyle.left = rsLeft;
			}
			return avalue;
		}
	}
		var px = d._toPixelValue;

	// FIXME: there opacity quirks on FF that we haven't ported over. Hrm.
	/*=====
	dojo._getOpacity = function(node){
			//	summary:
			//		Returns the current opacity of the passed node as a
			//		floating-point value between 0 and 1.
			//	node: DomNode
			//		a reference to a DOM node. Does NOT support taking an
			//		ID string for speed reasons.
			//	returns: Number between 0 and 1
			return; // Number
	}
	=====*/

		var astr = "DXImageTransform.Microsoft.Alpha";
	var af = function(n, f){ 
		try{
			return n.filters.item(astr);
		}catch(e){
			return f ? {} : null;
		}
	}

		dojo._getOpacity = 
			d.isIE ? function(node){
			try{
				return af(node).Opacity / 100; // Number
			}catch(e){
				return 1; // Number
			}
		} : 
			function(node){
			return gcs(node).opacity;
		};

	/*=====
	dojo._setOpacity = function(node, opacity){
			//	summary:
			//		set the opacity of the passed node portably. Returns the
			//		new opacity of the node.
			//	node: DOMNode
			//		a reference to a DOM node. Does NOT support taking an
			//		ID string for performance reasons.
			//	opacity: Number
			//		A Number between 0 and 1. 0 specifies transparent.
			//	returns: Number between 0 and 1
			return; // Number
	}
	=====*/

	dojo._setOpacity = 
				d.isIE ? function(/*DomNode*/node, /*Number*/opacity){
			var ov = opacity * 100;
			node.style.zoom = 1.0;

			// on IE7 Alpha(Filter opacity=100) makes text look fuzzy so disable it altogether (bug #2661),
			//but still update the opacity value so we can get a correct reading if it is read later.
			af(node, 1).Enabled = !(opacity == 1);

			if(!af(node)){
				node.style.filter += " progid:" + astr + "(Opacity=" + ov + ")";
			}else{
				af(node, 1).Opacity = ov;
			}

			if(node.nodeName.toLowerCase() == "tr"){
				d.query("> td", node).forEach(function(i){
					d._setOpacity(i, opacity);
				});
			}
			return opacity;
		} : 
				function(node, opacity){
			return node.style.opacity = opacity;
		};

	var _pixelNamesCache = {
		left: true, top: true
	};
	var _pixelRegExp = /margin|padding|width|height|max|min|offset/;  // |border
	var _toStyleValue = function(node, type, value){
		type = type.toLowerCase(); // FIXME: should we really be doing string case conversion here? Should we cache it? Need to profile!
				if(d.isIE){
			if(value == "auto"){
				if(type == "height"){ return node.offsetHeight; }
				if(type == "width"){ return node.offsetWidth; }
			}
			if(type == "fontweight"){
				switch(value){
					case 700: return "bold";
					case 400:
					default: return "normal";
				}
			}
		}
				if(!(type in _pixelNamesCache)){
			_pixelNamesCache[type] = _pixelRegExp.test(type);
		}
		return _pixelNamesCache[type] ? px(node, value) : value;
	}

	var _floatStyle = d.isIE ? "styleFloat" : "cssFloat",
		_floatAliases = { "cssFloat": _floatStyle, "styleFloat": _floatStyle, "float": _floatStyle }
	;
	
	// public API
	
	dojo.style = function(	/*DomNode|String*/ node, 
							/*String?|Object?*/ style, 
							/*String?*/ value){
		//	summary:
		//		Accesses styles on a node. If 2 arguments are
		//		passed, acts as a getter. If 3 arguments are passed, acts
		//		as a setter.
		//	description:
		//		Getting the style value uses the computed style for the node, so the value
		//		will be a calculated value, not just the immediate node.style value.
		//		Also when getting values, use specific style names,
		//		like "borderBottomWidth" instead of "border" since compound values like
		//		"border" are not necessarily reflected as expected.
		//		If you want to get node dimensions, use dojo.marginBox() or
		//		dojo.contentBox(). 
		//	node:
		//		id or reference to node to get/set style for
		//	style:
		//		the style property to set in DOM-accessor format
		//		("borderWidth", not "border-width") or an object with key/value
		//		pairs suitable for setting each property.
		//	value:
		//		If passed, sets value on the node for style, handling
		//		cross-browser concerns.  When setting a pixel value,
		//		be sure to include "px" in the value. For instance, top: "200px".
		//		Otherwise, in some cases, some browsers will not apply the style.
		//	example:
		//		Passing only an ID or node returns the computed style object of
		//		the node:
		//	|	dojo.style("thinger");
		//	example:
		//		Passing a node and a style property returns the current
		//		normalized, computed value for that property:
		//	|	dojo.style("thinger", "opacity"); // 1 by default
		//
		//	example:
		//		Passing a node, a style property, and a value changes the
		//		current display of the node and returns the new computed value
		//	|	dojo.style("thinger", "opacity", 0.5); // == 0.5
		//
		//	example:
		//		Passing a node, an object-style style property sets each of the values in turn and returns the computed style object of the node:
		//	|	dojo.style("thinger", {
		//	|		"opacity": 0.5,
		//	|		"border": "3px solid black",
		//	|		"height": "300px"
		//	|	});
		//
		// 	example:
		//		When the CSS style property is hyphenated, the JavaScript property is camelCased.
		//		font-size becomes fontSize, and so on.
		//	|	dojo.style("thinger",{
		//	|		fontSize:"14pt",
		//	|		letterSpacing:"1.2em"
		//	|	});
		//
		//	example:
		//		dojo.NodeList implements .style() using the same syntax, omitting the "node" parameter, calling
		//		dojo.style() on every element of the list. See: dojo.query and dojo.NodeList
		//	|	dojo.query(".someClassName").style("visibility","hidden");
		//	|	// or
		//	|	dojo.query("#baz > div").style({
		//	|		opacity:0.75,
		//	|		fontSize:"13pt"
		//	|	});

		var n = d.byId(node), args = arguments.length, op = (style == "opacity");
		style = _floatAliases[style] || style;
		if(args == 3){
			return op ? d._setOpacity(n, value) : n.style[style] = value; /*Number*/
		}
		if(args == 2 && op){
			return d._getOpacity(n);
		}
		var s = gcs(n);
		if(args == 2 && !d.isString(style)){
			for(var x in style){
				d.style(node, x, style[x]);
			}
			return s;
		}
		return (args == 1) ? s : _toStyleValue(n, style, s[style] || n.style[style]); /* CSS2Properties||String||Number */
	}

	// =============================
	// Box Functions
	// =============================

	dojo._getPadExtents = function(/*DomNode*/n, /*Object*/computedStyle){
		//	summary:
		// 		Returns object with special values specifically useful for node
		// 		fitting.
		//
		// 		* l/t = left/top padding (respectively)
		// 		* w = the total of the left and right padding 
		// 		* h = the total of the top and bottom padding
		//
		//		If 'node' has position, l/t forms the origin for child nodes. 
		//		The w/h are used for calculating boxes.
		//		Normally application code will not need to invoke this
		//		directly, and will use the ...box... functions instead.
		var 
			s = computedStyle||gcs(n), 
			l = px(n, s.paddingLeft), 
			t = px(n, s.paddingTop);
		return { 
			l: l,
			t: t,
			w: l+px(n, s.paddingRight),
			h: t+px(n, s.paddingBottom)
		};
	}

	dojo._getBorderExtents = function(/*DomNode*/n, /*Object*/computedStyle){
		//	summary:
		//		returns an object with properties useful for noting the border
		//		dimensions.
		//
		// 		* l/t = the sum of left/top border (respectively)
		//		* w = the sum of the left and right border
		//		* h = the sum of the top and bottom border
		//
		//		The w/h are used for calculating boxes.
		//		Normally application code will not need to invoke this
		//		directly, and will use the ...box... functions instead.
		var 
			ne = "none",
			s = computedStyle||gcs(n), 
			bl = (s.borderLeftStyle != ne ? px(n, s.borderLeftWidth) : 0),
			bt = (s.borderTopStyle != ne ? px(n, s.borderTopWidth) : 0);
		return { 
			l: bl,
			t: bt,
			w: bl + (s.borderRightStyle!=ne ? px(n, s.borderRightWidth) : 0),
			h: bt + (s.borderBottomStyle!=ne ? px(n, s.borderBottomWidth) : 0)
		};
	}

	dojo._getPadBorderExtents = function(/*DomNode*/n, /*Object*/computedStyle){
		//	summary:
		//		Returns object with properties useful for box fitting with
		//		regards to padding.
		//
		//		* l/t = the sum of left/top padding and left/top border (respectively)
		//		* w = the sum of the left and right padding and border
		//		* h = the sum of the top and bottom padding and border
		//
		//		The w/h are used for calculating boxes.
		//		Normally application code will not need to invoke this
		//		directly, and will use the ...box... functions instead.
		var 
			s = computedStyle||gcs(n), 
			p = d._getPadExtents(n, s),
			b = d._getBorderExtents(n, s);
		return { 
			l: p.l + b.l,
			t: p.t + b.t,
			w: p.w + b.w,
			h: p.h + b.h
		};
	}

	dojo._getMarginExtents = function(n, computedStyle){
		//	summary:
		//		returns object with properties useful for box fitting with
		//		regards to box margins (i.e., the outer-box).
		//
		//		* l/t = marginLeft, marginTop, respectively
		//		* w = total width, margin inclusive
		//		* h = total height, margin inclusive
		//
		//		The w/h are used for calculating boxes.
		//		Normally application code will not need to invoke this
		//		directly, and will use the ...box... functions instead.
		var 
			s = computedStyle||gcs(n), 
			l = px(n, s.marginLeft),
			t = px(n, s.marginTop),
			r = px(n, s.marginRight),
			b = px(n, s.marginBottom);
		if(d.isWebKit && (s.position != "absolute")){
			// FIXME: Safari's version of the computed right margin
			// is the space between our right edge and the right edge 
			// of our offsetParent. 
			// What we are looking for is the actual margin value as 
			// determined by CSS.
			// Hack solution is to assume left/right margins are the same.
			r = l;
		}
		return { 
			l: l,
			t: t,
			w: l+r,
			h: t+b
		};
	}

	// Box getters work in any box context because offsetWidth/clientWidth
	// are invariant wrt box context
	//
	// They do *not* work for display: inline objects that have padding styles
	// because the user agent ignores padding (it's bogus styling in any case)
	//
	// Be careful with IMGs because they are inline or block depending on 
	// browser and browser mode.

	// Although it would be easier to read, there are not separate versions of 
	// _getMarginBox for each browser because:
	// 1. the branching is not expensive
	// 2. factoring the shared code wastes cycles (function call overhead)
	// 3. duplicating the shared code wastes bytes
	
	dojo._getMarginBox = function(/*DomNode*/node, /*Object*/computedStyle){
		// summary:
		//		returns an object that encodes the width, height, left and top
		//		positions of the node's margin box.
		var s = computedStyle || gcs(node), me = d._getMarginExtents(node, s);
		var l = node.offsetLeft - me.l, t = node.offsetTop - me.t, p = node.parentNode;
				if(d.isMoz){
			// Mozilla:
			// If offsetParent has a computed overflow != visible, the offsetLeft is decreased
			// by the parent's border.
			// We don't want to compute the parent's style, so instead we examine node's
			// computed left/top which is more stable.
			var sl = parseFloat(s.left), st = parseFloat(s.top);
			if(!isNaN(sl) && !isNaN(st)){
				l = sl, t = st;
			}else{
				// If child's computed left/top are not parseable as a number (e.g. "auto"), we
				// have no choice but to examine the parent's computed style.
				if(p && p.style){
					var pcs = gcs(p);
					if(pcs.overflow != "visible"){
						var be = d._getBorderExtents(p, pcs);
						l += be.l, t += be.t;
					}
				}
			}
		}else if(d.isOpera || (d.isIE > 7 && !d.isQuirks)){
			// On Opera and IE 8, offsetLeft/Top includes the parent's border
			if(p){
				be = d._getBorderExtents(p);
				l -= be.l;
				t -= be.t;
			}
		}
				return { 
			l: l, 
			t: t, 
			w: node.offsetWidth + me.w, 
			h: node.offsetHeight + me.h 
		};
	}
	
	dojo._getContentBox = function(node, computedStyle){
		// summary:
		//		Returns an object that encodes the width, height, left and top
		//		positions of the node's content box, irrespective of the
		//		current box model.

		// clientWidth/Height are important since the automatically account for scrollbars
		// fallback to offsetWidth/Height for special cases (see #3378)
		var s = computedStyle || gcs(node),
			pe = d._getPadExtents(node, s),
			be = d._getBorderExtents(node, s),
			w = node.clientWidth, 
			h
		;
		if(!w){
			w = node.offsetWidth, h = node.offsetHeight;
		}else{
			h = node.clientHeight, be.w = be.h = 0; 
		}
		// On Opera, offsetLeft includes the parent's border
				if(d.isOpera){ pe.l += be.l; pe.t += be.t; };
				return { 
			l: pe.l, 
			t: pe.t, 
			w: w - pe.w - be.w, 
			h: h - pe.h - be.h
		};
	}

	dojo._getBorderBox = function(node, computedStyle){
		var s = computedStyle || gcs(node), 
			pe = d._getPadExtents(node, s),
			cb = d._getContentBox(node, s)
		;
		return { 
			l: cb.l - pe.l, 
			t: cb.t - pe.t, 
			w: cb.w + pe.w, 
			h: cb.h + pe.h
		};
	}

	// Box setters depend on box context because interpretation of width/height styles
	// vary wrt box context.
	//
	// The value of dojo.boxModel is used to determine box context.
	// dojo.boxModel can be set directly to change behavior.
	//
	// Beware of display: inline objects that have padding styles
	// because the user agent ignores padding (it's a bogus setup anyway)
	//
	// Be careful with IMGs because they are inline or block depending on 
	// browser and browser mode.
	// 
	// Elements other than DIV may have special quirks, like built-in
	// margins or padding, or values not detectable via computedStyle.
	// In particular, margins on TABLE do not seems to appear 
	// at all in computedStyle on Mozilla.
	
	dojo._setBox = function(/*DomNode*/node, /*Number?*/l, /*Number?*/t, /*Number?*/w, /*Number?*/h, /*String?*/u){
		//	summary:
		//		sets width/height/left/top in the current (native) box-model
		//		dimentions. Uses the unit passed in u.
		//	node: DOM Node reference. Id string not supported for performance reasons.
		//	l: optional. left offset from parent.
		//	t: optional. top offset from parent.
		//	w: optional. width in current box model.
		//	h: optional. width in current box model.
		//	u: optional. unit measure to use for other measures. Defaults to "px".
		u = u || "px";
		var s = node.style;
		if(!isNaN(l)){ s.left = l + u; }
		if(!isNaN(t)){ s.top = t + u; }
		if(w >= 0){ s.width = w + u; }
		if(h >= 0){ s.height = h + u; }
	}

	dojo._isButtonTag = function(/*DomNode*/node) {
		// summary:
		//		True if the node is BUTTON or INPUT.type="button".
		return node.tagName == "BUTTON" 
			|| node.tagName=="INPUT" && node.getAttribute("type").toUpperCase() == "BUTTON"; // boolean
	}
	
	dojo._usesBorderBox = function(/*DomNode*/node){
		//	summary: 
		//		True if the node uses border-box layout.

		// We could test the computed style of node to see if a particular box
		// has been specified, but there are details and we choose not to bother.
		
		// TABLE and BUTTON (and INPUT type=button) are always border-box by default.
		// If you have assigned a different box to either one via CSS then
		// box functions will break.
		
		var n = node.tagName;
		return d.boxModel=="border-box" || n=="TABLE" || d._isButtonTag(node); // boolean
	}

	dojo._setContentSize = function(/*DomNode*/node, /*Number*/widthPx, /*Number*/heightPx, /*Object*/computedStyle){
		//	summary:
		//		Sets the size of the node's contents, irrespective of margins,
		//		padding, or borders.
		if(d._usesBorderBox(node)){
			var pb = d._getPadBorderExtents(node, computedStyle);
			if(widthPx >= 0){ widthPx += pb.w; }
			if(heightPx >= 0){ heightPx += pb.h; }
		}
		d._setBox(node, NaN, NaN, widthPx, heightPx);
	}

	dojo._setMarginBox = function(/*DomNode*/node, 	/*Number?*/leftPx, /*Number?*/topPx, 
													/*Number?*/widthPx, /*Number?*/heightPx, 
													/*Object*/computedStyle){
		//	summary:
		//		sets the size of the node's margin box and placement
		//		(left/top), irrespective of box model. Think of it as a
		//		passthrough to dojo._setBox that handles box-model vagaries for
		//		you.

		var s = computedStyle || gcs(node),
		// Some elements have special padding, margin, and box-model settings. 
		// To use box functions you may need to set padding, margin explicitly.
		// Controlling box-model is harder, in a pinch you might set dojo.boxModel.
			bb = d._usesBorderBox(node),
			pb = bb ? _nilExtents : d._getPadBorderExtents(node, s)
		;
		if(d.isWebKit){
			// on Safari (3.1.2), button nodes with no explicit size have a default margin
			// setting an explicit size eliminates the margin.
			// We have to swizzle the width to get correct margin reading.
			if(d._isButtonTag(node)){
				var ns = node.style;
				if(widthPx >= 0 && !ns.width) { ns.width = "4px"; }
				if(heightPx >= 0 && !ns.height) { ns.height = "4px"; }
			}
		}
		var mb = d._getMarginExtents(node, s);
		if(widthPx >= 0){ widthPx = Math.max(widthPx - pb.w - mb.w, 0); }
		if(heightPx >= 0){ heightPx = Math.max(heightPx - pb.h - mb.h, 0); }
		d._setBox(node, leftPx, topPx, widthPx, heightPx);
	}
	
	var _nilExtents = { l:0, t:0, w:0, h:0 };

	// public API
	
	dojo.marginBox = function(/*DomNode|String*/node, /*Object?*/box){
		//	summary:
		//		Getter/setter for the margin-box of node.
		//	description: 
		//		Returns an object in the expected format of box (regardless
		//		if box is passed). The object might look like:
		//			`{ l: 50, t: 200, w: 300: h: 150 }`
		//		for a node offset from its parent 50px to the left, 200px from
		//		the top with a margin width of 300px and a margin-height of
		//		150px.
		//	node:
		//		id or reference to DOM Node to get/set box for
		//	box:
		//		If passed, denotes that dojo.marginBox() should
		//		update/set the margin box for node. Box is an object in the
		//		above format. All properties are optional if passed.
		var n = d.byId(node), s = gcs(n), b = box;
		return !b ? d._getMarginBox(n, s) : d._setMarginBox(n, b.l, b.t, b.w, b.h, s); // Object
	}

	dojo.contentBox = function(/*DomNode|String*/node, /*Object?*/box){
		//	summary:
		//		Getter/setter for the content-box of node.
		//	description:
		//		Returns an object in the expected format of box (regardless if box is passed).
		//		The object might look like:
		//			`{ l: 50, t: 200, w: 300: h: 150 }`
		//		for a node offset from its parent 50px to the left, 200px from
		//		the top with a content width of 300px and a content-height of
		//		150px. Note that the content box may have a much larger border
		//		or margin box, depending on the box model currently in use and
		//		CSS values set/inherited for node.
		//	node:
		//		id or reference to DOM Node to get/set box for
		//	box:
		//		If passed, denotes that dojo.contentBox() should
		//		update/set the content box for node. Box is an object in the
		//		above format. All properties are optional if passed.
		var n = d.byId(node), s = gcs(n), b = box;
		return !b ? d._getContentBox(n, s) : d._setContentSize(n, b.w, b.h, s); // Object
	}
	
	// =============================
	// Positioning 
	// =============================
	
	var _sumAncestorProperties = function(node, prop){
		if(!(node = (node||0).parentNode)){return 0}
		var val, retVal = 0, _b = d.body();
		while(node && node.style){
			if(gcs(node).position == "fixed"){
				return 0;
			}
			val = node[prop];
			if(val){
				retVal += val - 0;
				// opera and khtml #body & #html has the same values, we only
				// need one value
				if(node == _b){ break; }
			}
			node = node.parentNode;
		}
		return retVal;	//	integer
	}

	dojo._docScroll = function(){
		var 
			_b = d.body(),
			_w = d.global,
			de = d.doc.documentElement;
		return {
			y: (_w.pageYOffset || de.scrollTop || _b.scrollTop || 0),
			x: (_w.pageXOffset || d._fixIeBiDiScrollLeft(de.scrollLeft) || _b.scrollLeft || 0)
		};
	};
	
	dojo._isBodyLtr = function(){
		return "_bodyLtr" in d? d._bodyLtr :
			d._bodyLtr = (d.body().dir || d.doc.documentElement.dir || "ltr").toLowerCase() == "ltr"; // Boolean
	}
	
		dojo._getIeDocumentElementOffset = function(){
		// summary
		// The following values in IE contain an offset:
		//     event.clientX
		//     event.clientY
		//     node.getBoundingClientRect().left
		//     node.getBoundingClientRect().top
		// But other position related values do not contain this offset, such as
		// node.offsetLeft, node.offsetTop, node.style.left and node.style.top.
		// The offset is always (2, 2) in LTR direction. When the body is in RTL
		// direction, the offset counts the width of left scroll bar's width.
		// This function computes the actual offset.

		//NOTE: assumes we're being called in an IE browser

		var de = d.doc.documentElement;
		//FIXME: use this instead?			var de = d.compatMode == "BackCompat" ? d.body : d.documentElement;

		if(d.isIE < 7){
			return { x: d._isBodyLtr() || window.parent == window ?
				de.clientLeft : de.offsetWidth - de.clientWidth - de.clientLeft, 
				y: de.clientTop }; // Object
		}else if(d.isIE < 8){
			return {x: de.getBoundingClientRect().left, y: de.getBoundingClientRect().top};
		}else{
			return {
				x: 0,
				y: 0
			};
		}

	};
		
	dojo._fixIeBiDiScrollLeft = function(/*Integer*/ scrollLeft){
		// In RTL direction, scrollLeft should be a negative value, but IE < 8
		// returns a positive one. All codes using documentElement.scrollLeft
		// must call this function to fix this error, otherwise the position
		// will offset to right when there is a horizontal scrollbar.

				var dd = d.doc;
		if(d.isIE < 8 && !d._isBodyLtr()){
			var de = dd.compatMode == "BackCompat" ? dd.body : dd.documentElement;
			return scrollLeft + de.clientWidth - de.scrollWidth; // Integer
		}
				return scrollLeft; // Integer
	}

	dojo._abs = function(/*DomNode*/node, /*Boolean?*/includeScroll){
		//	summary:
		//		Gets the position of the passed element relative to
		//		the viewport (if includeScroll==false), or relative to the
		//		document root (if includeScroll==true).
		//
		//		Returns an object of the form:
		//			{ x: 100, y: 300 }
		//		if includeScroll is passed, the x and y values will include any
		//		document offsets that may affect the position relative to the
		//		viewport.

		// FIXME: need to decide in the brave-new-world if we're going to be
		// margin-box or border-box.
		
		// targetBoxType == "border-box"
		var db = d.body(), dh = d.body().parentNode, ret;
		if(node["getBoundingClientRect"]){
			// IE6+, FF3+, super-modern WebKit, and Opera 9.6+ all take this branch
			var client = node.getBoundingClientRect();
			ret = { x: client.left, y: client.top };
					if(d.isFF >= 3){
				// in FF3 you have to subtract the document element margins
				var cs = gcs(dh);
				ret.x -= px(dh, cs.marginLeft) + px(dh, cs.borderLeftWidth);
				ret.y -= px(dh, cs.marginTop) + px(dh, cs.borderTopWidth);
			}
			if(d.isIE){
				// On IE there's a 2px offset that we need to adjust for, see _getIeDocumentElementOffset()
				var offset = d._getIeDocumentElementOffset();

				// fixes the position in IE, quirks mode
				ret.x -= offset.x + (d.isQuirks ? db.clientLeft : 0);
				ret.y -= offset.y + (d.isQuirks ? db.clientTop : 0);
			}
				}else{
			// FF2 and Safari
			ret = {
				x: 0,
				y: 0
			};
			if(node["offsetParent"]){
				ret.x -= _sumAncestorProperties(node, "scrollLeft");
				ret.y -= _sumAncestorProperties(node, "scrollTop");
				
				var curnode = node;
				do{
					var n = curnode.offsetLeft,
						t = curnode.offsetTop;
					ret.x += isNaN(n) ? 0 : n;
					ret.y += isNaN(t) ? 0 : t;

					cs = gcs(curnode);
					if(curnode != node){
								if(d.isFF){
							// tried left+right with differently sized left/right borders
							// it really is 2xleft border in FF, not left+right, even in RTL!
							ret.x += 2 * px(curnode,cs.borderLeftWidth);
							ret.y += 2 * px(curnode,cs.borderTopWidth);
						}else{
									ret.x += px(curnode, cs.borderLeftWidth);
							ret.y += px(curnode, cs.borderTopWidth);
								}
							}
					// static children in a static div in FF2 are affected by the div's border as well
					// but offsetParent will skip this div!
							if(d.isFF && cs.position=="static"){
						var parent=curnode.parentNode;
						while(parent!=curnode.offsetParent){
							var pcs=gcs(parent);
							if(pcs.position=="static"){
								ret.x += px(curnode,pcs.borderLeftWidth);
								ret.y += px(curnode,pcs.borderTopWidth);
							}
							parent=parent.parentNode;
						}
					}
							curnode = curnode.offsetParent;
				}while((curnode != dh) && curnode);
			}else if(node.x && node.y){
				ret.x += isNaN(node.x) ? 0 : node.x;
				ret.y += isNaN(node.y) ? 0 : node.y;
			}
		}
		// account for document scrolling
		// if offsetParent is used, ret value already includes scroll position
		// so we may have to actually remove that value if !includeScroll
		if(includeScroll){
			var scroll = d._docScroll();
			ret.x += scroll.x;
			ret.y += scroll.y;
		}

		return ret; // Object
	}

	// FIXME: need a setter for coords or a moveTo!!
	dojo.coords = function(/*DomNode|String*/node, /*Boolean?*/includeScroll){
		//	summary:
		//		Returns an object that measures margin box width/height and
		//		absolute positioning data from dojo._abs().
		//
		//	description:
		//		Returns an object that measures margin box width/height and
		//		absolute positioning data from dojo._abs().
		//		Return value will be in the form:
		//			`{ l: 50, t: 200, w: 300: h: 150, x: 100, y: 300 }`
		//		Does not act as a setter. If includeScroll is passed, the x and
		//		y params are affected as one would expect in dojo._abs().
		var n = d.byId(node), s = gcs(n), mb = d._getMarginBox(n, s);
		var abs = d._abs(n, includeScroll);
		mb.x = abs.x;
		mb.y = abs.y;
		return mb;
	}

	// =============================
	// Element attribute Functions
	// =============================

		var ieLT8 = d.isIE < 8;
	
	var _fixAttrName = function(/*String*/name){
		switch(name.toLowerCase()){
			// Internet Explorer will only set or remove tabindex/readonly
			// if it is spelled "tabIndex"/"readOnly"
						case "tabindex":
				return ieLT8 ? "tabIndex" : "tabindex";
						case "readonly":
				return "readOnly";
			case "class":
				return "className";
						case "for": case "htmlfor":
				// to pick up for attrib set in markup via getAttribute() IE<8 uses "htmlFor" and others use "for"
				// get/setAttribute works in all as long use same value for both get/set
				return ieLT8 ? "htmlFor" : "for";
						default:
				return name;
		}
	}

	// non-deprecated HTML4 attributes with default values
	// http://www.w3.org/TR/html401/index/attributes.html
	// FF and Safari will return the default values if you
	// access the attributes via a property but not
	// via getAttribute()
	var _attrProps = {
		colspan: "colSpan",
		enctype: "enctype",
		frameborder: "frameborder",
		method: "method",
		rowspan: "rowSpan",
		scrolling: "scrolling",
		shape: "shape",
		span: "span",
		type: "type",
		valuetype: "valueType",
		// the following attributes don't have the default but should be treated like properties
		classname: "className",
		innerhtml: "innerHTML"
	}

	dojo.hasAttr = function(/*DomNode|String*/node, /*String*/name){
		//	summary:
		//		Returns true if the requested attribute is specified on the
		//		given element, and false otherwise.
		//	node:
		//		id or reference to the element to check
		//	name:
		//		the name of the attribute
		//	returns:
		//		true if the requested attribute is specified on the
		//		given element, and false otherwise
		node = d.byId(node);
		var fixName = _fixAttrName(name);
		fixName = fixName == "htmlFor" ? "for" : fixName; //IE<8 uses htmlFor except in this case
		var attr = node.getAttributeNode && node.getAttributeNode(fixName);
		return attr ? attr.specified : false; // Boolean
	}

	var _evtHdlrMap = {}, _ctr = 0,
		_attrId = dojo._scopeName + "attrid",
		// the next dictionary lists elements with read-only innerHTML on IE
		_roInnerHtml = {col: 1, colgroup: 1,
			// frameset: 1, head: 1, html: 1, style: 1,
			table: 1, tbody: 1, tfoot: 1, thead: 1, tr: 1, title: 1};

	dojo.attr = function(/*DomNode|String*/node, /*String|Object*/name, /*String?*/value){
		//	summary:
		//		Gets or sets an attribute on an HTML element.
		//	description:
		//		Handles normalized getting and setting of attributes on DOM
		//		Nodes. If 2 arguments are passed, and a the second argumnt is a
		//		string, acts as a getter.
		//	
		//		If a third argument is passed, or if the second argumnt is a
		//		map of attributes, acts as a setter.
		//
		//		When passing functions as values, note that they will not be
		//		directly assigned to slots on the node, but rather the default
		//		behavior will be removed and the new behavior will be added
		//		using `dojo.connect()`, meaning that event handler properties
		//		will be normalized and that some caveats with regards to
		//		non-standard behaviors for onsubmit apply. Namely that you
		//		should cancel form submission using `dojo.stopEvent()` on the
		//		passed event object instead of returning a boolean value from
		//		the handler itself.
		//	node:
		//		id or reference to the element to get or set the attribute on
		//	name:
		//		the name of the attribute to get or set.
		//	value:
		//		The value to set for the attribute
		//	returns:
		//		when used as a getter, the value of the requested attribute
		//		or null if that attribute does not have a specified or
		//		default value;
		//
		//		when used as a setter, undefined
		//
		//	example:
		//	|	// get the current value of the "foo" attribute on a node
		//	|	dojo.attr(dojo.byId("nodeId"), "foo");
		//	|	// or we can just pass the id:
		//	|	dojo.attr("nodeId", "foo");
		//
		//	example:
		//	|	// use attr() to set the tab index
		//	|	dojo.attr("nodeId", "tabindex", 3);
		//	|
		//
		//	example:
		//	Set multiple values at once, including event handlers:
		//	|	dojo.attr("formId", {
		//	|		"foo": "bar",
		//	|		"tabindex": -1,
		//	|		"method": "POST",
		//	|		"onsubmit": function(e){
		//	|			// stop submitting the form. Note that the IE behavior
		//	|			// of returning true or false will have no effect here
		//	|			// since our handler is connect()ed to the built-in
		//	|			// onsubmit behavior and so we need to use
		//	|			// dojo.stopEvent() to ensure that the submission
		//	|			// doesn't proceed.
		//	|			dojo.stopEvent(e);
		//	|
		//	|			// submit the form with Ajax
		//	|			dojo.xhrPost({ form: "formId" });
		//	|		}
		//	|	});
		//
		//	example:
		//	Style is s special case: Only set with an object hash of styles
		//	|	dojo.attr("someNode",{
		//	|		id:"bar",
		//	|		style:{
		//	|			width:"200px", height:"100px", color:"#000"
		//	|		}
		//	|	});
		//
		//	example:
		//	Again, only set style as an object hash of styles:
		//	|	var obj = { color:"#fff", backgroundColor:"#000" };
		//	|	dojo.attr("someNode", "style", obj);
		//	|
		//	|	// though shorter to use `dojo.style` in this case:
		//	|	dojo.style("someNode", obj);
		
		node = d.byId(node);
		var args = arguments.length;
		if(args == 2 && !d.isString(name)){
			// the object form of setter: the 2nd argument is a dictionary
			for(var x in name){ d.attr(node, x, name[x]); }
			// FIXME: return the node in this case? could be useful.
			return;
		}
		name = _fixAttrName(name);
		if(args == 3){ // setter
			if(d.isFunction(value)){
				// clobber if we can
				var attrId = d.attr(node, _attrId);
				if(!attrId){
					attrId = _ctr++;
					d.attr(node, _attrId, attrId);
				}
				if(!_evtHdlrMap[attrId]){
					_evtHdlrMap[attrId] = {};
				}
				var h = _evtHdlrMap[attrId][name];
				if(h){
					d.disconnect(h);
				}else{
					try{
						delete node[name];
					}catch(e){}
				}

				// ensure that event objects are normalized, etc.
				_evtHdlrMap[attrId][name] = d.connect(node, name, value);

			}else if(typeof value == "boolean"){ // e.g. onsubmit, disabled
				node[name] = value;
			}else if(name === "style" && !d.isString(value)){
				// when the name is "style" and value is an object, pass along
				d.style(node, value);
			}else if(name == "className"){
				node.className = value;
			}else if(name === "innerHTML"){
								if(d.isIE && node.tagName.toLowerCase() in _roInnerHtml){
					d.empty(node);
					node.appendChild(d._toDom(value, node.ownerDocument));
				}else{
									node[name] = value;
								}
							}else{
				node.setAttribute(name, value);
			}
		}else{
			// getter
			// should we access this attribute via a property or
			// via getAttribute()?
			var prop = _attrProps[name.toLowerCase()];
			if(prop){
				return node[prop];
			}
			var attrValue = node[name];
			return (typeof attrValue == 'boolean' || typeof attrValue == 'function') ? attrValue
				: (d.hasAttr(node, name) ? node.getAttribute(name) : null);
		}
	}

	dojo.removeAttr = function(/*DomNode|String*/node, /*String*/name){
		//	summary:
		//		Removes an attribute from an HTML element.
		//	node:
		//		id or reference to the element to remove the attribute from
		//	name:
		//		the name of the attribute to remove
		d.byId(node).removeAttribute(_fixAttrName(name));
	}
	
	dojo.create = function(tag, attrs, refNode, pos){
		// summary: Create an element, allowing for optional attribute decoration
		//		and placement. 
		//
		// description:
		//		A DOM Element creation function. A shorthand method for creating a node or
		//		a fragment, and allowing for a convenient optional attribute setting step, 
		//		as well as an optional DOM placement reference.
		//|
		//		Attributes are set by passing the optional object through `dojo.attr`.
		//		See `dojo.attr` for noted caveats and nuances, and API if applicable. 
		//|
		//		Placement is done via `dojo.place`, assuming the new node to be the action 
		//		node, passing along the optional reference node and position. 
		//
		// tag: String|DomNode
		//		A string of the element to create (eg: "div", "a", "p", "li", "script", "br"),
		//		or an existing DOM node to process.
		//
		// attrs: Object
		//		An object-hash of attributes to set on the newly created node.
		//		Can be null, if you don't want to set any attributes/styles.
		//		See: `dojo.attr` for a description of available attributes.
		//
		// refNode: String?|DomNode?
		//		Optional reference node. Used by `dojo.place` to place the newly created
		//		node somewhere in the dom relative to refNode. Can be a DomNode reference
		//		or String ID of a node.
		//	
		// pos: String?
		//		Optional positional reference. Defaults to "last" by way of `dojo.place`,
		//		though can be set to "first","after","before","last", "replace" or "only"
		//		to further control the placement of the new node relative to the refNode.
		//		'refNode' is required if a 'pos' is specified.
		//
		// returns: DomNode
		//
		// example:
		//	Create a DIV:
		//	| var n = dojo.create("div");
		//
		// example:
		//	Create a DIV with content:
		//	| var n = dojo.create("div", { innerHTML:"<p>hi</p>" });
		//
		// example:
		//	Place a new DIV in the BODY, with no attributes set
		//	| var n = dojo.create("div", null, dojo.body());
		//
		// example:
		//	Create an UL, and populate it with LI's. Place the list as the first-child of a 
		//	node with id="someId":
		//	| var ul = dojo.create("ul", null, "someId", "first"); 
		//	| var items = ["one", "two", "three", "four"];
		//	| dojo.forEach(items, function(data){
		//	|	dojo.create("li", { innerHTML: data }, ul);
		//	| });
		//
		// example:
		//	Create an anchor, with an href. Place in BODY:
		//	| dojo.create("a", { href:"foo.html", title:"Goto FOO!" }, dojo.body());
		//
		// example:
		//	Create a `dojo.NodeList` from a new element (for syntatic sugar):
		//	|	dojo.query(dojo.create('div'))
		//	|		.addClass("newDiv")
		//	|		.onclick(function(e){ console.log('clicked', e.target) })
		//	|		.place("#someNode"); // redundant, but cleaner.

		var doc = d.doc;
		if(refNode){		
			refNode = d.byId(refNode);
			doc = refNode.ownerDocument;
		}
		if(d.isString(tag)){
			tag = doc.createElement(tag);
		}
		if(attrs){ d.attr(tag, attrs); }
		if(refNode){ d.place(tag, refNode, pos); }
		return tag; // DomNode
	}
	
	/*=====
	dojo.empty = function(node){
			//	summary:
			//		safely removes all children of the node.
			//	node: DOMNode|String
			//		a reference to a DOM node or an id.
			//	example:
			//	Destroy node's children byId:
			//	| dojo.empty("someId");
			//
			//	example:
			//	Destroy all nodes' children in a list by reference:
			//	| dojo.query(".someNode").forEach(dojo.empty);
	}
	=====*/

	d.empty = 
				d.isIE ?  function(node){
			node = d.byId(node);
			for(var c; c = node.lastChild;){ // intentional assignment
				d.destroy(c);
			}
		} :
				function(node){
			d.byId(node).innerHTML = "";
		};

	/*=====
	dojo._toDom = function(frag, doc){
			//	summary:
			//		instantiates an HTML fragment returning the corresponding DOM.
			//	frag: String
			//		the HTML fragment
			//	doc: DocumentNode?
			//		optional document to use when creating DOM nodes, defaults to
			//		dojo.doc if not specified.
			//	returns: DocumentFragment
			//
			//	example:
			//	Create a table row:
			//	| var tr = dojo._toDom("<tr><td>First!</td></tr>");
	}
	=====*/

	// support stuff for dojo._toDom
	var tagWrap = {
			option: ["select"],
			tbody: ["table"],
			thead: ["table"],
			tfoot: ["table"],
			tr: ["table", "tbody"],
			td: ["table", "tbody", "tr"],
			th: ["table", "thead", "tr"],
			legend: ["fieldset"],
			caption: ["table"],
			colgroup: ["table"],
			col: ["table", "colgroup"],
			li: ["ul"]
		},
		reTag = /<\s*([\w\:]+)/,
		masterNode = {}, masterNum = 0,
		masterName = "__" + d._scopeName + "ToDomId";

	// generate start/end tag strings to use
	// for the injection for each special tag wrap case.
	for(var param in tagWrap){
		var tw = tagWrap[param];
		tw.pre  = param == "option" ? '<select multiple="multiple">' : "<" + tw.join("><") + ">";
		tw.post = "</" + tw.reverse().join("></") + ">";
		// the last line is destructive: it reverses the array,
		// but we don't care at this point
	}

	d._toDom = function(frag, doc){
		// summary converts HTML string into DOM nodes.

		doc = doc || d.doc;
		var masterId = doc[masterName];
		if(!masterId){
			doc[masterName] = masterId = ++masterNum + "";
			masterNode[masterId] = doc.createElement("div");
		}

		// make sure the frag is a string.
		frag += "";

		// find the starting tag, and get node wrapper
		var match = frag.match(reTag),
			tag = match ? match[1].toLowerCase() : "",
			master = masterNode[masterId],
			wrap, i, fc, df;
		if(match && tagWrap[tag]){
			wrap = tagWrap[tag];
			master.innerHTML = wrap.pre + frag + wrap.post;
			for(i = wrap.length; i; --i){
				master = master.firstChild;
			}
		}else{
			master.innerHTML = frag;
		}

		// one node shortcut => return the node itself
		if(master.childNodes.length == 1){
			return master.removeChild(master.firstChild); // DOMNode
		}
		
		// return multiple nodes as a document fragment
		df = doc.createDocumentFragment();
		while(fc = master.firstChild){ // intentional assignment
			df.appendChild(fc);
		}
		return df; // DOMNode
	}

	// =============================
	// (CSS) Class Functions
	// =============================
	var _className = "className";

	dojo.hasClass = function(/*DomNode|String*/node, /*String*/classStr){
		//	summary:
		//		Returns whether or not the specified classes are a portion of the
		//		class list currently applied to the node. 
		//
		//	node: 
		//		String ID or DomNode reference to check the class for.
		//
		//	classStr:
		//		A string class name to look for.
		// 
		//	example:
		//	| if(dojo.hasClass("someNode","aSillyClassName")){ ... }
		
		return ((" "+ d.byId(node)[_className] +" ").indexOf(" "+ classStr +" ") >= 0);  // Boolean
	};

	dojo.addClass = function(/*DomNode|String*/node, /*String*/classStr){
		//	summary:
		//		Adds the specified classes to the end of the class list on the
		//		passed node. Will not re-apply duplicate classes, except in edge
		//		cases when adding multiple classes at once.
		//
		//	node: String ID or DomNode reference to add a class string too
		//	classStr: A String class name to add
		//
		// example:
		//	Add A class to some node:
		//	|	dojo.addClass("someNode", "anewClass");
		//
		// example:
		//	Add two classes at once (could potentially add duplicate):
		//	| 	dojo.addClass("someNode", "firstClass secondClass");
		//
		// example:
		//	Available in `dojo.NodeList` for multiple additions
		//	| dojo.query("ul > li").addClass("firstLevel");
		
		node = d.byId(node);
		var cls = node[_className];
		if((" "+ cls +" ").indexOf(" " + classStr + " ") < 0){
			node[_className] = cls + (cls ? ' ' : '') + classStr;
		}
	};

	dojo.removeClass = function(/*DomNode|String*/node, /*String*/classStr){
		// summary: Removes the specified classes from node. No `dojo.hasClass` 
		//		check is required. 
		//
		// node: String ID or DomNode reference to remove the class from.
		//
		// classString: String class name to remove
		//
		// example:
		// 	| dojo.removeClass("someNode", "firstClass");
		//
		// example:
		//	Available in `dojo.NodeList` for multiple removal
		//	| dojo.query(".foo").removeClass("foo");
		
		node = d.byId(node);
		var t = d.trim((" " + node[_className] + " ").replace(" " + classStr + " ", " "));
		if(node[_className] != t){ node[_className] = t; }
	};

	dojo.toggleClass = function(/*DomNode|String*/node, /*String*/classStr, /*Boolean?*/condition){
		//	summary:
		//		Adds a class to node if not present, or removes if present.
		//		Pass a boolean condition if you want to explicitly add or remove.
		//	condition:
		//		If passed, true means to add the class, false means to remove.
		//
		// example:
		//	| dojo.toggleClass("someNode", "hovered");
		//
		// example:
		// 	Forcefully add a class
		//	| dojo.toggleClass("someNode", "hovered", true);
		//
		// example:
		//	Available in `dojo.NodeList` for multiple toggles
		//	| dojo.query(".toggleMe").toggleClass("toggleMe");
		
		if(condition === undefined){
			condition = !d.hasClass(node, classStr);
		}
		d[condition ? "addClass" : "removeClass"](node, classStr);
	};

})();

}

if(!dojo._hasResource["dojo._base.NodeList"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo._base.NodeList"] = true;
dojo.provide("dojo._base.NodeList");



(function(){

	var d = dojo;

	var ap = Array.prototype, aps = ap.slice, apc = ap.concat;
	
	var tnl = function(a){
		// decorate an array to make it look like a NodeList
		a.constructor = d.NodeList;
		dojo._mixin(a, d.NodeList.prototype);
		return a;
	};

	var loopBody = function(f, a, o){
		a = [0].concat(aps.call(a, 0));
		if(!a.sort){
			// make sure it's a real array before we pass it on to be wrapped
			a = aps.call(a, 0);
		}
		o = o || d.global;
		return function(node){
			a[0] = node;
			return f.apply(o, a);
		};
	};
	
	// adapters

	var adaptAsForEach = function(f, o){
		//	summary:
		//		adapts a single node function to be used in the forEach-type
		//		actions. The initial object is returned from the specialized
		//		function.
		//	f: Function
		//		a function to adapt
		//	o: Object?
		//		an optional context for f
		return function(){
			this.forEach(loopBody(f, arguments, o));
			return this;	// Object
		};
	};

	var adaptAsMap = function(f, o){
		//	summary:
		//		adapts a single node function to be used in the map-type
		//		actions. The return is a new array of values, as via `dojo.map`
		//	f: Function
		//		a function to adapt
		//	o: Object?
		//		an optional context for f
		return function(){
			return this.map(loopBody(f, arguments, o));
		};
	};
	
	var adaptAsFilter = function(f, o){
		//	summary:
		//		adapts a single node function to be used in the filter-type actions
		//	f: Function
		//		a function to adapt
		//	o: Object?
		//		an optional context for f
		return function(){
			return this.filter(loopBody(f, arguments, o));
		};
	};
	
	var adaptWithCondition = function(f, g, o){
		//	summary: 
		//		adapts a single node function to be used in the map-type
		//		actions, behaves like forEach() or map() depending on arguments
		//	f: Function
		//		a function to adapt
		//	g: Function
		//		a condition function, if true runs as map(), otherwise runs as forEach()
		//	o: Object?
		//		an optional context for f and g
		return function(){
			var a = arguments, body = loopBody(f, a, o);
			if(g.call(o || d.global, a)){
				return this.map(body);	// self
			}
			this.forEach(body);
			return this;	// self
		};
	};
	
	var magicGuard = function(a){
		//	summary:
		//		the guard function for dojo.attr() and dojo.style()
		return a.length == 1 && d.isString(a[0])
	};
	
	var orphan = function(node){
		//	summary:
		//		function to orphan nodes
		var p = node.parentNode;
		if(p){
			p.removeChild(node);
		}
	};
	// FIXME: should we move orphan() to dojo.html?

	dojo.NodeList = function(){
		//	summary:
		//		dojo.NodeList is an of Array subclass which adds syntactic
		//		sugar for chaining, common iteration operations, animation, and
		//		node manipulation. NodeLists are most often returned as the
		//		result of dojo.query() calls.
		//	description:
		//		dojo.NodeList instances provide many utilities that reflect
		//		core Dojo APIs for Array iteration and manipulation, DOM
		//		manipulation, and event handling. Instead of needing to dig up
		//		functions in the dojo.* namespace, NodeLists generally make the
		//		full power of Dojo available for DOM manipulation tasks in a
		//		simple, chainable way.
		//	example:
		//		create a node list from a node
		//		|	new dojo.NodeList(dojo.byId("foo"));
		//	example:
		//		get a NodeList from a CSS query and iterate on it
		//		|	var l = dojo.query(".thinger");
		//		|	l.forEach(function(node, index, nodeList){
		//		|		console.log(index, node.innerHTML);
		//		|	});
		//	example:
		//		use native and Dojo-provided array methods to manipulate a
		//		NodeList without needing to use dojo.* functions explicitly:
		//		|	var l = dojo.query(".thinger");
		//		|	// since NodeLists are real arrays, they have a length
		//		|	// property that is both readable and writable and
		//		|	// push/pop/shift/unshift methods
		//		|	console.log(l.length);
		//		|	l.push(dojo.create("<span>howdy!</span>"));
		//		|
		//		|	// dojo's normalized array methods work too:
		//		|	console.log( l.indexOf(dojo.byId("foo")) );
		//		|	// ...including the special "function as string" shorthand
		//		|	console.log( l.every("item.nodeType == 1") );
		//		|
		//		|	// NodeLists can be [..] indexed, or you can use the at()
		//		|	// function to get specific items wrapped in a new NodeList:
		//		|	var node = l[3]; // the 4th element
		//		|	var newList = l.at(1, 3); // the 2nd and 4th elements
		//	example:
		//		the style functions you expect are all there too:
		//		|	// style() as a getter...
		//		|	var borders = dojo.query(".thinger").style("border");
		//		|	// ...and as a setter:
		//		|	dojo.query(".thinger").style("border", "1px solid black");
		//		|	// class manipulation
		//		|	dojo.query("li:nth-child(even)").addClass("even");
		//		|	// even getting the coordinates of all the items
		//		|	var coords = dojo.query(".thinger").coords();
		//	example:
		//		DOM manipulation functions from the dojo.* namespace area also
		//		available:
		//		|	// remove all of the elements in the list from their
		//		|	// parents (akin to "deleting" them from the document)
		//		|	dojo.query(".thinger").orphan();
		//		|	// place all elements in the list at the front of #foo
		//		|	dojo.query(".thinger").place("foo", "first");
		//	example:
		//		Event handling couldn't be easier. `dojo.connect` is mapped in,
		//		and shortcut handlers are provided for most DOM events:
		//		|	// like dojo.connect(), but with implicit scope
		//		|	dojo.query("li").connect("onclick", console, "log");
		//		|
		//		|	// many common event handlers are already available directly:
		//		|	dojo.query("li").onclick(console, "log");
		//		|	var toggleHovered = dojo.hitch(dojo, "toggleClass", "hovered");
		//		|	dojo.query("p")
		//		|		.onmouseenter(toggleHovered)
		//		|		.onmouseleave(toggleHovered);
		//	example:
		//		chainability is a key advantage of NodeLists:
		//		|	dojo.query(".thinger")
		//		|		.onclick(function(e){ /* ... */ })
		//		|		.at(1, 3, 8) // get a subset
		//		|			.style("padding", "5px")
		//		|			.forEach(console.log);

		return tnl(Array.apply(null, arguments));
	};

	var nl = d.NodeList, nlp = nl.prototype;
	
	// expose adapters and the wrapper as private functions
	
	nl._wrap = tnl;
	nl._adaptAsMap = adaptAsMap;
	nl._adaptAsForEach = adaptAsForEach;
	nl._adaptAsFilter  = adaptAsFilter;
	nl._adaptWithCondition = adaptWithCondition;
	
	// mass assignment
	
	// add array redirectors
	d.forEach(["slice", "splice"], function(name){
		var f = ap[name];
		nlp[name] = function(){ return tnl(f.apply(this, arguments)); };
	});
	// concat should be here but some browsers with native NodeList have problems with it
	
	// add array.js redirectors
	d.forEach(["indexOf", "lastIndexOf", "every", "some"], function(name){
		var f = d[name];
		nlp[name] = function(){ return f.apply(d, [this].concat(aps.call(arguments, 0))); };
	});
	
	// add conditional methods
	d.forEach(["attr", "style"], function(name){
		nlp[name] = adaptWithCondition(d[name], magicGuard);
	});
	
	// add forEach actions
	d.forEach(["connect", "addClass", "removeClass", "toggleClass", "empty"], function(name){
		nlp[name] = adaptAsForEach(d[name]);
	});

	dojo.extend(dojo.NodeList, {
		// http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array#Methods

		// FIXME: handle return values for #3244
		//		http://trac.dojotoolkit.org/ticket/3244
		
		// FIXME:
		//		need to wrap or implement:
		//			join (perhaps w/ innerHTML/outerHTML overload for toString() of items?)
		//			reduce
		//			reduceRight

		/*=====
		slice: function(begin, end){
			// summary:
			//		Returns a new NodeList, maintaining this one in place
			// description:
			//		This method behaves exactly like the Array.slice method
			//		with the caveat that it returns a dojo.NodeList and not a
			//		raw Array. For more details, see Mozilla's (slice
			//		documentation)[http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:slice]
			// begin: Integer
			//		Can be a positive or negative integer, with positive
			//		integers noting the offset to begin at, and negative
			//		integers denoting an offset from the end (i.e., to the left
			//		of the end)
			// end: Integer?
			//		Optional parameter to describe what position relative to
			//		the NodeList's zero index to end the slice at. Like begin,
			//		can be positive or negative.
			return tnl(a.slice.apply(this, arguments));
		},

		splice: function(index, howmany, item){
			// summary:
			//		Returns a new NodeList, manipulating this NodeList based on
			//		the arguments passed, potentially splicing in new elements
			//		at an offset, optionally deleting elements
			// description:
			//		This method behaves exactly like the Array.splice method
			//		with the caveat that it returns a dojo.NodeList and not a
			//		raw Array. For more details, see Mozilla's (splice
			//		documentation)[http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:splice]
			// index: Integer
			//		begin can be a positive or negative integer, with positive
			//		integers noting the offset to begin at, and negative
			//		integers denoting an offset from the end (i.e., to the left
			//		of the end)
			// howmany: Integer?
			//		Optional parameter to describe what position relative to
			//		the NodeList's zero index to end the slice at. Like begin,
			//		can be positive or negative.
			// item: Object...?
			//		Any number of optional parameters may be passed in to be
			//		spliced into the NodeList
			// returns:
			//		dojo.NodeList
			return tnl(a.splice.apply(this, arguments));
		},

		indexOf: function(value, fromIndex){
			//	summary:
			//		see dojo.indexOf(). The primary difference is that the acted-on 
			//		array is implicitly this NodeList
			// value: Object:
			//		The value to search for.
			// fromIndex: Integer?:
			//		The loction to start searching from. Optional. Defaults to 0.
			//	description:
			//		For more details on the behavior of indexOf, see Mozilla's
			//		(indexOf
			//		docs)[http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:indexOf]
			//	returns:
			//		Positive Integer or 0 for a match, -1 of not found.
			return d.indexOf(this, value, fromIndex); // Integer
		},

		lastIndexOf: function(value, fromIndex){
			// summary:
			//		see dojo.lastIndexOf(). The primary difference is that the
			//		acted-on array is implicitly this NodeList
			//	description:
			//		For more details on the behavior of lastIndexOf, see
			//		Mozilla's (lastIndexOf
			//		docs)[http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:lastIndexOf]
			// value: Object
			//		The value to search for.
			// fromIndex: Integer?
			//		The loction to start searching from. Optional. Defaults to 0.
			// returns:
			//		Positive Integer or 0 for a match, -1 of not found.
			return d.lastIndexOf(this, value, fromIndex); // Integer
		},

		every: function(callback, thisObject){
			//	summary:
			//		see `dojo.every()` and the (Array.every
			//		docs)[http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:every].
			//		Takes the same structure of arguments and returns as
			//		dojo.every() with the caveat that the passed array is
			//		implicitly this NodeList
			// callback: Function: the callback
			// thisObject: Object?: the context
			return d.every(this, callback, thisObject); // Boolean
		},

		some: function(callback, thisObject){
			//	summary:
			//		Takes the same structure of arguments and returns as
			//		`dojo.some()` with the caveat that the passed array is
			//		implicitly this NodeList.  See `dojo.some()` and Mozilla's
			//		(Array.some
			//		documentation)[http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:some].
			// callback: Function: the callback
			// thisObject: Object?: the context
			return d.some(this, callback, thisObject); // Boolean
		},
		=====*/

		concat: function(item){
			// summary:
			//		Returns a new NodeList comprised of items in this NodeList
			//		as well as items passed in as parameters
			// description:
			//		This method behaves exactly like the Array.concat method
			//		with the caveat that it returns a `dojo.NodeList` and not a
			//		raw Array. For more details, see the (Array.concat
			//		docs)[http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:concat]
			// item: Object?
			//		Any number of optional parameters may be passed in to be
			//		spliced into the NodeList
			// returns:
			//		dojo.NodeList
			
			//return tnl(apc.apply(this, arguments));
			// the line above won't work for the native NodeList :-(
			
			// implementation notes:
			// 1) Native NodeList is not an array, and cannot be used directly
			// in concat() --- the latter doesn't recognize it as an array, and
			// does not inline it, but append as a single entity.
			// 2) On some browsers (e.g., Safari) the "constructor" property is
			// read-only and cannot be changed. So we have to test for both
			// native NodeList and dojo.NodeList in this property to recognize
			// the node list.
			
			var t = d.isArray(this) ? this : aps.call(this, 0),
				m = d.map(arguments, function(a){
					return a && !d.isArray(a) &&
						(a.constructor === NodeList || a.constructor == nl) ?
							aps.call(a, 0) : a;
				});
			return tnl(apc.apply(t, m));	// dojo.NodeList
		},

		map: function(/*Function*/ func, /*Function?*/ obj){
			//	summary:
			//		see dojo.map(). The primary difference is that the acted-on
			//		array is implicitly this NodeList and the return is a
			//		dojo.NodeList (a subclass of Array)
			///return d.map(this, func, obj, d.NodeList); // dojo.NodeList
			return tnl(d.map(this, func, obj)); // dojo.NodeList
		},

		forEach: function(callback, thisObj){
			//	summary:
			//		see `dojo.forEach()`. The primary difference is that the acted-on 
			//		array is implicitly this NodeList
			d.forEach(this, callback, thisObj);
			// non-standard return to allow easier chaining
			return this; // dojo.NodeList 
		},


		/*=====
		coords: function(){
			//	summary:
			// 		Returns the box objects all elements in a node list as
			// 		an Array (*not* a NodeList)
			
			return d.map(this, d.coords); // Array
		},

		attr: function(property, value){
			//	summary:
			//		gets or sets the DOM attribute for every element in the
			//		NodeList
			//	property: String
			//		the attribute to get/set
			//	value: String?
			//		optional. The value to set the property to
			//	returns:
			//		if no value is passed, the result is an array of attribute values
			//		If a value is passed, the return is this NodeList
			return; // dojo.NodeList
			return; // Array
		},

		style: function(property, value){
			//	summary:
			//		gets or sets the CSS property for every element in the NodeList
			//	property: String
			//		the CSS property to get/set, in JavaScript notation
			//		("lineHieght" instead of "line-height") 
			//	value: String?
			//		optional. The value to set the property to
			//	returns:
			//		if no value is passed, the result is an array of strings.
			//		If a value is passed, the return is this NodeList
			return; // dojo.NodeList
			return; // Array
		},

		addClass: function(className){
			//	summary:
			//		adds the specified class to every node in the list
			//	className: String
			//		the CSS class to add
			return; // dojo.NodeList
		},

		removeClass: function(className){
			//	summary:
			//		removes the specified class from every node in the list
			//	className: String
			//		the CSS class to add
			//	returns:
			//		dojo.NodeList, this list
			return; // dojo.NodeList
		},

		toggleClass: function(className, condition){
			//	summary:
			//		Adds a class to node if not present, or removes if present.
			//		Pass a boolean condition if you want to explicitly add or remove.
			//	condition: Boolean?
			//		If passed, true means to add the class, false means to remove.
			//	className: String
			//		the CSS class to add
			return; // dojo.NodeList
		},

		connect: function(methodName, objOrFunc, funcName){
			//	summary:
			//		attach event handlers to every item of the NodeList. Uses dojo.connect()
			//		so event properties are normalized
			//	methodName: String
			//		the name of the method to attach to. For DOM events, this should be
			//		the lower-case name of the event
			//	objOrFunc: Object|Function|String
			//		if 2 arguments are passed (methodName, objOrFunc), objOrFunc should
			//		reference a function or be the name of the function in the global
			//		namespace to attach. If 3 arguments are provided
			//		(methodName, objOrFunc, funcName), objOrFunc must be the scope to 
			//		locate the bound function in
			//	funcName: String?
			//		optional. A string naming the function in objOrFunc to bind to the
			//		event. May also be a function reference.
			//	example:
			//		add an onclick handler to every button on the page
			//		|	dojo.query("div:nth-child(odd)").connect("onclick", function(e){
			//		|		console.log("clicked!");
			//		|	});
			// example:
			//		attach foo.bar() to every odd div's onmouseover
			//		|	dojo.query("div:nth-child(odd)").connect("onmouseover", foo, "bar");
		},

		empty: function(){
			//	summary:
			//		clears all content from each node in the list. Effectively
			//		equivalent to removing all child nodes from every item in
			//		the list.
			return this.forEach("item.innerHTML='';"); // dojo.NodeList
			// FIXME: should we be checking for and/or disposing of widgets below these nodes?
		},
		=====*/
		
		// useful html methods
		coords:	adaptAsMap(d.coords),

		// FIXME: connectPublisher()? connectRunOnce()?

		/*
		destroy: function(){
			//	summary:
			//		destroys every item in 	the list.
			this.forEach(d.destroy);
			// FIXME: should we be checking for and/or disposing of widgets below these nodes?
		},
		*/

		place: function(/*String||Node*/ queryOrNode, /*String*/ position){
			//	summary:
			//		places elements of this node list relative to the first element matched
			//		by queryOrNode. Returns the original NodeList. See: `dojo.place`
			//	queryOrNode:
			//		may be a string representing any valid CSS3 selector or a DOM node.
			//		In the selector case, only the first matching element will be used 
			//		for relative positioning.
			//	position:
			//		can be one of:
			//		|	"last" (default)
			//		|	"first"
			//		|	"before"
			//		|	"after"
			//		|	"only"
			//		|	"replace"
			// 		or an offset in the childNodes property
			var item = d.query(queryOrNode)[0];
			return this.forEach(function(node){ d.place(node, item, position); }); // dojo.NodeList
		},

		orphan: function(/*String?*/ simpleFilter){
			//	summary:
			//		removes elements in this list that match the simple filter
			//		from their parents and returns them as a new NodeList.
			//	simpleFilter:
			//		single-expression CSS rule. For example, ".thinger" or
			//		"#someId[attrName='value']" but not "div > span". In short,
			//		anything which does not invoke a descent to evaluate but
			//		can instead be used to test a single node is acceptable.
			//	returns:
			//		`dojo.NodeList` containing the orpahned elements 
			return (simpleFilter ? d._filterQueryResult(this, simpleFilter) : this).forEach(orphan); // dojo.NodeList
		},

		adopt: function(/*String||Array||DomNode*/ queryOrListOrNode, /*String?*/ position){
			//	summary:
			//		places any/all elements in queryOrListOrNode at a
			//		position relative to the first element in this list.
			//		Returns a dojo.NodeList of the adopted elements.
			//	queryOrListOrNode:
			//		a DOM node or a query string or a query result.
			//		Represents the nodes to be adopted relative to the
			//		first element of this NodeList.
			//	position:
			//		can be one of:
			//		|	"last" (default)
			//		|	"first"
			//		|	"before"
			//		|	"after"
			//		|	"only"
			//		|	"replace"
			// 		or an offset in the childNodes property
			return d.query(queryOrListOrNode).place(this[0], position);	// dojo.NodeList
		},

		// FIXME: do we need this?
		query: function(/*String*/ queryStr){
			//	summary:
			//		Returns a new list whose memebers match the passed query,
			//		assuming elements of the current NodeList as the root for
			//		each search.
			//	example:
			//		assume a DOM created by this markup:
			//	|	<div id="foo">
			//	|		<p>
			//	|			bacon is tasty, <span>dontcha think?</span>
			//	|		</p>
			//	|	</div>
			//	|	<div id="bar">
			//	|		<p>great commedians may not be funny <span>in person</span></p>
			//	|	</div>
			//		If we are presented with the following defintion for a NodeList:
			//	|	var l = new dojo.NodeList(dojo.byId("foo"), dojo.byId("bar"));
			//		it's possible to find all span elements under paragraphs
			//		contained by these elements with this sub-query:
			//	| 	var spans = l.query("p span");

			// FIXME: probably slow
			if(!queryStr){ return this; }
			var ret = this.map(function(node){
				// FIXME: why would we ever get undefined here?
				return d.query(queryStr, node).filter(function(subNode){ return subNode !== undefined; });
			});
			return tnl(apc.apply([], ret));	// dojo.NodeList
		},

		filter: function(/*String|Function*/ simpleFilter){
			//	summary:
			// 		"masks" the built-in javascript filter() method (supported
			// 		in Dojo via `dojo.filter`) to support passing a simple
			// 		string filter in addition to supporting filtering function
			// 		objects.
			//	simpleFilter:
			//		If a string, a single-expression CSS rule. For example,
			//		".thinger" or "#someId[attrName='value']" but not "div >
			//		span". In short, anything which does not invoke a descent
			//		to evaluate but can instead be used to test a single node
			//		is acceptable.
			//	example:
			//		"regular" JS filter syntax as exposed in dojo.filter:
			//		|	dojo.query("*").filter(function(item){
			//		|		// highlight every paragraph
			//		|		return (item.nodeName == "p");
			//		|	}).style("backgroundColor", "yellow");
			// example:
			//		the same filtering using a CSS selector
			//		|	dojo.query("*").filter("p").styles("backgroundColor", "yellow");

			var a = arguments, items = this, start = 0;
			if(d.isString(simpleFilter)){
				items = d._filterQueryResult(this, a[0]);
				if(a.length == 1){
					// if we only got a string query, pass back the filtered results
					return items; // dojo.NodeList
				}
				// if we got a callback, run it over the filtered items
				start = 1;
			}
			return tnl(d.filter(items, a[start], a[start + 1]));	// dojo.NodeList
		},
		
		/*
		// FIXME: should this be "copyTo" and include parenting info?
		clone: function(){
			// summary:
			//		creates node clones of each element of this list
			//		and returns a new list containing the clones
		},
		*/

		addContent: function(/*String|DomNode*/ content, /*String||Integer?*/ position){
			//	summary:
			//		add a node or some HTML as a string to every item in the
			//		list.  Returns the original list.
			//	description:
			//		a copy of the HTML content is added to each item in the
			//		list, with an optional position argument. If no position
			//		argument is provided, the content is appended to the end of
			//		each item.
			//	content:
			//		DOM node or HTML in string format to add at position to
			//		every item
			//	position:
			//		can be one of:
			//		|	"last"||"end" (default)
			//		|	"first||"start"
			//		|	"before"
			//		|	"after"
			// 		or an offset in the childNodes property
			//	example:
			//		appends content to the end if the position is ommitted
			//	|	dojo.query("h3 > p").addContent("hey there!");
			//	example:
			//		add something to the front of each element that has a
			//		"thinger" property:
			//	|	dojo.query("[thinger]").addContent("...", "first");
			//	example:
			//		adds a header before each element of the list
			//	|	dojo.query(".note").addContent("<h4>NOTE:</h4>", "before");
			//	example:
			//		add a clone of a DOM node to the end of every element in
			//		the list, removing it from its existing parent.
			//	|	dojo.query(".note").addContent(dojo.byId("foo"));
			var c = d.isString(content) ? 
						d._toDom(content, this[0] && this[0].ownerDocument) : 
						content, 
					i, 
					l = this.length - 1;
			for(i = 0; i < l; ++i){
				d.place(c.cloneNode(true), this[i], position);
			}
			if(l >= 0){
				d.place(c, this[l], position);
			}
			return this;	// dojo.NodeList
		},

		instantiate: function(/*String|Object*/ declaredClass, /*Object?*/ properties){
			//	summary:
			//		Create a new instance of a specified class, using the
			//		specified properties and each node in the nodeList as a
			//		srcNodeRef
			var c = d.isFunction(declaredClass) ? declaredClass : d.getObject(declaredClass);
			properties = properties || {};
			return this.forEach(function(node){ new c(properties, node); });	// dojo.NodeList
		},

		at: function(/*===== index =====*/){
			//	summary:
			//		Returns a new NodeList comprised of items in this NodeList
			//		at the given index or indices.
			//	index: Integer...
			//		One or more 0-based indices of items in the current
			//		NodeList.
			//	returns:
			//		dojo.NodeList
			var t = new dojo.NodeList();
			d.forEach(arguments, function(i){ if(this[i]){ t.push(this[i]); }}, this);
			return t; // dojo.NodeList
		}

	});

	// syntactic sugar for DOM events
	d.forEach([
		"blur", "focus", "change", "click", "error", "keydown", "keypress",
		"keyup", "load", "mousedown", "mouseenter", "mouseleave", "mousemove",
		"mouseout", "mouseover", "mouseup", "submit" 
		], function(evt){
			var _oe = "on"+evt;
			nlp[_oe] = function(a, b){
				return this.connect(_oe, a, b);
			}
				// FIXME: should these events trigger publishes?
				/*
				return (a ? this.connect(_oe, a, b) : 
							this.forEach(function(n){  
								// FIXME:
								//		listeners get buried by
								//		addEventListener and can't be dug back
								//		out to be triggered externally.
								// see:
								//		http://developer.mozilla.org/en/docs/DOM:element

								console.log(n, evt, _oe);

								// FIXME: need synthetic event support!
								var _e = { target: n, faux: true, type: evt };
								// dojo._event_listener._synthesizeEvent({}, { target: n, faux: true, type: evt });
								try{ n[evt](_e); }catch(e){ console.log(e); }
								try{ n[_oe](_e); }catch(e){ console.log(e); }
							})
				);
			}
			*/
		}
	);

})();

}

if(!dojo._hasResource["dojo._base.query"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo._base.query"] = true;
if(typeof dojo != "undefined"){
	dojo.provide("dojo._base.query");
	
	

}

/*
	dojo.query() architectural overview:

		dojo.query is a relatively full-featured CSS3 query library. It is
		designed to take any valid CSS3 selector and return the nodes matching
		the selector. To do this quickly, it processes queries in several
		steps, applying caching where profitable.
		
		The steps (roughly in reverse order of the way they appear in the code):
			1.) check to see if we already have a "query dispatcher"
				- if so, use that with the given parameterization. Skip to step 4.
			2.) attempt to determine which branch to dispatch the query to:
				- JS (optimized DOM iteration)
				- native (FF3.1+, Safari 3.1+, IE 8+)
			3.) tokenize and convert to executable "query dispatcher"
				- this is where the lion's share of the complexity in the
				  system lies. In the DOM version, the query dispatcher is
				  assembled as a chain of "yes/no" test functions pertaining to
				  a section of a simple query statement (".blah:nth-child(odd)"
				  but not "div div", which is 2 simple statements). Individual
				  statement dispatchers are cached (to prevent re-definition)
				  as are entire dispatch chains (to make re-execution of the
				  same query fast)
			4.) the resulting query dispatcher is called in the passed scope
			    (by default the top-level document)
				- for DOM queries, this results in a recursive, top-down
				  evaluation of nodes based on each simple query section
				- for native implementations, this may mean working around spec
				  bugs. So be it.
			5.) matched nodes are pruned to ensure they are unique (if necessary)
*/

;(function(d){
	// define everything in a closure for compressability reasons. "d" is an
	// alias to "dojo" (or the toolkit alias object, e.g., "acme").

	////////////////////////////////////////////////////////////////////////
	// Toolkit aliases
	////////////////////////////////////////////////////////////////////////

	// if you are extracing dojo.query for use in your own system, you will
	// need to provide these methods and properties. No other porting should be
	// necessary, save for configuring the system to use a class other than
	// dojo.NodeList as the return instance instantiator
	var trim = 			d.trim;
	var each = 			d.forEach;
	// 					d.isIE; // float
	// 					d.isSafari; // float
	// 					d.isOpera; // float
	// 					d.isWebKit; // float
	// 					d.doc ; // document element
	var qlc = d._queryListCtor = 		d.NodeList;
	var isString = 		d.isString;

	var getDoc = function(){ return d.doc; };
	// NOTE(alex): the spec is idiotic. CSS queries should ALWAYS be case-sensitive, but nooooooo
	var cssCaseBug = ((d.isWebKit||d.isMozilla) && ((getDoc().compatMode) == "BackCompat"));

	////////////////////////////////////////////////////////////////////////
	// Global utilities
	////////////////////////////////////////////////////////////////////////


	// on browsers that support the "children" collection we can avoid a lot of
	// iteration on chaff (non-element) nodes.
	// why.
	var childNodesName = !!getDoc().firstChild["children"] ? "children" : "childNodes";

	var specials = ">~+";

	// global thunk to determine whether we should treat the current query as
	// case sensitive or not. This switch is flipped by the query evaluator
	// based on the document passed as the context to search.
	var caseSensitive = false;

	// how high?
	var yesman = function(){ return true; };

	////////////////////////////////////////////////////////////////////////
	// Tokenizer
	////////////////////////////////////////////////////////////////////////

	var getQueryParts = function(query){
		//	summary: 
		//		state machine for query tokenization
		//	description:
		//		instead of using a brittle and slow regex-based CSS parser,
		//		dojo.query implements an AST-style query representation. This
		//		representation is only generated once per query. For example,
		//		the same query run multiple times or under different root nodes
		//		does not re-parse the selector expression but instead uses the
		//		cached data structure. The state machine implemented here
		//		terminates on the last " " (space) charachter and returns an
		//		ordered array of query component structures (or "parts"). Each
		//		part represents an operator or a simple CSS filtering
		//		expression. The structure for parts is documented in the code
		//		below.


		// NOTE: 
		//		this code is designed to run fast and compress well. Sacrifices
		//		to readibility and maintainability have been made.  Your best
		//		bet when hacking the tokenizer is to put The Donnas on *really*
		//		loud (may we recommend their "Spend The Night" release?) and
		//		just assume you're gonna make mistakes. Keep the unit tests
		//		open and run them frequently. Knowing is half the battle ;-)
		if(specials.indexOf(query.slice(-1)) >= 0){
			// if we end with a ">", "+", or "~", that means we're implicitly
			// searching all children, so make it explicit
			query += " * "
		}else{
			// if you have not provided a terminator, one will be provided for
			// you...
			query += " ";
		}

		var ts = function(/*Integer*/ s, /*Integer*/ e){
			// trim and slice. 

			// take an index to start a string slice from and an end position
			// and return a trimmed copy of that sub-string
			return trim(query.slice(s, e));
		}

		// the overall data graph of the full query, as represented by queryPart objects
		var queryParts = []; 


		// state keeping vars
		var inBrackets = -1, inParens = -1, inMatchFor = -1, 
			inPseudo = -1, inClass = -1, inId = -1, inTag = -1, 
			lc = "", cc = "", pStart;

		// iteration vars
		var x = 0, // index in the query
			ql = query.length,
			currentPart = null, // data structure representing the entire clause
			_cp = null; // the current pseudo or attr matcher

		// several temporary variables are assigned to this structure durring a
		// potential sub-expression match:
		//		attr:
		//			a string representing the current full attribute match in a
		//			bracket expression
		//		type:
		//			if there's an operator in a bracket expression, this is
		//			used to keep track of it
		//		value:
		//			the internals of parenthetical expression for a pseudo. for
		//			:nth-child(2n+1), value might be "2n+1"

		var endTag = function(){
			// called when the tokenizer hits the end of a particular tag name.
			// Re-sets state variables for tag matching and sets up the matcher
			// to handle the next type of token (tag or operator).
			if(inTag >= 0){
				var tv = (inTag == x) ? null : ts(inTag, x); // .toLowerCase();
				currentPart[ (specials.indexOf(tv) < 0) ? "tag" : "oper" ] = tv;
				inTag = -1;
			}
		}

		var endId = function(){
			// called when the tokenizer might be at the end of an ID portion of a match
			if(inId >= 0){
				currentPart.id = ts(inId, x).replace(/\\/g, "");
				inId = -1;
			}
		}

		var endClass = function(){
			// called when the tokenizer might be at the end of a class name
			// match. CSS allows for multiple classes, so we augment the
			// current item with another class in its list
			if(inClass >= 0){
				currentPart.classes.push(ts(inClass+1, x).replace(/\\/g, ""));
				inClass = -1;
			}
		}

		var endAll = function(){
			// at the end of a simple fragment, so wall off the matches
			endId(); endTag(); endClass();
		}

		var endPart = function(){
			endAll();
			if(inPseudo >= 0){
				currentPart.pseudos.push({ name: ts(inPseudo+1, x) });
			}
			// hint to the selector engine to tell it whether or not it
			// needs to do any iteration. Many simple selectors don't, and
			// we can avoid significant construction-time work by advising
			// the system to skip them
			currentPart.loops = (	
					currentPart.pseudos.length || 
					currentPart.attrs.length || 
					currentPart.classes.length	);

			currentPart.oquery = currentPart.query = ts(pStart, x); // save the full expression as a string


			// otag/tag are hints to suggest to the system whether or not
			// it's an operator or a tag. We save a copy of otag since the
			// tag name is cast to upper-case in regular HTML matches. The
			// system has a global switch to figure out if the current
			// expression needs to be case sensitive or not and it will use
			// otag or tag accordingly
			currentPart.otag = currentPart.tag = (currentPart["oper"]) ? null : (currentPart.tag || "*");

			if(currentPart.tag){
				// if we're in a case-insensitive HTML doc, we likely want
				// the toUpperCase when matching on element.tagName. If we
				// do it here, we can skip the string op per node
				// comparison
				currentPart.tag = currentPart.tag.toUpperCase();
			}

			// add the part to the list
			if(queryParts.length && (queryParts[queryParts.length-1].oper)){
				// operators are always infix, so we remove them from the
				// list and attach them to the next match. The evaluator is
				// responsible for sorting out how to handle them.
				currentPart.infixOper = queryParts.pop();
				currentPart.query = currentPart.infixOper.query + " " + currentPart.query;
				/*
				console.debug(	"swapping out the infix", 
								currentPart.infixOper, 
								"and attaching it to", 
								currentPart);
				*/
			}
			queryParts.push(currentPart);

			currentPart = null;
		}

		// iterate over the query, charachter by charachter, building up a 
		// list of query part objects
		for(; lc=cc, cc=query.charAt(x), x < ql; x++){
			//		cc: the current character in the match
			//		lc: the last charachter (if any)

			// someone is trying to escape something, so don't try to match any
			// fragments. We assume we're inside a literal.
			if(lc == "\\"){ continue; } 
			if(!currentPart){ // a part was just ended or none has yet been created
				// NOTE: I hate all this alloc, but it's shorter than writing tons of if's
				pStart = x;
				//	rules describe full CSS sub-expressions, like:
				//		#someId
				//		.className:first-child
				//	but not:
				//		thinger > div.howdy[type=thinger]
				//	the indidual components of the previous query would be
				//	split into 3 parts that would be represented a structure
				//	like:
				//		[
				//			{
				//				query: "thinger",
				//				tag: "thinger",
				//			},
				//			{
				//				query: "div.howdy[type=thinger]",
				//				classes: ["howdy"],
				//				infixOper: {
				//					query: ">",
				//					oper: ">",
				//				}
				//			},
				//		]
				currentPart = {
					query: null, // the full text of the part's rule
					pseudos: [], // CSS supports multiple pseud-class matches in a single rule
					attrs: [], 	// CSS supports multi-attribute match, so we need an array
					classes: [], // class matches may be additive, e.g.: .thinger.blah.howdy
					tag: null, 	// only one tag...
					oper: null, // ...or operator per component. Note that these wind up being exclusive.
					id: null, 	// the id component of a rule
					getTag: function(){
						return (caseSensitive) ? this.otag : this.tag;
					}
				};

				// if we don't have a part, we assume we're going to start at
				// the beginning of a match, which should be a tag name. This
				// might fault a little later on, but we detect that and this
				// iteration will still be fine.
				inTag = x; 
			}

			if(inBrackets >= 0){
				// look for a the close first
				if(cc == "]"){ // if we're in a [...] clause and we end, do assignment
					if(!_cp.attr){
						// no attribute match was previously begun, so we
						// assume this is an attribute existance match in the
						// form of [someAttributeName]
						_cp.attr = ts(inBrackets+1, x);
					}else{
						// we had an attribute already, so we know that we're
						// matching some sort of value, as in [attrName=howdy]
						_cp.matchFor = ts((inMatchFor||inBrackets+1), x);
					}
					var cmf = _cp.matchFor;
					if(cmf){
						// try to strip quotes from the matchFor value. We want
						// [attrName=howdy] to match the same 
						//	as [attrName = 'howdy' ]
						if(	(cmf.charAt(0) == '"') || (cmf.charAt(0)  == "'") ){
							_cp.matchFor = cmf.slice(1, -1);
						}
					}
					// end the attribute by adding it to the list of attributes. 
					currentPart.attrs.push(_cp);
					_cp = null; // necessary?
					inBrackets = inMatchFor = -1;
				}else if(cc == "="){
					// if the last char was an operator prefix, make sure we
					// record it along with the "=" operator. 
					var addToCc = ("|~^$*".indexOf(lc) >=0 ) ? lc : "";
					_cp.type = addToCc+cc;
					_cp.attr = ts(inBrackets+1, x-addToCc.length);
					inMatchFor = x+1;
				}
				// now look for other clause parts
			}else if(inParens >= 0){
				// if we're in a parenthetical expression, we need to figure
				// out if it's attached to a pseduo-selector rule like
				// :nth-child(1)
				if(cc == ")"){
					if(inPseudo >= 0){
						_cp.value = ts(inParens+1, x);
					}
					inPseudo = inParens = -1;
				}
			}else if(cc == "#"){
				// start of an ID match
				endAll();
				inId = x+1;
			}else if(cc == "."){
				// start of a class match
				endAll();
				inClass = x;
			}else if(cc == ":"){
				// start of a pseudo-selector match
				endAll();
				inPseudo = x;
			}else if(cc == "["){
				// start of an attribute match. 
				endAll();
				inBrackets = x;
				// provide a new structure for the attribute match to fill-in
				_cp = {
					/*=====
					attr: null, type: null, matchFor: null
					=====*/
				};
			}else if(cc == "("){
				// we really only care if we've entered a parenthetical
				// expression if we're already inside a pseudo-selector match
				if(inPseudo >= 0){
					// provide a new structure for the pseudo match to fill-in
					_cp = { 
						name: ts(inPseudo+1, x), 
						value: null
					}
					currentPart.pseudos.push(_cp);
				}
				inParens = x;
			}else if(
				(cc == " ") && 
				// if it's a space char and the last char is too, consume the
				// current one without doing more work
				(lc != cc)
			){
				endPart();
			}
		}
		return queryParts;
	};
	

	////////////////////////////////////////////////////////////////////////
	// DOM query infrastructure
	////////////////////////////////////////////////////////////////////////

	var agree = function(first, second){
		// the basic building block of the yes/no chaining system. agree(f1,
		// f2) generates a new function which returns the boolean results of
		// both of the passed functions to a single logical-anded result. If
		// either are not possed, the other is used exclusively.
		if(!first){ return second; }
		if(!second){ return first; }

		return function(){
			return first.apply(window, arguments) && second.apply(window, arguments);
		}
	};

	var getArr = function(i, arr){
		// helps us avoid array alloc when we don't need it
		var r = arr||[]; // FIXME: should this be 'new d._queryListCtor()' ?
		if(i){ r.push(i); }
		return r;
	};

	var _isElement = function(n){ return (1 == n.nodeType); };

	// FIXME: need to coalesce _getAttr with defaultGetter
	var blank = "";
	var _getAttr = function(elem, attr){
		if(!elem){ return blank; }
		if(attr == "class"){
			return elem.className || blank;
		}
		if(attr == "for"){
			return elem.htmlFor || blank;
		}
		if(attr == "style"){
			return elem.style.cssText || blank;
		}
		return (caseSensitive ? elem.getAttribute(attr) : elem.getAttribute(attr, 2)) || blank;
	};

	var attrs = {
		"*=": function(attr, value){
			return function(elem){
				// E[foo*="bar"]
				//		an E element whose "foo" attribute value contains
				//		the substring "bar"
				return (_getAttr(elem, attr).indexOf(value)>=0);
			}
		},
		"^=": function(attr, value){
			// E[foo^="bar"]
			//		an E element whose "foo" attribute value begins exactly
			//		with the string "bar"
			return function(elem){
				return (_getAttr(elem, attr).indexOf(value)==0);
			}
		},
		"$=": function(attr, value){
			// E[foo$="bar"]	
			//		an E element whose "foo" attribute value ends exactly
			//		with the string "bar"
			var tval = " "+value;
			return function(elem){
				var ea = " "+_getAttr(elem, attr);
				return (ea.lastIndexOf(value)==(ea.length-value.length));
			}
		},
		"~=": function(attr, value){
			// E[foo~="bar"]	
			//		an E element whose "foo" attribute value is a list of
			//		space-separated values, one of which is exactly equal
			//		to "bar"

			// return "[contains(concat(' ',@"+attr+",' '), ' "+ value +" ')]";
			var tval = " "+value+" ";
			return function(elem){
				var ea = " "+_getAttr(elem, attr)+" ";
				return (ea.indexOf(tval)>=0);
			}
		},
		"|=": function(attr, value){
			// E[hreflang|="en"]
			//		an E element whose "hreflang" attribute has a
			//		hyphen-separated list of values beginning (from the
			//		left) with "en"
			var valueDash = " "+value+"-";
			return function(elem){
				var ea = " "+_getAttr(elem, attr);
				return (
					(ea == value) ||
					(ea.indexOf(valueDash)==0)
				);
			}
		},
		"=": function(attr, value){
			return function(elem){
				return (_getAttr(elem, attr) == value);
			}
		}
	};

	// avoid testing for node type if we can. Defining this in the negative
	// here to avoid negation in the fast path.
	var _noNES = (typeof getDoc().firstChild.nextElementSibling == "undefined");
	var _ns = !_noNES ? "nextElementSibling" : "nextSibling";
	var _ps = !_noNES ? "previousElementSibling" : "previousSibling";
	var _simpleNodeTest = (_noNES ? _isElement : yesman);

	var _lookLeft = function(node){
		// look left
		while(node = node[_ps]){
			if(_simpleNodeTest(node)){ return false; }
		}
		return true;
	};

	var _lookRight = function(node){
		// look right
		while(node = node[_ns]){
			if(_simpleNodeTest(node)){ return false; }
		}
		return true;
	};

	var getNodeIndex = function(node){
		var root = node.parentNode;
		var i = 0,
			tret = root[childNodesName],
			ci = (node["_i"]||-1),
			cl = (root["_l"]||-1);

		if(!tret){ return -1; }
		var l = tret.length;

		// we calcuate the parent length as a cheap way to invalidate the
		// cache. It's not 100% accurate, but it's much more honest than what
		// other libraries do
		if( cl == l && ci >= 0 && cl >= 0 ){
			// if it's legit, tag and release
			return ci;
		}

		// else re-key things
		root["_l"] = l;
		ci = -1;
		for(var te = root["firstElementChild"]||root["firstChild"]; te; te = te[_ns]){
			if(_simpleNodeTest(te)){ 
				te["_i"] = ++i;
				if(node === te){ 
					// NOTE:
					// 	shortcuting the return at this step in indexing works
					// 	very well for benchmarking but we avoid it here since
					// 	it leads to potential O(n^2) behavior in sequential
					// 	getNodexIndex operations on a previously un-indexed
					// 	parent. We may revisit this at a later time, but for
					// 	now we just want to get the right answer more often
					// 	than not.
					ci = i;
				}
			}
		}
		return ci;
	};

	var isEven = function(elem){
		return !((getNodeIndex(elem)) % 2);
	};

	var isOdd = function(elem){
		return ((getNodeIndex(elem)) % 2);
	};

	var pseudos = {
		"checked": function(name, condition){
			return function(elem){
				// FIXME: make this more portable!!
				return !!d.attr(elem, "checked");
			}
		},
		"first-child": function(){ return _lookLeft; },
		"last-child": function(){ return _lookRight; },
		"only-child": function(name, condition){
			return function(node){ 
				if(!_lookLeft(node)){ return false; }
				if(!_lookRight(node)){ return false; }
				return true;
			};
		},
		"empty": function(name, condition){
			return function(elem){
				// DomQuery and jQuery get this wrong, oddly enough.
				// The CSS 3 selectors spec is pretty explicit about it, too.
				var cn = elem.childNodes;
				var cnl = elem.childNodes.length;
				// if(!cnl){ return true; }
				for(var x=cnl-1; x >= 0; x--){
					var nt = cn[x].nodeType;
					if((nt === 1)||(nt == 3)){ return false; }
				}
				return true;
			}
		},
		"contains": function(name, condition){
			var cz = condition.charAt(0);
			if( cz == '"' || cz == "'" ){ //remove quote
				condition = condition.slice(1, -1);
			}
			return function(elem){
				return (elem.innerHTML.indexOf(condition) >= 0);
			}
		},
		"not": function(name, condition){
			var p = getQueryParts(condition)[0];
			var ignores = { el: 1 }; 
			if(p.tag != "*"){
				ignores.tag = 1;
			}
			if(!p.classes.length){
				ignores.classes = 1;
			}
			var ntf = getSimpleFilterFunc(p, ignores);
			return function(elem){
				return (!ntf(elem));
			}
		},
		"nth-child": function(name, condition){
			var pi = parseInt;
			// avoid re-defining function objects if we can
			if(condition == "odd"){
				return isOdd;
			}else if(condition == "even"){
				return isEven;
			}
			// FIXME: can we shorten this?
			if(condition.indexOf("n") != -1){
				var tparts = condition.split("n", 2);
				var pred = tparts[0] ? ((tparts[0] == '-') ? -1 : pi(tparts[0])) : 1;
				var idx = tparts[1] ? pi(tparts[1]) : 0;
				var lb = 0, ub = -1;
				if(pred > 0){
					if(idx < 0){
						idx = (idx % pred) && (pred + (idx % pred));
					}else if(idx>0){
						if(idx >= pred){
							lb = idx - idx % pred;
						}
						idx = idx % pred;
					}
				}else if(pred<0){
					pred *= -1;
					// idx has to be greater than 0 when pred is negative;
					// shall we throw an error here?
					if(idx > 0){
						ub = idx;
						idx = idx % pred;
					}
				}
				if(pred > 0){
					return function(elem){
						var i = getNodeIndex(elem);
						return (i>=lb) && (ub<0 || i<=ub) && ((i % pred) == idx);
					}
				}else{
					condition = idx;
				}
			}
			var ncount = pi(condition);
			return function(elem){
				return (getNodeIndex(elem) == ncount);
			}
		}
	};

	var defaultGetter = (d.isIE) ? function(cond){
		var clc = cond.toLowerCase();
		if(clc == "class"){ cond = "className"; }
		return function(elem){
			return (caseSensitive ? elem.getAttribute(cond) : elem[cond]||elem[clc]);
		}
	} : function(cond){
		return function(elem){
			return (elem && elem.getAttribute && elem.hasAttribute(cond));
		}
	};

	var getSimpleFilterFunc = function(query, ignores){
		// generates a node tester function based on the passed query part. The
		// query part is one of the structures generatd by the query parser
		// when it creates the query AST. The "ignores" object specifies which
		// (if any) tests to skip, allowing the system to avoid duplicating
		// work where it may have already been taken into account by other
		// factors such as how the nodes to test were fetched in the first
		// place
		if(!query){ return yesman; }
		ignores = ignores||{};

		var ff = null;

		if(!("el" in ignores)){
			ff = agree(ff, _isElement);
		}

		if(!("tag" in ignores)){
			if(query.tag != "*"){
				ff = agree(ff, function(elem){
					return (elem && (elem.tagName == query.getTag()));
				});
			}
		}

		if(!("classes" in ignores)){
			each(query.classes, function(cname, idx, arr){
				// get the class name
				/*
				var isWildcard = cname.charAt(cname.length-1) == "*";
				if(isWildcard){
					cname = cname.substr(0, cname.length-1);
				}
				// I dislike the regex thing, even if memozied in a cache, but it's VERY short
				var re = new RegExp("(?:^|\\s)" + cname + (isWildcard ? ".*" : "") + "(?:\\s|$)");
				*/
				var re = new RegExp("(?:^|\\s)" + cname + "(?:\\s|$)");
				ff = agree(ff, function(elem){
					return re.test(elem.className);
				});
				ff.count = idx;
			});
		}

		if(!("pseudos" in ignores)){
			each(query.pseudos, function(pseudo){
				var pn = pseudo.name;
				if(pseudos[pn]){
					ff = agree(ff, pseudos[pn](pn, pseudo.value));
				}
			});
		}

		if(!("attrs" in ignores)){
			each(query.attrs, function(attr){
				var matcher;
				var a = attr.attr;
				// type, attr, matchFor
				if(attr.type && attrs[attr.type]){
					matcher = attrs[attr.type](a, attr.matchFor);
				}else if(a.length){
					matcher = defaultGetter(a);
				}
				if(matcher){
					ff = agree(ff, matcher);
				}
			});
		}

		if(!("id" in ignores)){
			if(query.id){
				ff = agree(ff, function(elem){ 
					return (!!elem && (elem.id == query.id));
				});
			}
		}

		if(!ff){
			if(!("default" in ignores)){
				ff = yesman; 
			}
		}
		return ff;
	};

	var _nextSibling = function(filterFunc){
		return function(node, ret, bag){
			while(node = node[_ns]){
				if(_noNES && (!_isElement(node))){ continue; }
				if(
					(!bag || _isUnique(node, bag)) &&
					filterFunc(node)
				){
					ret.push(node);
				}
				break;
			}
			return ret;
		}
	};

	var _nextSiblings = function(filterFunc){
		return function(root, ret, bag){
			var te = root[_ns];
			while(te){
				if(_simpleNodeTest(te)){
					if(bag && !_isUnique(te, bag)){
						break;
					}
					if(filterFunc(te)){
						ret.push(te);
					}
				}
				te = te[_ns];
			}
			return ret;
		}
	};

	// get an array of child *elements*, skipping text and comment nodes
	var _childElements = function(filterFunc){
		filterFunc = filterFunc||yesman;
		return function(root, ret, bag){
			// get an array of child elements, skipping text and comment nodes
			var te, x = 0, tret = root[childNodesName];
			while(te = tret[x++]){
				if(
					_simpleNodeTest(te) &&
					(!bag || _isUnique(te, bag)) &&
					(filterFunc(te, x))
				){ 
					ret.push(te);
				}
			}
			return ret;
		};
	};
	
	/*
	// thanks, Dean!
	var itemIsAfterRoot = d.isIE ? function(item, root){
		return (item.sourceIndex > root.sourceIndex);
	} : function(item, root){
		return (item.compareDocumentPosition(root) == 2);
	};
	*/

	// test to see if node is below root
	var _isDescendant = function(node, root){
		var pn = node.parentNode;
		while(pn){
			if(pn == root){
				break;
			}
			pn = pn.parentNode;
		}
		return !!pn;
	};

	var _getElementsFuncCache = {};

	var getElementsFunc = function(query){
		var retFunc = _getElementsFuncCache[query.query];
		// if we've got a cached dispatcher, just use that
		if(retFunc){ return retFunc; }
		// else, generate a new on

		// NOTE:
		//		this function returns a function that searches for nodes and
		//		filters them.  The search may be specialized by infix operators
		//		(">", "~", or "+") else it will default to searching all
		//		descendants (the " " selector). Once a group of children is
		//		founde, a test function is applied to weed out the ones we
		//		don't want. Many common cases can be fast-pathed. We spend a
		//		lot of cycles to create a dispatcher that doesn't do more work
		//		than necessary at any point since, unlike this function, the
		//		dispatchers will be called every time. The logic of generating
		//		efficient dispatchers looks like this in pseudo code:
		//
		//		# if it's a purely descendant query (no ">", "+", or "~" modifiers)
		//		if infixOperator == " ":
		//			if only(id):
		//				return def(root):
		//					return d.byId(id, root);
		//
		//			elif id:
		//				return def(root):
		//					return filter(d.byId(id, root));
		//
		//			elif cssClass && getElementsByClassName:
		//				return def(root):
		//					return filter(root.getElementsByClassName(cssClass));
		//
		//			elif only(tag):
		//				return def(root):
		//					return root.getElementsByTagName(tagName);
		//
		//			else:
		//				# search by tag name, then filter
		//				return def(root):
		//					return filter(root.getElementsByTagName(tagName||"*"));
		//
		//		elif infixOperator == ">":
		//			# search direct children
		//			return def(root):
		//				return filter(root.children);
		//
		//		elif infixOperator == "+":
		//			# search next sibling
		//			return def(root):
		//				return filter(root.nextElementSibling);
		//
		//		elif infixOperator == "~":
		//			# search rightward siblings
		//			return def(root):
		//				return filter(nextSiblings(root));

		var io = query.infixOper;
		var oper = (io ? io.oper : "");
		// the default filter func which tests for all conditions in the query
		// part. This is potentially inefficient, so some optimized paths may
		// re-define it to test fewer things.
		var filterFunc = getSimpleFilterFunc(query, { el: 1 });
		var qt = query.tag;
		var wildcardTag = ("*" == qt);
		var ecs = getDoc()["getElementsByClassName"]; 

		if(!oper){
			// if there's no infix operator, then it's a descendant query. ID
			// and "elements by class name" variants can be accelerated so we
			// call them out explicitly:
			if(query.id){
				// testing shows that the overhead of yesman() is acceptable
				// and can save us some bytes vs. re-defining the function
				// everywhere.
				filterFunc = (!query.loops && wildcardTag) ? 
					yesman : 
					getSimpleFilterFunc(query, { el: 1, id: 1 });

				retFunc = function(root, arr){
					var te = d.byId(query.id, (root.ownerDocument||root));
					if(!te || !filterFunc(te)){ return; }
					if(9 == root.nodeType){ // if root's a doc, we just return directly
						return getArr(te, arr);
					}else{ // otherwise check ancestry
						if(_isDescendant(te, root)){
							return getArr(te, arr);
						}
					}
				}
			}else if(
				ecs && 
				// isAlien check. Workaround for Prototype.js being totally evil/dumb.
				/\{\s*\[native code\]\s*\}/.test(String(ecs)) && 
				query.classes.length &&
				!cssCaseBug
			){
				// it's a class-based query and we've got a fast way to run it.

				// ignore class and ID filters since we will have handled both
				filterFunc = getSimpleFilterFunc(query, { el: 1, classes: 1, id: 1 });
				var classesString = query.classes.join(" ");
				retFunc = function(root, arr, bag){
					var ret = getArr(0, arr), te, x=0;
					var tret = root.getElementsByClassName(classesString);
					while((te = tret[x++])){
						if(filterFunc(te, root) && _isUnique(te, bag)){
							ret.push(te);
						}
					}
					return ret;
				};

			}else if(!wildcardTag && !query.loops){
				// it's tag only. Fast-path it.
				retFunc = function(root, arr, bag){
					var ret = getArr(0, arr), te, x=0;
					var tret = root.getElementsByTagName(query.getTag());
					while((te = tret[x++])){
						if(_isUnique(te, bag)){
							ret.push(te);
						}
					}
					return ret;
				};
			}else{
				// the common case:
				//		a descendant selector without a fast path. By now it's got
				//		to have a tag selector, even if it's just "*" so we query
				//		by that and filter
				filterFunc = getSimpleFilterFunc(query, { el: 1, tag: 1, id: 1 });
				retFunc = function(root, arr, bag){
					var ret = getArr(0, arr), te, x=0;
					// we use getTag() to avoid case sensitivity issues
					var tret = root.getElementsByTagName(query.getTag());
					while((te = tret[x++])){
						if(filterFunc(te, root) && _isUnique(te, bag)){
							ret.push(te);
						}
					}
					return ret;
				};
			}
		}else{
			// the query is scoped in some way. Instead of querying by tag we
			// use some other collection to find candidate nodes
			var skipFilters = { el: 1 };
			if(wildcardTag){
				skipFilters.tag = 1;
			}
			filterFunc = getSimpleFilterFunc(query, skipFilters);
			if("+" == oper){
				retFunc = _nextSibling(filterFunc);
			}else if("~" == oper){
				retFunc = _nextSiblings(filterFunc);
			}else if(">" == oper){
				retFunc = _childElements(filterFunc);
			}
		}
		// cache it and return
		return _getElementsFuncCache[query.query] = retFunc;
	};

	var filterDown = function(root, queryParts){
		// NOTE:
		//		this is the guts of the DOM query system. It takes a list of
		//		parsed query parts and a root and finds children which match
		//		the selector represented by the parts
		var candidates = getArr(root), qp, x, te, qpl = queryParts.length, bag, ret;

		for(var i = 0; i < qpl; i++){
			ret = [];
			qp = queryParts[i];
			x = candidates.length - 1;
			if(x > 0){
				// if we have more than one root at this level, provide a new
				// hash to use for checking group membership but tell the
				// system not to post-filter us since we will already have been
				// gauranteed to be unique
				bag = {};
				ret.nozip = true;
			}
			var gef = getElementsFunc(qp);
			while(te = candidates[x--]){
				// for every root, get the elements that match the descendant
				// selector, adding them to the "ret" array and filtering them
				// via membership in this level's bag. If there are more query
				// parts, then this level's return will be used as the next
				// level's candidates
				gef(te, ret, bag);
			}
			if(!ret.length){ break; }
			candidates = ret;
		}
		return ret;
	};

	////////////////////////////////////////////////////////////////////////
	// the query runner
	////////////////////////////////////////////////////////////////////////

	// these are the primary caches for full-query results. The query
	// dispatcher functions are generated then stored here for hash lookup in
	// the future
	var _queryFuncCacheDOM = {},
		_queryFuncCacheQSA = {};

	// this is the second level of spliting, from full-length queries (e.g.,
	// "div.foo .bar") into simple query expressions (e.g., ["div.foo",
	// ".bar"])
	var getStepQueryFunc = function(query){
		var qparts = getQueryParts(trim(query));

		// if it's trivial, avoid iteration and zipping costs
		if(qparts.length == 1){
			// we optimize this case here to prevent dispatch further down the
			// chain, potentially slowing things down. We could more elegantly
			// handle this in filterDown(), but it's slower for simple things
			// that need to be fast (e.g., "#someId").
			var tef = getElementsFunc(qparts[0]);
			return function(root){
				var r = tef(root, new qlc());
				if(r){ r.nozip = true; }
				return r;
			}
		}

		// otherwise, break it up and return a runner that iterates over the parts recursively
		return function(root){
			return filterDown(root, qparts);
		}
	};

	// NOTES:
	//	* we can't trust QSA for anything but document-rooted queries, so
	//	  caching is split into DOM query evaluators and QSA query evaluators
	//	* caching query results is dirty and leak-prone (or, at a minimum,
	//	  prone to unbounded growth). Other toolkits may go this route, but
	//	  they totally destroy their own ability to manage their memory
	//	  footprint. If we implement it, it should only ever be with a fixed
	//	  total element reference # limit and an LRU-style algorithm since JS
	//	  has no weakref support. Caching compiled query evaluators is also
	//	  potentially problematic, but even on large documents the size of the
	//	  query evaluators is often < 100 function objects per evaluator (and
	//	  LRU can be applied if it's ever shown to be an issue).
	//	* since IE's QSA support is currently only for HTML documents and even
	//	  then only in IE 8's "standards mode", we have to detect our dispatch
	//	  route at query time and keep 2 separate caches. Ugg.

	// we need to determine if we think we can run a given query via
	// querySelectorAll or if we'll need to fall back on DOM queries to get
	// there. We need a lot of information about the environment and the query
	// to make the determiniation (e.g. does it support QSA, does the query in
	// question work in the native QSA impl, etc.).
	var nua = navigator.userAgent;
	// some versions of Safari provided QSA, but it was buggy and crash-prone.
	// We need te detect the right "internal" webkit version to make this work.
	var wk = "WebKit/";
	var is525 = (
		d.isWebKit && 
		(nua.indexOf(wk) > 0) && 
		(parseFloat(nua.split(wk)[1]) > 528)
	);

	// IE QSA queries may incorrectly include comment nodes, so we throw the
	// zipping function into "remove" comments mode instead of the normal "skip
	// it" which every other QSA-clued browser enjoys
	var noZip = d.isIE ? "commentStrip" : "nozip";

	var qsa = "querySelectorAll";
	var qsaAvail = (
		!!getDoc()[qsa] && 
		// see #5832
		(!d.isSafari || (d.isSafari > 3.1) || is525 )
	); 
	var getQueryFunc = function(query, forceDOM){

		if(qsaAvail){
			// if we've got a cached variant and we think we can do it, run it!
			var qsaCached = _queryFuncCacheQSA[query];
			if(qsaCached && !forceDOM){ return qsaCached; }
		}

		// else if we've got a DOM cached variant, assume that we already know
		// all we need to and use it
		var domCached = _queryFuncCacheDOM[query];
		if(domCached){ return domCached; }

		// TODO: 
		//		today we're caching DOM and QSA branches separately so we
		//		recalc useQSA every time. If we had a way to tag root+query
		//		efficiently, we'd be in good shape to do a global cache.

		var qcz = query.charAt(0);
		var nospace = (-1 == query.indexOf(" "));

		// byId searches are wicked fast compared to QSA, even when filtering
		// is required
		if( (query.indexOf("#") >= 0) && (nospace) ){
			forceDOM = true;
		}

		var useQSA = ( 
			qsaAvail && (!forceDOM) &&
			// as per CSS 3, we can't currently start w/ combinator:
			//		http://www.w3.org/TR/css3-selectors/#w3cselgrammar
			(specials.indexOf(qcz) == -1) && 
			// IE's QSA impl sucks on pseudos
			(!d.isIE || (query.indexOf(":") == -1)) &&

			(!(cssCaseBug && (query.indexOf(".") >= 0))) &&

			// FIXME:
			//		need to tighten up browser rules on ":contains" and "|=" to
			//		figure out which aren't good
			(query.indexOf(":contains") == -1) &&
			(query.indexOf("|=") == -1) // some browsers don't grok it
		);

		// TODO: 
		//		if we've got a descendant query (e.g., "> .thinger" instead of
		//		just ".thinger") in a QSA-able doc, but are passed a child as a
		//		root, it should be possible to give the item a synthetic ID and
		//		trivially rewrite the query to the form "#synid > .thinger" to
		//		use the QSA branch


		if(useQSA){
			var tq = (specials.indexOf(query.charAt(query.length-1)) >= 0) ? 
						(query + " *") : query;
			return _queryFuncCacheQSA[query] = function(root){
				try{
					// the QSA system contains an egregious spec bug which
					// limits us, effectively, to only running QSA queries over
					// entire documents.  See:
					//		http://ejohn.org/blog/thoughts-on-queryselectorall/
					//	despite this, we can also handle QSA runs on simple
					//	selectors, but we don't want detection to be expensive
					//	so we're just checking for the presence of a space char
					//	right now. Not elegant, but it's cheaper than running
					//	the query parser when we might not need to
					if(!((9 == root.nodeType) || nospace)){ throw ""; }
					var r = root[qsa](tq);
					// skip expensive duplication checks and just wrap in a NodeList
					r[noZip] = true;
					return r;
				}catch(e){
					// else run the DOM branch on this query, ensuring that we
					// default that way in the future
					return getQueryFunc(query, true)(root);
				}
			}
		}else{
			// DOM branch
			var parts = query.split(/\s*,\s*/);
			return _queryFuncCacheDOM[query] = ((parts.length < 2) ? 
				// if not a compound query (e.g., ".foo, .bar"), cache and return a dispatcher
				getStepQueryFunc(query) : 
				// if it *is* a complex query, break it up into its
				// constituent parts and return a dispatcher that will
				// merge the parts when run
				function(root){
					var pindex = 0, // avoid array alloc for every invocation
						ret = [],
						tp;
					while((tp = parts[pindex++])){
						ret = ret.concat(getStepQueryFunc(tp)(root));
					}
					return ret;
				}
			);
		}
	};

	var _zipIdx = 0;

	// NOTE:
	//		this function is Moo inspired, but our own impl to deal correctly
	//		with XML in IE
	var _nodeUID = d.isIE ? function(node){
		if(caseSensitive){
			// XML docs don't have uniqueID on their nodes
			return (node.getAttribute("_uid") || node.setAttribute("_uid", ++_zipIdx) || _zipIdx);

		}else{
			return node.uniqueID;
		}
	} : 
	function(node){
		return (node._uid || (node._uid = ++_zipIdx));
	};

	// determine if a node in is unique in a "bag". In this case we don't want
	// to flatten a list of unique items, but rather just tell if the item in
	// question is already in the bag. Normally we'd just use hash lookup to do
	// this for us but IE's DOM is busted so we can't really count on that. On
	// the upside, it gives us a built in unique ID function. 
	var _isUnique = function(node, bag){
		if(!bag){ return 1; }
		var id = _nodeUID(node);
		if(!bag[id]){ return bag[id] = 1; }
		return 0;
	};

	// attempt to efficiently determine if an item in a list is a dupe,
	// returning a list of "uniques", hopefully in doucment order
	var _zipIdxName = "_zipIdx";
	var _zip = function(arr){
		if(arr && arr.nozip){ 
			return (qlc._wrap) ? qlc._wrap(arr) : arr;
		}
		// var ret = new d._queryListCtor();
		var ret = new qlc();
		if(!arr || !arr.length){ return ret; }
		if(arr[0]){
			ret.push(arr[0]);
		}
		if(arr.length < 2){ return ret; }

		_zipIdx++;
		
		// we have to fork here for IE and XML docs because we can't set
		// expandos on their nodes (apparently). *sigh*
		if(d.isIE && caseSensitive){
			var szidx = _zipIdx+"";
			arr[0].setAttribute(_zipIdxName, szidx);
			for(var x = 1, te; te = arr[x]; x++){
				if(arr[x].getAttribute(_zipIdxName) != szidx){ 
					ret.push(te);
				}
				te.setAttribute(_zipIdxName, szidx);
			}
		}else if(d.isIE && arr.commentStrip){
			try{
				for(var x = 1, te; te = arr[x]; x++){
					if(_isElement(te)){ 
						ret.push(te);
					}
				}
			}catch(e){ /* squelch */ }
		}else{
			if(arr[0]){ arr[0][_zipIdxName] = _zipIdx; }
			for(var x = 1, te; te = arr[x]; x++){
				if(arr[x][_zipIdxName] != _zipIdx){ 
					ret.push(te);
				}
				te[_zipIdxName] = _zipIdx;
			}
		}
		return ret;
	};

	// the main executor
	d.query = function(/*String*/ query, /*String|DOMNode?*/ root){
		//	summary:
		//		Returns nodes which match the given CSS3 selector, searching the
		//		entire document by default but optionally taking a node to scope
		//		the search by. Returns an instance of dojo.NodeList.
		//	description:
		//		dojo.query() is the swiss army knife of DOM node manipulation in
		//		Dojo. Much like Prototype's "$$" (bling-bling) function or JQuery's
		//		"$" function, dojo.query provides robust, high-performance
		//		CSS-based node selector support with the option of scoping searches
		//		to a particular sub-tree of a document.
		//
		//		Supported Selectors:
		//		--------------------
		//
		//		dojo.query() supports a rich set of CSS3 selectors, including:
		//
		//			* class selectors (e.g., `.foo`)
		//			* node type selectors like `span`
		//			* ` ` descendant selectors
		//			* `>` child element selectors 
		//			* `#foo` style ID selectors
		//			* `*` universal selector
		//			* `~`, the immediately preceeded-by sibling selector
		//			* `+`, the preceeded-by sibling selector
		//			* attribute queries:
		//			|	* `[foo]` attribute presence selector
		//			|	* `[foo='bar']` attribute value exact match
		//			|	* `[foo~='bar']` attribute value list item match
		//			|	* `[foo^='bar']` attribute start match
		//			|	* `[foo$='bar']` attribute end match
		//			|	* `[foo*='bar']` attribute substring match
		//			* `:first-child`, `:last-child`, and `:only-child` positional selectors
		//			* `:empty` content emtpy selector
		//			* `:checked` pseudo selector
		//			* `:nth-child(n)`, `:nth-child(2n+1)` style positional calculations
		//			* `:nth-child(even)`, `:nth-child(odd)` positional selectors
		//			* `:not(...)` negation pseudo selectors
		//
		//		Any legal combination of these selectors will work with
		//		`dojo.query()`, including compound selectors ("," delimited).
		//		Very complex and useful searches can be constructed with this
		//		palette of selectors and when combined with functions for
		//		manipulation presented by dojo.NodeList, many types of DOM
		//		manipulation operations become very straightforward.
		//		
		//		Unsupported Selectors:
		//		----------------------
		//
		//		While dojo.query handles many CSS3 selectors, some fall outside of
		//		what's resaonable for a programmatic node querying engine to
		//		handle. Currently unsupported selectors include:
		//		
		//			* namespace-differentiated selectors of any form
		//			* all `::` pseduo-element selectors
		//			* certain pseduo-selectors which don't get a lot of day-to-day use:
		//			|	* `:root`, `:lang()`, `:target`, `:focus`
		//			* all visual and state selectors:
		//			|	* `:root`, `:active`, `:hover`, `:visisted`, `:link`,
		//				  `:enabled`, `:disabled`
		//			* `:*-of-type` pseudo selectors
		//		
		//		dojo.query and XML Documents:
		//		-----------------------------
		//		
		//		`dojo.query` (as of dojo 1.2) supports searching XML documents
		//		in a case-sensitive manner. If an HTML document is served with
		//		a doctype that forces case-sensitivity (e.g., XHTML 1.1
		//		Strict), dojo.query() will detect this and "do the right
		//		thing". Case sensitivity is dependent upon the document being
		//		searched and not the query used. It is therefore possible to
		//		use case-sensitive queries on strict sub-documents (iframes,
		//		etc.) or XML documents while still assuming case-insensitivity
		//		for a host/root document.
		//
		//		Non-selector Queries:
		//		---------------------
		//
		//		If something other than a String is passed for the query,
		//		`dojo.query` will return a new `dojo.NodeList` instance
		//		constructed from that parameter alone and all further
		//		processing will stop. This means that if you have a reference
		//		to a node or NodeList, you can quickly construct a new NodeList
		//		from the original by calling `dojo.query(node)` or
		//		`dojo.query(list)`.
		//
		//	query:
		//		The CSS3 expression to match against. For details on the syntax of
		//		CSS3 selectors, see <http://www.w3.org/TR/css3-selectors/#selectors>
		//	root:
		//		A DOMNode (or node id) to scope the search from. Optional.
		//	returns: dojo.NodeList
		//		An instance of `dojo.NodeList`. Many methods are available on
		//		NodeLists for searching, iterating, manipulating, and handling
		//		events on the matched nodes in the returned list.
		//	example:
		//		search the entire document for elements with the class "foo":
		//	|	dojo.query(".foo");
		//		these elements will match:
		//	|	<span class="foo"></span>
		//	|	<span class="foo bar"></span>
		//	|	<p class="thud foo"></p>
		//	example:
		//		search the entire document for elements with the classes "foo" *and* "bar":
		//	|	dojo.query(".foo.bar");
		//		these elements will match:
		//	|	<span class="foo bar"></span>
		//		while these will not:
		//	|	<span class="foo"></span>
		//	|	<p class="thud foo"></p>
		//	example:
		//		find `<span>` elements which are descendants of paragraphs and
		//		which have a "highlighted" class:
		//	|	dojo.query("p span.highlighted");
		//		the innermost span in this fragment matches:
		//	|	<p class="foo">
		//	|		<span>...
		//	|			<span class="highlighted foo bar">...</span>
		//	|		</span>
		//	|	</p>
		//	example:
		//		set an "odd" class on all odd table rows inside of the table
		//		`#tabular_data`, using the `>` (direct child) selector to avoid
		//		affecting any nested tables:
		//	|	dojo.query("#tabular_data > tbody > tr:nth-child(odd)").addClass("odd");
		//	example:
		//		remove all elements with the class "error" from the document
		//		and store them in a list:
		//	|	var errors = dojo.query(".error").orphan();
		//	example:
		//		add an onclick handler to every submit button in the document
		//		which causes the form to be sent via Ajax instead:
		//	|	dojo.query("input[type='submit']").onclick(function(e){
		//	|		dojo.stopEvent(e); // prevent sending the form
		//	|		var btn = e.target;
		//	|		dojo.xhrPost({
		//	|			form: btn.form,
		//	|			load: function(data){
		//	|				// replace the form with the response
		//	|				var div = dojo.doc.createElement("div");
		//	|				dojo.place(div, btn.form, "after");
		//	|				div.innerHTML = data;
		//	|				dojo.style(btn.form, "display", "none");
		//	|			}
		//	|		});
		//	|	});

		//Set list constructor to desired value. This can change
		//between calls, so always re-assign here.
		qlc = d._queryListCtor;

		if(!query){
			return new qlc();
		}

		if(query.constructor == qlc){
			return query;
		}
		if(!isString(query)){
			return new qlc(query); // dojo.NodeList
		}
		if(isString(root)){
			root = d.byId(root);
			if(!root){ return new qlc(); }
		}

		root = root||getDoc();
		var od = root.ownerDocument||root.documentElement;

		// throw the big case sensitivity switch

		// NOTE:
		// 		Opera in XHTML mode doesn't detect case-sensitivity correctly
		// 		and it's not clear that there's any way to test for it
		caseSensitive = (root.contentType && root.contentType=="application/xml") || 
						(d.isOpera && (root.doctype || od.toString() == "[object XMLDocument]")) ||
						(!!od) && 
						(d.isIE ? od.xml : (root.xmlVersion||od.xmlVersion));

		// NOTE: 
		//		adding "true" as the 2nd argument to getQueryFunc is useful for
		//		testing the DOM branch without worrying about the
		//		behavior/performance of the QSA branch.
		var r = getQueryFunc(query)(root);

		// FIXME:
		//		need to investigate this branch WRT #8074 and #8075
		if(r && r.nozip && !qlc._wrap){
			return r;
		}
		return _zip(r); // dojo.NodeList
	}

	// FIXME: need to add infrastructure for post-filtering pseudos, ala :last
	d.query.pseudos = pseudos;

	// one-off function for filtering a NodeList based on a simple selector
	d._filterQueryResult = function(nodeList, simpleFilter){
		var tmpNodeList = new d._queryListCtor();
		var filterFunc = getSimpleFilterFunc(getQueryParts(simpleFilter)[0]);
		for(var x = 0, te; te = nodeList[x]; x++){
			if(filterFunc(te)){ tmpNodeList.push(te); }
		}
		return tmpNodeList;
	}
})(this["queryPortability"]||this["acme"]||dojo);

/*
*/

}

if(!dojo._hasResource["dojo._base.xhr"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo._base.xhr"] = true;
dojo.provide("dojo._base.xhr");





(function(){
	var _d = dojo;
	function setValue(/*Object*/obj, /*String*/name, /*String*/value){
		//summary:
		//		For the named property in object, set the value. If a value
		//		already exists and it is a string, convert the value to be an
		//		array of values.
		var val = obj[name];
		if(_d.isString(val)){
			obj[name] = [val, value];
		}else if(_d.isArray(val)){
			val.push(value);
		}else{
			obj[name] = value;
		}
	}

	dojo.formToObject = function(/*DOMNode||String*/ formNode){
		// summary:
		//		dojo.formToObject returns the values encoded in an HTML form as
		//		string properties in an object which it then returns. Disabled form
		//		elements, buttons, and other non-value form elements are skipped.
		//		Multi-select elements are returned as an array of string values.
		// description:
		//		This form:
		//
		//		|	<form id="test_form">
		//		|		<input type="text" name="blah" value="blah">
		//		|		<input type="text" name="no_value" value="blah" disabled>
		//		|		<input type="button" name="no_value2" value="blah">
		//		|		<select type="select" multiple name="multi" size="5">
		//		|			<option value="blah">blah</option>
		//		|			<option value="thud" selected>thud</option>
		//		|			<option value="thonk" selected>thonk</option>
		//		|		</select>
		//		|	</form>
		//
		//		yields this object structure as the result of a call to
		//		formToObject():
		//
		//		|	{ 
		//		|		blah: "blah",
		//		|		multi: [
		//		|			"thud",
		//		|			"thonk"
		//		|		]
		//		|	};

		var ret = {};
		var exclude = "file|submit|image|reset|button|";
		_d.forEach(dojo.byId(formNode).elements, function(item){
			var _in = item.name;
			var type = (item.type||"").toLowerCase();
			if(_in && type && exclude.indexOf(type) == -1 && !item.disabled){
				if(type == "radio" || type == "checkbox"){
					if(item.checked){ setValue(ret, _in, item.value); }
				}else if(item.multiple){
					ret[_in] = [];
					_d.query("option", item).forEach(function(opt){
						if(opt.selected){
							setValue(ret, _in, opt.value);
						}
					});
				}else{ 
					setValue(ret, _in, item.value);
					if(type == "image"){
						ret[_in+".x"] = ret[_in+".y"] = ret[_in].x = ret[_in].y = 0;
					}
				}
			}
		});
		return ret; // Object
	}

	dojo.objectToQuery = function(/*Object*/ map){
		//	summary:
		//		takes a name/value mapping object and returns a string representing
		//		a URL-encoded version of that object.
		//	example:
		//		this object:
		//
		//		|	{ 
		//		|		blah: "blah",
		//		|		multi: [
		//		|			"thud",
		//		|			"thonk"
		//		|		]
		//		|	};
		//
		//	yields the following query string:
		//	
		//	|	"blah=blah&multi=thud&multi=thonk"

		// FIXME: need to implement encodeAscii!!
		var enc = encodeURIComponent;
		var pairs = [];
		var backstop = {};
		for(var name in map){
			var value = map[name];
			if(value != backstop[name]){
				var assign = enc(name) + "=";
				if(_d.isArray(value)){
					for(var i=0; i < value.length; i++){
						pairs.push(assign + enc(value[i]));
					}
				}else{
					pairs.push(assign + enc(value));
				}
			}
		}
		return pairs.join("&"); // String
	}

	dojo.formToQuery = function(/*DOMNode||String*/ formNode){
		// summary:
		//		Returns a URL-encoded string representing the form passed as either a
		//		node or string ID identifying the form to serialize
		return _d.objectToQuery(_d.formToObject(formNode)); // String
	}

	dojo.formToJson = function(/*DOMNode||String*/ formNode, /*Boolean?*/prettyPrint){
		// summary:
		//		return a serialized JSON string from a form node or string
		//		ID identifying the form to serialize
		return _d.toJson(_d.formToObject(formNode), prettyPrint); // String
	}

	dojo.queryToObject = function(/*String*/ str){
		// summary:
		//		returns an object representing a de-serialized query section of a
		//		URL. Query keys with multiple values are returned in an array.
		// description:
		//		This string:
		//
		//	|		"foo=bar&foo=baz&thinger=%20spaces%20=blah&zonk=blarg&"
		//		
		//		results in this object structure:
		//
		//	|		{
		//	|			foo: [ "bar", "baz" ],
		//	|			thinger: " spaces =blah",
		//	|			zonk: "blarg"
		//	|		}
		//	
		//		Note that spaces and other urlencoded entities are correctly
		//		handled.

		// FIXME: should we grab the URL string if we're not passed one?
		var ret = {};
		var qp = str.split("&");
		var dec = decodeURIComponent;
		_d.forEach(qp, function(item){
			if(item.length){
				var parts = item.split("=");
				var name = dec(parts.shift());
				var val = dec(parts.join("="));
				if(_d.isString(ret[name])){
					ret[name] = [ret[name]];
				}
				if(_d.isArray(ret[name])){
					ret[name].push(val);
				}else{
					ret[name] = val;
				}
			}
		});
		return ret; // Object
	}

	/*
		from refactor.txt:

		all bind() replacement APIs take the following argument structure:

			{
				url: "blah.html",

				// all below are optional, but must be supported in some form by
				// every IO API
				timeout: 1000, // milliseconds
				handleAs: "text", // replaces the always-wrong "mimetype"
				content: { 
					key: "value"
				},

				// browser-specific, MAY be unsupported
				sync: true, // defaults to false
				form: dojo.byId("someForm") 
			}
	*/

	// need to block async callbacks from snatching this thread as the result
	// of an async callback might call another sync XHR, this hangs khtml forever
	// must checked by watchInFlight()

	dojo._blockAsync = false;

	dojo._contentHandlers = {
		text: function(xhr){ return xhr.responseText; },
		json: function(xhr){
			return _d.fromJson(xhr.responseText || null);
		},
		"json-comment-filtered": function(xhr){ 
			// NOTE: the json-comment-filtered option was implemented to prevent
			// "JavaScript Hijacking", but it is less secure than standard JSON. Use
			// standard JSON instead. JSON prefixing can be used to subvert hijacking.
			if(!dojo.config.useCommentedJson){
				console.warn("Consider using the standard mimetype:application/json."
					+ " json-commenting can introduce security issues. To"
					+ " decrease the chances of hijacking, use the standard the 'json' handler and"
					+ " prefix your json with: {}&&\n"
					+ "Use djConfig.useCommentedJson=true to turn off this message.");
			}

			var value = xhr.responseText;
			var cStartIdx = value.indexOf("\/*");
			var cEndIdx = value.lastIndexOf("*\/");
			if(cStartIdx == -1 || cEndIdx == -1){
				throw new Error("JSON was not comment filtered");
			}
			return _d.fromJson(value.substring(cStartIdx+2, cEndIdx));
		},
		javascript: function(xhr){ 
			// FIXME: try Moz and IE specific eval variants?
			return _d.eval(xhr.responseText);
		},
		xml: function(xhr){
			var result = xhr.responseXML;
						if(_d.isIE && (!result || !result.documentElement)){
				var ms = function(n){ return "MSXML" + n + ".DOMDocument"; }
				var dp = ["Microsoft.XMLDOM", ms(6), ms(4), ms(3), ms(2)];
				_d.some(dp, function(p){
					try{
						var dom = new ActiveXObject(p);
						dom.async = false;
						dom.loadXML(xhr.responseText);
						result = dom;
					}catch(e){ return false; }
					return true;
				});
			}
						return result; // DOMDocument
		}
	};

	dojo._contentHandlers["json-comment-optional"] = function(xhr){
		var handlers = _d._contentHandlers;
		if(xhr.responseText && xhr.responseText.indexOf("\/*") != -1){
			return handlers["json-comment-filtered"](xhr);
		}else{
			return handlers["json"](xhr);
		}
	};

	/*=====
	dojo.__IoArgs = function(){
		//	url: String
		//		URL to server endpoint.
		//	content: Object?
		//		Contains properties with string values. These
		//		properties will be serialized as name1=value2 and
		//		passed in the request.
		//	timeout: Integer?
		//		Milliseconds to wait for the response. If this time
		//		passes, the then error callbacks are called.
		//	form: DOMNode?
		//		DOM node for a form. Used to extract the form values
		//		and send to the server.
		//	preventCache: Boolean?
		//		Default is false. If true, then a
		//		"dojo.preventCache" parameter is sent in the request
		//		with a value that changes with each request
		//		(timestamp). Useful only with GET-type requests.
		//	handleAs: String?
		//		Acceptable values depend on the type of IO
		//		transport (see specific IO calls for more information).
		//	load: Function?
		//		function(response, ioArgs){} response is of type Object, ioArgs
		//		is of type dojo.__IoCallbackArgs.  This function will be
		//		called on a successful HTTP response code.
		//	error: Function?
		//		function(response, ioArgs){} response is of type Object, ioArgs
		//		is of type dojo.__IoCallbackArgs. This function will
		//		be called when the request fails due to a network or server error, the url
		//		is invalid, etc. It will also be called if the load or handle callback throws an
		//		exception, unless djConfig.debugAtAllCosts is true.  This allows deployed applications
		//		to continue to run even when a logic error happens in the callback, while making
		//		it easier to troubleshoot while in debug mode.
		//	handle: Function?
		//		function(response, ioArgs){} response is of type Object, ioArgs
		//		is of type dojo.__IoCallbackArgs.  This function will
		//		be called at the end of every request, whether or not an error occurs.
		this.url = url;
		this.content = content;
		this.timeout = timeout;
		this.form = form;
		this.preventCache = preventCache;
		this.handleAs = handleAs;
		this.load = load;
		this.error = error;
		this.handle = handle;
	}
	=====*/

	/*=====
	dojo.__IoCallbackArgs = function(args, xhr, url, query, handleAs, id, canDelete, json){
		//	args: Object
		//		the original object argument to the IO call.
		//	xhr: XMLHttpRequest
		//		For XMLHttpRequest calls only, the
		//		XMLHttpRequest object that was used for the
		//		request.
		//	url: String
		//		The final URL used for the call. Many times it
		//		will be different than the original args.url
		//		value.
		//	query: String
		//		For non-GET requests, the
		//		name1=value1&name2=value2 parameters sent up in
		//		the request.
		//	handleAs: String
		//		The final indicator on how the response will be
		//		handled.
		//	id: String
		//		For dojo.io.script calls only, the internal
		//		script ID used for the request.
		//	canDelete: Boolean
		//		For dojo.io.script calls only, indicates
		//		whether the script tag that represents the
		//		request can be deleted after callbacks have
		//		been called. Used internally to know when
		//		cleanup can happen on JSONP-type requests.
		//	json: Object
		//		For dojo.io.script calls only: holds the JSON
		//		response for JSONP-type requests. Used
		//		internally to hold on to the JSON responses.
		//		You should not need to access it directly --
		//		the same object should be passed to the success
		//		callbacks directly.
		this.args = args;
		this.xhr = xhr;
		this.url = url;
		this.query = query;
		this.handleAs = handleAs;
		this.id = id;
		this.canDelete = canDelete;
		this.json = json;
	}
	=====*/



	dojo._ioSetArgs = function(/*dojo.__IoArgs*/args,
			/*Function*/canceller,
			/*Function*/okHandler,
			/*Function*/errHandler){
		//	summary: 
		//		sets up the Deferred and ioArgs property on the Deferred so it
		//		can be used in an io call.
		//	args:
		//		The args object passed into the public io call. Recognized properties on
		//		the args object are:
		//	canceller:
		//		The canceller function used for the Deferred object. The function
		//		will receive one argument, the Deferred object that is related to the
		//		canceller.
		//	okHandler:
		//		The first OK callback to be registered with Deferred. It has the opportunity
		//		to transform the OK response. It will receive one argument -- the Deferred
		//		object returned from this function.
		//	errHandler:
		//		The first error callback to be registered with Deferred. It has the opportunity
		//		to do cleanup on an error. It will receive two arguments: error (the 
		//		Error object) and dfd, the Deferred object returned from this function.

		var ioArgs = {args: args, url: args.url};

		//Get values from form if requestd.
		var formObject = null;
		if(args.form){ 
			var form = _d.byId(args.form);
			//IE requires going through getAttributeNode instead of just getAttribute in some form cases, 
			//so use it for all.  See #2844
			var actnNode = form.getAttributeNode("action");
			ioArgs.url = ioArgs.url || (actnNode ? actnNode.value : null); 
			formObject = _d.formToObject(form);
		}

		// set up the query params
		var miArgs = [{}];
	
		if(formObject){
			// potentially over-ride url-provided params w/ form values
			miArgs.push(formObject);
		}
		if(args.content){
			// stuff in content over-rides what's set by form
			miArgs.push(args.content);
		}
		if(args.preventCache){
			miArgs.push({"dojo.preventCache": new Date().valueOf()});
		}
		ioArgs.query = _d.objectToQuery(_d.mixin.apply(null, miArgs));
	
		// .. and the real work of getting the deferred in order, etc.
		ioArgs.handleAs = args.handleAs || "text";
		var d = new _d.Deferred(canceller);
		d.addCallbacks(okHandler, function(error){
			return errHandler(error, d);
		});

		//Support specifying load, error and handle callback functions from the args.
		//For those callbacks, the "this" object will be the args object.
		//The callbacks will get the deferred result value as the
		//first argument and the ioArgs object as the second argument.
		var ld = args.load;
		if(ld && _d.isFunction(ld)){
			d.addCallback(function(value){
				return ld.call(args, value, ioArgs);
			});
		}
		var err = args.error;
		if(err && _d.isFunction(err)){
			d.addErrback(function(value){
				return err.call(args, value, ioArgs);
			});
		}
		var handle = args.handle;
		if(handle && _d.isFunction(handle)){
			d.addBoth(function(value){
				return handle.call(args, value, ioArgs);
			});
		}
		
		d.ioArgs = ioArgs;
	
		// FIXME: need to wire up the xhr object's abort method to something
		// analagous in the Deferred
		return d;
	}

	var _deferredCancel = function(/*Deferred*/dfd){
		//summary: canceller function for dojo._ioSetArgs call.
		
		dfd.canceled = true;
		var xhr = dfd.ioArgs.xhr;
		var _at = typeof xhr.abort;
		if(_at == "function" || _at == "object" || _at == "unknown"){
			xhr.abort();
		}
		var err = dfd.ioArgs.error;
		if(!err){
			err = new Error("xhr cancelled");
			err.dojoType="cancel";
		}
		return err;
	}
	var _deferredOk = function(/*Deferred*/dfd){
		//summary: okHandler function for dojo._ioSetArgs call.

		var ret = _d._contentHandlers[dfd.ioArgs.handleAs](dfd.ioArgs.xhr);
		return ret === undefined ? null : ret;
	}
	var _deferError = function(/*Error*/error, /*Deferred*/dfd){
		//summary: errHandler function for dojo._ioSetArgs call.

		console.error(error);
		return error;
	}

	// avoid setting a timer per request. It degrades performance on IE
	// something fierece if we don't use unified loops.
	var _inFlightIntvl = null;
	var _inFlight = [];
	var _watchInFlight = function(){
		//summary: 
		//		internal method that checks each inflight XMLHttpRequest to see
		//		if it has completed or if the timeout situation applies.
		
		var now = (new Date()).getTime();
		// make sure sync calls stay thread safe, if this callback is called
		// during a sync call and this results in another sync call before the
		// first sync call ends the browser hangs
		if(!_d._blockAsync){
			// we need manual loop because we often modify _inFlight (and therefore 'i') while iterating
			// note: the second clause is an assigment on purpose, lint may complain
			for(var i = 0, tif; i < _inFlight.length && (tif = _inFlight[i]); i++){
				var dfd = tif.dfd;
				var func = function(){
					if(!dfd || dfd.canceled || !tif.validCheck(dfd)){
						_inFlight.splice(i--, 1); 
					}else if(tif.ioCheck(dfd)){
						_inFlight.splice(i--, 1);
						tif.resHandle(dfd);
					}else if(dfd.startTime){
						//did we timeout?
						if(dfd.startTime + (dfd.ioArgs.args.timeout || 0) < now){
							_inFlight.splice(i--, 1);
							var err = new Error("timeout exceeded");
							err.dojoType = "timeout";
							dfd.errback(err);
							//Cancel the request so the io module can do appropriate cleanup.
							dfd.cancel();
						}
					}
				};
				if(dojo.config.debugAtAllCosts){
					func.call(this);
				}else{
					try{
						func.call(this);
					}catch(e){
						dfd.errback(e);
					}
				}
			}
		}

		if(!_inFlight.length){
			clearInterval(_inFlightIntvl);
			_inFlightIntvl = null;
			return;
		}

	}

	dojo._ioCancelAll = function(){
		//summary: Cancels all pending IO requests, regardless of IO type
		//(xhr, script, iframe).
		try{
			_d.forEach(_inFlight, function(i){
				try{
					i.dfd.cancel();
				}catch(e){/*squelch*/}
			});
		}catch(e){/*squelch*/}
	}

	//Automatically call cancel all io calls on unload
	//in IE for trac issue #2357.
		if(_d.isIE){
		_d.addOnWindowUnload(_d._ioCancelAll);
	}
	
	_d._ioWatch = function(/*Deferred*/dfd,
		/*Function*/validCheck,
		/*Function*/ioCheck,
		/*Function*/resHandle){
		//summary: watches the io request represented by dfd to see if it completes.
		//dfd:
		//		The Deferred object to watch.
		//validCheck:
		//		Function used to check if the IO request is still valid. Gets the dfd
		//		object as its only argument.
		//ioCheck:
		//		Function used to check if basic IO call worked. Gets the dfd
		//		object as its only argument.
		//resHandle:
		//		Function used to process response. Gets the dfd
		//		object as its only argument.
		var args = dfd.ioArgs.args;
		if(args.timeout){
			dfd.startTime = (new Date()).getTime();
		}
		_inFlight.push({dfd: dfd, validCheck: validCheck, ioCheck: ioCheck, resHandle: resHandle});
		if(!_inFlightIntvl){
			_inFlightIntvl = setInterval(_watchInFlight, 50);
		}
		// handle sync requests
		//A weakness: async calls in flight
		//could have their handlers called as part of the
		//_watchInFlight call, before the sync's callbacks
		// are called.
		if(args.sync){
			_watchInFlight();
		}
	}

	var _defaultContentType = "application/x-www-form-urlencoded";

	var _validCheck = function(/*Deferred*/dfd){
		return dfd.ioArgs.xhr.readyState; //boolean
	}
	var _ioCheck = function(/*Deferred*/dfd){
		return 4 == dfd.ioArgs.xhr.readyState; //boolean
	}
	var _resHandle = function(/*Deferred*/dfd){
		var xhr = dfd.ioArgs.xhr;
		if(_d._isDocumentOk(xhr)){
			dfd.callback(dfd);
		}else{
			var err = new Error("Unable to load " + dfd.ioArgs.url + " status:" + xhr.status);
			err.status = xhr.status;
			err.responseText = xhr.responseText;
			dfd.errback(err);
		}
	}

	dojo._ioAddQueryToUrl = function(/*dojo.__IoCallbackArgs*/ioArgs){
		//summary: Adds query params discovered by the io deferred construction to the URL.
		//Only use this for operations which are fundamentally GET-type operations.
		if(ioArgs.query.length){
			ioArgs.url += (ioArgs.url.indexOf("?") == -1 ? "?" : "&") + ioArgs.query;
			ioArgs.query = null;
		}		
	}

	/*=====
	dojo.declare("dojo.__XhrArgs", dojo.__IoArgs, {
		constructor: function(){
			//	summary:
			//		In addition to the properties listed for the dojo._IoArgs type,
			//		the following properties are allowed for dojo.xhr* methods.
			//	handleAs: String?
			//		Acceptable values are: text (default), json, json-comment-optional,
			//		json-comment-filtered, javascript, xml
			//	sync: Boolean?
			//		false is default. Indicates whether the request should
			//		be a synchronous (blocking) request.
			//	headers: Object?
			//		Additional HTTP headers to send in the request.
			this.handleAs = handleAs;
			this.sync = sync;
			this.headers = headers;
		}
	});
	=====*/

	dojo.xhr = function(/*String*/ method, /*dojo.__XhrArgs*/ args, /*Boolean?*/ hasBody){
		//	summary:
		//		Sends an HTTP request with the given method.
		//	description:
		//		Sends an HTTP request with the given method.
		//		See also dojo.xhrGet(), xhrPost(), xhrPut() and dojo.xhrDelete() for shortcuts
		//		for those HTTP methods. There are also methods for "raw" PUT and POST methods
		//		via dojo.rawXhrPut() and dojo.rawXhrPost() respectively.
		//	method:
		//		HTTP method to be used, such as GET, POST, PUT, DELETE.  Should be uppercase.
		//	hasBody:
		//		If the request has an HTTP body, then pass true for hasBody.

		//Make the Deferred object for this xhr request.
		var dfd = _d._ioSetArgs(args, _deferredCancel, _deferredOk, _deferError);

		//Pass the args to _xhrObj, to allow xhr iframe proxy interceptions.
		dfd.ioArgs.xhr = _d._xhrObj(dfd.ioArgs.args);

		if(hasBody){
			if("postData" in args){
				dfd.ioArgs.query = args.postData;
			}else if("putData" in args){
				dfd.ioArgs.query = args.putData;
			}
		}else{
			_d._ioAddQueryToUrl(dfd.ioArgs);
		}

		// IE 6 is a steaming pile. It won't let you call apply() on the native function (xhr.open).
		// workaround for IE6's apply() "issues"
		var ioArgs = dfd.ioArgs;
		var xhr = ioArgs.xhr;
		xhr.open(method, ioArgs.url, args.sync !== true, args.user || undefined, args.password || undefined);
		if(args.headers){
			for(var hdr in args.headers){
				if(hdr.toLowerCase() === "content-type" && !args.contentType){
					args.contentType = args.headers[hdr];
				}else{
					xhr.setRequestHeader(hdr, args.headers[hdr]);
				}
			}
		}
		// FIXME: is this appropriate for all content types?
		xhr.setRequestHeader("Content-Type", args.contentType || _defaultContentType);
		if(!args.headers || !args.headers["X-Requested-With"]){
			xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
		}
		// FIXME: set other headers here!
		if(dojo.config.debugAtAllCosts){
			xhr.send(ioArgs.query);
		}else{
			try{
				xhr.send(ioArgs.query);
			}catch(e){
				dfd.ioArgs.error = e;
				dfd.cancel();
			}
		}
		_d._ioWatch(dfd, _validCheck, _ioCheck, _resHandle);
		xhr = null;
		return dfd; // dojo.Deferred
	}

	dojo.xhrGet = function(/*dojo.__XhrArgs*/ args){
		//	summary: 
		//		Sends an HTTP GET request to the server.
		return _d.xhr("GET", args); // dojo.Deferred
	}

	dojo.rawXhrPost = dojo.xhrPost = function(/*dojo.__XhrArgs*/ args){
		//	summary:
		//		Sends an HTTP POST request to the server. In addtion to the properties
		//		listed for the dojo.__XhrArgs type, the following property is allowed:
		//	postData:
		//		String. Send raw data in the body of the POST request.
		return _d.xhr("POST", args, true); // dojo.Deferred
	}

	dojo.rawXhrPut = dojo.xhrPut = function(/*dojo.__XhrArgs*/ args){
		//	summary:
		//		Sends an HTTP PUT request to the server. In addtion to the properties
		//		listed for the dojo.__XhrArgs type, the following property is allowed:
		//	putData:
		//		String. Send raw data in the body of the PUT request.
		return _d.xhr("PUT", args, true); // dojo.Deferred
	}

	dojo.xhrDelete = function(/*dojo.__XhrArgs*/ args){
		//	summary:
		//		Sends an HTTP DELETE request to the server.
		return _d.xhr("DELETE", args); //dojo.Deferred
	}

	/*
	dojo.wrapForm = function(formNode){
		//summary:
		//		A replacement for FormBind, but not implemented yet.

		// FIXME: need to think harder about what extensions to this we might
		// want. What should we allow folks to do w/ this? What events to
		// set/send?
		throw new Error("dojo.wrapForm not yet implemented");
	}
	*/
})();

}

if(!dojo._hasResource["dojo._base.fx"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo._base.fx"] = true;
dojo.provide("dojo._base.fx");






/*
	Animation losely package based on Dan Pupius' work, contributed under CLA: 
		http://pupius.co.uk/js/Toolkit.Drawing.js
*/
(function(){ 

	var d = dojo;
	var _mixin = d.mixin;
	
	dojo._Line = function(/*int*/ start, /*int*/ end){
		//	summary:
		//		dojo._Line is the object used to generate values from a start value
		//		to an end value
		//	start: int
		//		Beginning value for range
		//	end: int
		//		Ending value for range
		this.start = start;
		this.end = end;
	}
	dojo._Line.prototype.getValue = function(/*float*/ n){
		//	summary: Returns the point on the line
		//	n: a floating point number greater than 0 and less than 1
		return ((this.end - this.start) * n) + this.start; // Decimal
	}
	
	d.declare("dojo._Animation", null, {
		//	summary
		//		A generic animation class that fires callbacks into its handlers
		//		object at various states. Nearly all dojo animation functions
		//		return an instance of this method, usually without calling the
		//		.play() method beforehand. Therefore, you will likely need to
		//		call .play() on instances of dojo._Animation when one is
		//		returned.
		constructor: function(/*Object*/ args){
			_mixin(this, args);
			if(d.isArray(this.curve)){
				/* curve: Array
					pId: a */
				this.curve = new d._Line(this.curve[0], this.curve[1]);
			}
		},
		
		// duration: Integer
		//	The time in milliseonds the animation will take to run
		duration: 350,
	
	/*=====
		// curve: dojo._Line||Array
		//	A two element array of start and end values, or a dojo._Line instance to be
		//	used in the Animation. 
		curve: null,
	
		// easing: Function
		//	A Function to adjust the acceleration (or deceleration) of the progress 
		//	across a dojo._Line
		easing: null,
	=====*/
	
		// repeat: Integer
		//	The number of times to loop the animation
		repeat: 0,
	
		// rate: Integer
		//	the time in milliseconds to wait before advancing to next frame 
		//	(used as a fps timer: rate/1000 = fps)
		rate: 10 /* 100 fps */,
	
	/*===== 
		// delay: Integer
		// 	The time in milliseconds to wait before starting animation after it has been .play()'ed
		delay: null,
	
		// events
		//
		// beforeBegin: Event
		//	Synthetic event fired before a dojo._Animation begins playing (synchronous)
		beforeBegin: null,
	
		// onBegin: Event
		//	Synthetic event fired as a dojo._Animation begins playing (useful?)
		onBegin: null,
	
		// onAnimate: Event
		//	Synthetic event fired at each interval of a dojo._Animation
		onAnimate: null,
	
		// onEnd: Event
		//	Synthetic event fired after the final frame of a dojo._Animation
		onEnd: null,
	
		// onPlay: Event
		//	Synthetic event fired any time a dojo._Animation is play()'ed
		onPlay: null,
	
		// onPause: Event
		//	Synthetic event fired when a dojo._Animation is paused
		onPause: null,
	
		// onStop: Event
		//	Synthetic event fires when a dojo._Animation is stopped
		onStop: null,
	
	=====*/
	
		_percent: 0,
		_startRepeatCount: 0,
	
		_fire: function(/*Event*/ evt, /*Array?*/ args){
			//	summary:
			//		Convenience function.  Fire event "evt" and pass it the
			//		arguments specified in "args".
			//	evt:
			//		The event to fire.
			//	args:
			//		The arguments to pass to the event.
			if(this[evt]){
				if(dojo.config.debugAtAllCosts){
					this[evt].apply(this, args||[]);
				}else{
					try{
						this[evt].apply(this, args||[]);
					}catch(e){
						// squelch and log because we shouldn't allow exceptions in
						// synthetic event handlers to cause the internal timer to run
						// amuck, potentially pegging the CPU. I'm not a fan of this
						// squelch, but hopefully logging will make it clear what's
						// going on
						console.error("exception in animation handler for:", evt);
						console.error(e);
					}
				}
			}
			return this; // dojo._Animation
		},

		play: function(/*int?*/ delay, /*Boolean?*/ gotoStart){
			// summary:
			//		Start the animation.
			// delay:
			//		How many milliseconds to delay before starting.
			// gotoStart:
			//		If true, starts the animation from the beginning; otherwise,
			//		starts it from its current position.
			var _t = this;
			if(_t._delayTimer){ _t._clearTimer(); }
			if(gotoStart){
				_t._stopTimer();
				_t._active = _t._paused = false;
				_t._percent = 0;
			}else if(_t._active && !_t._paused){
				return _t; // dojo._Animation
			}
	
			_t._fire("beforeBegin");
	
			var de = delay || _t.delay,
				_p = dojo.hitch(_t, "_play", gotoStart);
				
			if(de > 0){
				_t._delayTimer = setTimeout(_p, de);
				return _t; // dojo._Animation
			}
			_p();
			return _t;
		},
	
		_play: function(gotoStart){
			var _t = this;
			if(_t._delayTimer){ _t._clearTimer(); }
			_t._startTime = new Date().valueOf();
			if(_t._paused){
				_t._startTime -= _t.duration * _t._percent;
			}
			_t._endTime = _t._startTime + _t.duration;
	
			_t._active = true;
			_t._paused = false;
	
			var value = _t.curve.getValue(_t._percent);
			if(!_t._percent){
				if(!_t._startRepeatCount){
					_t._startRepeatCount = _t.repeat;
				}
				_t._fire("onBegin", [value]);
			}
	
			_t._fire("onPlay", [value]);
	
			_t._cycle();
			return _t; // dojo._Animation
		},
	
		pause: function(){
			// summary: Pauses a running animation.
			var _t = this;
			if(_t._delayTimer){ _t._clearTimer(); }
			_t._stopTimer();
			if(!_t._active){ return _t; /*dojo._Animation*/ }
			_t._paused = true;
			_t._fire("onPause", [_t.curve.getValue(_t._percent)]);
			return _t; // dojo._Animation
		},
	
		gotoPercent: function(/*Decimal*/ percent, /*Boolean?*/ andPlay){
			//	summary:
			//		Sets the progress of the animation.
			//	percent:
			//		A percentage in decimal notation (between and including 0.0 and 1.0).
			//	andPlay:
			//		If true, play the animation after setting the progress.
			var _t = this;
			_t._stopTimer();
			_t._active = _t._paused = true;
			_t._percent = percent;
			if(andPlay){ _t.play(); }
			return _t; // dojo._Animation
		},
	
		stop: function(/*boolean?*/ gotoEnd){
			// summary: Stops a running animation.
			// gotoEnd: If true, the animation will end.
			var _t = this;
			if(_t._delayTimer){ _t._clearTimer(); }
			if(!_t._timer){ return _t; /* dojo._Animation */ }
			_t._stopTimer();
			if(gotoEnd){
				_t._percent = 1;
			}
			_t._fire("onStop", [_t.curve.getValue(_t._percent)]);
			_t._active = _t._paused = false;
			return _t; // dojo._Animation
		},
	
		status: function(){
			// summary: Returns a string token representation of the status of
			//			the animation, one of: "paused", "playing", "stopped"
			if(this._active){
				return this._paused ? "paused" : "playing"; // String
			}
			return "stopped"; // String
		},
	
		_cycle: function(){
			var _t = this;
			if(_t._active){
				var curr = new Date().valueOf();
				var step = (curr - _t._startTime) / (_t._endTime - _t._startTime);
	
				if(step >= 1){
					step = 1;
				}
				_t._percent = step;
	
				// Perform easing
				if(_t.easing){
					step = _t.easing(step);
				}
	
				_t._fire("onAnimate", [_t.curve.getValue(step)]);
	
				if(_t._percent < 1){
					_t._startTimer();
				}else{
					_t._active = false;
	
					if(_t.repeat > 0){
						_t.repeat--;
						_t.play(null, true);
					}else if(_t.repeat == -1){
						_t.play(null, true);
					}else{
						if(_t._startRepeatCount){
							_t.repeat = _t._startRepeatCount;
							_t._startRepeatCount = 0;
						}
					}
					_t._percent = 0;
					_t._fire("onEnd");
					_t._stopTimer();
				}
			}
			return _t; // dojo._Animation
		},
		
		_clearTimer: function(){
			// summary: Clear the play delay timer
			clearTimeout(this._delayTimer);
			delete this._delayTimer;
		}
		
	});

	var ctr = 0,
		_globalTimerList = [],
		timer = null,
		runner = {
			run: function(){ }
		};

	dojo._Animation.prototype._startTimer = function(){
		// this._timer = setTimeout(dojo.hitch(this, "_cycle"), this.rate);
		if(!this._timer){
			this._timer = d.connect(runner, "run", this, "_cycle");
			ctr++;
		}
		if(!timer){
			timer = setInterval(d.hitch(runner, "run"), this.rate);
		}
	};

	dojo._Animation.prototype._stopTimer = function(){
		if(this._timer){
			d.disconnect(this._timer);
			this._timer = null;
			ctr--;
		}
		if(ctr <= 0){
			clearInterval(timer);
			timer = null;
			ctr = 0;
		}
	};

	var _makeFadeable = 
				d.isIE ? function(node){
			// only set the zoom if the "tickle" value would be the same as the
			// default
			var ns = node.style;
			// don't set the width to auto if it didn't already cascade that way.
			// We don't want to f anyones designs
			if(!ns.width.length && d.style(node, "width") == "auto"){
				ns.width = "auto";
			}
		} : 
				function(){};

	dojo._fade = function(/*Object*/ args){
		//	summary: 
		//		Returns an animation that will fade the node defined by
		//		args.node from the start to end values passed (args.start
		//		args.end) (end is mandatory, start is optional)

		args.node = d.byId(args.node);
		var fArgs = _mixin({ properties: {} }, args),
		 	props = (fArgs.properties.opacity = {});
		
		props.start = !("start" in fArgs) ?
			function(){ 
				return +d.style(fArgs.node, "opacity")||0; 
			} : fArgs.start;
		props.end = fArgs.end;

		var anim = d.animateProperty(fArgs);
		d.connect(anim, "beforeBegin", d.partial(_makeFadeable, fArgs.node));

		return anim; // dojo._Animation
	}

	/*=====
	dojo.__FadeArgs = function(node, duration, easing){
		// 	node: DOMNode|String
		//		The node referenced in the animation
		//	duration: Integer?
		//		Duration of the animation in milliseconds.
		//	easing: Function?
		//		An easing function.
		this.node = node;
		this.duration = duration;
		this.easing = easing;
	}
	=====*/

	dojo.fadeIn = function(/*dojo.__FadeArgs*/ args){
		// summary: 
		//		Returns an animation that will fade node defined in 'args' from
		//		its current opacity to fully opaque.
		return d._fade(_mixin({ end: 1 }, args)); // dojo._Animation
	}

	dojo.fadeOut = function(/*dojo.__FadeArgs*/  args){
		// summary: 
		//		Returns an animation that will fade node defined in 'args'
		//		from its current opacity to fully transparent.
		return d._fade(_mixin({ end: 0 }, args)); // dojo._Animation
	}

	dojo._defaultEasing = function(/*Decimal?*/ n){
		// summary: The default easing function for dojo._Animation(s)
		return 0.5 + ((Math.sin((n + 1.5) * Math.PI))/2);
	}

	var PropLine = function(properties){
		// PropLine is an internal class which is used to model the values of
		// an a group of CSS properties across an animation lifecycle. In
		// particular, the "getValue" function handles getting interpolated
		// values between start and end for a particular CSS value.
		this._properties = properties;
		for(var p in properties){
			var prop = properties[p];
			if(prop.start instanceof d.Color){
				// create a reusable temp color object to keep intermediate results
				prop.tempColor = new d.Color();
			}
		}
	}

	PropLine.prototype.getValue = function(r){
		var ret = {};
		for(var p in this._properties){
			var prop = this._properties[p],
				start = prop.start;
			if(start instanceof d.Color){
				ret[p] = d.blendColors(start, prop.end, r, prop.tempColor).toCss();
			}else if(!d.isArray(start)){
				ret[p] = ((prop.end - start) * r) + start + (p != "opacity" ? prop.units || "px" : 0);
			}
		}
		return ret;
	}

	/*=====
	dojo.declare("dojo.__AnimArgs", [dojo.__FadeArgs], {
		// Properties: Object?
		//	A hash map of style properties to Objects describing the transition,
		//	such as the properties of dojo._Line with an additional 'unit' property
		properties: {}
		
		//TODOC: add event callbacks
	});
	=====*/

	dojo.animateProperty = function(/*dojo.__AnimArgs*/ args){
		//	summary: 
		//		Returns an animation that will transition the properties of
		//		node defined in 'args' depending how they are defined in
		//		'args.properties'
		//
		// description:
		//		dojo.animateProperty is the foundation of most dojo.fx
		//		animations. It takes an object of "properties" corresponding to
		//		style properties, and animates them in parallel over a set
		//		duration.
		//	
		// 	example:
		//		A simple animation that changes the width of the specified node.
		//	|	dojo.animateProperty({ 
		//	|		node: "nodeId",
		//	|		properties: { width: 400 },
		//	|	}).play();
		//		Dojo figures out the start value for the width and converts the
		//		integer specified for the width to the more expressive but
		//		verbose form `{ width: { end: '400', units: 'px' } }` which you
		//		can also specify directly
		//
		// 	example:
		//		Animate width, height, and padding over 2 seconds... the
		//		pedantic way:
		//	|	dojo.animateProperty({ node: node, duration:2000,
		//	|		properties: {
		//	|			width: { start: '200', end: '400', unit:"px" },
		//	|			height: { start:'200', end: '400', unit:"px" },
		//	|			paddingTop: { start:'5', end:'50', unit:"px" } 
		//	|		}
		//	|	}).play();
		//		Note 'paddingTop' is used over 'padding-top'. Multi-name CSS properties
		//		are written using "mixed case", as the hyphen is illegal as an object key.
		//		
		// 	example:
		//		Plug in a different easing function and register a callback for
		//		when the animation ends. Easing functions accept values between
		//		zero and one and return a value on that basis. In this case, an
		//		exponential-in curve.
		//	|	dojo.animateProperty({ 
		//	|		node: "nodeId",
		//	|		// dojo figures out the start value
		//	|		properties: { width: { end: 400 } },
		//	|		easing: function(n){
		//	|			return (n==0) ? 0 : Math.pow(2, 10 * (n - 1));
		//	|		},
		//	|		onEnd: function(){
		//	|			// called when the animation finishes
		//	|		}
		//	|	}).play(500); // delay playing half a second
		//
		//	example:
		//		Like all `dojo._Animation`s, animateProperty returns a handle to the
		//		Animation instance, which fires the events common to Dojo FX. Use `dojo.connect`
		//		to access these events outside of the Animation definiton:
		//	|	var anim = dojo.animateProperty({
		//	|		node:"someId",
		//	|		properties:{
		//	|			width:400, height:500
		//	|		}
		//	|	});
		//	|	dojo.connect(anim,"onEnd", function(){
		//	|		console.log("animation ended");
		//	|	});
		//	|	// play the animation now:
		//	|	anim.play();
		
		args.node = d.byId(args.node);
		if(!args.easing){ args.easing = d._defaultEasing; }

		var anim = new d._Animation(args);
		d.connect(anim, "beforeBegin", anim, function(){
			var pm = {};
			for(var p in this.properties){
				// Make shallow copy of properties into pm because we overwrite
				// some values below. In particular if start/end are functions
				// we don't want to overwrite them or the functions won't be
				// called if the animation is reused.
				if(p == "width" || p == "height"){
					this.node.display = "block";
				}
				var prop = this.properties[p];
				prop = pm[p] = _mixin({}, (d.isObject(prop) ? prop: { end: prop }));

				if(d.isFunction(prop.start)){
					prop.start = prop.start();
				}
				if(d.isFunction(prop.end)){
					prop.end = prop.end();
				}
				var isColor = (p.toLowerCase().indexOf("color") >= 0);
				function getStyle(node, p){
					// dojo.style(node, "height") can return "auto" or "" on IE; this is more reliable:
					var v = {height: node.offsetHeight, width: node.offsetWidth}[p];
					if(v !== undefined){ return v; }
					v = d.style(node, p);
					return (p == "opacity") ? +v : (isColor ? v : parseFloat(v));
				}
				if(!("end" in prop)){
					prop.end = getStyle(this.node, p);
				}else if(!("start" in prop)){
					prop.start = getStyle(this.node, p);
				}

				if(isColor){
					prop.start = new d.Color(prop.start);
					prop.end = new d.Color(prop.end);
				}else{
					prop.start = (p == "opacity") ? +prop.start : parseFloat(prop.start);
				}
			}
			this.curve = new PropLine(pm);
		});
		d.connect(anim, "onAnimate", d.hitch(d, "style", anim.node));
		return anim; // dojo._Animation
	}

	dojo.anim = function(	/*DOMNode|String*/ 	node, 
							/*Object*/ 			properties, 
							/*Integer?*/		duration, 
							/*Function?*/		easing, 
							/*Function?*/		onEnd,
							/*Integer?*/		delay){
		//	summary:
		//		A simpler interface to `dojo.animateProperty()`, also returns
		//		an instance of `dojo._Animation` but begins the animation
		//		immediately, unlike nearly every other Dojo animation API.
		//	description:
		//		`dojo.anim` is a simpler (but somewhat less powerful) version
		//		of `dojo.animateProperty`.  It uses defaults for many basic properties
		//		and allows for positional parameters to be used in place of the
		//		packed "property bag" which is used for other Dojo animation
		//		methods.
		//
		//		The `dojo._Animation` object returned from `dojo.anim` will be
		//		already playing when it is returned from this function, so
		//		calling play() on it again is (usually) a no-op.
		//	node:
		//		a DOM node or the id of a node to animate CSS properties on
		//	duration:
		//		The number of milliseconds over which the animation
		//		should run. Defaults to the global animation default duration
		//		(350ms).
		//	easing:
		//		An easing function over which to calculate acceleration
		//		and deceleration of the animation through its duration.
		//		A default easing algorithm is provided, but you may
		//		plug in any you wish. A large selection of easing algorithms
		//		are available in `dojo.fx.easing`.
		//	onEnd:
		//		A function to be called when the animation finishes
		//		running.
		//	delay:
		//		The number of milliseconds to delay beginning the
		//		animation by. The default is 0.
		//	example:
		//		Fade out a node
		//	|	dojo.anim("id", { opacity: 0 });
		//	example:
		//		Fade out a node over a full second
		//	|	dojo.anim("id", { opacity: 0 }, 1000);
		return d.animateProperty({ 
			node: node,
			duration: duration||d._Animation.prototype.duration,
			properties: properties,
			easing: easing,
			onEnd: onEnd 
		}).play(delay||0);
	}
})();

}

if(!dojo._hasResource["dojo._base.browser"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo._base.browser"] = true;
dojo.provide("dojo._base.browser");










//Need this to be the last code segment in base, so do not place any
//dojo.requireIf calls in this file. Otherwise, due to how the build system
//puts all requireIf dependencies after the current file, the require calls
//could be called before all of base is defined.
dojo.forEach(dojo.config.require, function(i){
	dojo["require"](i);
});

}

if(!dojo._hasResource["dojo.date.stamp"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.date.stamp"] = true;
dojo.provide("dojo.date.stamp");

// Methods to convert dates to or from a wire (string) format using well-known conventions

dojo.date.stamp.fromISOString = function(/*String*/formattedString, /*Number?*/defaultTime){
	//	summary:
	//		Returns a Date object given a string formatted according to a subset of the ISO-8601 standard.
	//
	//	description:
	//		Accepts a string formatted according to a profile of ISO8601 as defined by
	//		[RFC3339](http://www.ietf.org/rfc/rfc3339.txt), except that partial input is allowed.
	//		Can also process dates as specified [by the W3C](http://www.w3.org/TR/NOTE-datetime)
	//		The following combinations are valid:
	//
	//			* dates only
	//			|	* yyyy
	//			|	* yyyy-MM
	//			|	* yyyy-MM-dd
	// 			* times only, with an optional time zone appended
	//			|	* THH:mm
	//			|	* THH:mm:ss
	//			|	* THH:mm:ss.SSS
	// 			* and "datetimes" which could be any combination of the above
	//
	//		timezones may be specified as Z (for UTC) or +/- followed by a time expression HH:mm
	//		Assumes the local time zone if not specified.  Does not validate.  Improperly formatted
	//		input may return null.  Arguments which are out of bounds will be handled
	// 		by the Date constructor (e.g. January 32nd typically gets resolved to February 1st)
	//		Only years between 100 and 9999 are supported.
	//
  	//	formattedString:
	//		A string such as 2005-06-30T08:05:00-07:00 or 2005-06-30 or T08:05:00
	//
	//	defaultTime:
	//		Used for defaults for fields omitted in the formattedString.
	//		Uses 1970-01-01T00:00:00.0Z by default.

	if(!dojo.date.stamp._isoRegExp){
		dojo.date.stamp._isoRegExp =
//TODO: could be more restrictive and check for 00-59, etc.
			/^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(.\d+)?)?((?:[+-](\d{2}):(\d{2}))|Z)?)?$/;
	}

	var match = dojo.date.stamp._isoRegExp.exec(formattedString);
	var result = null;

	if(match){
		match.shift();
		if(match[1]){match[1]--;} // Javascript Date months are 0-based
		if(match[6]){match[6] *= 1000;} // Javascript Date expects fractional seconds as milliseconds

		if(defaultTime){
			// mix in defaultTime.  Relatively expensive, so use || operators for the fast path of defaultTime === 0
			defaultTime = new Date(defaultTime);
			dojo.map(["FullYear", "Month", "Date", "Hours", "Minutes", "Seconds", "Milliseconds"], function(prop){
				return defaultTime["get" + prop]();
			}).forEach(function(value, index){
				if(match[index] === undefined){
					match[index] = value;
				}
			});
		}
		result = new Date(match[0]||1970, match[1]||0, match[2]||1, match[3]||0, match[4]||0, match[5]||0, match[6]||0);
//		result.setFullYear(match[0]||1970); // for year < 100

		var offset = 0;
		var zoneSign = match[7] && match[7].charAt(0);
		if(zoneSign != 'Z'){
			offset = ((match[8] || 0) * 60) + (Number(match[9]) || 0);
			if(zoneSign != '-'){ offset *= -1; }
		}
		if(zoneSign){
			offset -= result.getTimezoneOffset();
		}
		if(offset){
			result.setTime(result.getTime() + offset * 60000);
		}
	}

	return result; // Date or null
}

/*=====
	dojo.date.stamp.__Options = function(){
		//	selector: String
		//		"date" or "time" for partial formatting of the Date object.
		//		Both date and time will be formatted by default.
		//	zulu: Boolean
		//		if true, UTC/GMT is used for a timezone
		//	milliseconds: Boolean
		//		if true, output milliseconds
		this.selector = selector;
		this.zulu = zulu;
		this.milliseconds = milliseconds;
	}
=====*/

dojo.date.stamp.toISOString = function(/*Date*/dateObject, /*dojo.date.stamp.__Options?*/options){
	//	summary:
	//		Format a Date object as a string according a subset of the ISO-8601 standard
	//
	//	description:
	//		When options.selector is omitted, output follows [RFC3339](http://www.ietf.org/rfc/rfc3339.txt)
	//		The local time zone is included as an offset from GMT, except when selector=='time' (time without a date)
	//		Does not check bounds.  Only years between 100 and 9999 are supported.
	//
	//	dateObject:
	//		A Date object

	var _ = function(n){ return (n < 10) ? "0" + n : n; };
	options = options || {};
	var formattedDate = [];
	var getter = options.zulu ? "getUTC" : "get";
	var date = "";
	if(options.selector != "time"){
		var year = dateObject[getter+"FullYear"]();
		date = ["0000".substr((year+"").length)+year, _(dateObject[getter+"Month"]()+1), _(dateObject[getter+"Date"]())].join('-');
	}
	formattedDate.push(date);
	if(options.selector != "date"){
		var time = [_(dateObject[getter+"Hours"]()), _(dateObject[getter+"Minutes"]()), _(dateObject[getter+"Seconds"]())].join(':');
		var millis = dateObject[getter+"Milliseconds"]();
		if(options.milliseconds){
			time += "."+ (millis < 100 ? "0" : "") + _(millis);
		}
		if(options.zulu){
			time += "Z";
		}else if(options.selector != "time"){
			var timezoneOffset = dateObject.getTimezoneOffset();
			var absOffset = Math.abs(timezoneOffset);
			time += (timezoneOffset > 0 ? "-" : "+") + 
				_(Math.floor(absOffset/60)) + ":" + _(absOffset%60);
		}
		formattedDate.push(time);
	}
	return formattedDate.join('T'); // String
}

}

if(!dojo._hasResource["dojo.parser"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.parser"] = true;
dojo.provide("dojo.parser");


dojo.parser = new function(){
	// summary: The Dom/Widget parsing package

	var d = dojo;
	this._attrName = d._scopeName + "Type";
	this._query = "[" + this._attrName + "]";

	var _anonCtr = 0, _anon = {};
	var nameAnonFunc = function(/*Function*/anonFuncPtr, /*Object*/thisObj){
		// summary:
		//		Creates a reference to anonFuncPtr in thisObj with a completely
		//		unique name. The new name is returned as a String. 
		var nso = thisObj || _anon;
		if(dojo.isIE){
			var cn = anonFuncPtr["__dojoNameCache"];
			if(cn && nso[cn] === anonFuncPtr){
				return cn;
			}
		}
		var name;
		do{
			name = "__" + _anonCtr++;
		}while(name in nso)
		nso[name] = anonFuncPtr;
		return name; // String
	}

	function val2type(/*Object*/ value){
		// summary:
		//		Returns name of type of given value.

		if(d.isString(value)){ return "string"; }
		if(typeof value == "number"){ return "number"; }
		if(typeof value == "boolean"){ return "boolean"; }
		if(d.isFunction(value)){ return "function"; }
		if(d.isArray(value)){ return "array"; } // typeof [] == "object"
		if(value instanceof Date) { return "date"; } // assume timestamp
		if(value instanceof d._Url){ return "url"; }
		return "object";
	}

	function str2obj(/*String*/ value, /*String*/ type){
		// summary:
		//		Convert given string value to given type
		switch(type){
			case "string":
				return value;
			case "number":
				return value.length ? Number(value) : NaN;
			case "boolean":
				// for checked/disabled value might be "" or "checked".  interpret as true.
				return typeof value == "boolean" ? value : !(value.toLowerCase()=="false");
			case "function":
				if(d.isFunction(value)){
					// IE gives us a function, even when we say something like onClick="foo"
					// (in which case it gives us an invalid function "function(){ foo }"). 
					//  Therefore, convert to string
					value=value.toString();
					value=d.trim(value.substring(value.indexOf('{')+1, value.length-1));
				}
				try{
					if(value.search(/[^\w\.]+/i) != -1){
						// TODO: "this" here won't work
						value = nameAnonFunc(new Function(value), this);
					}
					return d.getObject(value, false);
				}catch(e){ return new Function(); }
			case "array":
				return value ? value.split(/\s*,\s*/) : [];
			case "date":
				switch(value){
					case "": return new Date("");	// the NaN of dates
					case "now": return new Date();	// current date
					default: return d.date.stamp.fromISOString(value);
				}
			case "url":
				return d.baseUrl + value;
			default:
				return d.fromJson(value);
		}
	}

	var instanceClasses = {
		// map from fully qualified name (like "dijit.Button") to structure like
		// { cls: dijit.Button, params: {label: "string", disabled: "boolean"} }
	};
	
	function getClassInfo(/*String*/ className){
		// className:
		//		fully qualified name (like "dijit.form.Button")
		// returns:
		//		structure like
		//			{ 
		//				cls: dijit.Button, 
		//				params: { label: "string", disabled: "boolean"}
		//			}

		if(!instanceClasses[className]){
			// get pointer to widget class
			var cls = d.getObject(className);
			if(!d.isFunction(cls)){
				throw new Error("Could not load class '" + className +
					"'. Did you spell the name correctly and use a full path, like 'dijit.form.Button'?");
			}
			var proto = cls.prototype;
	
			// get table of parameter names & types
			var params = {}, dummyClass = {};
			for(var name in proto){
				if(name.charAt(0)=="_"){ continue; } 	// skip internal properties
				if(name in dummyClass){ continue; }		// skip "constructor" and "toString"
				var defVal = proto[name];
				params[name]=val2type(defVal);
			}

			instanceClasses[className] = { cls: cls, params: params };
		}
		return instanceClasses[className];
	}

	this._functionFromScript = function(script){
		var preamble = "";
		var suffix = "";
		var argsStr = script.getAttribute("args");
		if(argsStr){
			d.forEach(argsStr.split(/\s*,\s*/), function(part, idx){
				preamble += "var "+part+" = arguments["+idx+"]; ";
			});
		}
		var withStr = script.getAttribute("with");
		if(withStr && withStr.length){
			d.forEach(withStr.split(/\s*,\s*/), function(part){
				preamble += "with("+part+"){";
				suffix += "}";
			});
		}
		return new Function(preamble+script.innerHTML+suffix);
	}

	this.instantiate = function(/* Array */nodes, /* Object? */mixin){
		// summary:
		//		Takes array of nodes, and turns them into class instances and
		//		potentially calls a layout method to allow them to connect with
		//		any children		
		// mixin: Object
		//		An object that will be mixed in with each node in the array.
		//		Values in the mixin will override values in the node, if they
		//		exist.
		var thelist = [], dp = dojo.parser;
		mixin = mixin||{};
		d.forEach(nodes, function(node){
			if(!node){ return; }
			var type = dp._attrName in mixin?mixin[dp._attrName]:node.getAttribute(dp._attrName);
			if(!type || !type.length){ return; }
			var clsInfo = getClassInfo(type),
				clazz = clsInfo.cls,
				ps = clazz._noScript || clazz.prototype._noScript;

			// read parameters (ie, attributes).
			// clsInfo.params lists expected params like {"checked": "boolean", "n": "number"}
			var params = {},
				attributes = node.attributes;
			for(var name in clsInfo.params){
				var item = name in mixin?{value:mixin[name],specified:true}:attributes.getNamedItem(name);
				if(!item || (!item.specified && (!dojo.isIE || name.toLowerCase()!="value"))){ continue; }
				var value = item.value;
				// Deal with IE quirks for 'class' and 'style'
				switch(name){
				case "class":
					value = "className" in mixin?mixin.className:node.className;
					break;
				case "style":
					value = "style" in mixin?mixin.style:(node.style && node.style.cssText); // FIXME: Opera?
				}
				var _type = clsInfo.params[name];
				if(typeof value == "string"){
					params[name] = str2obj(value, _type);
				}else{
					params[name] = value;
				}
			}

			// Process <script type="dojo/*"> script tags
			// <script type="dojo/method" event="foo"> tags are added to params, and passed to
			// the widget on instantiation.
			// <script type="dojo/method"> tags (with no event) are executed after instantiation
			// <script type="dojo/connect" event="foo"> tags are dojo.connected after instantiation
			// note: dojo/* script tags cannot exist in self closing widgets, like <input />
			if(!ps){
				var connects = [],	// functions to connect after instantiation
					calls = [];		// functions to call after instantiation

				d.query("> script[type^='dojo/']", node).orphan().forEach(function(script){
					var event = script.getAttribute("event"),
						type = script.getAttribute("type"),
						nf = d.parser._functionFromScript(script);
					if(event){
						if(type == "dojo/connect"){
							connects.push({event: event, func: nf});
						}else{
							params[event] = nf;
						}
					}else{
						calls.push(nf);
					}
				});
			}

			var markupFactory = clazz["markupFactory"];
			if(!markupFactory && clazz["prototype"]){
				markupFactory = clazz.prototype["markupFactory"];
			}
			// create the instance
			var instance = markupFactory ? markupFactory(params, node, clazz) : new clazz(params, node);
			thelist.push(instance);

			// map it to the JS namespace if that makes sense
			var jsname = node.getAttribute("jsId");
			if(jsname){
				d.setObject(jsname, instance);
			}

			// process connections and startup functions
			if(!ps){
				d.forEach(connects, function(connect){
					d.connect(instance, connect.event, null, connect.func);
				});
				d.forEach(calls, function(func){
					func.call(instance);
				});
			}
		});

		// Call startup on each top level instance if it makes sense (as for
		// widgets).  Parent widgets will recursively call startup on their
		// (non-top level) children
		d.forEach(thelist, function(instance){
			if(	instance  && 
				instance.startup &&
				!instance._started && 
				(!instance.getParent || !instance.getParent())
			){
				instance.startup();
			}
		});
		return thelist;
	};

	this.parse = function(/*DomNode?*/ rootNode){
		// summary:
		//		Search specified node (or root node) recursively for class instances,
		//		and instantiate them Searches for
		//		dojoType="qualified.class.name"
		var list = d.query(this._query, rootNode);
		// go build the object instances
		var instances = this.instantiate(list);
		return instances;
	};
}();

//Register the parser callback. It should be the first callback
//after the a11y test.

(function(){
	var parseRunner = function(){ 
		if(dojo.config["parseOnLoad"] == true){
			dojo.parser.parse(); 
		}
	};

	// FIXME: need to clobber cross-dependency!!
	if(dojo.exists("dijit.wai.onload") && (dijit.wai.onload === dojo._loaders[0])){
		dojo._loaders.splice(1, 0, parseRunner);
	}else{
		dojo._loaders.unshift(parseRunner);
	}
})();

}

if(!dojo._hasResource["dojo.data.util.filter"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.data.util.filter"] = true;
dojo.provide("dojo.data.util.filter");

dojo.data.util.filter.patternToRegExp = function(/*String*/pattern, /*boolean?*/ ignoreCase){
	//	summary:  
	//		Helper function to convert a simple pattern to a regular expression for matching.
	//	description:
	//		Returns a regular expression object that conforms to the defined conversion rules.
	//		For example:  
	//			ca*   -> /^ca.*$/
	//			*ca*  -> /^.*ca.*$/
	//			*c\*a*  -> /^.*c\*a.*$/
	//			*c\*a?*  -> /^.*c\*a..*$/
	//			and so on.
	//
	//	pattern: string
	//		A simple matching pattern to convert that follows basic rules:
	//			* Means match anything, so ca* means match anything starting with ca
	//			? Means match single character.  So, b?b will match to bob and bab, and so on.
	//      	\ is an escape character.  So for example, \* means do not treat * as a match, but literal character *.
	//				To use a \ as a character in the string, it must be escaped.  So in the pattern it should be 
	//				represented by \\ to be treated as an ordinary \ character instead of an escape.
	//
	//	ignoreCase:
	//		An optional flag to indicate if the pattern matching should be treated as case-sensitive or not when comparing
	//		By default, it is assumed case sensitive.

	var rxp = "^";
	var c = null;
	for(var i = 0; i < pattern.length; i++){
		c = pattern.charAt(i);
		switch (c) {
			case '\\':
				rxp += c;
				i++;
				rxp += pattern.charAt(i);
				break;
			case '*':
				rxp += ".*"; break;
			case '?':
				rxp += "."; break;
			case '$':
			case '^':
			case '/':
			case '+':
			case '.':
			case '|':
			case '(':
			case ')':
			case '{':
			case '}':
			case '[':
			case ']':
				rxp += "\\"; //fallthrough
			default:
				rxp += c;
		}
	}
	rxp += "$";
	if(ignoreCase){
		return new RegExp(rxp,"mi"); //RegExp
	}else{
		return new RegExp(rxp,"m"); //RegExp
	}
	
};

}

if(!dojo._hasResource["dojo.data.util.sorter"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.data.util.sorter"] = true;
dojo.provide("dojo.data.util.sorter");

dojo.data.util.sorter.basicComparator = function(	/*anything*/ a, 
													/*anything*/ b){
	//	summary:  
	//		Basic comparision function that compares if an item is greater or less than another item
	//	description:  
	//		returns 1 if a > b, -1 if a < b, 0 if equal.
	//		'null' values (null, undefined) are treated as larger values so that they're pushed to the end of the list.
	//		And compared to each other, null is equivalent to undefined.
	
	//null is a problematic compare, so if null, we set to undefined.
	//Makes the check logic simple, compact, and consistent
	//And (null == undefined) === true, so the check later against null
	//works for undefined and is less bytes.
	var r = -1;
	if(a === null){
		a = undefined;
	}
	if(b === null){
		b = undefined;
	}
	if(a == b){
		r = 0; 
	}else if(a > b || a == null){
		r = 1; 
	}
	return r; //int {-1,0,1}
};

dojo.data.util.sorter.createSortFunction = function(	/* attributes array */sortSpec,
														/*dojo.data.core.Read*/ store){
	//	summary:  
	//		Helper function to generate the sorting function based off the list of sort attributes.
	//	description:  
	//		The sort function creation will look for a property on the store called 'comparatorMap'.  If it exists
	//		it will look in the mapping for comparisons function for the attributes.  If one is found, it will
	//		use it instead of the basic comparator, which is typically used for strings, ints, booleans, and dates.
	//		Returns the sorting function for this particular list of attributes and sorting directions.
	//
	//	sortSpec: array
	//		A JS object that array that defines out what attribute names to sort on and whether it should be descenting or asending.
	//		The objects should be formatted as follows:
	//		{
	//			attribute: "attributeName-string" || attribute,
	//			descending: true|false;   // Default is false.
	//		}
	//	store: object
	//		The datastore object to look up item values from.
	//
	var sortFunctions=[];   

	function createSortFunction(attr, dir){
		return function(itemA, itemB){
			var a = store.getValue(itemA, attr);
			var b = store.getValue(itemB, attr);
			//See if we have a override for an attribute comparison.
			var comparator = null;
			if(store.comparatorMap){
				if(typeof attr !== "string"){
					 attr = store.getIdentity(attr);
				}
				comparator = store.comparatorMap[attr]||dojo.data.util.sorter.basicComparator;
			}
			comparator = comparator||dojo.data.util.sorter.basicComparator; 
			return dir * comparator(a,b); //int
		};
	}
	var sortAttribute;
	for(var i = 0; i < sortSpec.length; i++){
		sortAttribute = sortSpec[i];
		if(sortAttribute.attribute){
			var direction = (sortAttribute.descending) ? -1 : 1;
			sortFunctions.push(createSortFunction(sortAttribute.attribute, direction));
		}
	}

	return function(rowA, rowB){
		var i=0;
		while(i < sortFunctions.length){
			var ret = sortFunctions[i++](rowA, rowB);
			if(ret !== 0){
				return ret;//int
			}
		}
		return 0; //int  
	};  //  Function
};

}

if(!dojo._hasResource["dojo.data.util.simpleFetch"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.data.util.simpleFetch"] = true;
dojo.provide("dojo.data.util.simpleFetch");


dojo.data.util.simpleFetch.fetch = function(/* Object? */ request){
	//	summary:
	//		The simpleFetch mixin is designed to serve as a set of function(s) that can
	//		be mixed into other datastore implementations to accelerate their development.  
	//		The simpleFetch mixin should work well for any datastore that can respond to a _fetchItems() 
	//		call by returning an array of all the found items that matched the query.  The simpleFetch mixin
	//		is not designed to work for datastores that respond to a fetch() call by incrementally
	//		loading items, or sequentially loading partial batches of the result
	//		set.  For datastores that mixin simpleFetch, simpleFetch 
	//		implements a fetch method that automatically handles eight of the fetch()
	//		arguments -- onBegin, onItem, onComplete, onError, start, count, sort and scope
	//		The class mixing in simpleFetch should not implement fetch(),
	//		but should instead implement a _fetchItems() method.  The _fetchItems() 
	//		method takes three arguments, the keywordArgs object that was passed 
	//		to fetch(), a callback function to be called when the result array is
	//		available, and an error callback to be called if something goes wrong.
	//		The _fetchItems() method should ignore any keywordArgs parameters for
	//		start, count, onBegin, onItem, onComplete, onError, sort, and scope.  
	//		The _fetchItems() method needs to correctly handle any other keywordArgs
	//		parameters, including the query parameter and any optional parameters 
	//		(such as includeChildren).  The _fetchItems() method should create an array of 
	//		result items and pass it to the fetchHandler along with the original request object 
	//		-- or, the _fetchItems() method may, if it wants to, create an new request object 
	//		with other specifics about the request that are specific to the datastore and pass 
	//		that as the request object to the handler.
	//
	//		For more information on this specific function, see dojo.data.api.Read.fetch()
	request = request || {};
	if(!request.store){
		request.store = this;
	}
	var self = this;

	var _errorHandler = function(errorData, requestObject){
		if(requestObject.onError){
			var scope = requestObject.scope || dojo.global;
			requestObject.onError.call(scope, errorData, requestObject);
		}
	};

	var _fetchHandler = function(items, requestObject){
		var oldAbortFunction = requestObject.abort || null;
		var aborted = false;

		var startIndex = requestObject.start?requestObject.start:0;
		var endIndex   = (requestObject.count && (requestObject.count !== Infinity))?(startIndex + requestObject.count):items.length;

		requestObject.abort = function(){
			aborted = true;
			if(oldAbortFunction){
				oldAbortFunction.call(requestObject);
			}
		};

		var scope = requestObject.scope || dojo.global;
		if(!requestObject.store){
			requestObject.store = self;
		}
		if(requestObject.onBegin){
			requestObject.onBegin.call(scope, items.length, requestObject);
		}
		if(requestObject.sort){
			items.sort(dojo.data.util.sorter.createSortFunction(requestObject.sort, self));
		}
		if(requestObject.onItem){
			for(var i = startIndex; (i < items.length) && (i < endIndex); ++i){
				var item = items[i];
				if(!aborted){
					requestObject.onItem.call(scope, item, requestObject);
				}
			}
		}
		if(requestObject.onComplete && !aborted){
			var subset = null;
			if (!requestObject.onItem) {
				subset = items.slice(startIndex, endIndex);
			}
			requestObject.onComplete.call(scope, subset, requestObject);   
		}
	};
	this._fetchItems(request, _fetchHandler, _errorHandler);
	return request;	// Object
};

}

if(!dojo._hasResource["dojo.data.ItemFileReadStore"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.data.ItemFileReadStore"] = true;
dojo.provide("dojo.data.ItemFileReadStore");





dojo.declare("dojo.data.ItemFileReadStore", null,{
	//	summary:
	//		The ItemFileReadStore implements the dojo.data.api.Read API and reads
	//		data from JSON files that have contents in this format --
	//		{ items: [
	//			{ name:'Kermit', color:'green', age:12, friends:['Gonzo', {_reference:{name:'Fozzie Bear'}}]},
	//			{ name:'Fozzie Bear', wears:['hat', 'tie']},
	//			{ name:'Miss Piggy', pets:'Foo-Foo'}
	//		]}
	//		Note that it can also contain an 'identifer' property that specified which attribute on the items 
	//		in the array of items that acts as the unique identifier for that item.
	//
	constructor: function(/* Object */ keywordParameters){
		//	summary: constructor
		//	keywordParameters: {url: String}
		//	keywordParameters: {data: jsonObject}
		//	keywordParameters: {typeMap: object)
		//		The structure of the typeMap object is as follows:
		//		{
		//			type0: function || object,
		//			type1: function || object,
		//			...
		//			typeN: function || object
		//		}
		//		Where if it is a function, it is assumed to be an object constructor that takes the 
		//		value of _value as the initialization parameters.  If it is an object, then it is assumed
		//		to be an object of general form:
		//		{
		//			type: function, //constructor.
		//			deserialize:	function(value) //The function that parses the value and constructs the object defined by type appropriately.
		//		}
	
		this._arrayOfAllItems = [];
		this._arrayOfTopLevelItems = [];
		this._loadFinished = false;
		this._jsonFileUrl = keywordParameters.url;
		this._jsonData = keywordParameters.data;
		this._datatypeMap = keywordParameters.typeMap || {};
		if(!this._datatypeMap['Date']){
			//If no default mapping for dates, then set this as default.
			//We use the dojo.date.stamp here because the ISO format is the 'dojo way'
			//of generically representing dates.
			this._datatypeMap['Date'] = {
											type: Date,
											deserialize: function(value){
												return dojo.date.stamp.fromISOString(value);
											}
										};
		}
		this._features = {'dojo.data.api.Read':true, 'dojo.data.api.Identity':true};
		this._itemsByIdentity = null;
		this._storeRefPropName = "_S";  // Default name for the store reference to attach to every item.
		this._itemNumPropName = "_0"; // Default Item Id for isItem to attach to every item.
		this._rootItemPropName = "_RI"; // Default Item Id for isItem to attach to every item.
		this._reverseRefMap = "_RRM"; // Default attribute for constructing a reverse reference map for use with reference integrity
		this._loadInProgress = false;	//Got to track the initial load to prevent duelling loads of the dataset.
		this._queuedFetches = [];
		if(keywordParameters.urlPreventCache !== undefined){
			this.urlPreventCache = keywordParameters.urlPreventCache?true:false;
		}
		if(keywordParameters.clearOnClose){
			this.clearOnClose = true;
		}
	},
	
	url: "",	// use "" rather than undefined for the benefit of the parser (#3539)

	data: null,	// define this so that the parser can populate it

	typeMap: null, //Define so parser can populate.
	
	//Parameter to allow users to specify if a close call should force a reload or not.
	//By default, it retains the old behavior of not clearing if close is called.  But
	//if set true, the store will be reset to default state.  Note that by doing this,
	//all item handles will become invalid and a new fetch must be issued.
	clearOnClose: false,

	//Parameter to allow specifying if preventCache should be passed to the xhrGet call or not when loading data from a url.  
	//Note this does not mean the store calls the server on each fetch, only that the data load has preventCache set as an option.
	//Added for tracker: #6072
	urlPreventCache: false,  

	_assertIsItem: function(/* item */ item){
		//	summary:
		//		This function tests whether the item passed in is indeed an item in the store.
		//	item: 
		//		The item to test for being contained by the store.
		if(!this.isItem(item)){ 
			throw new Error("dojo.data.ItemFileReadStore: Invalid item argument.");
		}
	},

	_assertIsAttribute: function(/* attribute-name-string */ attribute){
		//	summary:
		//		This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.
		//	attribute: 
		//		The attribute to test for being contained by the store.
		if(typeof attribute !== "string"){ 
			throw new Error("dojo.data.ItemFileReadStore: Invalid attribute argument.");
		}
	},

	getValue: function(	/* item */ item, 
						/* attribute-name-string */ attribute, 
						/* value? */ defaultValue){
		//	summary: 
		//		See dojo.data.api.Read.getValue()
		var values = this.getValues(item, attribute);
		return (values.length > 0)?values[0]:defaultValue; // mixed
	},

	getValues: function(/* item */ item, 
						/* attribute-name-string */ attribute){
		//	summary: 
		//		See dojo.data.api.Read.getValues()

		this._assertIsItem(item);
		this._assertIsAttribute(attribute);
		return item[attribute] || []; // Array
	},

	getAttributes: function(/* item */ item){
		//	summary: 
		//		See dojo.data.api.Read.getAttributes()
		this._assertIsItem(item);
		var attributes = [];
		for(var key in item){
			// Save off only the real item attributes, not the special id marks for O(1) isItem.
			if((key !== this._storeRefPropName) && (key !== this._itemNumPropName) && (key !== this._rootItemPropName) && (key !== this._reverseRefMap)){
				attributes.push(key);
			}
		}
		return attributes; // Array
	},

	hasAttribute: function(	/* item */ item,
							/* attribute-name-string */ attribute) {
		//	summary: 
		//		See dojo.data.api.Read.hasAttribute()
		return this.getValues(item, attribute).length > 0;
	},

	containsValue: function(/* item */ item, 
							/* attribute-name-string */ attribute, 
							/* anything */ value){
		//	summary: 
		//		See dojo.data.api.Read.containsValue()
		var regexp = undefined;
		if(typeof value === "string"){
			regexp = dojo.data.util.filter.patternToRegExp(value, false);
		}
		return this._containsValue(item, attribute, value, regexp); //boolean.
	},

	_containsValue: function(	/* item */ item, 
								/* attribute-name-string */ attribute, 
								/* anything */ value,
								/* RegExp?*/ regexp){
		//	summary: 
		//		Internal function for looking at the values contained by the item.
		//	description: 
		//		Internal function for looking at the values contained by the item.  This 
		//		function allows for denoting if the comparison should be case sensitive for
		//		strings or not (for handling filtering cases where string case should not matter)
		//	
		//	item:
		//		The data item to examine for attribute values.
		//	attribute:
		//		The attribute to inspect.
		//	value:	
		//		The value to match.
		//	regexp:
		//		Optional regular expression generated off value if value was of string type to handle wildcarding.
		//		If present and attribute values are string, then it can be used for comparison instead of 'value'
		return dojo.some(this.getValues(item, attribute), function(possibleValue){
			if(possibleValue !== null && !dojo.isObject(possibleValue) && regexp){
				if(possibleValue.toString().match(regexp)){
					return true; // Boolean
				}
			}else if(value === possibleValue){
				return true; // Boolean
			}
		});
	},

	isItem: function(/* anything */ something){
		//	summary: 
		//		See dojo.data.api.Read.isItem()
		if(something && something[this._storeRefPropName] === this){
			if(this._arrayOfAllItems[something[this._itemNumPropName]] === something){
				return true;
			}
		}
		return false; // Boolean
	},

	isItemLoaded: function(/* anything */ something){
		//	summary: 
		//		See dojo.data.api.Read.isItemLoaded()
		return this.isItem(something); //boolean
	},

	loadItem: function(/* object */ keywordArgs){
		//	summary: 
		//		See dojo.data.api.Read.loadItem()
		this._assertIsItem(keywordArgs.item);
	},

	getFeatures: function(){
		//	summary: 
		//		See dojo.data.api.Read.getFeatures()
		return this._features; //Object
	},

	getLabel: function(/* item */ item){
		//	summary: 
		//		See dojo.data.api.Read.getLabel()
		if(this._labelAttr && this.isItem(item)){
			return this.getValue(item,this._labelAttr); //String
		}
		return undefined; //undefined
	},

	getLabelAttributes: function(/* item */ item){
		//	summary: 
		//		See dojo.data.api.Read.getLabelAttributes()
		if(this._labelAttr){
			return [this._labelAttr]; //array
		}
		return null; //null
	},

	_fetchItems: function(	/* Object */ keywordArgs, 
							/* Function */ findCallback, 
							/* Function */ errorCallback){
		//	summary: 
		//		See dojo.data.util.simpleFetch.fetch()
		var self = this;
		var filter = function(requestArgs, arrayOfItems){
			var items = [];
			var i, key;
			if(requestArgs.query){
				var value;
				var ignoreCase = requestArgs.queryOptions ? requestArgs.queryOptions.ignoreCase : false; 

				//See if there are any string values that can be regexp parsed first to avoid multiple regexp gens on the
				//same value for each item examined.  Much more efficient.
				var regexpList = {};
				for(key in requestArgs.query){
					value = requestArgs.query[key];
					if(typeof value === "string"){
						regexpList[key] = dojo.data.util.filter.patternToRegExp(value, ignoreCase);
					}
				}

				for(i = 0; i < arrayOfItems.length; ++i){
					var match = true;
					var candidateItem = arrayOfItems[i];
					if(candidateItem === null){
						match = false;
					}else{
						for(key in requestArgs.query) {
							value = requestArgs.query[key];
							if (!self._containsValue(candidateItem, key, value, regexpList[key])){
								match = false;
							}
						}
					}
					if(match){
						items.push(candidateItem);
					}
				}
				findCallback(items, requestArgs);
			}else{
				// We want a copy to pass back in case the parent wishes to sort the array. 
				// We shouldn't allow resort of the internal list, so that multiple callers 
				// can get lists and sort without affecting each other.  We also need to
				// filter out any null values that have been left as a result of deleteItem()
				// calls in ItemFileWriteStore.
				for(i = 0; i < arrayOfItems.length; ++i){
					var item = arrayOfItems[i];
					if(item !== null){
						items.push(item);
					}
				}
				findCallback(items, requestArgs);
			}
		};

		if(this._loadFinished){
			filter(keywordArgs, this._getItemsArray(keywordArgs.queryOptions));
		}else{

			if(this._jsonFileUrl){
				//If fetches come in before the loading has finished, but while
				//a load is in progress, we have to defer the fetching to be 
				//invoked in the callback.
				if(this._loadInProgress){
					this._queuedFetches.push({args: keywordArgs, filter: filter});
				}else{
					this._loadInProgress = true;
					var getArgs = {
							url: self._jsonFileUrl, 
							handleAs: "json-comment-optional",
							preventCache: this.urlPreventCache
						};
					var getHandler = dojo.xhrGet(getArgs);
					getHandler.addCallback(function(data){
						try{
							self._getItemsFromLoadedData(data);
							self._loadFinished = true;
							self._loadInProgress = false;
							
							filter(keywordArgs, self._getItemsArray(keywordArgs.queryOptions));
							self._handleQueuedFetches();
						}catch(e){
							self._loadFinished = true;
							self._loadInProgress = false;
							errorCallback(e, keywordArgs);
						}
					});
					getHandler.addErrback(function(error){
						self._loadInProgress = false;
						errorCallback(error, keywordArgs);
					});

					//Wire up the cancel to abort of the request
					//This call cancel on the deferred if it hasn't been called
					//yet and then will chain to the simple abort of the
					//simpleFetch keywordArgs
					var oldAbort = null;
					if(keywordArgs.abort){
						oldAbort = keywordArgs.abort;
					}
					keywordArgs.abort = function(){
						var df = getHandler;
						if (df && df.fired === -1){
							df.cancel();
							df = null;
						}
						if(oldAbort){
							oldAbort.call(keywordArgs);
						}
					};
				}
			}else if(this._jsonData){
				try{
					this._loadFinished = true;
					this._getItemsFromLoadedData(this._jsonData);
					this._jsonData = null;
					filter(keywordArgs, this._getItemsArray(keywordArgs.queryOptions));
				}catch(e){
					errorCallback(e, keywordArgs);
				}
			}else{
				errorCallback(new Error("dojo.data.ItemFileReadStore: No JSON source data was provided as either URL or a nested Javascript object."), keywordArgs);
			}
		}
	},

	_handleQueuedFetches: function(){
		//	summary: 
		//		Internal function to execute delayed request in the store.
		//Execute any deferred fetches now.
		if (this._queuedFetches.length > 0) {
			for(var i = 0; i < this._queuedFetches.length; i++){
				var fData = this._queuedFetches[i];
				var delayedQuery = fData.args;
				var delayedFilter = fData.filter;
				if(delayedFilter){
					delayedFilter(delayedQuery, this._getItemsArray(delayedQuery.queryOptions)); 
				}else{
					this.fetchItemByIdentity(delayedQuery);
				}
			}
			this._queuedFetches = [];
		}
	},

	_getItemsArray: function(/*object?*/queryOptions){
		//	summary: 
		//		Internal function to determine which list of items to search over.
		//	queryOptions: The query options parameter, if any.
		if(queryOptions && queryOptions.deep) {
			return this._arrayOfAllItems; 
		}
		return this._arrayOfTopLevelItems;
	},

	close: function(/*dojo.data.api.Request || keywordArgs || null */ request){
		 //	summary: 
		 //		See dojo.data.api.Read.close()
		 if(this.clearOnClose && (this._jsonFileUrl !== "")){
			 //Reset all internalsback to default state.  This will force a reload
			 //on next fetch, but only if the data came from a url.  Passed in data
			 //means it should not clear the data.
			 this._arrayOfAllItems = [];
			 this._arrayOfTopLevelItems = [];
			 this._loadFinished = false;
			 this._itemsByIdentity = null;
			 this._loadInProgress = false;
			 this._queuedFetches = [];
		 }
	},

	_getItemsFromLoadedData: function(/* Object */ dataObject){
		//	summary:
		//		Function to parse the loaded data into item format and build the internal items array.
		//	description:
		//		Function to parse the loaded data into item format and build the internal items array.
		//
		//	dataObject:
		//		The JS data object containing the raw data to convery into item format.
		//
		// 	returns: array
		//		Array of items in store item format.
		
		// First, we define a couple little utility functions...
		var addingArrays = false;
		
		function valueIsAnItem(/* anything */ aValue){
			// summary:
			//		Given any sort of value that could be in the raw json data,
			//		return true if we should interpret the value as being an
			//		item itself, rather than a literal value or a reference.
			// example:
			// 	|	false == valueIsAnItem("Kermit");
			// 	|	false == valueIsAnItem(42);
			// 	|	false == valueIsAnItem(new Date());
			// 	|	false == valueIsAnItem({_type:'Date', _value:'May 14, 1802'});
			// 	|	false == valueIsAnItem({_reference:'Kermit'});
			// 	|	true == valueIsAnItem({name:'Kermit', color:'green'});
			// 	|	true == valueIsAnItem({iggy:'pop'});
			// 	|	true == valueIsAnItem({foo:42});
			var isItem = (
				(aValue !== null) &&
				(typeof aValue === "object") &&
				(!dojo.isArray(aValue) || addingArrays) &&
				(!dojo.isFunction(aValue)) &&
				(aValue.constructor == Object || dojo.isArray(aValue)) &&
				(typeof aValue._reference === "undefined") && 
				(typeof aValue._type === "undefined") && 
				(typeof aValue._value === "undefined")
			);
			return isItem;
		}
		
		var self = this;
		function addItemAndSubItemsToArrayOfAllItems(/* Item */ anItem){
			self._arrayOfAllItems.push(anItem);
			for(var attribute in anItem){
				var valueForAttribute = anItem[attribute];
				if(valueForAttribute){
					if(dojo.isArray(valueForAttribute)){
						var valueArray = valueForAttribute;
						for(var k = 0; k < valueArray.length; ++k){
							var singleValue = valueArray[k];
							if(valueIsAnItem(singleValue)){
								addItemAndSubItemsToArrayOfAllItems(singleValue);
							}
						}
					}else{
						if(valueIsAnItem(valueForAttribute)){
							addItemAndSubItemsToArrayOfAllItems(valueForAttribute);
						}
					}
				}
			}
		}

		this._labelAttr = dataObject.label;

		// We need to do some transformations to convert the data structure
		// that we read from the file into a format that will be convenient
		// to work with in memory.

		// Step 1: Walk through the object hierarchy and build a list of all items
		var i;
		var item;
		this._arrayOfAllItems = [];
		this._arrayOfTopLevelItems = dataObject.items;

		for(i = 0; i < this._arrayOfTopLevelItems.length; ++i){
			item = this._arrayOfTopLevelItems[i];
			if(dojo.isArray(item)){
				addingArrays = true;
			}
			addItemAndSubItemsToArrayOfAllItems(item);
			item[this._rootItemPropName]=true;
		}

		// Step 2: Walk through all the attribute values of all the items, 
		// and replace single values with arrays.  For example, we change this:
		//		{ name:'Miss Piggy', pets:'Foo-Foo'}
		// into this:
		//		{ name:['Miss Piggy'], pets:['Foo-Foo']}
		// 
		// We also store the attribute names so we can validate our store  
		// reference and item id special properties for the O(1) isItem
		var allAttributeNames = {};
		var key;

		for(i = 0; i < this._arrayOfAllItems.length; ++i){
			item = this._arrayOfAllItems[i];
			for(key in item){
				if (key !== this._rootItemPropName)
				{
					var value = item[key];
					if(value !== null){
						if(!dojo.isArray(value)){
							item[key] = [value];
						}
					}else{
						item[key] = [null];
					}
				}
				allAttributeNames[key]=key;
			}
		}

		// Step 3: Build unique property names to use for the _storeRefPropName and _itemNumPropName
		// This should go really fast, it will generally never even run the loop.
		while(allAttributeNames[this._storeRefPropName]){
			this._storeRefPropName += "_";
		}
		while(allAttributeNames[this._itemNumPropName]){
			this._itemNumPropName += "_";
		}
		while(allAttributeNames[this._reverseRefMap]){
			this._reverseRefMap += "_";
		}

		// Step 4: Some data files specify an optional 'identifier', which is 
		// the name of an attribute that holds the identity of each item. 
		// If this data file specified an identifier attribute, then build a 
		// hash table of items keyed by the identity of the items.
		var arrayOfValues;

		var identifier = dataObject.identifier;
		if(identifier){
			this._itemsByIdentity = {};
			this._features['dojo.data.api.Identity'] = identifier;
			for(i = 0; i < this._arrayOfAllItems.length; ++i){
				item = this._arrayOfAllItems[i];
				arrayOfValues = item[identifier];
				var identity = arrayOfValues[0];
				if(!this._itemsByIdentity[identity]){
					this._itemsByIdentity[identity] = item;
				}else{
					if(this._jsonFileUrl){
						throw new Error("dojo.data.ItemFileReadStore:  The json data as specified by: [" + this._jsonFileUrl + "] is malformed.  Items within the list have identifier: [" + identifier + "].  Value collided: [" + identity + "]");
					}else if(this._jsonData){
						throw new Error("dojo.data.ItemFileReadStore:  The json data provided by the creation arguments is malformed.  Items within the list have identifier: [" + identifier + "].  Value collided: [" + identity + "]");
					}
				}
			}
		}else{
			this._features['dojo.data.api.Identity'] = Number;
		}

		// Step 5: Walk through all the items, and set each item's properties 
		// for _storeRefPropName and _itemNumPropName, so that store.isItem() will return true.
		for(i = 0; i < this._arrayOfAllItems.length; ++i){
			item = this._arrayOfAllItems[i];
			item[this._storeRefPropName] = this;
			item[this._itemNumPropName] = i;
		}

		// Step 6: We walk through all the attribute values of all the items,
		// looking for type/value literals and item-references.
		//
		// We replace item-references with pointers to items.  For example, we change:
		//		{ name:['Kermit'], friends:[{_reference:{name:'Miss Piggy'}}] }
		// into this:
		//		{ name:['Kermit'], friends:[miss_piggy] } 
		// (where miss_piggy is the object representing the 'Miss Piggy' item).
		//
		// We replace type/value pairs with typed-literals.  For example, we change:
		//		{ name:['Nelson Mandela'], born:[{_type:'Date', _value:'July 18, 1918'}] }
		// into this:
		//		{ name:['Kermit'], born:(new Date('July 18, 1918')) } 
		//
		// We also generate the associate map for all items for the O(1) isItem function.
		for(i = 0; i < this._arrayOfAllItems.length; ++i){
			item = this._arrayOfAllItems[i]; // example: { name:['Kermit'], friends:[{_reference:{name:'Miss Piggy'}}] }
			for(key in item){
				arrayOfValues = item[key]; // example: [{_reference:{name:'Miss Piggy'}}]
				for(var j = 0; j < arrayOfValues.length; ++j) {
					value = arrayOfValues[j]; // example: {_reference:{name:'Miss Piggy'}}
					if(value !== null && typeof value == "object"){
						if(value._type && value._value){
							var type = value._type; // examples: 'Date', 'Color', or 'ComplexNumber'
							var mappingObj = this._datatypeMap[type]; // examples: Date, dojo.Color, foo.math.ComplexNumber, {type: dojo.Color, deserialize(value){ return new dojo.Color(value)}}
							if(!mappingObj){ 
								throw new Error("dojo.data.ItemFileReadStore: in the typeMap constructor arg, no object class was specified for the datatype '" + type + "'");
							}else if(dojo.isFunction(mappingObj)){
								arrayOfValues[j] = new mappingObj(value._value);
							}else if(dojo.isFunction(mappingObj.deserialize)){
								arrayOfValues[j] = mappingObj.deserialize(value._value);
							}else{
								throw new Error("dojo.data.ItemFileReadStore: Value provided in typeMap was neither a constructor, nor a an object with a deserialize function");
							}
						}
						if(value._reference){
							var referenceDescription = value._reference; // example: {name:'Miss Piggy'}
							if(!dojo.isObject(referenceDescription)){
								// example: 'Miss Piggy'
								// from an item like: { name:['Kermit'], friends:[{_reference:'Miss Piggy'}]}
								arrayOfValues[j] = this._itemsByIdentity[referenceDescription];
							}else{
								// example: {name:'Miss Piggy'}
								// from an item like: { name:['Kermit'], friends:[{_reference:{name:'Miss Piggy'}}] }
								for(var k = 0; k < this._arrayOfAllItems.length; ++k){
									var candidateItem = this._arrayOfAllItems[k];
									var found = true;
									for(var refKey in referenceDescription){
										if(candidateItem[refKey] != referenceDescription[refKey]){ 
											found = false; 
										}
									}
									if(found){ 
										arrayOfValues[j] = candidateItem; 
									}
								}
							}
							if(this.referenceIntegrity){
								var refItem = arrayOfValues[j];
								if(this.isItem(refItem)){
									this._addReferenceToMap(refItem, item, key);
								}
							}
						}else if(this.isItem(value)){
							//It's a child item (not one referenced through _reference).  
							//We need to treat this as a referenced item, so it can be cleaned up
							//in a write store easily.
							if(this.referenceIntegrity){
								this._addReferenceToMap(value, item, key);
							}
						}
					}
				}
			}
		}
	},

	_addReferenceToMap: function(/*item*/ refItem, /*item*/ parentItem, /*string*/ attribute){
		 //	summary:
		 //		Method to add an reference map entry for an item and attribute.
		 //	description:
		 //		Method to add an reference map entry for an item and attribute. 		 //
		 //	refItem:
		 //		The item that is referenced.
		 //	parentItem:
		 //		The item that holds the new reference to refItem.
		 //	attribute:
		 //		The attribute on parentItem that contains the new reference.
		 
		 //Stub function, does nothing.  Real processing is in ItemFileWriteStore.
	},

	getIdentity: function(/* item */ item){
		//	summary: 
		//		See dojo.data.api.Identity.getIdentity()
		var identifier = this._features['dojo.data.api.Identity'];
		if(identifier === Number){
			return item[this._itemNumPropName]; // Number
		}else{
			var arrayOfValues = item[identifier];
			if(arrayOfValues){
				return arrayOfValues[0]; // Object || String
			}
		}
		return null; // null
	},

	fetchItemByIdentity: function(/* Object */ keywordArgs){
		//	summary: 
		//		See dojo.data.api.Identity.fetchItemByIdentity()

		// Hasn't loaded yet, we have to trigger the load.
		var item;
		var scope;
		if(!this._loadFinished){
			var self = this;
			if(this._jsonFileUrl){

				if(this._loadInProgress){
					this._queuedFetches.push({args: keywordArgs});
				}else{
					this._loadInProgress = true;
					var getArgs = {
							url: self._jsonFileUrl, 
							handleAs: "json-comment-optional",
							preventCache: this.urlPreventCache
					};
					var getHandler = dojo.xhrGet(getArgs);
					getHandler.addCallback(function(data){
						var scope =  keywordArgs.scope?keywordArgs.scope:dojo.global;
						try{
							self._getItemsFromLoadedData(data);
							self._loadFinished = true;
							self._loadInProgress = false;
							item = self._getItemByIdentity(keywordArgs.identity);
							if(keywordArgs.onItem){
								keywordArgs.onItem.call(scope, item);
							}
							self._handleQueuedFetches();
						}catch(error){
							self._loadInProgress = false;
							if(keywordArgs.onError){
								keywordArgs.onError.call(scope, error);
							}
						}
					});
					getHandler.addErrback(function(error){
						self._loadInProgress = false;
						if(keywordArgs.onError){
							var scope =  keywordArgs.scope?keywordArgs.scope:dojo.global;
							keywordArgs.onError.call(scope, error);
						}
					});
				}

			}else if(this._jsonData){
				// Passed in data, no need to xhr.
				self._getItemsFromLoadedData(self._jsonData);
				self._jsonData = null;
				self._loadFinished = true;
				item = self._getItemByIdentity(keywordArgs.identity);
				if(keywordArgs.onItem){
					scope =  keywordArgs.scope?keywordArgs.scope:dojo.global;
					keywordArgs.onItem.call(scope, item);
				}
			} 
		}else{
			// Already loaded.  We can just look it up and call back.
			item = this._getItemByIdentity(keywordArgs.identity);
			if(keywordArgs.onItem){
				scope =  keywordArgs.scope?keywordArgs.scope:dojo.global;
				keywordArgs.onItem.call(scope, item);
			}
		}
	},

	_getItemByIdentity: function(/* Object */ identity){
		//	summary:
		//		Internal function to look an item up by its identity map.
		var item = null;
		if(this._itemsByIdentity){
			item = this._itemsByIdentity[identity];
		}else{
			item = this._arrayOfAllItems[identity];
		}
		if(item === undefined){
			item = null;
		}
		return item; // Object
	},

	getIdentityAttributes: function(/* item */ item){
		//	summary: 
		//		See dojo.data.api.Identity.getIdentifierAttributes()
		 
		var identifier = this._features['dojo.data.api.Identity'];
		if(identifier === Number){
			// If (identifier === Number) it means getIdentity() just returns
			// an integer item-number for each item.  The dojo.data.api.Identity
			// spec says we need to return null if the identity is not composed 
			// of attributes 
			return null; // null
		}else{
			return [identifier]; // Array
		}
	},
	
	_forceLoad: function(){
		//	summary: 
		//		Internal function to force a load of the store if it hasn't occurred yet.  This is required
		//		for specific functions to work properly.  
		var self = this;
		if(this._jsonFileUrl){
				var getArgs = {
					url: self._jsonFileUrl, 
					handleAs: "json-comment-optional",
					preventCache: this.urlPreventCache,
					sync: true
				};
			var getHandler = dojo.xhrGet(getArgs);
			getHandler.addCallback(function(data){
				try{
					//Check to be sure there wasn't another load going on concurrently 
					//So we don't clobber data that comes in on it.  If there is a load going on
					//then do not save this data.  It will potentially clobber current data.
					//We mainly wanted to sync/wait here.
					//TODO:  Revisit the loading scheme of this store to improve multi-initial
					//request handling.
					if(self._loadInProgress !== true && !self._loadFinished){
						self._getItemsFromLoadedData(data);
						self._loadFinished = true;
					}else if(self._loadInProgress){
						//Okay, we hit an error state we can't recover from.  A forced load occurred
						//while an async load was occurring.  Since we cannot block at this point, the best
						//that can be managed is to throw an error.
						throw new Error("dojo.data.ItemFileReadStore:  Unable to perform a synchronous load, an async load is in progress."); 
					}
				}catch(e){
					console.log(e);
					throw e;
				}
			});
			getHandler.addErrback(function(error){
				throw error;
			});
		}else if(this._jsonData){
			self._getItemsFromLoadedData(self._jsonData);
			self._jsonData = null;
			self._loadFinished = true;
		} 
	}
});
//Mix in the simple fetch implementation to this class.
dojo.extend(dojo.data.ItemFileReadStore,dojo.data.util.simpleFetch);

}

if(!dojo._hasResource["dojo.data.ItemFileWriteStore"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.data.ItemFileWriteStore"] = true;
dojo.provide("dojo.data.ItemFileWriteStore");


dojo.declare("dojo.data.ItemFileWriteStore", dojo.data.ItemFileReadStore, {
	constructor: function(/* object */ keywordParameters){
		//	keywordParameters: {typeMap: object)
		//		The structure of the typeMap object is as follows:
		//		{
		//			type0: function || object,
		//			type1: function || object,
		//			...
		//			typeN: function || object
		//		}
		//		Where if it is a function, it is assumed to be an object constructor that takes the 
		//		value of _value as the initialization parameters.  It is serialized assuming object.toString()
		//		serialization.  If it is an object, then it is assumed
		//		to be an object of general form:
		//		{
		//			type: function, //constructor.
		//			deserialize:	function(value) //The function that parses the value and constructs the object defined by type appropriately.
		//			serialize:	function(object) //The function that converts the object back into the proper file format form.
		//		}

		// ItemFileWriteStore extends ItemFileReadStore to implement these additional dojo.data APIs
		this._features['dojo.data.api.Write'] = true;
		this._features['dojo.data.api.Notification'] = true;
		
		// For keeping track of changes so that we can implement isDirty and revert
		this._pending = {
			_newItems:{}, 
			_modifiedItems:{}, 
			_deletedItems:{}
		};

		if(!this._datatypeMap['Date'].serialize){
			this._datatypeMap['Date'].serialize = function(obj){
				return dojo.date.stamp.toISOString(obj, {zulu:true});
			};
		}
		//Disable only if explicitly set to false.
		if(keywordParameters && (keywordParameters.referenceIntegrity === false)){
			this.referenceIntegrity = false;
		}

		// this._saveInProgress is set to true, briefly, from when save() is first called to when it completes
		this._saveInProgress = false;
	},

	referenceIntegrity: true,  //Flag that defaultly enabled reference integrity tracking.  This way it can also be disabled pogrammatially or declaratively.

	_assert: function(/* boolean */ condition){
		if(!condition) {
			throw new Error("assertion failed in ItemFileWriteStore");
		}
	},

	_getIdentifierAttribute: function(){
		var identifierAttribute = this.getFeatures()['dojo.data.api.Identity'];
		// this._assert((identifierAttribute === Number) || (dojo.isString(identifierAttribute)));
		return identifierAttribute;
	},
	
	
/* dojo.data.api.Write */

	newItem: function(/* Object? */ keywordArgs, /* Object? */ parentInfo){
		// summary: See dojo.data.api.Write.newItem()

		this._assert(!this._saveInProgress);

		if (!this._loadFinished){
			// We need to do this here so that we'll be able to find out what
			// identifierAttribute was specified in the data file.
			this._forceLoad();
		}

		if(typeof keywordArgs != "object" && typeof keywordArgs != "undefined"){
			throw new Error("newItem() was passed something other than an object");
		}
		var newIdentity = null;
		var identifierAttribute = this._getIdentifierAttribute();
		if(identifierAttribute === Number){
			newIdentity = this._arrayOfAllItems.length;
		}else{
			newIdentity = keywordArgs[identifierAttribute];
			if (typeof newIdentity === "undefined"){
				throw new Error("newItem() was not passed an identity for the new item");
			}
			if (dojo.isArray(newIdentity)){
				throw new Error("newItem() was not passed an single-valued identity");
			}
		}
		
		// make sure this identity is not already in use by another item, if identifiers were 
		// defined in the file.  Otherwise it would be the item count, 
		// which should always be unique in this case.
		if(this._itemsByIdentity){
			this._assert(typeof this._itemsByIdentity[newIdentity] === "undefined");
		}
		this._assert(typeof this._pending._newItems[newIdentity] === "undefined");
		this._assert(typeof this._pending._deletedItems[newIdentity] === "undefined");
		
		var newItem = {};
		newItem[this._storeRefPropName] = this;		
		newItem[this._itemNumPropName] = this._arrayOfAllItems.length;
		if(this._itemsByIdentity){
			this._itemsByIdentity[newIdentity] = newItem;
			//We have to set the identifier now, otherwise we can't look it
			//up at calls to setValueorValues in parentInfo handling.
			newItem[identifierAttribute] = [newIdentity];
		}
		this._arrayOfAllItems.push(newItem);

		//We need to construct some data for the onNew call too...
		var pInfo = null;
		
		// Now we need to check to see where we want to assign this thingm if any.
		if(parentInfo && parentInfo.parent && parentInfo.attribute){
			pInfo = {
				item: parentInfo.parent,
				attribute: parentInfo.attribute,
				oldValue: undefined
			};

			//See if it is multi-valued or not and handle appropriately
			//Generally, all attributes are multi-valued for this store
			//So, we only need to append if there are already values present.
			var values = this.getValues(parentInfo.parent, parentInfo.attribute);
			if(values && values.length > 0){
				var tempValues = values.slice(0, values.length);
				if(values.length === 1){
					pInfo.oldValue = values[0];
				}else{
					pInfo.oldValue = values.slice(0, values.length);
				}
				tempValues.push(newItem);
				this._setValueOrValues(parentInfo.parent, parentInfo.attribute, tempValues, false);
				pInfo.newValue = this.getValues(parentInfo.parent, parentInfo.attribute);
			}else{
				this._setValueOrValues(parentInfo.parent, parentInfo.attribute, newItem, false);
				pInfo.newValue = newItem;
			}
		}else{
			//Toplevel item, add to both top list as well as all list.
			newItem[this._rootItemPropName]=true;
			this._arrayOfTopLevelItems.push(newItem);
		}
		
		this._pending._newItems[newIdentity] = newItem;
		
		//Clone over the properties to the new item
		for(var key in keywordArgs){
			if(key === this._storeRefPropName || key === this._itemNumPropName){
				// Bummer, the user is trying to do something like
				// newItem({_S:"foo"}).  Unfortunately, our superclass,
				// ItemFileReadStore, is already using _S in each of our items
				// to hold private info.  To avoid a naming collision, we 
				// need to move all our private info to some other property 
				// of all the items/objects.  So, we need to iterate over all
				// the items and do something like: 
				//    item.__S = item._S;
				//    item._S = undefined;
				// But first we have to make sure the new "__S" variable is 
				// not in use, which means we have to iterate over all the 
				// items checking for that.
				throw new Error("encountered bug in ItemFileWriteStore.newItem");
			}
			var value = keywordArgs[key];
			if(!dojo.isArray(value)){
				value = [value];
			}
			newItem[key] = value;
			if(this.referenceIntegrity){
				for(var i = 0; i < value.length; i++){
					var val = value[i];
					if(this.isItem(val)){
						this._addReferenceToMap(val, newItem, key);
					}
				}
			}
		}
		this.onNew(newItem, pInfo); // dojo.data.api.Notification call
		return newItem; // item
	},
	
	_removeArrayElement: function(/* Array */ array, /* anything */ element){
		var index = dojo.indexOf(array, element);
		if (index != -1){
			array.splice(index, 1);
			return true;
		}
		return false;
	},
	
	deleteItem: function(/* item */ item){
		// summary: See dojo.data.api.Write.deleteItem()
		this._assert(!this._saveInProgress);
		this._assertIsItem(item);

		// Remove this item from the _arrayOfAllItems, but leave a null value in place
		// of the item, so as not to change the length of the array, so that in newItem() 
		// we can still safely do: newIdentity = this._arrayOfAllItems.length;
		var indexInArrayOfAllItems = item[this._itemNumPropName];
		var identity = this.getIdentity(item);

		//If we have reference integrity on, we need to do reference cleanup for the deleted item
		if(this.referenceIntegrity){
			//First scan all the attributes of this items for references and clean them up in the map 
			//As this item is going away, no need to track its references anymore.

			//Get the attributes list before we generate the backup so it 
			//doesn't pollute the attributes list.
			var attributes = this.getAttributes(item);

			//Backup the map, we'll have to restore it potentially, in a revert.
			if(item[this._reverseRefMap]){
				item["backup_" + this._reverseRefMap] = dojo.clone(item[this._reverseRefMap]);
			}
			
			//TODO:  This causes a reversion problem.  This list won't be restored on revert since it is
			//attached to the 'value'. item, not ours.  Need to back tese up somehow too.
			//Maybe build a map of the backup of the entries and attach it to the deleted item to be restored
			//later.  Or just record them and call _addReferenceToMap on them in revert.
			dojo.forEach(attributes, function(attribute){
				dojo.forEach(this.getValues(item, attribute), function(value){
					if(this.isItem(value)){
						//We have to back up all the references we had to others so they can be restored on a revert.
						if(!item["backupRefs_" + this._reverseRefMap]){
							item["backupRefs_" + this._reverseRefMap] = [];
						}
						item["backupRefs_" + this._reverseRefMap].push({id: this.getIdentity(value), attr: attribute});
						this._removeReferenceFromMap(value, item, attribute);
					}
				}, this);
			}, this);

			//Next, see if we have references to this item, if we do, we have to clean them up too.
			var references = item[this._reverseRefMap];
			if(references){
				//Look through all the items noted as references to clean them up.
				for(var itemId in references){
					var containingItem = null;
					if(this._itemsByIdentity){
						containingItem = this._itemsByIdentity[itemId];
					}else{
						containingItem = this._arrayOfAllItems[itemId];
					}
					//We have a reference to a containing item, now we have to process the
					//attributes and clear all references to the item being deleted.
					if(containingItem){
						for(var attribute in references[itemId]){
							var oldValues = this.getValues(containingItem, attribute) || [];
							var newValues = dojo.filter(oldValues, function(possibleItem){
							   return !(this.isItem(possibleItem) && this.getIdentity(possibleItem) == identity);
							}, this);
							//Remove the note of the reference to the item and set the values on the modified attribute.
							this._removeReferenceFromMap(item, containingItem, attribute); 
							if(newValues.length < oldValues.length){
								this._setValueOrValues(containingItem, attribute, newValues, true);
							}
						}
					}
				}
			}
		}

		this._arrayOfAllItems[indexInArrayOfAllItems] = null;

		item[this._storeRefPropName] = null;
		if(this._itemsByIdentity){
			delete this._itemsByIdentity[identity];
		}
		this._pending._deletedItems[identity] = item;
		
		//Remove from the toplevel items, if necessary...
		if(item[this._rootItemPropName]){
			this._removeArrayElement(this._arrayOfTopLevelItems, item);
		}
		this.onDelete(item); // dojo.data.api.Notification call
		return true;
	},

	setValue: function(/* item */ item, /* attribute-name-string */ attribute, /* almost anything */ value){
		// summary: See dojo.data.api.Write.set()
		return this._setValueOrValues(item, attribute, value, true); // boolean
	},
	
	setValues: function(/* item */ item, /* attribute-name-string */ attribute, /* array */ values){
		// summary: See dojo.data.api.Write.setValues()
		return this._setValueOrValues(item, attribute, values, true); // boolean
	},
	
	unsetAttribute: function(/* item */ item, /* attribute-name-string */ attribute){
		// summary: See dojo.data.api.Write.unsetAttribute()
		return this._setValueOrValues(item, attribute, [], true);
	},
	
	_setValueOrValues: function(/* item */ item, /* attribute-name-string */ attribute, /* anything */ newValueOrValues, /*boolean?*/ callOnSet){
		this._assert(!this._saveInProgress);
		
		// Check for valid arguments
		this._assertIsItem(item);
		this._assert(dojo.isString(attribute));
		this._assert(typeof newValueOrValues !== "undefined");

		// Make sure the user isn't trying to change the item's identity
		var identifierAttribute = this._getIdentifierAttribute();
		if(attribute == identifierAttribute){
			throw new Error("ItemFileWriteStore does not have support for changing the value of an item's identifier.");
		}

		// To implement the Notification API, we need to make a note of what
		// the old attribute value was, so that we can pass that info when
		// we call the onSet method.
		var oldValueOrValues = this._getValueOrValues(item, attribute);

		var identity = this.getIdentity(item);
		if(!this._pending._modifiedItems[identity]){
			// Before we actually change the item, we make a copy of it to 
			// record the original state, so that we'll be able to revert if 
			// the revert method gets called.  If the item has already been
			// modified then there's no need to do this now, since we already
			// have a record of the original state.						
			var copyOfItemState = {};
			for(var key in item){
				if((key === this._storeRefPropName) || (key === this._itemNumPropName) || (key === this._rootItemPropName)){
					copyOfItemState[key] = item[key];
				}else if(key === this._reverseRefMap){
					copyOfItemState[key] = dojo.clone(item[key]);
				}else{
					copyOfItemState[key] = item[key].slice(0, item[key].length);
				}
			}
			// Now mark the item as dirty, and save the copy of the original state
			this._pending._modifiedItems[identity] = copyOfItemState;
		}
		
		// Okay, now we can actually change this attribute on the item
		var success = false;
		
		if(dojo.isArray(newValueOrValues) && newValueOrValues.length === 0){
			
			// If we were passed an empty array as the value, that counts
			// as "unsetting" the attribute, so we need to remove this 
			// attribute from the item.
			success = delete item[attribute];
			newValueOrValues = undefined; // used in the onSet Notification call below

			if(this.referenceIntegrity && oldValueOrValues){
				var oldValues = oldValueOrValues;
				if (!dojo.isArray(oldValues)){
					oldValues = [oldValues];
				}
				for(var i = 0; i < oldValues.length; i++){
					var value = oldValues[i];
					if(this.isItem(value)){
						this._removeReferenceFromMap(value, item, attribute);
					}
				}
			}
		}else{
			var newValueArray;
			if(dojo.isArray(newValueOrValues)){
				var newValues = newValueOrValues;
				// Unfortunately, it's not safe to just do this:
				//    newValueArray = newValues;
				// Instead, we need to copy the array, which slice() does very nicely.
				// This is so that our internal data structure won't  
				// get corrupted if the user mucks with the values array *after*
				// calling setValues().
				newValueArray = newValueOrValues.slice(0, newValueOrValues.length);
			}else{
				newValueArray = [newValueOrValues];
			}

			//We need to handle reference integrity if this is on. 
			//In the case of set, we need to see if references were added or removed
			//and update the reference tracking map accordingly.
			if(this.referenceIntegrity){
				if(oldValueOrValues){
					var oldValues = oldValueOrValues;
					if(!dojo.isArray(oldValues)){
						oldValues = [oldValues];
					}
					//Use an associative map to determine what was added/removed from the list.
					//Should be O(n) performant.  First look at all the old values and make a list of them
					//Then for any item not in the old list, we add it.  If it was already present, we remove it.
					//Then we pass over the map and any references left it it need to be removed (IE, no match in
					//the new values list).
					var map = {};
					dojo.forEach(oldValues, function(possibleItem){
						if(this.isItem(possibleItem)){
							var id = this.getIdentity(possibleItem);
							map[id.toString()] = true;
						}
					}, this);
					dojo.forEach(newValueArray, function(possibleItem){
						if(this.isItem(possibleItem)){
							var id = this.getIdentity(possibleItem);
							if(map[id.toString()]){
								delete map[id.toString()];
							}else{
								this._addReferenceToMap(possibleItem, item, attribute); 
							}
						}
					}, this);
					for(var rId in map){
						var removedItem;
						if(this._itemsByIdentity){
							removedItem = this._itemsByIdentity[rId];
						}else{
							removedItem = this._arrayOfAllItems[rId];
						}
						this._removeReferenceFromMap(removedItem, item, attribute);
					}
				}else{
					//Everything is new (no old values) so we have to just
					//insert all the references, if any.
					for(var i = 0; i < newValueArray.length; i++){
						var value = newValueArray[i];
						if(this.isItem(value)){
							this._addReferenceToMap(value, item, attribute);
						}
					}
				}
			}
			item[attribute] = newValueArray;
			success = true;
		}

		// Now we make the dojo.data.api.Notification call
		if(callOnSet){
			this.onSet(item, attribute, oldValueOrValues, newValueOrValues); 
		}
		return success; // boolean
	},

	_addReferenceToMap: function(/*item*/ refItem, /*item*/ parentItem, /*string*/ attribute){
		//	summary:
		//		Method to add an reference map entry for an item and attribute.
		//	description:
		//		Method to add an reference map entry for an item and attribute. 		 //
		//	refItem:
		//		The item that is referenced.
		//	parentItem:
		//		The item that holds the new reference to refItem.
		//	attribute:
		//		The attribute on parentItem that contains the new reference.
		 
		var parentId = this.getIdentity(parentItem);
		var references = refItem[this._reverseRefMap];

		if(!references){
			references = refItem[this._reverseRefMap] = {};
		}
		var itemRef = references[parentId];
		if(!itemRef){
			itemRef = references[parentId] = {};
		}
		itemRef[attribute] = true;
	},

	_removeReferenceFromMap: function(/* item */ refItem, /* item */ parentItem, /*strin*/ attribute){
		//	summary:
		//		Method to remove an reference map entry for an item and attribute.
		//	description:
		//		Method to remove an reference map entry for an item and attribute.  This will
		//		also perform cleanup on the map such that if there are no more references at all to 
		//		the item, its reference object and entry are removed.
		//
		//	refItem:
		//		The item that is referenced.
		//	parentItem:
		//		The item holding a reference to refItem.
		//	attribute:
		//		The attribute on parentItem that contains the reference.
		var identity = this.getIdentity(parentItem);
		var references = refItem[this._reverseRefMap];
		var itemId;
		if(references){
			for(itemId in references){
				if(itemId == identity){
					delete references[itemId][attribute];
					if(this._isEmpty(references[itemId])){
						delete references[itemId];
					}
				}
			}
			if(this._isEmpty(references)){
				delete refItem[this._reverseRefMap];
			}
		}
	},

	_dumpReferenceMap: function(){
		//	summary:
		//		Function to dump the reverse reference map of all items in the store for debug purposes.
		//	description:
		//		Function to dump the reverse reference map of all items in the store for debug purposes.
		var i;
		for(i = 0; i < this._arrayOfAllItems.length; i++){
			var item = this._arrayOfAllItems[i];
			if(item && item[this._reverseRefMap]){
				console.log("Item: [" + this.getIdentity(item) + "] is referenced by: " + dojo.toJson(item[this._reverseRefMap]));
			}
		}
	},
						   
	_getValueOrValues: function(/* item */ item, /* attribute-name-string */ attribute){
		var valueOrValues = undefined;
		if(this.hasAttribute(item, attribute)){
			var valueArray = this.getValues(item, attribute);
			if(valueArray.length == 1){
				valueOrValues = valueArray[0];
			}else{
				valueOrValues = valueArray;
			}
		}
		return valueOrValues;
	},
	
	_flatten: function(/* anything */ value){
		if(this.isItem(value)){
			var item = value;
			// Given an item, return an serializable object that provides a 
			// reference to the item.
			// For example, given kermit:
			//    var kermit = store.newItem({id:2, name:"Kermit"});
			// we want to return
			//    {_reference:2}
			var identity = this.getIdentity(item);
			var referenceObject = {_reference: identity};
			return referenceObject;
		}else{
			if(typeof value === "object"){
				for(var type in this._datatypeMap){
					var typeMap = this._datatypeMap[type];
					if (dojo.isObject(typeMap) && !dojo.isFunction(typeMap)){
						if(value instanceof typeMap.type){
							if(!typeMap.serialize){
								throw new Error("ItemFileWriteStore:  No serializer defined for type mapping: [" + type + "]");
							}
							return {_type: type, _value: typeMap.serialize(value)};
						}
					} else if(value instanceof typeMap){
						//SImple mapping, therefore, return as a toString serialization.
						return {_type: type, _value: value.toString()};
					}
				}
			}
			return value;
		}
	},
	
	_getNewFileContentString: function(){
		// summary: 
		//		Generate a string that can be saved to a file.
		//		The result should look similar to:
		//		http://trac.dojotoolkit.org/browser/dojo/trunk/tests/data/countries.json
		var serializableStructure = {};
		
		var identifierAttribute = this._getIdentifierAttribute();
		if(identifierAttribute !== Number){
			serializableStructure.identifier = identifierAttribute;
		}
		if(this._labelAttr){
			serializableStructure.label = this._labelAttr;
		}
		serializableStructure.items = [];
		for(var i = 0; i < this._arrayOfAllItems.length; ++i){
			var item = this._arrayOfAllItems[i];
			if(item !== null){
				var serializableItem = {};
				for(var key in item){
					if(key !== this._storeRefPropName && key !== this._itemNumPropName && key !== this._reverseRefMap && key !== this._rootItemPropName){
						var attribute = key;
						var valueArray = this.getValues(item, attribute);
						if(valueArray.length == 1){
							serializableItem[attribute] = this._flatten(valueArray[0]);
						}else{
							var serializableArray = [];
							for(var j = 0; j < valueArray.length; ++j){
								serializableArray.push(this._flatten(valueArray[j]));
								serializableItem[attribute] = serializableArray;
							}
						}
					}
				}
				serializableStructure.items.push(serializableItem);
			}
		}
		var prettyPrint = true;
		return dojo.toJson(serializableStructure, prettyPrint);
	},

	_isEmpty: function(something){
		//	summary: 
		//		Function to determine if an array or object has no properties or values.
		//	something:
		//		The array or object to examine.
		var empty = true;
		if(dojo.isObject(something)){
			var i;
			for(i in something){
				empty = false;
				break;
			}
		}else if(dojo.isArray(something)){
			if(something.length > 0){
				empty = false;
			}
		}
		return empty; //boolean
	},
	
	save: function(/* object */ keywordArgs){
		// summary: See dojo.data.api.Write.save()
		this._assert(!this._saveInProgress);
		
		// this._saveInProgress is set to true, briefly, from when save is first called to when it completes
		this._saveInProgress = true;
		
		var self = this;
		var saveCompleteCallback = function(){
			self._pending = {
				_newItems:{}, 
				_modifiedItems:{},
				_deletedItems:{}
			};

			self._saveInProgress = false; // must come after this._pending is cleared, but before any callbacks
			if(keywordArgs && keywordArgs.onComplete){
				var scope = keywordArgs.scope || dojo.global;
				keywordArgs.onComplete.call(scope);
			}
		};
		var saveFailedCallback = function(err){
			self._saveInProgress = false;
			if(keywordArgs && keywordArgs.onError){
				var scope = keywordArgs.scope || dojo.global;
				keywordArgs.onError.call(scope, err);
			}
		};
		
		if(this._saveEverything){
			var newFileContentString = this._getNewFileContentString();
			this._saveEverything(saveCompleteCallback, saveFailedCallback, newFileContentString);
		}
		if(this._saveCustom){
			this._saveCustom(saveCompleteCallback, saveFailedCallback);
		}
		if(!this._saveEverything && !this._saveCustom){
			// Looks like there is no user-defined save-handler function.
			// That's fine, it just means the datastore is acting as a "mock-write"
			// store -- changes get saved in memory but don't get saved to disk.
			saveCompleteCallback();
		}
	},
	
	revert: function(){
		// summary: See dojo.data.api.Write.revert()
		this._assert(!this._saveInProgress);

		var identity;
		for(identity in this._pending._modifiedItems){
			// find the original item and the modified item that replaced it
			var originalItem = this._pending._modifiedItems[identity];
			var modifiedItem = null;
			if(this._itemsByIdentity){
				modifiedItem = this._itemsByIdentity[identity];
			}else{
				modifiedItem = this._arrayOfAllItems[identity];
			}
			
			// make the original item into a full-fledged item again
			originalItem[this._storeRefPropName] = this;
			modifiedItem[this._storeRefPropName] = null;

			// replace the modified item with the original one
			var arrayIndex = modifiedItem[this._itemNumPropName];
			this._arrayOfAllItems[arrayIndex] = originalItem;
			
			if(modifiedItem[this._rootItemPropName]){
				var i;
				for (i = 0; i < this._arrayOfTopLevelItems.length; i++) {
					var possibleMatch = this._arrayOfTopLevelItems[i];
					if (this.getIdentity(possibleMatch) == identity){
						this._arrayOfTopLevelItems[i] = originalItem;
						break;
					}
				}
			}
			if(this._itemsByIdentity){
				this._itemsByIdentity[identity] = originalItem;
			}			
		}
		var deletedItem;
		for(identity in this._pending._deletedItems){
			deletedItem = this._pending._deletedItems[identity];
			deletedItem[this._storeRefPropName] = this;
			var index = deletedItem[this._itemNumPropName];

			//Restore the reverse refererence map, if any.
			if(deletedItem["backup_" + this._reverseRefMap]){
				deletedItem[this._reverseRefMap] = deletedItem["backup_" + this._reverseRefMap];
				delete deletedItem["backup_" + this._reverseRefMap];
			}
			this._arrayOfAllItems[index] = deletedItem;
			if (this._itemsByIdentity) {
				this._itemsByIdentity[identity] = deletedItem;
			}
			if(deletedItem[this._rootItemPropName]){
				this._arrayOfTopLevelItems.push(deletedItem);
			}	  
		}
		//We have to pass through it again and restore the reference maps after all the
		//undeletes have occurred.
		for(identity in this._pending._deletedItems){
			deletedItem = this._pending._deletedItems[identity];
			if(deletedItem["backupRefs_" + this._reverseRefMap]){
				dojo.forEach(deletedItem["backupRefs_" + this._reverseRefMap], function(reference){
					var refItem;
					if(this._itemsByIdentity){
						refItem = this._itemsByIdentity[reference.id];
					}else{
						refItem = this._arrayOfAllItems[reference.id];
					}
					this._addReferenceToMap(refItem, deletedItem, reference.attr);
				}, this);
				delete deletedItem["backupRefs_" + this._reverseRefMap]; 
			}
		}

		for(identity in this._pending._newItems){
			var newItem = this._pending._newItems[identity];
			newItem[this._storeRefPropName] = null;
			// null out the new item, but don't change the array index so
			// so we can keep using _arrayOfAllItems.length.
			this._arrayOfAllItems[newItem[this._itemNumPropName]] = null;
			if(newItem[this._rootItemPropName]){
				this._removeArrayElement(this._arrayOfTopLevelItems, newItem);
			}
			if(this._itemsByIdentity){
				delete this._itemsByIdentity[identity];
			}
		}

		this._pending = {
			_newItems:{}, 
			_modifiedItems:{}, 
			_deletedItems:{}
		};
		return true; // boolean
	},
	
	isDirty: function(/* item? */ item){
		// summary: See dojo.data.api.Write.isDirty()
		if(item){
			// return true if the item is dirty
			var identity = this.getIdentity(item);
			return new Boolean(this._pending._newItems[identity] || 
				this._pending._modifiedItems[identity] ||
				this._pending._deletedItems[identity]).valueOf(); // boolean
		}else{
			// return true if the store is dirty -- which means return true
			// if there are any new items, dirty items, or modified items
			if(!this._isEmpty(this._pending._newItems) || 
			   !this._isEmpty(this._pending._modifiedItems) ||
			   !this._isEmpty(this._pending._deletedItems)){
				return true;
			}
			return false; // boolean
		}
	},

/* dojo.data.api.Notification */

	onSet: function(/* item */ item, 
					/*attribute-name-string*/ attribute, 
					/*object | array*/ oldValue,
					/*object | array*/ newValue){
		// summary: See dojo.data.api.Notification.onSet()
		
		// No need to do anything. This method is here just so that the 
		// client code can connect observers to it.
	},

	onNew: function(/* item */ newItem, /*object?*/ parentInfo){
		// summary: See dojo.data.api.Notification.onNew()
		
		// No need to do anything. This method is here just so that the 
		// client code can connect observers to it. 
	},

	onDelete: function(/* item */ deletedItem){
		// summary: See dojo.data.api.Notification.onDelete()
		
		// No need to do anything. This method is here just so that the 
		// client code can connect observers to it. 
	},

	close: function(/* object? */ request) {
		 // summary:
		 //		Over-ride of base close function of ItemFileReadStore to add in check for store state.
		 // description:
		 //		Over-ride of base close function of ItemFileReadStore to add in check for store state.
		 //		If the store is still dirty (unsaved changes), then an error will be thrown instead of
		 //		clearing the internal state for reload from the url.

		 //Clear if not dirty ... or throw an error
		 if(this.clearOnClose){
			 if(!this.isDirty()){
				 this.inherited(arguments);
			 }else if(this._jsonFileUrl !== ""){
				 //Only throw an error if the store was dirty and we were loading from a url (cannot reload from url until state is saved).
				 throw new Error("dojo.data.ItemFileWriteStore: There are unsaved changes present in the store.  Please save or revert the changes before invoking close.");
			 }
		 }
	}
});

}

if(!dojo._hasResource["dojo.io.iframe"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.io.iframe"] = true;
dojo.provide("dojo.io.iframe");

/*=====
dojo.declare("dojo.io.iframe.__ioArgs", dojo.__IoArgs, {
	constructor: function(){
		//	summary:
		//		All the properties described in the dojo.__ioArgs type, apply
		//		to this type. The following additional properties are allowed
		//		for dojo.io.iframe.send():
		//	method: String?
		//		The HTTP method to use. "GET" or "POST" are the only supported
		//		values.  It will try to read the value from the form node's
		//		method, then try this argument. If neither one exists, then it
		//		defaults to POST.
		//	handleAs: String?
		//		Specifies what format the result data should be given to the
		//		load/handle callback. Valid values are: text, html, xml, json,
		//		javascript. IMPORTANT: For all values EXCEPT html and xml, The
		//		server response should be an HTML file with a textarea element.
		//		The response data should be inside the textarea element. Using an
		//		HTML document the only reliable, cross-browser way this
		//		transport can know when the response has loaded. For the html
		//		handleAs value, just return a normal HTML document.  NOTE: xml
		//		is now supported with this transport (as of 1.1+); a known issue
		//		is if the XML document in question is malformed, Internet Explorer
		//		will throw an uncatchable error.
		//	content: Object?
		//		If "form" is one of the other args properties, then the content
		//		object properties become hidden form form elements. For
		//		instance, a content object of {name1 : "value1"} is converted
		//		to a hidden form element with a name of "name1" and a value of
		//		"value1". If there is not a "form" property, then the content
		//		object is converted into a name=value&name=value string, by
		//		using dojo.objectToQuery().
		this.method = method;
		this.handleAs = handleAs;
		this.content = content;
	}
});
=====*/

dojo.io.iframe = {
	create: function(/*String*/fname, /*String*/onloadstr, /*String?*/uri){
		//	summary:
		//		Creates a hidden iframe in the page. Used mostly for IO
		//		transports.  You do not need to call this to start a
		//		dojo.io.iframe request. Just call send().
		//	fname: String
		//		The name of the iframe. Used for the name attribute on the
		//		iframe.
		//	onloadstr: String
		//		A string of JavaScript that will be executed when the content
		//		in the iframe loads.
		//	uri: String
		//		The value of the src attribute on the iframe element. If a
		//		value is not given, then dojo/resources/blank.html will be
		//		used.
		if(window[fname]){ return window[fname]; }
		if(window.frames[fname]){ return window.frames[fname]; }
		var cframe = null;
		var turi = uri;
		if(!turi){
			if(dojo.config["useXDomain"] && !dojo.config["dojoBlankHtmlUrl"]){
				console.warn("dojo.io.iframe.create: When using cross-domain Dojo builds,"
					+ " please save dojo/resources/blank.html to your domain and set djConfig.dojoBlankHtmlUrl"
					+ " to the path on your domain to blank.html");
			}
			turi = (dojo.config["dojoBlankHtmlUrl"]||dojo.moduleUrl("dojo", "resources/blank.html"));
		}
		var ifrstr = dojo.isIE ? '<iframe name="'+fname+'" src="'+turi+'" onload="'+onloadstr+'">' : 'iframe';
		cframe = dojo.doc.createElement(ifrstr);
		with(cframe){
			name = fname;
			setAttribute("name", fname);
			id = fname;
		}
		dojo.body().appendChild(cframe);
		window[fname] = cframe;
	
		with(cframe.style){
			if(!(dojo.isSafari < 3)){
				//We can't change the src in Safari 2.0.3 if absolute position. Bizarro.
				position = "absolute";
			}
			left = top = "1px";
			height = width = "1px";
			visibility = "hidden";
		}

		if(!dojo.isIE){
			this.setSrc(cframe, turi, true);
			cframe.onload = new Function(onloadstr);
		}

		return cframe;
	},

	setSrc: function(/*DOMNode*/iframe, /*String*/src, /*Boolean*/replace){
		//summary:
		//		Sets the URL that is loaded in an IFrame. The replace parameter
		//		indicates whether location.replace() should be used when
		//		changing the location of the iframe.
		try{
			if(!replace){
				if(dojo.isWebKit){
					iframe.location = src;
				}else{
					frames[iframe.name].location = src;
				}
			}else{
				// Fun with DOM 0 incompatibilities!
				var idoc;
				//WebKit > 521 corresponds with Safari 3, which started with 522 WebKit version.
				if(dojo.isIE || dojo.isWebKit > 521){
					idoc = iframe.contentWindow.document;
				}else if(dojo.isSafari){
					idoc = iframe.document;
				}else{ //  if(d.isMozilla){
					idoc = iframe.contentWindow;
				}
	
				//For Safari (at least 2.0.3) and Opera, if the iframe
				//has just been created but it doesn't have content
				//yet, then iframe.document may be null. In that case,
				//use iframe.location and return.
				if(!idoc){
					iframe.location = src;
					return;
				}else{
					idoc.location.replace(src);
				}
			}
		}catch(e){ 
			console.log("dojo.io.iframe.setSrc: ", e); 
		}
	},

	doc: function(/*DOMNode*/iframeNode){
		//summary: Returns the document object associated with the iframe DOM Node argument.
		var doc = iframeNode.contentDocument || // W3
			(
				(
					(iframeNode.name) && (iframeNode.document) && 
					(document.getElementsByTagName("iframe")[iframeNode.name].contentWindow) &&
					(document.getElementsByTagName("iframe")[iframeNode.name].contentWindow.document)
				)
			) ||  // IE
			(
				(iframeNode.name)&&(document.frames[iframeNode.name])&&
				(document.frames[iframeNode.name].document)
			) || null;
		return doc;
	},

	send: function(/*dojo.io.iframe.__ioArgs*/args){
		//summary: function that sends the request to the server.
		//This transport can only process one send() request at a time, so if send() is called
		//multiple times, it will queue up the calls and only process one at a time.
		if(!this["_frame"]){
			this._frame = this.create(this._iframeName, dojo._scopeName + ".io.iframe._iframeOnload();");
		}

		//Set up the deferred.
		var dfd = dojo._ioSetArgs(
			args,
			function(/*Deferred*/dfd){
				//summary: canceller function for dojo._ioSetArgs call.
				dfd.canceled = true;
				dfd.ioArgs._callNext();
			},
			function(/*Deferred*/dfd){
				//summary: okHandler function for dojo._ioSetArgs call.
				var value = null;
				try{
					var ioArgs = dfd.ioArgs;
					var dii = dojo.io.iframe;
					var ifd = dii.doc(dii._frame);
					var handleAs = ioArgs.handleAs;

					//Assign correct value based on handleAs value.
					value = ifd; //html
					if(handleAs != "html"){
						if(handleAs == "xml"){
							//	FF, Saf 3+ and Opera all seem to be fine with ifd being xml.  We have to
							//	do it manually for IE.  Refs #6334.
							if(dojo.isIE){
								dojo.query("a", dii._frame.contentWindow.document.documentElement).orphan();
								var xmlText=(dii._frame.contentWindow.document).documentElement.innerText;
								xmlText=xmlText.replace(/>\s+</g, "><");
								xmlText=dojo.trim(xmlText);
								//Reusing some code in base dojo for handling XML content.  Simpler and keeps
								//Core from duplicating the effort needed to locate the XML Parser on IE.
								var fauxXhr = { responseText: xmlText };
								value = dojo._contentHandlers["xml"](fauxXhr); // DOMDocument
							}
						}else{
							value = ifd.getElementsByTagName("textarea")[0].value; //text
							if(handleAs == "json"){
								value = dojo.fromJson(value); //json
							}else if(handleAs == "javascript"){
								value = dojo.eval(value); //javascript
							}
						}
					}
				}catch(e){
					value = e;
				}finally{
					ioArgs._callNext();				
				}
				return value;
			},
			function(/*Error*/error, /*Deferred*/dfd){
				//summary: errHandler function for dojo._ioSetArgs call.
				dfd.ioArgs._hasError = true;
				dfd.ioArgs._callNext();
				return error;
			}
		);

		//Set up a function that will fire the next iframe request. Make sure it only
		//happens once per deferred.
		dfd.ioArgs._callNext = function(){
			if(!this["_calledNext"]){
				this._calledNext = true;
				dojo.io.iframe._currentDfd = null;
				dojo.io.iframe._fireNextRequest();
			}
		}

		this._dfdQueue.push(dfd);
		this._fireNextRequest();
		
		//Add it the IO watch queue, to get things like timeout support.
		dojo._ioWatch(
			dfd,
			function(/*Deferred*/dfd){
				//validCheck
				return !dfd.ioArgs["_hasError"];
			},
			function(dfd){
				//ioCheck
				return (!!dfd.ioArgs["_finished"]);
			},
			function(dfd){
				//resHandle
				if(dfd.ioArgs._finished){
					dfd.callback(dfd);
				}else{
					dfd.errback(new Error("Invalid dojo.io.iframe request state"));
				}
			}
		);

		return dfd;
	},

	_currentDfd: null,
	_dfdQueue: [],
	_iframeName: dojo._scopeName + "IoIframe",

	_fireNextRequest: function(){
		//summary: Internal method used to fire the next request in the bind queue.
		try{
			if((this._currentDfd)||(this._dfdQueue.length == 0)){ return; }
			var dfd = this._currentDfd = this._dfdQueue.shift();
			var ioArgs = dfd.ioArgs;
			var args = ioArgs.args;

			ioArgs._contentToClean = [];
			var fn = dojo.byId(args["form"]);
			var content = args["content"] || {};
			if(fn){
				if(content){
					// if we have things in content, we need to add them to the form
					// before submission
					var pHandler = function(name, value) {
						var tn;
						if(dojo.isIE){
							tn = dojo.doc.createElement("<input type='hidden' name='"+name+"'>");
						}else{
							tn = dojo.doc.createElement("input");
							tn.type = "hidden";
							tn.name = name;
						}
						tn.value = value;
						fn.appendChild(tn);
						ioArgs._contentToClean.push(name);
					};
					for(var x in content){
						var val = content[x];
						if(dojo.isArray(val) && val.length > 1){
							var i;
							for (i = 0; i < val.length; i++) {
								pHandler(x,val[i]);
							}
						}else{
							if(!fn[x]){
								pHandler(x,val);
							}else{
								fn[x].value = val;
							}
						}
					}
				}
				//IE requires going through getAttributeNode instead of just getAttribute in some form cases, 
				//so use it for all.  See #2844
				var actnNode = fn.getAttributeNode("action");
				var mthdNode = fn.getAttributeNode("method");
				var trgtNode = fn.getAttributeNode("target");
				if(args["url"]){
					ioArgs._originalAction = actnNode ? actnNode.value : null;
					if(actnNode){
						actnNode.value = args.url;
					}else{
						fn.setAttribute("action",args.url);
					}
				}
				if(!mthdNode || !mthdNode.value){
					if(mthdNode){
						mthdNode.value= (args["method"]) ? args["method"] : "post";
					}else{
						fn.setAttribute("method", (args["method"]) ? args["method"] : "post");
					}
				}
				ioArgs._originalTarget = trgtNode ? trgtNode.value: null;
				if(trgtNode){
					trgtNode.value = this._iframeName;
				}else{
					fn.setAttribute("target", this._iframeName);
				}
				fn.target = this._iframeName;
				fn.submit();
			}else{
				// otherwise we post a GET string by changing URL location for the
				// iframe
				var tmpUrl = args.url + (args.url.indexOf("?") > -1 ? "&" : "?") + ioArgs.query;
				this.setSrc(this._frame, tmpUrl, true);
			}
		}catch(e){
			dfd.errback(e);
		}
	},

	_iframeOnload: function(){
		var dfd = this._currentDfd;
		if(!dfd){
			this._fireNextRequest();
			return;
		}

		var ioArgs = dfd.ioArgs;
		var args = ioArgs.args;
		var fNode = dojo.byId(args.form);
	
		if(fNode){
			// remove all the hidden content inputs
			var toClean = ioArgs._contentToClean;
			for(var i = 0; i < toClean.length; i++) {
				var key = toClean[i];
				//Need to cycle over all nodes since we may have added
				//an array value which means that more than one node could
				//have the same .name value.
				for(var j = 0; j < fNode.childNodes.length; j++){
					var chNode = fNode.childNodes[j];
					if(chNode.name == key){
						dojo.destroy(chNode);
						break;
					}
				}
			}

			// restore original action + target
			if(ioArgs["_originalAction"]){
				fNode.setAttribute("action", ioArgs._originalAction);
			}
			if(ioArgs["_originalTarget"]){
				fNode.setAttribute("target", ioArgs._originalTarget);
				fNode.target = ioArgs._originalTarget;
			}
		}

		ioArgs._finished = true;
	}
}

}

if(!dojo._hasResource["dojo.i18n"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.i18n"] = true;
dojo.provide("dojo.i18n");

/*=====
dojo.i18n = {
	// summary: Utility classes to enable loading of resources for internationalization (i18n)
};
=====*/

dojo.i18n.getLocalization = function(/*String*/packageName, /*String*/bundleName, /*String?*/locale){
	//	summary:
	//		Returns an Object containing the localization for a given resource
	//		bundle in a package, matching the specified locale.
	//	description:
	//		Returns a hash containing name/value pairs in its prototypesuch
	//		that values can be easily overridden.  Throws an exception if the
	//		bundle is not found.  Bundle must have already been loaded by
	//		`dojo.requireLocalization()` or by a build optimization step.  NOTE:
	//		try not to call this method as part of an object property
	//		definition (`var foo = { bar: dojo.i18n.getLocalization() }`).  In
	//		some loading situations, the bundle may not be available in time
	//		for the object definition.  Instead, call this method inside a
	//		function that is run after all modules load or the page loads (like
	//		in `dojo.addOnLoad()`), or in a widget lifecycle method.
	//	packageName:
	//		package which is associated with this resource
	//	bundleName:
	//		the base filename of the resource bundle (without the ".js" suffix)
	//	locale:
	//		the variant to load (optional).  By default, the locale defined by
	//		the host environment: dojo.locale

	locale = dojo.i18n.normalizeLocale(locale);

	// look for nearest locale match
	var elements = locale.split('-');
	var module = [packageName,"nls",bundleName].join('.');
	var bundle = dojo._loadedModules[module];
	if(bundle){
		var localization;
		for(var i = elements.length; i > 0; i--){
			var loc = elements.slice(0, i).join('_');
			if(bundle[loc]){
				localization = bundle[loc];
				break;
			}
		}
		if(!localization){
			localization = bundle.ROOT;
		}

		// make a singleton prototype so that the caller won't accidentally change the values globally
		if(localization){
			var clazz = function(){};
			clazz.prototype = localization;
			return new clazz(); // Object
		}
	}

	throw new Error("Bundle not found: " + bundleName + " in " + packageName+" , locale=" + locale);
};

dojo.i18n.normalizeLocale = function(/*String?*/locale){
	//	summary:
	//		Returns canonical form of locale, as used by Dojo.
	//
	//  description:
	//		All variants are case-insensitive and are separated by '-' as specified in [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt).
	//		If no locale is specified, the dojo.locale is returned.  dojo.locale is defined by
	//		the user agent's locale unless overridden by djConfig.

	var result = locale ? locale.toLowerCase() : dojo.locale;
	if(result == "root"){
		result = "ROOT";
	}
	return result; // String
};

dojo.i18n._requireLocalization = function(/*String*/moduleName, /*String*/bundleName, /*String?*/locale, /*String?*/availableFlatLocales){
	//	summary:
	//		See dojo.requireLocalization()
	//	description:
	// 		Called by the bootstrap, but factored out so that it is only
	// 		included in the build when needed.

	var targetLocale = dojo.i18n.normalizeLocale(locale);
 	var bundlePackage = [moduleName, "nls", bundleName].join(".");
	// NOTE: 
	//		When loading these resources, the packaging does not match what is
	//		on disk.  This is an implementation detail, as this is just a
	//		private data structure to hold the loaded resources.  e.g.
	//		`tests/hello/nls/en-us/salutations.js` is loaded as the object
	//		`tests.hello.nls.salutations.en_us={...}` The structure on disk is
	//		intended to be most convenient for developers and translators, but
	//		in memory it is more logical and efficient to store in a different
	//		order.  Locales cannot use dashes, since the resulting path will
	//		not evaluate as valid JS, so we translate them to underscores.
	
	//Find the best-match locale to load if we have available flat locales.
	var bestLocale = "";
	if(availableFlatLocales){
		var flatLocales = availableFlatLocales.split(",");
		for(var i = 0; i < flatLocales.length; i++){
			//Locale must match from start of string.
			//Using ["indexOf"] so customBase builds do not see
			//this as a dojo._base.array dependency.
			if(targetLocale["indexOf"](flatLocales[i]) == 0){
				if(flatLocales[i].length > bestLocale.length){
					bestLocale = flatLocales[i];
				}
			}
		}
		if(!bestLocale){
			bestLocale = "ROOT";
		}		
	}

	//See if the desired locale is already loaded.
	var tempLocale = availableFlatLocales ? bestLocale : targetLocale;
	var bundle = dojo._loadedModules[bundlePackage];
	var localizedBundle = null;
	if(bundle){
		if(dojo.config.localizationComplete && bundle._built){return;}
		var jsLoc = tempLocale.replace(/-/g, '_');
		var translationPackage = bundlePackage+"."+jsLoc;
		localizedBundle = dojo._loadedModules[translationPackage];
	}

	if(!localizedBundle){
		bundle = dojo["provide"](bundlePackage);
		var syms = dojo._getModuleSymbols(moduleName);
		var modpath = syms.concat("nls").join("/");
		var parent;

		dojo.i18n._searchLocalePath(tempLocale, availableFlatLocales, function(loc){
			var jsLoc = loc.replace(/-/g, '_');
			var translationPackage = bundlePackage + "." + jsLoc;
			var loaded = false;
			if(!dojo._loadedModules[translationPackage]){
				// Mark loaded whether it's found or not, so that further load attempts will not be made
				dojo["provide"](translationPackage);
				var module = [modpath];
				if(loc != "ROOT"){module.push(loc);}
				module.push(bundleName);
				var filespec = module.join("/") + '.js';
				loaded = dojo._loadPath(filespec, null, function(hash){
					// Use singleton with prototype to point to parent bundle, then mix-in result from loadPath
					var clazz = function(){};
					clazz.prototype = parent;
					bundle[jsLoc] = new clazz();
					for(var j in hash){ bundle[jsLoc][j] = hash[j]; }
				});
			}else{
				loaded = true;
			}
			if(loaded && bundle[jsLoc]){
				parent = bundle[jsLoc];
			}else{
				bundle[jsLoc] = parent;
			}
			
			if(availableFlatLocales){
				//Stop the locale path searching if we know the availableFlatLocales, since
				//the first call to this function will load the only bundle that is needed.
				return true;
			}
		});
	}

	//Save the best locale bundle as the target locale bundle when we know the
	//the available bundles.
	if(availableFlatLocales && targetLocale != bestLocale){
		bundle[targetLocale.replace(/-/g, '_')] = bundle[bestLocale.replace(/-/g, '_')];
	}
};

(function(){
	// If other locales are used, dojo.requireLocalization should load them as
	// well, by default. 
	// 
	// Override dojo.requireLocalization to do load the default bundle, then
	// iterate through the extraLocale list and load those translations as
	// well, unless a particular locale was requested.

	var extra = dojo.config.extraLocale;
	if(extra){
		if(!extra instanceof Array){
			extra = [extra];
		}

		var req = dojo.i18n._requireLocalization;
		dojo.i18n._requireLocalization = function(m, b, locale, availableFlatLocales){
			req(m,b,locale, availableFlatLocales);
			if(locale){return;}
			for(var i=0; i<extra.length; i++){
				req(m,b,extra[i], availableFlatLocales);
			}
		};
	}
})();

dojo.i18n._searchLocalePath = function(/*String*/locale, /*Boolean*/down, /*Function*/searchFunc){
	//	summary:
	//		A helper method to assist in searching for locale-based resources.
	//		Will iterate through the variants of a particular locale, either up
	//		or down, executing a callback function.  For example, "en-us" and
	//		true will try "en-us" followed by "en" and finally "ROOT".

	locale = dojo.i18n.normalizeLocale(locale);

	var elements = locale.split('-');
	var searchlist = [];
	for(var i = elements.length; i > 0; i--){
		searchlist.push(elements.slice(0, i).join('-'));
	}
	searchlist.push(false);
	if(down){searchlist.reverse();}

	for(var j = searchlist.length - 1; j >= 0; j--){
		var loc = searchlist[j] || "ROOT";
		var stop = searchFunc(loc);
		if(stop){ break; }
	}
};

dojo.i18n._preloadLocalizations = function(/*String*/bundlePrefix, /*Array*/localesGenerated){
	//	summary:
	//		Load built, flattened resource bundles, if available for all
	//		locales used in the page. Only called by built layer files.

	function preload(locale){
		locale = dojo.i18n.normalizeLocale(locale);
		dojo.i18n._searchLocalePath(locale, true, function(loc){
			for(var i=0; i<localesGenerated.length;i++){
				if(localesGenerated[i] == loc){
					dojo["require"](bundlePrefix+"_"+loc);
					return true; // Boolean
				}
			}
			return false; // Boolean
		});
	}
	preload();
	var extra = dojo.config.extraLocale||[];
	for(var i=0; i<extra.length; i++){
		preload(extra[i]);
	}
};

}

if(!dojo._hasResource["dijit._base.focus"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.focus"] = true;
dojo.provide("dijit._base.focus");

// summary:
//		These functions are used to query or set the focus and selection.
//
//		Also, they trace when widgets become actived/deactivated,
//		so that the widget can fire _onFocus/_onBlur events.
//		"Active" here means something similar to "focused", but
//		"focus" isn't quite the right word because we keep track of
//		a whole stack of "active" widgets.  Example:  Combobutton --> Menu -->
//		MenuItem.   The onBlur event for Combobutton doesn't fire due to focusing
//		on the Menu or a MenuItem, since they are considered part of the
//		Combobutton widget.  It only happens when focus is shifted
//		somewhere completely different.

dojo.mixin(dijit,
{
	// _curFocus: DomNode
	//		Currently focused item on screen
	_curFocus: null,

	// _prevFocus: DomNode
	//		Previously focused item on screen
	_prevFocus: null,

	isCollapsed: function(){
		// summary:
		//		Returns true if there is no text selected
		var _document = dojo.doc;
		if(_document.selection){ // IE
			var s=_document.selection;
			if(s.type=='Text'){
				return !s.createRange().htmlText.length; // Boolean
			}else{ //Control range
				return !s.createRange().length; // Boolean
			}
		}else{
			var _window = dojo.global;
			var selection = _window.getSelection();
			
			if(dojo.isString(selection)){ // Safari
				// TODO: this is dead code; safari is taking the else branch.  remove after 1.3.
				return !selection; // Boolean
			}else{ // Mozilla/W3
				return !selection || selection.isCollapsed || !selection.toString(); // Boolean
			}
		}
	},

	getBookmark: function(){
		// summary:
		//		Retrieves a bookmark that can be used with moveToBookmark to return to the same range
		var bookmark, selection = dojo.doc.selection;
		if(selection){ // IE
			var range = selection.createRange();
			if(selection.type.toUpperCase()=='CONTROL'){
				if(range.length){
					bookmark=[];
					var i=0,len=range.length;
					while(i<len){
						bookmark.push(range.item(i++));
					}
				}else{
					bookmark=null;
				}
			}else{
				bookmark = range.getBookmark();
			}
		}else{
			if(window.getSelection){
				selection = dojo.global.getSelection();
				if(selection){
					range = selection.getRangeAt(0);
					bookmark = range.cloneRange();
				}
			}else{
				console.warn("No idea how to store the current selection for this browser!");
			}
		}
		return bookmark; // Array
	},

	moveToBookmark: function(/*Object*/bookmark){
		// summary:
		//		Moves current selection to a bookmark
		// bookmark:
		//		This should be a returned object from dojo.html.selection.getBookmark()
		var _document = dojo.doc;
		if(_document.selection){ // IE
			var range;
			if(dojo.isArray(bookmark)){
				range = _document.body.createControlRange();
				//range.addElement does not have call/apply method, so can not call it directly
				//range is not available in "range.addElement(item)", so can't use that either
				dojo.forEach(bookmark, function(n){
					range.addElement(n);
				});
			}else{
				range = _document.selection.createRange();
				range.moveToBookmark(bookmark);
			}
			range.select();
		}else{ //Moz/W3C
			var selection = dojo.global.getSelection && dojo.global.getSelection();
			if(selection && selection.removeAllRanges){
				selection.removeAllRanges();
				selection.addRange(bookmark);
			}else{
				console.warn("No idea how to restore selection for this browser!");
			}
		}
	},

	getFocus: function(/*Widget?*/menu, /*Window?*/openedForWindow){
		// summary:
		//		Returns the current focus and selection.
		//		Called when a popup appears (either a top level menu or a dialog),
		//		or when a toolbar/menubar receives focus
		//
		// menu:
		//		The menu that's being opened
		//
		// openedForWindow:
		//		iframe in which menu was opened
		//
		// returns:
		//		A handle to restore focus/selection

		return {
			// Node to return focus to
			node: menu && dojo.isDescendant(dijit._curFocus, menu.domNode) ? dijit._prevFocus : dijit._curFocus,

			// Previously selected text
			bookmark:
				!dojo.withGlobal(openedForWindow||dojo.global, dijit.isCollapsed) ?
				dojo.withGlobal(openedForWindow||dojo.global, dijit.getBookmark) :
				null,

			openedForWindow: openedForWindow
		}; // Object
	},

	focus: function(/*Object || DomNode */ handle){
		// summary:
		//		Sets the focused node and the selection according to argument.
		//		To set focus to an iframe's content, pass in the iframe itself.
		// handle:
		//		object returned by get(), or a DomNode

		if(!handle){ return; }

		var node = "node" in handle ? handle.node : handle,		// because handle is either DomNode or a composite object
			bookmark = handle.bookmark,
			openedForWindow = handle.openedForWindow;

		// Set the focus
		// Note that for iframe's we need to use the <iframe> to follow the parentNode chain,
		// but we need to set focus to iframe.contentWindow
		if(node){
			var focusNode = (node.tagName.toLowerCase()=="iframe") ? node.contentWindow : node;
			if(focusNode && focusNode.focus){
				try{
					// Gecko throws sometimes if setting focus is impossible,
					// node not displayed or something like that
					focusNode.focus();
				}catch(e){/*quiet*/}
			}			
			dijit._onFocusNode(node);
		}

		// set the selection
		// do not need to restore if current selection is not empty
		// (use keyboard to select a menu item)
		if(bookmark && dojo.withGlobal(openedForWindow||dojo.global, dijit.isCollapsed)){
			if(openedForWindow){
				openedForWindow.focus();
			}
			try{
				dojo.withGlobal(openedForWindow||dojo.global, dijit.moveToBookmark, null, [bookmark]);
			}catch(e){
				/*squelch IE internal error, see http://trac.dojotoolkit.org/ticket/1984 */
			}
		}
	},

	// _activeStack: Array
	//		List of currently active widgets (focused widget and it's ancestors)
	_activeStack: [],

	registerIframe: function(/*DomNode*/ iframe){
		// summary:
		//		Registers listeners on the specified iframe so that any click
		//		or focus event on that iframe (or anything in it) is reported
		//		as a focus/click event on the <iframe> itself.
		// description:
		//		Currently only used by editor.
		dijit.registerWin(iframe.contentWindow, iframe);
	},
		

	registerWin: function(/*Window?*/targetWindow, /*DomNode?*/ effectiveNode){
		// summary:
		//		Registers listeners on the specified window (either the main
		//		window or an iframe's window) to detect when the user has clicked somewhere
		//		or focused somewhere.
		// description:
		//		Users should call registerIframe() instead of this method.
		// targetWindow:
		//		If specified this is the window associated with the iframe,
		//		i.e. iframe.contentWindow.
		// effectiveNode:
		//		If specified, report any focus events inside targetWindow as
		//		an event on effectiveNode, rather than on evt.target.

		// TODO: make this function private in 2.0; Editor/users should call registerIframe(),
		// or if Editor stops using <iframe> altogether than we can probably just drop
		// the whole public API.

		dojo.connect(targetWindow.document, "onmousedown", function(evt){
			dijit._justMouseDowned = true;
			setTimeout(function(){ dijit._justMouseDowned = false; }, 0);
			dijit._onTouchNode(effectiveNode||evt.target||evt.srcElement);
		});
		//dojo.connect(targetWindow, "onscroll", ???);

		// Listen for blur and focus events on targetWindow's document.
		// IIRC, I'm using attachEvent() rather than dojo.connect() because focus/blur events don't bubble
		// through dojo.connect(), and also maybe to catch the focus events early, before onfocus handlers
		// fire.
		var doc = targetWindow.document;
		if(doc){
			if(dojo.isIE){
				doc.attachEvent('onactivate', function(evt){
					if(evt.srcElement.tagName.toLowerCase() != "#document"){
						dijit._onFocusNode(effectiveNode||evt.srcElement);
					}
				});
				doc.attachEvent('ondeactivate', function(evt){
					dijit._onBlurNode(effectiveNode||evt.srcElement);
				});
			}else{
				doc.addEventListener('focus', function(evt){
					dijit._onFocusNode(effectiveNode||evt.target);
				}, true);
				doc.addEventListener('blur', function(evt){
					dijit._onBlurNode(effectiveNode||evt.target);
				}, true);
			}
		}
		doc = null;	// prevent memory leak (apparent circular reference via closure)
	},

	_onBlurNode: function(/*DomNode*/ node){
		// summary:
		// 		Called when focus leaves a node.
		//		Usually ignored, _unless_ it *isn't* follwed by touching another node,
		//		which indicates that we tabbed off the last field on the page,
		//		in which case every widget is marked inactive
		dijit._prevFocus = dijit._curFocus;
		dijit._curFocus = null;

		if(dijit._justMouseDowned){
			// the mouse down caused a new widget to be marked as active; this blur event
			// is coming late, so ignore it.
			return;
		}

		// if the blur event isn't followed by a focus event then mark all widgets as inactive.
		if(dijit._clearActiveWidgetsTimer){
			clearTimeout(dijit._clearActiveWidgetsTimer);
		}
		dijit._clearActiveWidgetsTimer = setTimeout(function(){
			delete dijit._clearActiveWidgetsTimer;
			dijit._setStack([]);
			dijit._prevFocus = null;
		}, 100);
	},

	_onTouchNode: function(/*DomNode*/ node){
		// summary:
		//		Callback when node is focused or mouse-downed

		// ignore the recent blurNode event
		if(dijit._clearActiveWidgetsTimer){
			clearTimeout(dijit._clearActiveWidgetsTimer);
			delete dijit._clearActiveWidgetsTimer;
		}

		// compute stack of active widgets (ex: ComboButton --> Menu --> MenuItem)
		var newStack=[];
		try{
			while(node){
				if(node.dijitPopupParent){
					node=dijit.byId(node.dijitPopupParent).domNode;
				}else if(node.tagName && node.tagName.toLowerCase()=="body"){
					// is this the root of the document or just the root of an iframe?
					if(node===dojo.body()){
						// node is the root of the main document
						break;
					}
					// otherwise, find the iframe this node refers to (can't access it via parentNode,
					// need to do this trick instead). window.frameElement is supported in IE/FF/Webkit
					node=dijit.getDocumentWindow(node.ownerDocument).frameElement;
				}else{
					var id = node.getAttribute && node.getAttribute("widgetId");
					if(id){
						newStack.unshift(id);
					}
					node=node.parentNode;
				}
			}
		}catch(e){ /* squelch */ }

		dijit._setStack(newStack);
	},

	_onFocusNode: function(/*DomNode*/ node){
		// summary:
		//		Callback when node is focused

		if(!node){
			return;
		}

		if(node.nodeType == 9){
			// Ignore focus events on the document itself.  This is here so that
			// (for example) clicking the up/down arrows of a spinner
			// (which don't get focus) won't cause that widget to blur. (FF issue)
			return;
		}

		dijit._onTouchNode(node);

		if(node==dijit._curFocus){ return; }
		if(dijit._curFocus){
			dijit._prevFocus = dijit._curFocus;
		}
		dijit._curFocus = node;
		dojo.publish("focusNode", [node]);
	},

	_setStack: function(newStack){
		// summary:
		//		The stack of active widgets has changed.  Send out appropriate events and records new stack.

		var oldStack = dijit._activeStack;
		dijit._activeStack = newStack;

		// compare old stack to new stack to see how many elements they have in common
		for(var nCommon=0; nCommon<Math.min(oldStack.length, newStack.length); nCommon++){
			if(oldStack[nCommon] != newStack[nCommon]){
				break;
			}
		}

		// for all elements that have gone out of focus, send blur event
		for(var i=oldStack.length-1; i>=nCommon; i--){
			var widget = dijit.byId(oldStack[i]);
			if(widget){
				widget._focused = false;
				widget._hasBeenBlurred = true;
				if(widget._onBlur){
					widget._onBlur();
				}
				if (widget._setStateClass){
					widget._setStateClass();
				}
				dojo.publish("widgetBlur", [widget]);
			}
		}

		// for all element that have come into focus, send focus event
		for(i=nCommon; i<newStack.length; i++){
			widget = dijit.byId(newStack[i]);
			if(widget){
				widget._focused = true;
				if(widget._onFocus){
					widget._onFocus();
				}
				if (widget._setStateClass){
					widget._setStateClass();
				}
				dojo.publish("widgetFocus", [widget]);
			}
		}
	}
});

// register top window and all the iframes it contains
dojo.addOnLoad(function(){dijit.registerWin(window); });

}

if(!dojo._hasResource["dijit._base.manager"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.manager"] = true;
dojo.provide("dijit._base.manager");

dojo.declare("dijit.WidgetSet", null, {
	// summary:
	//		A set of widgets indexed by id. A default instance of this class is 
	//		available as `dijit.registry`
	//
	// example:
	//		Create a small list of widgets:
	//		|	var ws = new dijit.WidgetSet();
	//		|	ws.add(dijit.byId("one"));
	//		| 	ws.add(dijit.byId("two"));
	//		|	// destroy both:
	//		|	ws.forEach(function(w){ w.destroy(); });
	//
	// example:
	//		Using dijit.registry:
	//		|	dijit.registry.forEach(function(w){ /* do something */ });
	
	constructor: function(){
		this._hash = {};
	},

	add: function(/*Widget*/ widget){
		// summary:
		//		Add a widget to this list. If a duplicate ID is detected, a error is thrown.
		//
		// widget: dijit._Widget
		//		Any dijit._Widget subclass.
		if(this._hash[widget.id]){
			throw new Error("Tried to register widget with id==" + widget.id + " but that id is already registered");
		}
		this._hash[widget.id]=widget;
	},

	remove: function(/*String*/ id){
		// summary:
		//		Remove a widget from this WidgetSet. Does not destroy the widget; simply
		//		removes the reference.
		delete this._hash[id];
	},

	forEach: function(/*Function*/ func){
		// summary:
		//		Call specified function for each widget in this set.
		//
		// func:
		//		A callback function to run for each item. Is passed a the widget.
		//
		// example:
		//		Using the default `dijit.registry` instance:
		//		|	dijit.registry.forEach(function(widget){
		//		|		console.log(widget.declaredClass);	
		//		|	});
		for(var id in this._hash){
			func(this._hash[id]);
		}
	},

	filter: function(/*Function*/ filter){
		// summary:
		//		Filter down this WidgetSet to a smaller new WidgetSet
		//		Works the same as `dojo.filter` and `dojo.NodeList.filter`
		//		
		// filter:
		//		Callback function to test truthiness.
		//
		// example:
		//		Arbitrary: select the odd widgets in this list
		//		|	var i = 0;
		//		|	dijit.registry.filter(function(w){
		//		|		return ++i % 2 == 0;
		//		|	}).forEach(function(w){ /* odd ones */ });

		var res = new dijit.WidgetSet();
		this.forEach(function(widget){
			if(filter(widget)){ res.add(widget); }
		});
		return res; // dijit.WidgetSet
	},

	byId: function(/*String*/ id){
		// summary:
		//		Find a widget in this list by it's id. 
		// example:
		//		Test if an id is in a particular WidgetSet
		//		| var ws = new dijit.WidgetSet();
		//		| ws.add(dijit.byId("bar"));
		//		| var t = ws.byId("bar") // returns a widget
		//		| var x = ws.byId("foo"); // returns undefined
		
		return this._hash[id];	// dijit._Widget
	},

	byClass: function(/*String*/ cls){
		// summary:
		//		Reduce this widgetset to a new WidgetSet of a particular declaredClass
		// 
		// example:
		//		Find all titlePane's in a page:
		//		|	dijit.registry.byClass("dijit.TitlePane").forEach(function(tp){ tp.close(); });
		
		return this.filter(function(widget){ return widget.declaredClass==cls; });	// dijit.WidgetSet
	}
	
});

/*=====
dijit.registry = {
	// summary: A list of widgets on a page.
	// description: Is an instance of `dijit.WidgetSet`
};
=====*/
dijit.registry = new dijit.WidgetSet();

dijit._widgetTypeCtr = {};

dijit.getUniqueId = function(/*String*/widgetType){
	// summary: Generates a unique id for a given widgetType

	var id;
	do{
		id = widgetType + "_" +
			(widgetType in dijit._widgetTypeCtr ?
				++dijit._widgetTypeCtr[widgetType] : dijit._widgetTypeCtr[widgetType] = 0);
	}while(dijit.byId(id));
	return id; // String
};

dijit.findWidgets = function(/*DomNode*/ root){
	// summary:
	//		Search subtree under root, putting found widgets in outAry.
	//		Doesn't search for nested widgets (ie, widgets inside other widgets)
	
	var outAry = [];

	function getChildrenHelper(root){
		var list = dojo.isIE ? root.children : root.childNodes, i = 0, node;
		while(node = list[i++]){
			if(node.nodeType != 1){ continue; }
			var widgetId = node.getAttribute("widgetId");
			if(widgetId){
				var widget = dijit.byId(widgetId);
				outAry.push(widget);
			}else{
				getChildrenHelper(node);
			}
		}
	}

	getChildrenHelper(root);
	return outAry;
};

if(dojo.isIE){
	// Only run this for IE because we think it's only necessary in that case,
	// and because it causes problems on FF.  See bug #3531 for details.
	dojo.addOnWindowUnload(function(){
		dojo.forEach(dijit.findWidgets(dojo.body()), function(widget){
			if(widget.destroyRecursive){
				widget.destroyRecursive();
			}else if(widget.destroy){
				widget.destroy();
			}
		});
	});
}

dijit.byId = function(/*String|Widget*/id){
	// summary:
	//		Returns a widget by it's id, or if passed a widget, no-op (like dojo.byId())
	return (dojo.isString(id)) ? dijit.registry.byId(id) : id; // Widget
};

dijit.byNode = function(/* DOMNode */ node){
	// summary:
	//		Returns the widget corresponding to the given DOMNode
	return dijit.registry.byId(node.getAttribute("widgetId")); // Widget
};

dijit.getEnclosingWidget = function(/* DOMNode */ node){
	// summary:
	//		Returns the widget whose DOM tree contains the specified DOMNode, or null if
	//		the node is not contained within the DOM tree of any widget
	while(node){
		if(node.getAttribute && node.getAttribute("widgetId")){
			return dijit.registry.byId(node.getAttribute("widgetId"));
		}
		node = node.parentNode;
	}
	return null;
};

// elements that are tab-navigable if they have no tabindex value set
// (except for "a", which must have an href attribute)
dijit._tabElements = {
	area: true,
	button: true,
	input: true,
	object: true,
	select: true,
	textarea: true
};

dijit._isElementShown = function(/*Element*/elem){
	var style = dojo.style(elem);
	return (style.visibility != "hidden")
		&& (style.visibility != "collapsed")
		&& (style.display != "none")
		&& (dojo.attr(elem, "type") != "hidden");
}

dijit.isTabNavigable = function(/*Element*/elem){
	// summary:
	//		Tests if an element is tab-navigable
	if(dojo.hasAttr(elem, "disabled")){ return false; }
	var hasTabindex = dojo.hasAttr(elem, "tabindex");
	var tabindex = dojo.attr(elem, "tabindex");
	if(hasTabindex && tabindex >= 0) {
		return true; // boolean
	}
	var name = elem.nodeName.toLowerCase();
	if(((name == "a" && dojo.hasAttr(elem, "href"))
			|| dijit._tabElements[name])
		&& (!hasTabindex || tabindex >= 0)){
		return true; // boolean
	}
	return false; // boolean
};

dijit._getTabNavigable = function(/*DOMNode*/root){
	// summary:
	//		Finds descendants of the specified root node.
	//
	// description:
	//		Finds the following descendants of the specified root node:
	//		* the first tab-navigable element in document order
	//		  without a tabindex or with tabindex="0"
	//		* the last tab-navigable element in document order
	//		  without a tabindex or with tabindex="0"
	//		* the first element in document order with the lowest
	//		  positive tabindex value
	//		* the last element in document order with the highest
	//		  positive tabindex value
	var first, last, lowest, lowestTabindex, highest, highestTabindex;
	var walkTree = function(/*DOMNode*/parent){
		dojo.query("> *", parent).forEach(function(child){
			var isShown = dijit._isElementShown(child);
			if(isShown && dijit.isTabNavigable(child)){
				var tabindex = dojo.attr(child, "tabindex");
				if(!dojo.hasAttr(child, "tabindex") || tabindex == 0){
					if(!first){ first = child; }
					last = child;
				}else if(tabindex > 0){
					if(!lowest || tabindex < lowestTabindex){
						lowestTabindex = tabindex;
						lowest = child;
					}
					if(!highest || tabindex >= highestTabindex){
						highestTabindex = tabindex;
						highest = child;
					}
				}
			}
			if(isShown && child.nodeName.toUpperCase() != 'SELECT'){ walkTree(child) }
		});
	};
	if(dijit._isElementShown(root)){ walkTree(root) }
	return { first: first, last: last, lowest: lowest, highest: highest };
}
dijit.getFirstInTabbingOrder = function(/*String|DOMNode*/root){
	// summary:
	//		Finds the descendant of the specified root node
	//		that is first in the tabbing order
	var elems = dijit._getTabNavigable(dojo.byId(root));
	return elems.lowest ? elems.lowest : elems.first; // DomNode
};

dijit.getLastInTabbingOrder = function(/*String|DOMNode*/root){
	// summary:
	//		Finds the descendant of the specified root node
	//		that is last in the tabbing order
	var elems = dijit._getTabNavigable(dojo.byId(root));
	return elems.last ? elems.last : elems.highest; // DomNode
};

/*=====
dojo.mixin(dijit, {
	// defaultDuration: Integer
	//		The default animation speed (in ms) to use for all Dijit
	//		transitional animations, unless otherwise specified 
	//		on a per-instance basis. Defaults to 200, overrided by 
	//		`djConfig.defaultDuration`
	defaultDuration: 300
});
=====*/

dijit.defaultDuration = dojo.config["defaultDuration"] || 200;

}

if(!dojo._hasResource["dojo.AdapterRegistry"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.AdapterRegistry"] = true;
dojo.provide("dojo.AdapterRegistry");

dojo.AdapterRegistry = function(/*Boolean?*/ returnWrappers){
	//	summary:
	//		A registry to make contextual calling/searching easier.
	//	description:
	//		Objects of this class keep list of arrays in the form [name, check,
	//		wrap, directReturn] that are used to determine what the contextual
	//		result of a set of checked arguments is. All check/wrap functions
	//		in this registry should be of the same arity.
	//	example:
	//	|	// create a new registry
	//	|	var reg = new dojo.AdapterRegistry();
	//	|	reg.register("handleString",
	//	|		dojo.isString,
	//	|		function(str){
	//	|			// do something with the string here
	//	|		}
	//	|	);
	//	|	reg.register("handleArr",
	//	|		dojo.isArray,
	//	|		function(arr){
	//	|			// do something with the array here
	//	|		}
	//	|	);
	//	|
	//	|	// now we can pass reg.match() *either* an array or a string and
	//	|	// the value we pass will get handled by the right function
	//	|	reg.match("someValue"); // will call the first function
	//	|	reg.match(["someValue"]); // will call the second

	this.pairs = [];
	this.returnWrappers = returnWrappers || false; // Boolean
}

dojo.extend(dojo.AdapterRegistry, {
	register: function(/*String*/ name, /*Function*/ check, /*Function*/ wrap, /*Boolean?*/ directReturn, /*Boolean?*/ override){
		//	summary: 
		//		register a check function to determine if the wrap function or
		//		object gets selected
		//	name:
		//		a way to identify this matcher.
		//	check:
		//		a function that arguments are passed to from the adapter's
		//		match() function.  The check function should return true if the
		//		given arguments are appropriate for the wrap function.
		//	directReturn:
		//		If directReturn is true, the value passed in for wrap will be
		//		returned instead of being called. Alternately, the
		//		AdapterRegistry can be set globally to "return not call" using
		//		the returnWrappers property. Either way, this behavior allows
		//		the registry to act as a "search" function instead of a
		//		function interception library.
		//	override:
		//		If override is given and true, the check function will be given
		//		highest priority. Otherwise, it will be the lowest priority
		//		adapter.
		this.pairs[((override) ? "unshift" : "push")]([name, check, wrap, directReturn]);
	},

	match: function(/* ... */){
		// summary:
		//		Find an adapter for the given arguments. If no suitable adapter
		//		is found, throws an exception. match() accepts any number of
		//		arguments, all of which are passed to all matching functions
		//		from the registered pairs.
		for(var i = 0; i < this.pairs.length; i++){
			var pair = this.pairs[i];
			if(pair[1].apply(this, arguments)){
				if((pair[3])||(this.returnWrappers)){
					return pair[2];
				}else{
					return pair[2].apply(this, arguments);
				}
			}
		}
		throw new Error("No match found");
	},

	unregister: function(name){
		// summary: Remove a named adapter from the registry

		// FIXME: this is kind of a dumb way to handle this. On a large
		// registry this will be slow-ish and we can use the name as a lookup
		// should we choose to trade memory for speed.
		for(var i = 0; i < this.pairs.length; i++){
			var pair = this.pairs[i];
			if(pair[0] == name){
				this.pairs.splice(i, 1);
				return true;
			}
		}
		return false;
	}
});

}

if(!dojo._hasResource["dijit._base.place"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.place"] = true;
dojo.provide("dijit._base.place");



// ported from dojo.html.util

dijit.getViewport = function(){
	// summary:
	//		Returns the dimensions and scroll position of the viewable area of a browser window

	var scrollRoot = (dojo.doc.compatMode == 'BackCompat')? dojo.body() : dojo.doc.documentElement;

	// get scroll position
	var scroll = dojo._docScroll(); // scrollRoot.scrollTop/Left should work
	return { w: scrollRoot.clientWidth, h: scrollRoot.clientHeight, l: scroll.x, t: scroll.y };
};

/*=====
dijit.__Position = function(){
	// x: Integer
	//		horizontal coordinate in pixels, relative to document body
	// y: Integer
	//		vertical coordinate in pixels, relative to document body

	thix.x = x;
	this.y = y;
}
=====*/


dijit.placeOnScreen = function(
	/* DomNode */			node,
	/* dijit.__Position */	pos,
	/* String[] */			corners,
	/* dijit.__Position? */	padding){
	//	summary:
	//		Positions one of the node's corners at specified position
	//		such that node is fully visible in viewport.
	//	description:
	//		NOTE: node is assumed to be absolutely or relatively positioned.
	//	pos:
	//		Object like {x: 10, y: 20}
	//	corners:
	//		Array of Strings representing order to try corners in, like ["TR", "BL"].
	//		Possible values are:
	//			* "BL" - bottom left
	//			* "BR" - bottom right
	//			* "TL" - top left
	//			* "TR" - top right
	//	padding:
	//		set padding to put some buffer around the element you want to position.
	//	example:	
	//		Try to place node's top right corner at (10,20).
	//		If that makes node go (partially) off screen, then try placing
	//		bottom left corner at (10,20).
	//	|	placeOnScreen(node, {x: 10, y: 20}, ["TR", "BL"])

	var choices = dojo.map(corners, function(corner){
		var c = { corner: corner, pos: {x:pos.x,y:pos.y} };
		if(padding){
			c.pos.x += corner.charAt(1) == 'L' ? padding.x : -padding.x;
			c.pos.y += corner.charAt(0) == 'T' ? padding.y : -padding.y;
		}
		return c; 
	});

	return dijit._place(node, choices);
}

dijit._place = function(/*DomNode*/ node, /* Array */ choices, /* Function */ layoutNode){
	// summary:
	//		Given a list of spots to put node, put it at the first spot where it fits,
	//		of if it doesn't fit anywhere then the place with the least overflow
	// choices: Array
	//		Array of elements like: {corner: 'TL', pos: {x: 10, y: 20} }
	//		Above example says to put the top-left corner of the node at (10,20)
	// layoutNode: Function(node, aroundNodeCorner, nodeCorner)
	//		for things like tooltip, they are displayed differently (and have different dimensions)
	//		based on their orientation relative to the parent.   This adjusts the popup based on orientation.

	// get {x: 10, y: 10, w: 100, h:100} type obj representing position of
	// viewport over document
	var view = dijit.getViewport();

	// This won't work if the node is inside a <div style="position: relative">,
	// so reattach it to dojo.doc.body.   (Otherwise, the positioning will be wrong
	// and also it might get cutoff)
	if(!node.parentNode || String(node.parentNode.tagName).toLowerCase() != "body"){
		dojo.body().appendChild(node);
	}

	var best = null;
	dojo.some(choices, function(choice){
		var corner = choice.corner;
		var pos = choice.pos;

		// configure node to be displayed in given position relative to button
		// (need to do this in order to get an accurate size for the node, because
		// a tooltips size changes based on position, due to triangle)
		if(layoutNode){
			layoutNode(node, choice.aroundCorner, corner);
		}

		// get node's size
		var style = node.style;
		var oldDisplay = style.display;
		var oldVis = style.visibility;
		style.visibility = "hidden";
		style.display = "";
		var mb = dojo.marginBox(node);
		style.display = oldDisplay;
		style.visibility = oldVis;

		// coordinates and size of node with specified corner placed at pos,
		// and clipped by viewport
		var startX = (corner.charAt(1) == 'L' ? pos.x : Math.max(view.l, pos.x - mb.w)),
			startY = (corner.charAt(0) == 'T' ? pos.y : Math.max(view.t, pos.y -  mb.h)),
			endX = (corner.charAt(1) == 'L' ? Math.min(view.l + view.w, startX + mb.w) : pos.x),
			endY = (corner.charAt(0) == 'T' ? Math.min(view.t + view.h, startY + mb.h) : pos.y),
			width = endX - startX,
			height = endY - startY,
			overflow = (mb.w - width) + (mb.h - height);

		if(best == null || overflow < best.overflow){
			best = {
				corner: corner,
				aroundCorner: choice.aroundCorner,
				x: startX,
				y: startY,
				w: width,
				h: height,
				overflow: overflow
			};
		}
		return !overflow;
	});

	node.style.left = best.x + "px";
	node.style.top = best.y + "px";
	if(best.overflow && layoutNode){
		layoutNode(node, best.aroundCorner, best.corner);
	}
	return best;
}

dijit.placeOnScreenAroundNode = function(
	/* DomNode */		node,
	/* DomNode */		aroundNode,
	/* Object */		aroundCorners,
	/* Function? */		layoutNode){

	// summary:
	//		Position node adjacent or kitty-corner to aroundNode
	//		such that it's fully visible in viewport.
	//
	// description:
	//		Place node such that corner of node touches a corner of
	//		aroundNode, and that node is fully visible.
	//
	// aroundCorners:
	//		Ordered list of pairs of corners to try matching up.
	//		Each pair of corners is represented as a key/value in the hash,
	//		where the key corresponds to the aroundNode's corner, and
	//		the value corresponds to the node's corner:
	//
	//	|	{ aroundNodeCorner1: nodeCorner1, aroundNodeCorner2: nodeCorner2,  ...}
	//
	//		The following strings are used to represent the four corners:
	//			* "BL" - bottom left
	//			* "BR" - bottom right
	//			* "TL" - top left
	//			* "TR" - top right
	//
	// layoutNode: Function(node, aroundNodeCorner, nodeCorner)
	//		For things like tooltip, they are displayed differently (and have different dimensions)
	//		based on their orientation relative to the parent.   This adjusts the popup based on orientation.
	//
	// example:
	//	|	dijit.placeOnScreenAroundNode(node, aroundNode, {'BL':'TL', 'TR':'BR'}); 
	//		This will try to position node such that node's top-left corner is at the same position
	//		as the bottom left corner of the aroundNode (ie, put node below
	//		aroundNode, with left edges aligned).  If that fails it will try to put
	// 		the bottom-right corner of node where the top right corner of aroundNode is
	//		(ie, put node above aroundNode, with right edges aligned)
	//

	// get coordinates of aroundNode
	aroundNode = dojo.byId(aroundNode);
	var oldDisplay = aroundNode.style.display;
	aroundNode.style.display="";
	// #3172: use the slightly tighter border box instead of marginBox
	var aroundNodeW = aroundNode.offsetWidth; //mb.w; 
	var aroundNodeH = aroundNode.offsetHeight; //mb.h;
	var aroundNodePos = dojo.coords(aroundNode, true);
	aroundNode.style.display=oldDisplay;

	// place the node around the calculated rectangle
	return dijit._placeOnScreenAroundRect(node, 
		aroundNodePos.x, aroundNodePos.y, aroundNodeW, aroundNodeH,	// rectangle
		aroundCorners, layoutNode);
};

/*=====
dijit.__Rectangle = function(){
	// x: Integer
	//		horizontal offset in pixels, relative to document body
	// y: Integer
	//		vertical offset in pixels, relative to document body
	// width: Integer
	//		width in pixels
	// height: Integer
	//		height in pixels

	thix.x = x;
	this.y = y;
	thix.width = width;
	this.height = height;
}
=====*/


dijit.placeOnScreenAroundRectangle = function(
	/* DomNode */			node,
	/* dijit.__Rectangle */	aroundRect,
	/* Object */			aroundCorners,
	/* Function */			layoutNode){

	// summary:
	//		Like dijit.placeOnScreenAroundNode(), except that the "around"
	//		parameter is an arbitrary rectangle on the screen (x, y, width, height)
	//		instead of a dom node.

	return dijit._placeOnScreenAroundRect(node, 
		aroundRect.x, aroundRect.y, aroundRect.width, aroundRect.height,	// rectangle
		aroundCorners, layoutNode);
};

dijit._placeOnScreenAroundRect = function(
	/* DomNode */		node,
	/* Number */		x,
	/* Number */		y,
	/* Number */		width,
	/* Number */		height,
	/* Object */		aroundCorners,
	/* Function */		layoutNode){

	// summary:
	//		Like dijit.placeOnScreenAroundNode(), except it accepts coordinates
	//		of a rectangle to place node adjacent to.

	// TODO: combine with placeOnScreenAroundRectangle()

	// Generate list of possible positions for node
	var choices = [];
	for(var nodeCorner in aroundCorners){
		choices.push( {
			aroundCorner: nodeCorner,
			corner: aroundCorners[nodeCorner],
			pos: {
				x: x + (nodeCorner.charAt(1) == 'L' ? 0 : width),
				y: y + (nodeCorner.charAt(0) == 'T' ? 0 : height)
			}
		});
	}

	return dijit._place(node, choices, layoutNode);
};

dijit.placementRegistry = new dojo.AdapterRegistry();
dijit.placementRegistry.register("node",
	function(n, x){
		return typeof x == "object" &&
			typeof x.offsetWidth != "undefined" && typeof x.offsetHeight != "undefined";
	},
	dijit.placeOnScreenAroundNode);
dijit.placementRegistry.register("rect",
	function(n, x){
		return typeof x == "object" &&
			"x" in x && "y" in x && "width" in x && "height" in x;
	},
	dijit.placeOnScreenAroundRectangle);

dijit.placeOnScreenAroundElement = function(
	/* DomNode */		node,
	/* Object */		aroundElement,
	/* Object */		aroundCorners,
	/* Function */		layoutNode){

	// summary:
	//		Like dijit.placeOnScreenAroundNode(), except it accepts an arbitrary object
	//		for the "around" argument and finds a proper processor to place a node.

	return dijit.placementRegistry.match.apply(dijit.placementRegistry, arguments);
};

}

if(!dojo._hasResource["dijit._base.window"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.window"] = true;
dojo.provide("dijit._base.window");

// TODO: remove this in 2.0, it's not used anymore, or at least not internally

dijit.getDocumentWindow = function(doc){
	// summary:
	// 		Get window object associated with document doc

	// In some IE versions (at least 6.0), document.parentWindow does not return a
	// reference to the real window object (maybe a copy), so we must fix it as well
	// We use IE specific execScript to attach the real window reference to
	// document._parentWindow for later use
	if(dojo.isIE && window !== document.parentWindow && !doc._parentWindow){
		/*
		In IE 6, only the variable "window" can be used to connect events (others
		may be only copies).
		*/
		doc.parentWindow.execScript("document._parentWindow = window;", "Javascript");
		//to prevent memory leak, unset it after use
		//another possibility is to add an onUnload handler which seems overkill to me (liucougar)
		var win = doc._parentWindow;
		doc._parentWindow = null;
		return win;	//	Window
	}

	return doc._parentWindow || doc.parentWindow || doc.defaultView;	//	Window
}

}

if(!dojo._hasResource["dijit._base.popup"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.popup"] = true;
dojo.provide("dijit._base.popup");





dijit.popup = new function(){
	// summary:
	//		This class is used to show/hide widgets as popups.

	var stack = [],
		beginZIndex=1000,
		idGen = 1;

	this.prepare = function(/*DomNode*/ node){
		// summary:
		//		Prepares a node to be used as a popup
		//
		// description:
		//		Attaches node to dojo.doc.body, and
		//		positions it off screen, but not display:none, so that
		//		the widget doesn't appear in the page flow and/or cause a blank
		//		area at the bottom of the viewport (making scrollbar longer), but
		//		initialization of contained widgets works correctly

		var s = node.style;
		s.visibility = "hidden";	// so TAB key doesn't navigate to hidden popup
		s.position = "absolute";
		s.top = "-9999px";
		if(s.display == "none"){
			s.display="";
		}
		dojo.body().appendChild(node);
	};

/*=====
dijit.popup.__OpenArgs = function(){
	// popup: Widget
	//		widget to display
	// parent: Widget
	//		the button etc. that is displaying this popup
	// around: DomNode
	//		DOM node (typically a button); place popup relative to this node.  (Specify this *or* "x" and "y" parameters.)
	// x: Integer
	//		Absolute horizontal position (in pixels) to place node at.  (Specify this *or* "around" parameter.)
	// y: Integer
	//		Absolute vertical position (in pixels) to place node at.  (Specity this *or* "around" parameter.)
	// orient: Object || String
	//		When the around parameter is specified, orient should be an 
	//		ordered list of tuples of the form (around-node-corner, popup-node-corner).
	//		dijit.popup.open() tries to position the popup according to each tuple in the list, in order,
	//		until the popup appears fully within the viewport.
	//
	//		The default value is {BL:'TL', TL:'BL'}, which represents a list of two tuples:
	//			1. (BL, TL)
	//			2. (TL, BL)
	//		where BL means "bottom left" and "TL" means "top left".
	//		So by default, it first tries putting the popup below the around node, left-aligning them,
	//		and then tries to put it above the around node, still left-aligning them.   Note that the
	//		default is horizontally reversed when in RTL mode.
	//
	//		When an (x,y) position is specified rather than an around node, orient is either
	//		"R" or "L".  R (for right) means that it tries to put the popup to the right of the mouse,
	//		specifically positioning the popup's top-right corner at the mouse position, and if that doesn't
	//		fit in the viewport, then it tries, in order, the bottom-right corner, the top left corner,
	//		and the top-right corner.
	// onCancel: Function
	//		callback when user has canceled the popup by
	//			1. hitting ESC or
	//			2. by using the popup widget's proprietary cancel mechanism (like a cancel button in a dialog);
	//			   i.e. whenever popupWidget.onCancel() is called, args.onCancel is called
	// onClose: Function
	//		callback whenever this popup is closed
	// onExecute: Function
	//		callback when user "executed" on the popup/sub-popup by selecting a menu choice, etc. (top menu only)
	// padding: dijit.__Position
	//		adding a buffer around the opening position. This is only useful when around is not set.
	this.popup = popup;
	this.parent = parent;
	this.around = around;
	this.x = x;
	this.y = y;
	this.orient = orient;
	this.onCancel = onCancel;
	this.onClose = onClose;
	this.onExecute = onExecute;
	this.padding = padding;
}
=====*/
	this.open = function(/*dijit.popup.__OpenArgs*/ args){
		// summary:
		//		Popup the widget at the specified position
		//
		// example:
		//		opening at the mouse position
		//		|		dijit.popup.open({popup: menuWidget, x: evt.pageX, y: evt.pageY});
		//
		// example:
		//		opening the widget as a dropdown
		//		|		dijit.popup.open({parent: this, popup: menuWidget, around: this.domNode, onClose: function(){...}  });
		//
		//		Note that whatever widget called dijit.popup.open() should also listen to its own _onBlur callback
		//		(fired from _base/focus.js) to know that focus has moved somewhere else and thus the popup should be closed.

		var widget = args.popup,
			orient = args.orient || {'BL':'TL', 'TL':'BL'},
			around = args.around,
			id = (args.around && args.around.id) ? (args.around.id+"_dropdown") : ("popup_"+idGen++);

		// make wrapper div to hold widget and possibly hold iframe behind it.
		// we can't attach the iframe as a child of the widget.domNode because
		// widget.domNode might be a <table>, <ul>, etc.
		var wrapper = dojo.create("div",{
			id: id, 
			"class":"dijitPopup",
			style:{
				zIndex: beginZIndex + stack.length,
				visibility:"hidden"
			}
		}, dojo.body());
		dijit.setWaiRole(wrapper, "presentation");
		
		// prevent transient scrollbar causing misalign (#5776)
		wrapper.style.left = wrapper.style.top = "0px";		

		if(args.parent){
			wrapper.dijitPopupParent=args.parent.id;
		}

		var s = widget.domNode.style;
		s.display = "";
		s.visibility = "";
		s.position = "";
		s.top = "0px";
		wrapper.appendChild(widget.domNode);

		var iframe = new dijit.BackgroundIframe(wrapper);

		// position the wrapper node
		var best = around ?
			dijit.placeOnScreenAroundElement(wrapper, around, orient, widget.orient ? dojo.hitch(widget, "orient") : null) :
			dijit.placeOnScreen(wrapper, args, orient == 'R' ? ['TR','BR','TL','BL'] : ['TL','BL','TR','BR'], args.padding);

		wrapper.style.visibility = "visible";
		// TODO: use effects to fade in wrapper

		var handlers = [];

		// Compute the closest ancestor popup that's *not* a child of another popup.
		// Ex: For a TooltipDialog with a button that spawns a tree of menus, find the popup of the button.
		var getTopPopup = function(){
			for(var pi=stack.length-1; pi > 0 && stack[pi].parent === stack[pi-1].widget; pi--){
				/* do nothing, just trying to get right value for pi */
			}
			return stack[pi];
		}

		// provide default escape and tab key handling
		// (this will work for any widget, not just menu)
		handlers.push(dojo.connect(wrapper, "onkeypress", this, function(evt){
			if(evt.charOrCode == dojo.keys.ESCAPE && args.onCancel){
				dojo.stopEvent(evt);
				args.onCancel();
			}else if(evt.charOrCode === dojo.keys.TAB){
				dojo.stopEvent(evt);
				var topPopup = getTopPopup();
				if(topPopup && topPopup.onCancel){
					topPopup.onCancel();
				}
			}
		}));

		// watch for cancel/execute events on the popup and notify the caller
		// (for a menu, "execute" means clicking an item)
		if(widget.onCancel){
			handlers.push(dojo.connect(widget, "onCancel", null, args.onCancel));
		}

		handlers.push(dojo.connect(widget, widget.onExecute ? "onExecute" : "onChange", null, function(){
			var topPopup = getTopPopup();
			if(topPopup && topPopup.onExecute){
				topPopup.onExecute();
			}
		}));

		stack.push({
			wrapper: wrapper,
			iframe: iframe,
			widget: widget,
			parent: args.parent,
			onExecute: args.onExecute,
			onCancel: args.onCancel,
 			onClose: args.onClose,
			handlers: handlers
		});

		if(widget.onOpen){
			widget.onOpen(best);
		}

		return best;
	};

	this.close = function(/*Widget*/ popup){
		// summary:
		//		Close specified popup and any popups that it parented
		while(dojo.some(stack, function(elem){return elem.widget == popup;})){
			var top = stack.pop(),
				wrapper = top.wrapper,
				iframe = top.iframe,
				widget = top.widget,
				onClose = top.onClose;
	
			if(widget.onClose){
				widget.onClose();
			}
			dojo.forEach(top.handlers, dojo.disconnect);
	
			// #2685: check if the widget still has a domNode so ContentPane can change its URL without getting an error
			if(!widget||!widget.domNode){ return; }
			
			this.prepare(widget.domNode);

			iframe.destroy();
			dojo.destroy(wrapper);
	
			if(onClose){
				onClose();
			}
		}
	};
}();

dijit._frames = new function(){
	// summary: cache of iframes
	var queue = [];

	this.pop = function(){
		var iframe;
		if(queue.length){
			iframe = queue.pop();
			iframe.style.display="";
		}else{
			if(dojo.isIE){
				var burl = dojo.config["dojoBlankHtmlUrl"] || (dojo.moduleUrl("dojo", "resources/blank.html")+"") || "javascript:\"\"";
				var html="<iframe src='" + burl + "'"
					+ " style='position: absolute; left: 0px; top: 0px;"
					+ "z-index: -1; filter:Alpha(Opacity=\"0\");'>";
				iframe = dojo.doc.createElement(html);
			}else{
			 	iframe = dojo.create("iframe");
				iframe.src = 'javascript:""';
				iframe.className = "dijitBackgroundIframe";
			}
			iframe.tabIndex = -1; // Magic to prevent iframe from getting focus on tab keypress - as style didnt work.
			dojo.body().appendChild(iframe);
		}
		return iframe;
	};

	this.push = function(iframe){
		iframe.style.display="none";
		if(dojo.isIE){
			iframe.style.removeExpression("width");
			iframe.style.removeExpression("height");
		}
		queue.push(iframe);
	}
}();


dijit.BackgroundIframe = function(/* DomNode */node){
	// summary:
	//		For IE z-index schenanigans. id attribute is required.
	//
	// description:
	//		new dijit.BackgroundIframe(node)
	//			Makes a background iframe as a child of node, that fills
	//			area (and position) of node

	if(!node.id){ throw new Error("no id"); }
	if(dojo.isIE < 7 || (dojo.isFF < 3 && dojo.hasClass(dojo.body(), "dijit_a11y"))){
		var iframe = dijit._frames.pop();
		node.appendChild(iframe);
		if(dojo.isIE){
			iframe.style.setExpression("width", dojo._scopeName + ".doc.getElementById('" + node.id + "').offsetWidth");
			iframe.style.setExpression("height", dojo._scopeName + ".doc.getElementById('" + node.id + "').offsetHeight");
		}
		this.iframe = iframe;
	}
};

dojo.extend(dijit.BackgroundIframe, {
	destroy: function(){
		//	summary: destroy the iframe
		if(this.iframe){
			dijit._frames.push(this.iframe);
			delete this.iframe;
		}
	}
});

}

if(!dojo._hasResource["dijit._base.scroll"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.scroll"] = true;
dojo.provide("dijit._base.scroll");

dijit.scrollIntoView = function(/* DomNode */node){
	// summary:
	//		Scroll the passed node into view, if it is not.

	// don't rely on that node.scrollIntoView works just because the function is there
	// it doesnt work in Konqueror or Opera even though the function is there and probably
	//	not safari either
	// native scrollIntoView() causes FF3's whole window to scroll if there is no scroll bar 
	//	on the immediate parent
	// dont like browser sniffs implementations but sometimes you have to use it
	// It's not enough just to scroll the menu node into view if
	// node.scrollIntoView hides part of the parent's scrollbar,
	// so just manage the parent scrollbar ourselves

	//var testdir="H"; //debug
	try{ // catch unexpected/unrecreatable errors (#7808) since we can recover using a semi-acceptable native method
	node = dojo.byId(node);
	var doc = node.ownerDocument || dojo.doc;
	var body = doc.body || dojo.body();
	var html = doc.documentElement || body.parentNode;
	// if FF2 (which is perfect) or an untested browser, then use the native method

	if((!(dojo.isFF >= 3 || dojo.isIE || dojo.isWebKit) || node == body || node == html) && (typeof node.scrollIntoView == "function")){ // FF2 is perfect, too bad FF3 is not
		node.scrollIntoView(false); // short-circuit to native if possible
		return;
	}
	var ltr = dojo._isBodyLtr();
	var isIE8strict = dojo.isIE >= 8 && !compatMode;
	var rtl = !ltr && !isIE8strict; // IE8 flips scrolling so pretend it's ltr
	// body and html elements are all messed up due to browser bugs and inconsistencies related to doctype
	// normalize the values before proceeding (FF2 is not listed since its native behavior is perfect)
	// for computation simplification, client and offset width and height are the same for body and html
	// strict:       html:       |      body:       | compatMode:
	//           width   height  |  width   height  |------------
	//    ie*:  clientW  clientH | scrollW  clientH | CSS1Compat
	//    ff3:  clientW  clientH |HscrollW  clientH | CSS1Compat
	//    sf3:  clientW  clientH | clientW HclientH | CSS1Compat
	//    op9:  clientW  clientH |HscrollW  clientH | CSS1Compat
	// ---------------------------------------------|-----------
	//   none:        html:      |      body:       |
	//           width    height |  width   height  |
	//    ie*: BclientW BclientH | clientW  clientH | BackCompat
	//    ff3: BclientW BclientH | clientW  clientH | BackCompat
	//    sf3:  clientW  clientH | clientW HclientH | CSS1Compat
	//    op9: BclientW BclientH | clientW  clientH | BackCompat
	// ---------------------------------------------|-----------
	//  loose:        html:      |      body:       |
	//           width    height |  width   height  |
	//    ie*:  clientW  clientH | scrollW  clientH | CSS1Compat
	//    ff3: BclientW BclientH | clientW  clientH | BackCompat
	//    sf3:  clientW  clientH | clientW HclientH | CSS1Compat
	//    op9:  clientW  clientH |HscrollW  clientH | CSS1Compat
	var scrollRoot = body;
	var compatMode = doc.compatMode == 'BackCompat';
	if(compatMode){ // BODY is scrollable, HTML has same client size
		// body client values already OK
		html._offsetWidth = html._clientWidth = body._offsetWidth = body.clientWidth;
		html._offsetHeight = html._clientHeight = body._offsetHeight = body.clientHeight;
	}else{
		if(dojo.isWebKit){
			body._offsetWidth = body._clientWidth  = html.clientWidth;
			body._offsetHeight = body._clientHeight = html.clientHeight;
		}else{
			scrollRoot = html;
		}
		html._offsetHeight = html.clientHeight;
		html._offsetWidth  = html.clientWidth;
	}

	function isFixedPosition(element){
		var ie = dojo.isIE;
		return ((ie <= 6 || (ie >= 7 && compatMode))? false : (dojo.style(element, 'position').toLowerCase() == "fixed"));
	}

	function addPseudoAttrs(element){
		var parent = element.parentNode;
		var offsetParent = element.offsetParent;
		if(offsetParent == null || isFixedPosition(element)){ // position:fixed has no real offsetParent
			offsetParent = html; // prevents exeptions
			parent = (element == body)? html : null;
		}
		// all the V/H object members below are to reuse code for both directions
		element._offsetParent = offsetParent;
		element._parent = parent;
		//console.debug('parent = ' + (element._parentTag = element._parent?element._parent.tagName:'NULL'));
		//console.debug('offsetParent = ' + (element._offsetParentTag = element._offsetParent.tagName));
		var bp = dojo._getBorderExtents(element);
		element._borderStart = { H:(isIE8strict && !ltr)? (bp.w-bp.l):bp.l, V:bp.t };
		element._borderSize = { H:bp.w, V:bp.h };
		element._scrolledAmount = { H:element.scrollLeft, V:element.scrollTop };
		element._offsetSize = { H: element._offsetWidth||element.offsetWidth, V: element._offsetHeight||element.offsetHeight };
		//console.debug('element = ' + element.tagName + ', '+testdir+' size = ' + element[testdir=='H'?"offsetWidth":"offsetHeight"] + ', parent = ' + element._parentTag);
		// IE8 flips everything in rtl mode except offsetLeft and borderLeft - so manually change offsetLeft to offsetRight here 
		element._offsetStart = { H:(isIE8strict && !ltr)? offsetParent.clientWidth-element.offsetLeft-element._offsetSize.H:element.offsetLeft, V:element.offsetTop };
		//console.debug('element = ' + element.tagName + ', initial _relativeOffset = ' + element._offsetStart[testdir]);
		element._clientSize = { H:element._clientWidth||element.clientWidth, V:element._clientHeight||element.clientHeight };
		if(element != body && element != html && element != node){
			for(var dir in element._offsetSize){ // for both x and y directions
				var scrollBarSize = element._offsetSize[dir] - element._clientSize[dir] - element._borderSize[dir];
				//if(dir==testdir)console.log('element = ' + element.tagName + ', scrollBarSize = ' + scrollBarSize + ', clientSize = ' + element._clientSize[dir] + ', offsetSize = ' + element._offsetSize[dir] + ', border size = ' + element._borderSize[dir]);
				var hasScrollBar = element._clientSize[dir] > 0 && scrollBarSize > 0; // can't check for a specific scrollbar size since it changes dramatically as you zoom
				//if(dir==testdir)console.log('element = ' + element.tagName + ', hasScrollBar = ' + hasScrollBar);
				if(hasScrollBar){
					element._offsetSize[dir] -= scrollBarSize;
					if(dojo.isIE && rtl && dir=="H"){ element._offsetStart[dir] += scrollBarSize; }
				}
			}
		}
	}

	var element = node;
	while(element != null){
		if(isFixedPosition(element)){ node.scrollIntoView(false); return; } //TODO: handle without native call
		addPseudoAttrs(element);
		element = element._parent;
	}
	if(dojo.isIE && node._parent){ // if no parent, then offsetParent._borderStart may not tbe set
		var offsetParent = node._offsetParent;
		//console.debug('adding offsetParent borderStart = ' + offsetParent._borderStart.H + ' to node offsetStart');
		node._offsetStart.H += offsetParent._borderStart.H;
		node._offsetStart.V += offsetParent._borderStart.V;
	}
	if(dojo.isIE >= 7 && scrollRoot == html && rtl && body._offsetStart && body._offsetStart.H == 0){ // IE7 bug
		var scroll = html.scrollWidth - html._offsetSize.H;
		if(scroll > 0){
			//console.debug('adjusting html scroll by ' + -scroll + ', scrollWidth = ' + html.scrollWidth + ', offsetSize = ' + html._offsetSize.H);
			body._offsetStart.H = -scroll;
		}
	}
	if(dojo.isIE <= 6 && !compatMode){
		html._offsetSize.H += html._borderSize.H;
		html._offsetSize.V += html._borderSize.V;
	}
	// eliminate offsetLeft/Top oddities by tweaking scroll for ease of computation
	if(rtl && body._offsetStart && scrollRoot == html && html._scrolledAmount){
		var ofs = body._offsetStart.H;
		if(ofs < 0){
			html._scrolledAmount.H += ofs;
			body._offsetStart.H = 0;
		}
	}
	element = node;
	while(element){
		var parent = element._parent;
		if(!parent){ break; }
			//console.debug('element = ' + element.tagName + ', parent = ' + parent.tagName + ', parent offsetSize = ' + parent._offsetSize[testdir] + ' clientSize = ' + parent._clientSize[testdir]);
			if(parent.tagName == "TD"){
				var table = parent._parent._parent._parent; // point to TABLE
				if(parent != element._offsetParent && parent._offsetParent != element._offsetParent){
					parent = table; // child of TD has the same offsetParent as TABLE, so skip TD, TR, and TBODY (ie. verticalslider)
				}
			}
			// check if this node and its parent share the same offsetParent
			var relative = element._offsetParent == parent;
			//console.debug('element = ' + element.tagName + ', offsetParent = ' + element._offsetParent.tagName + ', parent = ' + parent.tagName + ', relative = ' + relative);
			for(var dir in element._offsetStart){ // for both x and y directions
				var otherDir = dir=="H"? "V" : "H";
				if(rtl && dir=="H" && (parent != html) && (parent != body) && (dojo.isIE || dojo.isWebKit) && parent._clientSize.H > 0 && parent.scrollWidth > parent._clientSize.H){ // scroll starts on the right
					var delta = parent.scrollWidth - parent._clientSize.H;
					//console.debug('rtl scroll delta = ' + delta + ', changing ' + parent.tagName + ' scroll from ' + parent._scrolledAmount.H + ' to ' + (parent._scrolledAmount.H - delta)  + ', parent.scrollWidth = ' + parent.scrollWidth + ', parent._clientSize.H = ' + parent._clientSize.H);
					if(delta > 0){
						parent._scrolledAmount.H -= delta;
					} // match FF3 which has cool negative scrollLeft values
				}
				if(parent._offsetParent.tagName == "TABLE"){ // make it consistent
					if(dojo.isIE){ // make it consistent with Safari and FF3 and exclude the starting TABLE border of TABLE children
						parent._offsetStart[dir] -= parent._offsetParent._borderStart[dir];
						parent._borderStart[dir] = parent._borderSize[dir] = 0;
					}
					else{
						parent._offsetStart[dir] += parent._offsetParent._borderStart[dir];
					}
				}
				//if(dir==testdir)console.debug('border start = ' + parent._borderStart[dir] + ',  border size = ' + parent._borderSize[dir]);
				if(dojo.isIE){
					//if(dir==testdir)console.debug('changing parent offsetStart from ' + parent._offsetStart[dir] + ' by adding offsetParent ' + parent._offsetParent.tagName + ' border start = ' + parent._offsetParent._borderStart[dir]);
					parent._offsetStart[dir] += parent._offsetParent._borderStart[dir];
				}
				//if(dir==testdir)console.debug('subtracting border start = ' + parent._borderStart[dir]);
				// underflow = visible gap between parent and this node taking scrolling into account
				// if negative, part of the node is obscured by the parent's beginning and should be scrolled to become visible
				var underflow = element._offsetStart[dir] - parent._scrolledAmount[dir] - (relative? 0 : parent._offsetStart[dir]) - parent._borderStart[dir];
				// if overflow is positive, number of pixels obscured by the parent's end
				var overflow = underflow + element._offsetSize[dir] - parent._offsetSize[dir] + parent._borderSize[dir];
				//if(dir==testdir)console.debug('element = ' + element.tagName + ', offsetStart = ' + element._offsetStart[dir] + ', relative = ' + relative + ', parent offsetStart = ' + parent._offsetStart[dir] + ', scroll = ' + parent._scrolledAmount[dir] + ', parent border start = ' + parent._borderStart[dir] + ', parent border size = ' + parent._borderSize[dir] + ', underflow = ' + underflow + ', overflow = ' + overflow + ', element offsetSize = ' + element._offsetSize[dir] + ', parent offsetSize = ' + parent._offsetSize[dir]);
				var scrollAttr = (dir=="H")? "scrollLeft" : "scrollTop";
				// see if we should scroll forward or backward
				var reverse = dir=="H" && rtl; // flip everything
				var underflowScroll = reverse? -overflow : underflow;
				var overflowScroll = reverse? -underflow : overflow;
				// don't scroll if the over/underflow signs are opposite since that means that
				// the node extends beyond parent's boundary in both/neither directions
				var scrollAmount = (underflowScroll*overflowScroll <= 0)? 0 : Math[(underflowScroll < 0)? "max" : "min"](underflowScroll, overflowScroll);
				//if(dir==testdir)console.debug('element = ' + element.tagName + ' dir = ' + dir + ', scrollAmount = ' + scrollAmount);
				if(scrollAmount != 0){
					var oldScroll = parent[scrollAttr];
					parent[scrollAttr] += (reverse)? -scrollAmount : scrollAmount; // actually perform the scroll
					var scrolledAmount = parent[scrollAttr] - oldScroll; // in case the scroll failed
					//if(dir==testdir)console.debug('scrolledAmount = ' + scrolledAmount);
				}
				if(relative){
					element._offsetStart[dir] += parent._offsetStart[dir];
				}
				element._offsetStart[dir] -= parent[scrollAttr];
			}
			element._parent = parent._parent;
			element._offsetParent = parent._offsetParent;
	}
	parent = node;
	var next;
	while(parent && parent.removeAttribute){
		next = parent.parentNode;
		parent.removeAttribute('_offsetParent');
		parent.removeAttribute('_parent');
		parent = next;
	}
	}catch(error){
		console.error('scrollIntoView: ' + error);
		node.scrollIntoView(false);
	}
};

}

if(!dojo._hasResource["dijit._base.sniff"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.sniff"] = true;
// summary:
//		Applies pre-set CSS classes to the top-level HTML node, based on:
// 			- browser (ex: dj_ie)
//			- browser version (ex: dj_ie6)
//			- box model (ex: dj_contentBox)
//			- text direction (ex: dijitRtl)
//
//		In addition, browser, browser version, and box model are
//		combined with an RTL flag when browser text is RTL.  ex: dj_ie-rtl.
//
//		Simply doing a require on this module will
//		establish this CSS.  Modified version of Morris' CSS hack.

dojo.provide("dijit._base.sniff");

(function(){
	
	var d = dojo,
		html = d.doc.documentElement,
		ie = d.isIE,
		opera = d.isOpera,
		maj = Math.floor,
		ff = d.isFF,
		boxModel = d.boxModel.replace(/-/,''),
		classes = {
			dj_ie: ie,
//			dj_ie55: ie == 5.5,
			dj_ie6: maj(ie) == 6,
			dj_ie7: maj(ie) == 7,
			dj_iequirks: ie && d.isQuirks,
			// NOTE: Opera not supported by dijit
			dj_opera: opera,
			dj_opera8: maj(opera) == 8,
			dj_opera9: maj(opera) == 9,
			dj_khtml: d.isKhtml,
			dj_webkit: d.isWebKit,
			dj_safari: d.isSafari,
			dj_gecko: d.isMozilla,
			dj_ff2: maj(ff) == 2,
			dj_ff3: maj(ff) == 3
		}; // no dojo unsupported browsers
		
	classes["dj_" + boxModel] = true;
	
	// apply browser, browser version, and box model class names
	for(var p in classes){
		if(classes[p]){
			if(html.className){
				html.className += " " + p;
			}else{
				html.className = p;
			}
		}
	}

	// If RTL mode then add dijitRtl flag plus repeat existing classes
	// with -rtl extension
	// (unshift is to make this code run after <body> node is loaded but before parser runs)
	dojo._loaders.unshift(function(){
		if(!dojo._isBodyLtr()){
			html.className += " dijitRtl";
			for(var p in classes){
				if(classes[p]){
					html.className += " " + p + "-rtl";
				}
			}
		}
	});
	
})();

}

if(!dojo._hasResource["dijit._base.typematic"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.typematic"] = true;
dojo.provide("dijit._base.typematic");

dijit.typematic = {
	// summary:
	//		These functions are used to repetitively call a user specified callback
	//		method when a specific key or mouse click over a specific DOM node is
	//		held down for a specific amount of time.
	//		Only 1 such event is allowed to occur on the browser page at 1 time.

	_fireEventAndReload: function(){
		this._timer = null;
		this._callback(++this._count, this._node, this._evt);
		this._currentTimeout = (this._currentTimeout < 0) ? this._initialDelay : ((this._subsequentDelay > 1) ? this._subsequentDelay : Math.round(this._currentTimeout * this._subsequentDelay));
		this._timer = setTimeout(dojo.hitch(this, "_fireEventAndReload"), this._currentTimeout);
	},

	trigger: function(/*Event*/ evt, /* Object */ _this, /*DOMNode*/ node, /* Function */ callback, /* Object */ obj, /* Number */ subsequentDelay, /* Number */ initialDelay){
		// summary:
		//	    Start a timed, repeating callback sequence.
		//	    If already started, the function call is ignored.
		//	    This method is not normally called by the user but can be
		//	    when the normal listener code is insufficient.
		// evt:
		//		key or mouse event object to pass to the user callback
		// _this:
		//		pointer to the user's widget space.
		// node:
		//		the DOM node object to pass the the callback function
		// callback:
		//		function to call until the sequence is stopped called with 3 parameters:
		// count:
		//		integer representing number of repeated calls (0..n) with -1 indicating the iteration has stopped
		// node:
		//		the DOM node object passed in
		// evt:
		//		key or mouse event object
		// obj:
		//		user space object used to uniquely identify each typematic sequence
		// subsequentDelay:
		//		if > 1, the number of milliseconds until the 3->n events occur
		//		or else the fractional time multiplier for the next event's delay, default=0.9
		// initialDelay:
		//		the number of milliseconds until the 2nd event occurs, default=500ms
		if(obj != this._obj){
			this.stop();
			this._initialDelay = initialDelay || 500;
			this._subsequentDelay = subsequentDelay || 0.90;
			this._obj = obj;
			this._evt = evt;
			this._node = node;
			this._currentTimeout = -1;
			this._count = -1;
			this._callback = dojo.hitch(_this, callback);
			this._fireEventAndReload();
		}
	},

	stop: function(){
		// summary:
		//	  Stop an ongoing timed, repeating callback sequence.
		if(this._timer){
			clearTimeout(this._timer);
			this._timer = null;
		}
		if(this._obj){
			this._callback(-1, this._node, this._evt);
			this._obj = null;
		}
	},

	addKeyListener: function(/*DOMNode*/ node, /*Object*/ keyObject, /*Object*/ _this, /*Function*/ callback, /*Number*/ subsequentDelay, /*Number*/ initialDelay){
		// summary:
		//		Start listening for a specific typematic key.
		//		See also the trigger method for other parameters.
		// keyObject:
		//		an object defining the key to listen for.
		// charOrCode:
		//		the printable character (string) or keyCode (number) to listen for.
		// keyCode:
		//		(deprecated - use charOrCode) the keyCode (number) to listen for (implies charCode = 0).
		// charCode:
		//		(deprecated - use charOrCode) the charCode (number) to listen for.
		// ctrlKey:
		//		desired ctrl key state to initiate the calback sequence:
		//			- pressed (true)
		//			- released (false)
		//			- either (unspecified)
		// altKey:
		//		same as ctrlKey but for the alt key
		// shiftKey:
		//		same as ctrlKey but for the shift key
		// returns:
		//		an array of dojo.connect handles
		if(keyObject.keyCode){
			keyObject.charOrCode = keyObject.keyCode;
			dojo.deprecated("keyCode attribute parameter for dijit.typematic.addKeyListener is deprecated. Use charOrCode instead.", "", "2.0");
		}else if(keyObject.charCode){
			keyObject.charOrCode = String.fromCharCode(keyObject.charCode);
			dojo.deprecated("charCode attribute parameter for dijit.typematic.addKeyListener is deprecated. Use charOrCode instead.", "", "2.0");
		}
		return [
			dojo.connect(node, "onkeypress", this, function(evt){
				if(evt.charOrCode == keyObject.charOrCode &&
				(keyObject.ctrlKey === undefined || keyObject.ctrlKey == evt.ctrlKey) &&
				(keyObject.altKey === undefined || keyObject.altKey == evt.ctrlKey) &&
				(keyObject.shiftKey === undefined || keyObject.shiftKey == evt.ctrlKey)){
					dojo.stopEvent(evt);
					dijit.typematic.trigger(keyObject, _this, node, callback, keyObject, subsequentDelay, initialDelay);
				}else if(dijit.typematic._obj == keyObject){
					dijit.typematic.stop();
				}
			}),
			dojo.connect(node, "onkeyup", this, function(evt){
				if(dijit.typematic._obj == keyObject){
					dijit.typematic.stop();
				}
			})
		];
	},

	addMouseListener: function(/*DOMNode*/ node, /*Object*/ _this, /*Function*/ callback, /*Number*/ subsequentDelay, /*Number*/ initialDelay){
		// summary:
		//		Start listening for a typematic mouse click.
		//		See the trigger method for other parameters.
		// returns:
		//		an array of dojo.connect handles
		var dc = dojo.connect;
		return [
			dc(node, "mousedown", this, function(evt){
				dojo.stopEvent(evt);
				dijit.typematic.trigger(evt, _this, node, callback, node, subsequentDelay, initialDelay);
			}),
			dc(node, "mouseup", this, function(evt){
				dojo.stopEvent(evt);
				dijit.typematic.stop();
			}),
			dc(node, "mouseout", this, function(evt){
				dojo.stopEvent(evt);
				dijit.typematic.stop();
			}),
			dc(node, "mousemove", this, function(evt){
				dojo.stopEvent(evt);
			}),
			dc(node, "dblclick", this, function(evt){
				dojo.stopEvent(evt);
				if(dojo.isIE){
					dijit.typematic.trigger(evt, _this, node, callback, node, subsequentDelay, initialDelay);
					setTimeout(dojo.hitch(this, dijit.typematic.stop), 50);
				}
			})
		];
	},

	addListener: function(/*Node*/ mouseNode, /*Node*/ keyNode, /*Object*/ keyObject, /*Object*/ _this, /*Function*/ callback, /*Number*/ subsequentDelay, /*Number*/ initialDelay){
		// summary:
		//		Start listening for a specific typematic key and mouseclick.
		//		This is a thin wrapper to addKeyListener and addMouseListener.
		//		See the addMouseListener and addKeyListener methods for other parameters.
		// mouseNode:
		//		the DOM node object to listen on for mouse events.
		// keyNode:
		//		the DOM node object to listen on for key events.
		// returns:
		//		an array of dojo.connect handles
		return this.addKeyListener(keyNode, keyObject, _this, callback, subsequentDelay, initialDelay).concat(
			this.addMouseListener(mouseNode, _this, callback, subsequentDelay, initialDelay));
	}
};

}

if(!dojo._hasResource["dijit._base.wai"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base.wai"] = true;
dojo.provide("dijit._base.wai");

dijit.wai = {
	onload: function(){
		// summary:
		//		Detects if we are in high-contrast mode or not

		// This must be a named function and not an anonymous
		// function, so that the widget parsing code can make sure it
		// registers its onload function after this function.
		// DO NOT USE "this" within this function.

		// create div for testing if high contrast mode is on or images are turned off
		var div = dojo.create("div",{
			id: "a11yTestNode",
			style:{
				cssText:'border: 1px solid;'
					+ 'border-color:red green;'
					+ 'position: absolute;'
					+ 'height: 5px;'
					+ 'top: -999px;'
					+ 'background-image: url("' + (dojo.config.blankGif || dojo.moduleUrl("dojo", "resources/blank.gif")) + '");'
			}
		}, dojo.body());

		// test it
		var cs = dojo.getComputedStyle(div);
		if(cs){
			var bkImg = cs.backgroundImage;
			var needsA11y = (cs.borderTopColor==cs.borderRightColor) || (bkImg != null && (bkImg == "none" || bkImg == "url(invalid-url:)" ));
			dojo[needsA11y ? "addClass" : "removeClass"](dojo.body(), "dijit_a11y");
			if(dojo.isIE){
				div.outerHTML = "";		// prevent mixed-content warning, see http://support.microsoft.com/kb/925014
			}else{
				dojo.body().removeChild(div);
			}
		}
	}
};

// Test if computer is in high contrast mode.
// Make sure the a11y test runs first, before widgets are instantiated.
if(dojo.isIE || dojo.isMoz){	// NOTE: checking in Safari messes things up
	dojo._loaders.unshift(dijit.wai.onload);
}

dojo.mixin(dijit,
{
	_XhtmlRoles: /banner|contentinfo|definition|main|navigation|search|note|secondary|seealso/,

	hasWaiRole: function(/*Element*/ elem, /*String*/ role){
		// summary:
		//		Determines if an element has a particular non-XHTML role.
		// returns:
		//		True if elem has the specific non-XHTML role attribute and false if not.
		// 		For backwards compatibility if role parameter not provided, 
		// 		returns true if has non XHTML role 
		var waiRole = this.getWaiRole(elem);		
		return role ? (waiRole.indexOf(role) > -1) : (waiRole.length > 0);
	},

	getWaiRole: function(/*Element*/ elem){
		// summary:
		//		Gets the non-XHTML role for an element (which should be a wai role).
		// returns:
		//		The non-XHTML role of elem or an empty string if elem
		//		does not have a role.
		 return dojo.trim((dojo.attr(elem, "role") || "").replace(this._XhtmlRoles,"").replace("wairole:",""));
	},

	setWaiRole: function(/*Element*/ elem, /*String*/ role){
		// summary:
		//		Sets the role on an element.
		// description:
		//		In other than FF2 replace existing role attribute with new role.
		//		FF3 supports XHTML and ARIA roles so    
		//		if elem already has an XHTML role, append this role to XHTML role 
		//		and remove other ARIA roles.
		//		On Firefox 2 and below, "wairole:" is
		//		prepended to the provided role value.

		var curRole = dojo.attr(elem, "role") || "";
		if(dojo.isFF < 3 || !this._XhtmlRoles.test(curRole)){
			dojo.attr(elem, "role", dojo.isFF < 3 ? "wairole:" + role : role);
		}else{
			if((" "+ curRole +" ").indexOf(" " + role + " ") < 0){
				var clearXhtml = dojo.trim(curRole.replace(this._XhtmlRoles, ""));
				var cleanRole = dojo.trim(curRole.replace(clearXhtml, ""));	 
         		dojo.attr(elem, "role", cleanRole + (cleanRole ? ' ' : '') + role);
			}
		}
	},

	removeWaiRole: function(/*Element*/ elem, /*String*/ role){
		// summary:
		//		Removes the specified non-XHTML role from an element.
		// 		Removes role attribute if no specific role provided (for backwards compat.)

		var roleValue = dojo.attr(elem, "role"); 
		if(!roleValue){ return; }
		if(role){
			var searchRole = dojo.isFF < 3 ? "wairole:" + role : role;
			var t = dojo.trim((" " + roleValue + " ").replace(" " + searchRole + " ", " "));
			dojo.attr(elem, "role", t);
		}else{
			elem.removeAttribute("role");	
		}
	},

	hasWaiState: function(/*Element*/ elem, /*String*/ state){
		// summary:
		//		Determines if an element has a given state.
		// description:
		//		On Firefox 2 and below, we check for an attribute in namespace
		//		"http://www.w3.org/2005/07/aaa" with a name of the given state.
		//		On all other browsers, we check for an attribute
		//		called "aria-"+state.
		// returns:
		//		true if elem has a value for the given state and
		//		false if it does not.
		if(dojo.isFF < 3){
			return elem.hasAttributeNS("http://www.w3.org/2005/07/aaa", state);
		}
		return elem.hasAttribute ? elem.hasAttribute("aria-"+state) : !!elem.getAttribute("aria-"+state);
	},

	getWaiState: function(/*Element*/ elem, /*String*/ state){
		// summary:
		//		Gets the value of a state on an element.
		// description:
		//		On Firefox 2 and below, we check for an attribute in namespace
		//		"http://www.w3.org/2005/07/aaa" with a name of the given state.
		//		On all other browsers, we check for an attribute called
		//		"aria-"+state.
		// returns:
		//		The value of the requested state on elem
		//		or an empty string if elem has no value for state.
		if(dojo.isFF < 3){
			return elem.getAttributeNS("http://www.w3.org/2005/07/aaa", state);
		}
		return elem.getAttribute("aria-"+state) || "";
	},

	setWaiState: function(/*Element*/ elem, /*String*/ state, /*String*/ value){
		// summary:
		//		Sets a state on an element.
		// description:
		//		On Firefox 2 and below, we set an attribute in namespace
		//		"http://www.w3.org/2005/07/aaa" with a name of the given state.
		//		On all other browsers, we set an attribute called
		//		"aria-"+state.
		if(dojo.isFF < 3){
			elem.setAttributeNS("http://www.w3.org/2005/07/aaa",
				"aaa:"+state, value);
		}else{
			elem.setAttribute("aria-"+state, value);
		}
	},

	removeWaiState: function(/*Element*/ elem, /*String*/ state){
		// summary:
		//		Removes a state from an element.
		// description:
		//		On Firefox 2 and below, we remove the attribute in namespace
		//		"http://www.w3.org/2005/07/aaa" with a name of the given state.
		//		On all other browsers, we remove the attribute called
		//		"aria-"+state.
		if(dojo.isFF < 3){
			elem.removeAttributeNS("http://www.w3.org/2005/07/aaa", state);
		}else{
			elem.removeAttribute("aria-"+state);
		}
	}
});

}

if(!dojo._hasResource["dijit._base"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._base"] = true;
dojo.provide("dijit._base");











}

if(!dojo._hasResource["dijit._Widget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._Widget"] = true;
dojo.provide("dijit._Widget");

dojo.require( "dijit._base" );

// This code is to assist deferring dojo.connect() calls in widgets (connecting to events on the widgets'
// DOM nodes) until someone actually needs to monitor that event.
dojo.connect(dojo, "connect", 
	function(/*Widget*/ widget, /*String*/ event){
		if(widget && dojo.isFunction(widget._onConnect)){
			widget._onConnect(event);
		}
	});

dijit._connectOnUseEventHandler = function(/*Event*/ event){};

//Keep track of where the last keydown event was, to help avoid generating
//spurious ondijitclick events when:
//1. focus is on a <button> or <a>
//2. user presses then releases the ENTER key
//3. onclick handler fires and shifts focus to another node, with an ondijitclick handler
//4. onkeyup event fires, causing the ondijitclick handler to fire
dijit._lastKeyDownNode = null;
if(dojo.isIE){
	dojo.doc.attachEvent('onkeydown', function(evt){
		//console.log("keypress on IE");
		dijit._lastKeyDownNode = evt.srcElement;
	});
}else{
	dojo.doc.addEventListener('keydown', function(evt){
		//console.log("keydown,  non-IE", evt.target);
		dijit._lastKeyDownNode = evt.target;
	}, true);
}

(function(){

var _attrReg = {};
var getAttrReg = function(dc){
	if(!_attrReg[dc]){
		var r = [];
		var attrs;
		var proto = dojo.getObject(dc).prototype;
		for(var fxName in proto){
			if(dojo.isFunction(proto[fxName]) && (attrs = fxName.match(/^_set([a-zA-Z]*)Attr$/)) && attrs[1]){
				r.push(attrs[1].charAt(0).toLowerCase() + attrs[1].substr(1));
			}
		}
		_attrReg[dc] = r;
	}
	return _attrReg[dc]||[];
}

dojo.declare("dijit._Widget", null, {
	// summary:
	//		Base class for all dijit widgets. 	

	// id: [const] String
	//		A unique, opaque ID string that can be assigned by users or by the
	//		system. If the developer passes an ID which is known not to be
	//		unique, the specified ID is ignored and the system-generated ID is
	//		used instead.
	id: "",

	// lang: [const] String
	//		Rarely used.  Overrides the default Dojo locale used to render this widget,
	//		as defined by the [HTML LANG](http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang) attribute.
	//		Value must be among the list of locales specified during by the Dojo bootstrap,
	//		formatted according to [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt) (like en-us).
	lang: "",

	// dir: [const] String
	//		Unsupported by Dijit, but here for completeness.  Dijit only supports setting text direction on the
	//		entire document.
	//		Bi-directional support, as defined by the [HTML DIR](http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir)
	//		attribute. Either left-to-right "ltr" or right-to-left "rtl".
	dir: "",

	// class: String
	//		HTML class attribute
	"class": "",

	// style: String||Object
	//		HTML style attributes as cssText string or name/value hash
	style: "",

	// title: String
	//		HTML title attribute, used to specify the title of tabs, accordion panes, etc.
	title: "",

	// srcNodeRef: [readonly] DomNode
	//		pointer to original dom node
	srcNodeRef: null,

	// domNode: [readonly] DomNode
	//		This is our visible representation of the widget! Other DOM
	//		Nodes may by assigned to other properties, usually through the
	//		template system's dojoAttachPoint syntax, but the domNode
	//		property is the canonical "top level" node in widget UI.
	domNode: null,

	// containerNode: [readonly] DomNode
	//		Designates where children of the source dom node will be placed.
	//		"Children" in this case refers to both dom nodes and widgets.
	//		For example, for myWidget:
	//
	//		|	<div dojoType=myWidget>
	//		|		<b> here's a plain dom node
	//		|		<span dojoType=subWidget>and a widget</span>
	//		|		<i> and another plain dom node </i>
	//		|	</div>
	//
	//		containerNode would point to:
	//
	//		|		<b> here's a plain dom node
	//		|		<span dojoType=subWidget>and a widget</span>
	//		|		<i> and another plain dom node </i>
	//
	//		In templated widgets, "containerNode" is set via a
	//		dojoAttachPoint assignment.
	//
	//		containerNode must be defined for any widget that accepts innerHTML
	//		(like ContentPane or BorderContainer or even Button), and conversely
	//		is null for widgets that don't, like TextBox.
	containerNode: null,

	// attributeMap: [protected] Object
	//		attributeMap sets up a "binding" between attributes (aka properties)
	//		of the widget and the widget's DOM.
	//		Changes to widget attributes listed in attributeMap will be 
	//		reflected into the DOM.
	//
	//		For example, calling attr('title', 'hello')
	//		on a TitlePane will automatically cause the TitlePane's DOM to update
	//		with the new title.
	//
	//		attributeMap is a hash where the key is an attribute of the widget,
	//		and the value reflects a binding to a:
	//
	//		- DOM node attribute
	// |		focus: {node: "focusNode", type: "attribute"}
	// 		Maps this.focus to this.focusNode.focus
	//
	//		- DOM node innerHTML
	//	|		title: { node: "titleNode", type: "innerHTML" }
	//		Maps this.title to this.titleNode.innerHTML
	//
	//		- DOM node CSS class
	// |		myClass: { node: "domNode", type: "class" }
	//		Maps this.myClass to this.domNode.className
	//
	//		If the value is an array, then each element in the array matches one of the
	//		formats of the above list.
	//
	//		There are also some shorthands for backwards compatibility:
	//		- string --> { node: string, type: "attribute" }, for example:
	//	|	"focusNode" ---> { node: "focusNode", type: "attribute" }
	//		- "" --> { node: "domNode", type: "attribute" }
	attributeMap: {id:"", dir:"", lang:"", "class":"", style:"", title:""},

	// _deferredConnects: [protected] Object
	//		attributeMap addendum for event handlers that should be connected only on first use
	_deferredConnects: {
		onClick: "",
		onDblClick: "",
		onKeyDown: "",
		onKeyPress: "",
		onKeyUp: "",
		onMouseMove: "",
		onMouseDown: "",
		onMouseOut: "",
		onMouseOver: "",
		onMouseLeave: "",
		onMouseEnter: "",
		onMouseUp: ""},

	onClick: dijit._connectOnUseEventHandler,
	/*=====
	onClick: function(event){
		// summary: 
		//		Connect to this function to receive notifications of mouse click events.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onDblClick: dijit._connectOnUseEventHandler,
	/*=====
	onDblClick: function(event){
		// summary: 
		//		Connect to this function to receive notifications of mouse double click events.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onKeyDown: dijit._connectOnUseEventHandler,
	/*=====
	onKeyDown: function(event){
		// summary: 
		//		Connect to this function to receive notifications of keys being pressed down.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onKeyPress: dijit._connectOnUseEventHandler,
	/*=====
	onKeyPress: function(event){
		// summary: 
		//		Connect to this function to receive notifications of printable keys being typed.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onKeyUp: dijit._connectOnUseEventHandler,
	/*=====
	onKeyUp: function(event){
		// summary: 
		//		Connect to this function to receive notifications of keys being released.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onMouseDown: dijit._connectOnUseEventHandler,
	/*=====
	onMouseDown: function(event){
		// summary: 
		//		Connect to this function to receive notifications of when the mouse button is pressed down.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseMove: dijit._connectOnUseEventHandler,
	/*=====
	onMouseMove: function(event){
		// summary: 
		//		Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseOut: dijit._connectOnUseEventHandler,
	/*=====
	onMouseOut: function(event){
		// summary: 
		//		Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseOver: dijit._connectOnUseEventHandler,
	/*=====
	onMouseOver: function(event){
		// summary: 
		//		Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseLeave: dijit._connectOnUseEventHandler,
	/*=====
	onMouseLeave: function(event){
		// summary: 
		//		Connect to this function to receive notifications of when the mouse moves off of this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseEnter: dijit._connectOnUseEventHandler,
	/*=====
	onMouseEnter: function(event){
		// summary: 
		//		Connect to this function to receive notifications of when the mouse moves onto this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseUp: dijit._connectOnUseEventHandler,
	/*=====
	onMouseUp: function(event){
		// summary: 
		//		Connect to this function to receive notifications of when the mouse button is released.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/

	// Constants used in templates
	
	// _blankGif: [protected] URL
	//		Used by <img> nodes in templates that really get there image via CSS background-image
	_blankGif: (dojo.config.blankGif || dojo.moduleUrl("dojo", "resources/blank.gif")),

	//////////// INITIALIZATION METHODS ///////////////////////////////////////

	postscript: function(/*Object?*/params, /*DomNode|String*/srcNodeRef){
		// summary:
		//		Kicks off widget instantiation.  See create() for details.
		// tags:
		//		private
		this.create(params, srcNodeRef);
	},

	create: function(/*Object?*/params, /*DomNode|String?*/srcNodeRef){
		// summary:
		//		Kick off the life-cycle of a widget
		// params:
		//		Hash of initialization parameters for widget, including
		//		scalar values (like title, duration etc.) and functions,
		//		typically callbacks like onClick.
		// srcNodeRef:
		//		If a srcNodeRef (dom node) is specified:
		//			- use srcNodeRef.innerHTML as my contents
		//			- if this is a behavioral widget then apply behavior
		//			  to that srcNodeRef 
		//			- otherwise, replace srcNodeRef with my generated DOM
		//			  tree
		// description:
		//		To understand the process by which widgets are instantiated, it
		//		is critical to understand what other methods create calls and
		//		which of them you'll want to override. Of course, adventurous
		//		developers could override create entirely, but this should
		//		only be done as a last resort.
		//
		//		Below is a list of the methods that are called, in the order
		//		they are fired, along with notes about what they do and if/when
		//		you should over-ride them in your widget:
		//
		// * postMixInProperties:
		//	|	* a stub function that you can over-ride to modify
		//		variables that may have been naively assigned by
		//		mixInProperties
		// * widget is added to manager object here
		// * buildRendering:
		//	|	* Subclasses use this method to handle all UI initialization
		//		Sets this.domNode.  Templated widgets do this automatically
		//		and otherwise it just uses the source dom node.
		// * postCreate:
		//	|	* a stub function that you can over-ride to modify take
		//		actions once the widget has been placed in the UI
		// tags:
		//		private

		// store pointer to original dom tree
		this.srcNodeRef = dojo.byId(srcNodeRef);

		// For garbage collection.  An array of handles returned by Widget.connect()
		// Each handle returned from Widget.connect() is an array of handles from dojo.connect()
		this._connects = [];

		// To avoid double-connects, remove entries from _deferredConnects
		// that have been setup manually by a subclass (ex, by dojoAttachEvent).
		// If a subclass has redefined a callback (ex: onClick) then assume it's being
		// connected to manually.
		this._deferredConnects = dojo.clone(this._deferredConnects);
		for(var attr in this.attributeMap){
			delete this._deferredConnects[attr]; // can't be in both attributeMap and _deferredConnects
		}
		for(attr in this._deferredConnects){
			if(this[attr] !== dijit._connectOnUseEventHandler){
				delete this._deferredConnects[attr];	// redefined, probably dojoAttachEvent exists
			}
		}

		//mixin our passed parameters
		if(this.srcNodeRef && (typeof this.srcNodeRef.id == "string")){ this.id = this.srcNodeRef.id; }
		if(params){
			this.params = params;
			dojo.mixin(this,params);
		}
		this.postMixInProperties();

		// generate an id for the widget if one wasn't specified
		// (be sure to do this before buildRendering() because that function might
		// expect the id to be there.)
		if(!this.id){
			this.id = dijit.getUniqueId(this.declaredClass.replace(/\./g,"_"));
		}
		dijit.registry.add(this);

		this.buildRendering();

		if(this.domNode){
			// Copy attributes listed in attributeMap into the [newly created] DOM for the widget.
			this._applyAttributes();

			var source = this.srcNodeRef;
			if(source && source.parentNode){
				source.parentNode.replaceChild(this.domNode, source);
			}

			// If the developer has specified a handler as a widget parameter
			// (ex: new Button({onClick: ...})
			// then naturally need to connect from dom node to that handler immediately, 
			for(attr in this.params){
				this._onConnect(attr);
			}
		}
		
		if(this.domNode){
			this.domNode.setAttribute("widgetId", this.id);
		}
		this.postCreate();

		// If srcNodeRef has been processed and removed from the DOM (e.g. TemplatedWidget) then delete it to allow GC.
		if(this.srcNodeRef && !this.srcNodeRef.parentNode){
			delete this.srcNodeRef;
		}	

		this._created = true;
	},

	_applyAttributes: function(){
		// summary:
		//		Step during widget creation to copy all widget attributes to the
		//		DOM as per attributeMap and _setXXXAttr functions.
		// description:
		//		Skips over blank/false attribute values, unless they were explicitly specified
		//		as parameters to the widget, since those are the default anyway,
		//		and setting tabIndex="" is different than not setting tabIndex at all.
		//
		//		It processes the attributes in the attribute map first, and then
		//		it goes through and processes the attributes for the _setXXXAttr
		//		functions that have been specified
		// tags:
		//		private
		var condAttrApply = function(attr, scope){
			if( (scope.params && attr in scope.params) || scope[attr]){
				scope.attr(attr, scope[attr]);
			}
		};
		for(var attr in this.attributeMap){
			condAttrApply(attr, this);
		}
		dojo.forEach(getAttrReg(this.declaredClass), function(a){
			if(!(a in this.attributeMap)){
				condAttrApply(a, this);
			}
		}, this);
	},

	postMixInProperties: function(){
		// summary:
		//		Called after the parameters to the widget have been read-in,
		//		but before the widget template is instantiated. Especially
		//		useful to set properties that are referenced in the widget
		//		template.
		// tags:
		//		protected
	},

	buildRendering: function(){
		// summary:
		//		Construct the UI for this widget, setting this.domNode.  Most
		//		widgets will mixin `dijit._Templated`, which implements this
		//		method.
		// tags:
		//		protected
		this.domNode = this.srcNodeRef || dojo.create('div');
	},

	postCreate: function(){
		// summary:
		//		Called after a widget's dom has been setup
		// tags:
		//		protected
	},

	startup: function(){
		// summary:
		//		Called after a widget's children, and other widgets on the page, have been created.
		//		Provides an opportunity to manipulate any children before they are displayed.
		//		This is useful for composite widgets that need to control or layout sub-widgets.
		//		Many layout widgets can use this as a wiring phase.
		this._started = true;
	},

	//////////// DESTROY FUNCTIONS ////////////////////////////////

	destroyRecursive: function(/*Boolean?*/ preserveDom){
		// summary:
		// 		Destroy this widget and it's descendants. This is the generic
		// 		"destructor" function that all widget users should call to
		// 		cleanly discard with a widget. Once a widget is destroyed, it's
		// 		removed from the manager object.
		// preserveDom:
		//		If true, this method will leave the original Dom structure
		//		alone of descendant Widgets. Note: This will NOT work with
		//		dijit._Templated widgets.

		this.destroyDescendants(preserveDom);
		this.destroy(preserveDom);
	},

	destroy: function(/*Boolean*/ preserveDom){
		// summary:
		// 		Destroy this widget, but not its descendants.
		//		Will, however, destroy internal widgets such as those used within a template.
		// preserveDom: Boolean
		//		If true, this method will leave the original Dom structure alone.
		//		Note: This will not yet work with _Templated widgets

		this.uninitialize();
		dojo.forEach(this._connects, function(array){
			dojo.forEach(array, dojo.disconnect);
		});

		// destroy widgets created as part of template, etc.
		dojo.forEach(this._supportingWidgets||[], function(w){ 
			if(w.destroy){
				w.destroy();
			}
		});
		
		this.destroyRendering(preserveDom);
		dijit.registry.remove(this.id);
	},

	destroyRendering: function(/*Boolean?*/ preserveDom){
		// summary:
		//		Destroys the DOM nodes associated with this widget
		// preserveDom:
		//		If true, this method will leave the original Dom structure alone
		//		during tear-down. Note: this will not work with _Templated
		//		widgets yet. 
		// tags:
		//		protected

		if(this.bgIframe){
			this.bgIframe.destroy(preserveDom);
			delete this.bgIframe;
		}

		if(this.domNode){
			if(preserveDom){
				dojo.removeAttr(this.domNode, "widgetId");
			}else{
				dojo.destroy(this.domNode);
			}
			delete this.domNode;
		}

		if(this.srcNodeRef){
			if(!preserveDom){
				dojo.destroy(this.srcNodeRef);
			}
			delete this.srcNodeRef;
		}
	},

	destroyDescendants: function(/*Boolean?*/ preserveDom){
		// summary:
		//		Recursively destroy the children of this widget and their
		//		descendants.
		// preserveDom:
		//		If true, the preserveDom attribute is passed to all descendant
		//		widget's .destroy() method. Not for use with _Templated
		//		widgets.

		// get all direct descendants and destroy them recursively
		dojo.forEach(this.getChildren(), function(widget){ 
			if(widget.destroyRecursive){
				widget.destroyRecursive(preserveDom);
			}
		});
	},


	uninitialize: function(){
		// summary:
		//		Stub function. Override to implement custom widget tear-down
		//		behavior.
		// tags:
		//		protected
		return false;
	},

	////////////////// MISCELLANEOUS METHODS ///////////////////

	onFocus: function(){
		// summary:
		//		Called when the widget becomes "active" because
		//		it or a widget inside of it either has focus, or has recently
		//		been clicked.
		// tags:
		//		callback
	},

	onBlur: function(){
		// summary:
		//		Called when the widget stops being "active" because
		//		focus moved to something outside of it, or the user
		//		clicked somewhere outside of it, or the widget was
		//		hidden.
		// tags:
		//		callback
	},

	_onFocus: function(e){
		// summary:
		//		This is where widgets do processing for when they are active,
		//		such as changing CSS classes.  See onFocus() for more details.
		// tags:
		//		protected
		this.onFocus();
	},

	_onBlur: function(){
		// summary:
		//		This is where widgets do processing for when they stop being active,
		//		such as changing CSS classes.  See onBlur() for more details.
		// tags:
		//		protected
		this.onBlur();
	},

	_onConnect: function(/*String*/ event){
		// summary:
		//		Called when someone connects to one of my handlers.
		//		"Turn on" that handler if it isn't active yet.
		//
		//		This is also called for every single initialization parameter
		//		so need to do nothing for parameters like "id".
		// tags:
		//		private
		if(event in this._deferredConnects){
			var mapNode = this[this._deferredConnects[event]||'domNode'];
			this.connect(mapNode, event.toLowerCase(), event);
			delete this._deferredConnects[event];
		}
	},

	_setClassAttr: function(/*String*/ value){
		// summary:
		//		Custom setter for the CSS "class" attribute
		// tags:
		//		protected
		var mapNode = this[this.attributeMap["class"]||'domNode'];
		dojo.removeClass(mapNode, this["class"])
		this["class"] = value;
		dojo.addClass(mapNode, value);
	},

	_setStyleAttr: function(/*String||Object*/ value){
		// summary:
		//		Sets the style attribut of the widget according to value,
		//		which is either a hash like {height: "5px", width: "3px"}
		//		or a plain string
		// description:
		//		Determines which node to set the style on based on style setting
		//		in attributeMap.
		// tags:
		//		protected

		var mapNode = this[this.attributeMap["style"]||'domNode'];
		
		// Note: technically we should revert any style setting made in a previous call
		// to his method, but that's difficult to keep track of.

		if(dojo.isObject(value)){
			dojo.style(mapNode, value);
		}else{
			if(mapNode.style.cssText){
				mapNode.style.cssText += "; " + value;
			}else{
				mapNode.style.cssText = value;
			}
		}

		this["style"] = value;
	},

	setAttribute: function(/*String*/ attr, /*anything*/ value){
		// summary:
		//		Deprecated.  Use attr() instead.
		// tags:
		//		deprecated
		dojo.deprecated(this.declaredClass+"::setAttribute() is deprecated. Use attr() instead.", "", "2.0");
		this.attr(attr, value);
	},
	
	_attrToDom: function(/*String*/ attr, /*String*/ value){
		// summary:
		//		Reflect a widget attribute (title, tabIndex, duration etc.) to
		//		the widget DOM, as specified in attributeMap.
		//
		// description:
		//		Also sets this["attr"] to the new value.
		//		Note some attributes like "type"
		//		cannot be processed this way as they are not mutable.
		//
		// tags:
		//		private

		var commands = this.attributeMap[attr];
		dojo.forEach( dojo.isArray(commands) ? commands : [commands], function(command){

			// Get target node and what we are doing to that node
			var mapNode = this[command.node || command || "domNode"];	// DOM node
			var type = command.type || "attribute";	// class, innerHTML, or attribute
	
			switch(type){
				case "attribute":
					if(dojo.isFunction(value)){ // functions execute in the context of the widget
						value = dojo.hitch(this, value);
					}
					if(/^on[A-Z][a-zA-Z]*$/.test(attr)){ // eg. onSubmit needs to be onsubmit
						attr = attr.toLowerCase();
					}
					dojo.attr(mapNode, attr, value);
					break;
				case "innerHTML":
					mapNode.innerHTML = value;
					break;
				case "class":
					dojo.removeClass(mapNode, this[attr]);
					dojo.addClass(mapNode, value);
					break;
			}
		}, this);
		this[attr] = value;
	},

	attr: function(/*String|Object*/name, /*Object?*/value){
		//	summary:
		//		Set or get properties on a widget instance.
		//	name:
		//		The property to get or set. If an object is passed here and not
		//		a string, its keys are used as names of attributes to be set
		//		and the value of the object as values to set in the widget.
		//	value:
		//		Optional. If provided, attr() operates as a setter. If omitted,
		//		the current value of the named property is returned.
		//	description:
		//		Get or set named properties on a widget. If no value is
		//		provided, the current value of the attribute is returned,
		//		potentially via a getter method. If a value is provided, then
		//		the method acts as a setter, assigning the value to the name,
		//		potentially calling any explicitly provided setters to handle
		//		the operation. For instance, if the widget has properties "foo"
		//		and "bar" and a method named "_setFooAttr", calling:
		//	|	myWidget.attr("foo", "Howdy!");
		//		would be equivalent to calling:
		//	|	widget._setFooAttr("Howdy!");
		//		while calling:
		//	|	myWidget.attr("bar", "Howdy!");
		//		would be the same as writing:
		//	|	widget.bar = "Howdy!";
		//		It also tries to copy the changes to the widget's DOM according
		//		to settings in attributeMap (see description of `dijit._Widget.attributeMap`
		//		for details)
		//		For example, calling:
		//	|	myTitlePane.attr("title", "Howdy!");
		//		will do
		//	|	myTitlePane.title = "Howdy!";
		//	|	myTitlePane.title.innerHTML = "Howdy!";
		//		It works for dom node attributes too.  Calling
		//	|	widget.attr("disabled", true)
		//		will set the disabled attribute on the widget's focusNode,
		//		among other housekeeping for a change in disabled state.

		//	open questions:
		//		- how to handle build shortcut for attributes which want to map
		//		into DOM attributes?
		//		- what relationship should setAttribute()/attr() have to
		//		layout() calls?
		var args = arguments.length;
		if(args == 1 && !dojo.isString(name)){
			for(var x in name){ this.attr(x, name[x]); }
			return this;
		}
		var names = this._getAttrNames(name);
		if(args == 2){ // setter
			if(this[names.s]){
				// use the explicit setter
				return this[names.s](value) || this;
			}else{
				// if param is specified as DOM node attribute, copy it
				if(name in this.attributeMap){
					this._attrToDom(name, value);
				}

				// FIXME: what about function assignments? Any way to connect() here?
				this[name] = value;
			}
			return this;
		}else{ // getter
			if(this[names.g]){
				return this[names.g]();
			}else{
				return this[name];
			}
		}
	},

	_attrPairNames: {},		// shared between all widgets
	_getAttrNames: function(name){
		// summary:
		//		Helper function for Widget.attr().
		//		Caches attribute name values so we don't do the string ops every time.
		// tags:
		//		private

		var apn = this._attrPairNames;
		if(apn[name]){ return apn[name]; }
		var uc = name.charAt(0).toUpperCase() + name.substr(1);
		return apn[name] = {
			n: name+"Node",
			s: "_set"+uc+"Attr",
			g: "_get"+uc+"Attr"
		};
	},

	toString: function(){
		// summary:
		//		Returns a string that represents the widget. When a widget is
		//		cast to a string, this method will be used to generate the
		//		output. Currently, it does not implement any sort of reversable
		//		serialization.
		return '[Widget ' + this.declaredClass + ', ' + (this.id || 'NO ID') + ']'; // String
	},

	getDescendants: function(){
		// summary:
		//		Returns all the widgets that contained by this, i.e., all widgets underneath this.containerNode.
		//		This method should generally be avoided as it returns widgets declared in templates, which are
		//		supposed to be internal/hidden, but it's left here for back-compat reasons.

		if(this.containerNode){
			var list = dojo.query('[widgetId]', this.containerNode);
			return list.map(dijit.byNode);		// Array
		}else{
			return [];
		}
	},

	getChildren: function(){
		// summary:
		//		Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
		//		Does not return nested widgets, nor widgets that are part of this widget's template.
		if(this.containerNode){
			return dijit.findWidgets(this.containerNode);
		}else{
			return [];
		}
	},

	// nodesWithKeyClick: [private] String[]
	//		List of nodes that correctly handle click events via native browser support,
	//		and don't need dijit's help
	nodesWithKeyClick: ["input", "button"],

	connect: function(
			/*Object|null*/ obj,
			/*String|Function*/ event,
			/*String|Function*/ method){
		// summary:
		//		Connects specified obj/event to specified method of this object
		//		and registers for disconnect() on widget destroy.
		// description:
		//		Provide widget-specific analog to dojo.connect, except with the
		//		implicit use of this widget as the target object.
		//		This version of connect also provides a special "ondijitclick"
		//		event which triggers on a click or space or enter keyup
		// example:
		//	|	var btn = new dijit.form.Button();
		//	|	// when foo.bar() is called, call the listener we're going to
		//	|	// provide in the scope of btn
		//	|	btn.connect(foo, "bar", function(){ 
		//	|		console.debug(this.toString());
		//	|	});
		// tags:
		//		protected

		var d = dojo;
		var dc = dojo.connect;
		var handles =[];
		if(event == "ondijitclick"){
			// add key based click activation for unsupported nodes.
			// do all processing onkey up to prevent spurious clicks
			// for details see comments at top of this file where _lastKeyDownNode is defined
			if(!this.nodesWithKeyClick[obj.tagName.toLowerCase()]){
				var m = d.hitch(this, method);
				handles.push(
					dc(obj, "onkeydown", this, function(e){
						//console.log(this.id + ": onkeydown, e.target = ", e.target, ", lastKeyDownNode was ", dijit._lastKeyDownNode, ", equality is ", (e.target === dijit._lastKeyDownNode));
						if((e.keyCode == d.keys.ENTER || e.keyCode == d.keys.SPACE) &&
							!e.ctrlKey && !e.shiftKey && !e.altKey && !e.metaKey){
							// needed on IE for when focus changes between keydown and keyup - otherwise dropdown menus do not work
							dijit._lastKeyDownNode = e.target;
							d.stopEvent(e);		// stop event to prevent scrolling on space key in IE
						}
			 		}),
					dc(obj, "onkeyup", this, function(e){
						//console.log(this.id + ": onkeyup, e.target = ", e.target, ", lastKeyDownNode was ", dijit._lastKeyDownNode, ", equality is ", (e.target === dijit._lastKeyDownNode));
						if( (e.keyCode == d.keys.ENTER || e.keyCode == d.keys.SPACE) &&
							e.target === dijit._lastKeyDownNode &&
							!e.ctrlKey && !e.shiftKey && !e.altKey && !e.metaKey){
								//need reset here or have problems in FF when focus returns to trigger element after closing popup/alert
								dijit._lastKeyDownNode = null;  
								return m(e);
						}
					})
				);
			}
			event = "onclick";
		}
		handles.push(dc(obj, event, this, method));

		// return handles for FormElement and ComboBox
		this._connects.push(handles);
		return handles;
	},

	disconnect: function(/*Object*/ handles){
		// summary:
		//		Disconnects handle created by this.connect.
		//		Also removes handle from this widget's list of connects
		// tags:
		//		protected
		for(var i=0; i<this._connects.length; i++){
			if(this._connects[i]==handles){
				dojo.forEach(handles, dojo.disconnect);
				this._connects.splice(i, 1);
				return;
			}
		}
	},

	isLeftToRight: function(){
		// summary:
		//		Checks the page for text direction
		// tags:
		//		protected
		return dojo._isBodyLtr(); //Boolean
	},

	isFocusable: function(){
		// summary:
		//		Return true if this widget can currently be focused
		//		and false if not
		return this.focus && (dojo.style(this.domNode, "display") != "none");
	},
	
	placeAt: function(/* String|DomNode|_Widget */reference, /* String?|Int? */position){
		// summary:
		//		Place this widget's domNode reference somewhere in the DOM based
		//		on standard dojo.place conventions, or passing a Widget reference that
		//		contains and addChild member.
		//
		// description:
		//		A convenience function provided in all _Widgets, providing a simple
		//		shorthand mechanism to put an existing (or newly created) Widget
		//		somewhere in the dom, and allow chaining.
		//
		// reference: 
		//		The String id of a domNode, a domNode reference, or a reference to a Widget posessing 
		//		an addChild method.
		//
		// position: 
		//		If passed a string or domNode reference, the position argument
		//		accepts a string just as dojo.place does, one of: "first", "last", 
		//		"before", or "after". 
		//
		//		If passed a _Widget reference, and that widget reference has an ".addChild" method, 
		//		it will be called passing this widget instance into that method, supplying the optional
		//		position index passed.
		//
		// returns: dijit._Widget
		//		Provides a useful return of the newly created dijit._Widget instance so you 
		//		can "chain" this function by instantiating, placing, then saving the return value
		//		to a variable. 
		//
		// example:
		// | 	// create a Button with no srcNodeRef, and place it in the body:
		// | 	var button = new dijit.form.Button({ label:"click" }).placeAt(dojo.body());
		// | 	// now, 'button' is still the widget reference to the newly created button
		// | 	dojo.connect(button, "onClick", function(e){ console.log('click'); });
		//
		// example:
		// |	// create a button out of a node with id="src" and append it to id="wrapper":
		// | 	var button = new dijit.form.Button({},"src").placeAt("wrapper");
		//
		// example:
		// |	// place a new button as the first element of some div
		// |	var button = new dijit.form.Button({ label:"click" }).placeAt("wrapper","first");
		//
		// example: 
		// |	// create a contentpane and add it to a TabContainer
		// |	var tc = dijit.byId("myTabs");
		// |	new dijit.layout.ContentPane({ href:"foo.html", title:"Wow!" }).placeAt(tc)

		if(reference["declaredClass"] && reference["addChild"]){
			reference.addChild(this, position);
		}else{
			dojo.place(this.domNode, reference, position);
		}
		return this;
	}

});

})();

}

if(!dojo._hasResource["dijit._Container"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._Container"] = true;
dojo.provide("dijit._Container");

dojo.declare("dijit._Container",
	null,
	{
		// summary:
		//		Mixin for widgets that contain a set of widget children.
		// description:
		//		Use this mixin for widgets that needs to know about and
		//		keep track of their widget children. Suitable for widgets like BorderContainer
		//		and TabContainer which contain (only) a set of child widgets.
		//
		//		It's not suitable for widgets like ContentPane
		//		which contains mixed HTML (plain DOM nodes in addition to widgets),
		//		and where contained widgets are not necessarily directly below
		//		this.containerNode.   In that case calls like addChild(node, position)
		//		wouldn't make sense.

		// isContainer: [protected] Boolean
		//		Just a flag indicating that this widget descends from dijit._Container
		isContainer: true,

		buildRendering: function(){
			this.inherited(arguments);
			if(!this.containerNode){
				// all widgets with descendants must set containerNode
   				this.containerNode = this.domNode;
			}
		},

		addChild: function(/*Widget*/ widget, /*int?*/ insertIndex){
			// summary:
			//		Makes the given widget a child of this widget.
			// description:
			//		Inserts specified child widget's dom node as a child of this widget's
			//		container node, and possibly does other processing (such as layout).

			var refNode = this.containerNode;
			if(insertIndex && typeof insertIndex == "number"){
				var children = this.getChildren();
				if(children && children.length >= insertIndex){
					refNode = children[insertIndex-1].domNode;
					insertIndex = "after";
				}
			}
			dojo.place(widget.domNode, refNode, insertIndex);

			// If I've been started but the child widget hasn't been started,
			// start it now.  Make sure to do this after widget has been
			// inserted into the DOM tree, so it can see that it's being controlled by me,
			// so it doesn't try to size itself.
			if(this._started && !widget._started){
				widget.startup();
			}
		},

		removeChild: function(/*Widget or int*/ widget){
			// summary:
			//		Removes the passed widget instance from this widget but does
			//		not destroy it.  You can also pass in an integer indicating
			//		the index within the container to remove
			if(typeof widget == "number" && widget > 0){
				widget = this.getChildren()[widget];
			}
			// If we cannot find the widget, just return
			if(!widget || !widget.domNode){ return; }
			
			var node = widget.domNode;
			node.parentNode.removeChild(node);	// detach but don't destroy
		},

		_nextElement: function(node){
			// summary:
			//      Find the next (non-text, non-comment etc) node
			// tags:
			//      private
			do{
				node = node.nextSibling;
			}while(node && node.nodeType != 1);
			return node;
		},

		_firstElement: function(node){
			// summary:
			//      Find the first (non-text, non-comment etc) node
			// tags:
			//      private
			node = node.firstChild;
			if(node && node.nodeType != 1){
				node = this._nextElement(node);
			}
			return node;
		},

		getChildren: function(){
			// summary:
			//		Returns array of children widgets.
			// description:
			//		Returns the widgets that are directly under this.containerNode.
			return dojo.query("> [widgetId]", this.containerNode).map(dijit.byNode); // Widget[]
		},

		hasChildren: function(){
			// summary:
			//		Returns true if widget has children, i.e. if this.containerNode contains something.
			return !!this._firstElement(this.containerNode); // Boolean
		},

		destroyDescendants: function(/*Boolean*/ preserveDom){
			// summary:
			//      Destroys all the widgets inside this.containerNode,
			//      but not this widget itself
			dojo.forEach(this.getChildren(), function(child){ child.destroyRecursive(preserveDom); });
		},
	
		_getSiblingOfChild: function(/*Widget*/ child, /*int*/ dir){
			// summary:
			//		Get the next or previous widget sibling of child
			// dir:
			//		if 1, get the next sibling
			//		if -1, get the previous sibling
			// tags:
			//      private
			var node = child.domNode;
			var which = (dir>0 ? "nextSibling" : "previousSibling");
			do{
				node = node[which];
			}while(node && (node.nodeType != 1 || !dijit.byNode(node)));
			return node ? dijit.byNode(node) : null;
		},
		
		getIndexOfChild: function(/*Widget*/ child){
			// summary:
			//		Gets the index of the child in this container or -1 if not found
			var children = this.getChildren();
			for(var i=0, c; c=children[i]; i++){
				if(c == child){ 
					return i; // int
				}
			}
			return -1; // int
		}
	}
);

}

if(!dojo._hasResource["dojo.string"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.string"] = true;
dojo.provide("dojo.string");

/*=====
dojo.string = { 
	// summary: String utilities for Dojo
};
=====*/

dojo.string.rep = function(/*String*/str, /*Integer*/num){
	//	summary:
	//		Efficiently replicate a string `n` times.
	//	str:
	//		the string to replicate
	//	num:
	//		number of times to replicate the string
	
	if(num <= 0 || !str){ return ""; }
	
	var buf = [];
	for(;;){
		if(num & 1){
			buf.push(str);
		}
		if(!(num >>= 1)){ break; }
		str += str;
	}
	return buf.join("");	// String
};

dojo.string.pad = function(/*String*/text, /*Integer*/size, /*String?*/ch, /*Boolean?*/end){
	//	summary:
	//		Pad a string to guarantee that it is at least `size` length by
	//		filling with the character `ch` at either the start or end of the
	//		string. Pads at the start, by default.
	//	text:
	//		the string to pad
	//	size:
	//		length to provide padding
	//	ch:
	//		character to pad, defaults to '0'
	//	end:
	//		adds padding at the end if true, otherwise pads at start
	//	example:
	//	|	// Fill the string to length 10 with "+" characters on the right.  Yields "Dojo++++++".
	//	|	dojo.string.pad("Dojo", 10, "+", true);

	if(!ch){
		ch = '0';
	}
	var out = String(text),
		pad = dojo.string.rep(ch, Math.ceil((size - out.length) / ch.length));
	return end ? out + pad : pad + out;	// String
};

dojo.string.substitute = function(	/*String*/		template, 
									/*Object|Array*/map, 
									/*Function?*/	transform, 
									/*Object?*/		thisObject){
	//	summary:
	//		Performs parameterized substitutions on a string. Throws an
	//		exception if any parameter is unmatched.
	//	template: 
	//		a string with expressions in the form `${key}` to be replaced or
	//		`${key:format}` which specifies a format function. keys are case-sensitive. 
	//	map:
	//		hash to search for substitutions
	//	transform: 
	//		a function to process all parameters before substitution takes
	//		place, e.g. dojo.string.encodeXML
	//	thisObject: 
	//		where to look for optional format function; default to the global
	//		namespace
	//	example:
	//	|	// returns "File 'foo.html' is not found in directory '/temp'."
	//	|	dojo.string.substitute(
	//	|		"File '${0}' is not found in directory '${1}'.",
	//	|		["foo.html","/temp"]
	//	|	);
	//	|
	//	|	// also returns "File 'foo.html' is not found in directory '/temp'."
	//	|	dojo.string.substitute(
	//	|		"File '${name}' is not found in directory '${info.dir}'.",
	//	|		{ name: "foo.html", info: { dir: "/temp" } }
	//	|	);
	//	example:
	//		use a transform function to modify the values:
	//	|	// returns "file 'foo.html' is not found in directory '/temp'."
	//	|	dojo.string.substitute(
	//	|		"${0} is not found in ${1}.",
	//	|		["foo.html","/temp"],
	//	|		function(str){
	//	|			// try to figure out the type
	//	|			var prefix = (str.charAt(0) == "/") ? "directory": "file";
	//	|			return prefix + " '" + str + "'";
	//	|		}
	//	|	);
	//	example:
	//		use a formatter
	//	|	// returns "thinger -- howdy"
	//	|	dojo.string.substitute(
	//	|		"${0:postfix}", ["thinger"], null, {
	//	|			postfix: function(value, key){
	//	|				return value + " -- howdy";
	//	|			}
	//	|		}
	//	|	);

	thisObject = thisObject||dojo.global;
	transform = (!transform) ? 
					function(v){ return v; } : 
					dojo.hitch(thisObject, transform);

	return template.replace(/\$\{([^\s\:\}]+)(?:\:([^\s\:\}]+))?\}/g, function(match, key, format){
		var value = dojo.getObject(key, false, map);
		if(format){
			value = dojo.getObject(format, false, thisObject).call(thisObject, value, key);
		}
		return transform(value, key).toString();
	}); // string
};

/*=====
dojo.string.trim = function(str){
	//	summary:
	//		Trims whitespace from both sides of the string
	//	str: String
	//		String to be trimmed
	//	returns: String
	//		Returns the trimmed string
	//	description:
	//		This version of trim() was taken from [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript).
	//		The short yet performant version of this function is dojo.trim(),
	//		which is part of Dojo base.  Uses String.prototype.trim instead, if available.
	return "";	// String
}
=====*/

dojo.string.trim = String.prototype.trim ?
	dojo.trim : // aliasing to the native function
	function(str){
		str = str.replace(/^\s+/, '');
		for(var i = str.length - 1; i >= 0; i--){
			if(/\S/.test(str.charAt(i))){
				str = str.substring(0, i + 1);
				break;
			}
		}
		return str;
	};

}

if(!dojo._hasResource["dijit._Templated"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._Templated"] = true;
dojo.provide("dijit._Templated");





dojo.declare("dijit._Templated",
	null,
	{
		//	summary:
		//		Mixin for widgets that are instantiated from a template
		// 

		// templateString: [protected] String
		//		A string that represents the widget template. Pre-empts the
		//		templatePath. In builds that have their strings "interned", the
		//		templatePath is converted to an inline templateString, thereby
		//		preventing a synchronous network call.
		templateString: null,

		// templatePath: [protected] String
		//		Path to template (HTML file) for this widget relative to dojo.baseUrl
		templatePath: null,

		// widgetsInTemplate: [protected] Boolean
		//		Should we parse the template to find widgets that might be
		//		declared in markup inside it?  False by default.
		widgetsInTemplate: false,

		// skipNodeCache: [protected] Boolean
		//		If using a cached widget template node poses issues for a
		//		particular widget class, it can set this property to ensure
		//		that its template is always re-built from a string
		_skipNodeCache: false,

		_stringRepl: function(tmpl){
			// summary:
			//		Does substitution of ${foo} type properties in template string
			// tags:
			//		private
			var className = this.declaredClass, _this = this;
			// Cache contains a string because we need to do property replacement
			// do the property replacement
			return dojo.string.substitute(tmpl, this, function(value, key){
				if(key.charAt(0) == '!'){ value = dojo.getObject(key.substr(1), false, _this); }
				if(typeof value == "undefined"){ throw new Error(className+" template:"+key); } // a debugging aide
				if(value == null){ return ""; }

				// Substitution keys beginning with ! will skip the transform step,
				// in case a user wishes to insert unescaped markup, e.g. ${!foo}
				return key.charAt(0) == "!" ? value :
					// Safer substitution, see heading "Attribute values" in
					// http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.3.2
					value.toString().replace(/"/g,"&quot;"); //TODO: add &amp? use encodeXML method?
			}, this);
		},

		// method over-ride
		buildRendering: function(){
			// summary:
			//		Construct the UI for this widget from a template, setting this.domNode.
			// tags:
			//		protected

			// Lookup cached version of template, and download to cache if it
			// isn't there already.  Returns either a DomNode or a string, depending on
			// whether or not the template contains ${foo} replacement parameters.
			var cached = dijit._Templated.getCachedTemplate(this.templatePath, this.templateString, this._skipNodeCache);

			var node;
			if(dojo.isString(cached)){
				node = dojo._toDom(this._stringRepl(cached));
			}else{
				// if it's a node, all we have to do is clone it
				node = cached.cloneNode(true);
			}

			this.domNode = node;

			// recurse through the node, looking for, and attaching to, our
			// attachment points and events, which should be defined on the template node.
			this._attachTemplateNodes(node);

			if(this.widgetsInTemplate){
				//Make sure dojoType is used for parsing widgets in template.
				//The dojo.parser.query could be changed from multiversion support.
				var parser = dojo.parser, qry, attr;
				if(parser._query != "[dojoType]"){
					qry = parser._query;
					attr = parser._attrName;
					parser._query = "[dojoType]";
					parser._attrName = "dojoType";
				}

				var cw = (this._supportingWidgets = dojo.parser.parse(node));

				//Restore the query. 
				if(qry){
					parser._query = qry;
					parser._attrName = attr;
				}

				this._attachTemplateNodes(cw, function(n,p){
					return n[p];
				});
			}

			this._fillContent(this.srcNodeRef);
		},

		_fillContent: function(/*DomNode*/ source){
			// summary:
			//		Relocate source contents to templated container node.
			//		this.containerNode must be able to receive children, or exceptions will be thrown.
			// tags:
			//		protected
			var dest = this.containerNode;
			if(source && dest){
				while(source.hasChildNodes()){
					dest.appendChild(source.firstChild);
				}
			}
		},

		_attachTemplateNodes: function(rootNode, getAttrFunc){
			// summary:
			//		Iterate through the template and attach functions and nodes accordingly.	
			// description:		
			//		Map widget properties and functions to the handlers specified in
			//		the dom node and it's descendants. This function iterates over all
			//		nodes and looks for these properties:
			//			* dojoAttachPoint
			//			* dojoAttachEvent	
			//			* waiRole
			//			* waiState
			// rootNode: DomNode|Array[Widgets]
			//		the node to search for properties. All children will be searched.
			// getAttrFunc: Function?
			//		a function which will be used to obtain property for a given
			//		DomNode/Widget
			// tags:
			//		private

			getAttrFunc = getAttrFunc || function(n,p){ return n.getAttribute(p); };

			var nodes = dojo.isArray(rootNode) ? rootNode : (rootNode.all || rootNode.getElementsByTagName("*"));
			var x = dojo.isArray(rootNode) ? 0 : -1;
			for(; x<nodes.length; x++){
				var baseNode = (x == -1) ? rootNode : nodes[x];
				if(this.widgetsInTemplate && getAttrFunc(baseNode, "dojoType")){
					continue;
				}
				// Process dojoAttachPoint
				var attachPoint = getAttrFunc(baseNode, "dojoAttachPoint");
				if(attachPoint){
					var point, points = attachPoint.split(/\s*,\s*/);
					while((point = points.shift())){
						if(dojo.isArray(this[point])){
							this[point].push(baseNode);
						}else{
							this[point]=baseNode;
						}
					}
				}

				// Process dojoAttachEvent
				var attachEvent = getAttrFunc(baseNode, "dojoAttachEvent");
				if(attachEvent){
					// NOTE: we want to support attributes that have the form
					// "domEvent: nativeEvent; ..."
					var event, events = attachEvent.split(/\s*,\s*/);
					var trim = dojo.trim;
					while((event = events.shift())){
						if(event){
							var thisFunc = null;
							if(event.indexOf(":") != -1){
								// oh, if only JS had tuple assignment
								var funcNameArr = event.split(":");
								event = trim(funcNameArr[0]);
								thisFunc = trim(funcNameArr[1]);
							}else{
								event = trim(event);
							}
							if(!thisFunc){
								thisFunc = event;
							}
							this.connect(baseNode, event, thisFunc);
						}
					}
				}

				// waiRole, waiState
				var role = getAttrFunc(baseNode, "waiRole");
				if(role){
					dijit.setWaiRole(baseNode, role);
				}
				var values = getAttrFunc(baseNode, "waiState");
				if(values){
					dojo.forEach(values.split(/\s*,\s*/), function(stateValue){
						if(stateValue.indexOf('-') != -1){
							var pair = stateValue.split('-');
							dijit.setWaiState(baseNode, pair[0], pair[1]);
						}
					});
				}
			}
		}
	}
);

// key is either templatePath or templateString; object is either string or DOM tree
dijit._Templated._templateCache = {};

dijit._Templated.getCachedTemplate = function(templatePath, templateString, alwaysUseString){
	// summary:
	//		Static method to get a template based on the templatePath or
	//		templateString key
	// templatePath: String
	//		The URL to get the template from. dojo.uri.Uri is often passed as well.
	// templateString: String?
	//		a string to use in lieu of fetching the template from a URL. Takes precedence
	//		over templatePath
	// returns: Mixed
	//		Either string (if there are ${} variables that need to be replaced) or just
	//		a DOM tree (if the node can be cloned directly)

	// is it already cached?
	var tmplts = dijit._Templated._templateCache;
	var key = templateString || templatePath;
	var cached = tmplts[key];
	if(cached){
		if(!cached.ownerDocument || cached.ownerDocument == dojo.doc){
			// string or node of the same document
			return cached;
		}
		// destroy the old cached node of a different document
		dojo.destroy(cached);
	}

	// If necessary, load template string from template path
	if(!templateString){
		templateString = dijit._Templated._sanitizeTemplateString(dojo.trim(dojo._getText(templatePath)));
	}

	templateString = dojo.string.trim(templateString);

	if(alwaysUseString || templateString.match(/\$\{([^\}]+)\}/g)){
		// there are variables in the template so all we can do is cache the string
		return (tmplts[key] = templateString); //String
	}else{
		// there are no variables in the template so we can cache the DOM tree
		return (tmplts[key] = dojo._toDom(templateString)); //Node
	}
};

dijit._Templated._sanitizeTemplateString = function(/*String*/tString){
	// summary: 
	//		Strips <?xml ...?> declarations so that external SVG and XML
	// 		documents can be added to a document without worry. Also, if the string
	//		is an HTML document, only the part inside the body tag is returned.
	if(tString){
		tString = tString.replace(/^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im, "");
		var matches = tString.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
		if(matches){
			tString = matches[1];
		}
	}else{
		tString = "";
	}
	return tString; //String
};


if(dojo.isIE){
	dojo.addOnWindowUnload(function(){
		var cache = dijit._Templated._templateCache;
		for(var key in cache){
			var value = cache[key];
			if(!isNaN(value.nodeType)){ // isNode equivalent
				dojo.destroy(value);
			}
			delete cache[key];
		}
	});
}

// These arguments can be specified for widgets which are used in templates.
// Since any widget can be specified as sub widgets in template, mix it
// into the base widget class.  (This is a hack, but it's effective.)
dojo.extend(dijit._Widget,{
	dojoAttachEvent: "",
	dojoAttachPoint: "",
	waiRole: "",
	waiState:""
});

}

if(!dojo._hasResource["dijit.form._FormWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form._FormWidget"] = true;
dojo.provide("dijit.form._FormWidget");




dojo.declare("dijit.form._FormWidget", [dijit._Widget, dijit._Templated],
	{
	//
	// summary:
	//		Base class for widgets corresponding to native HTML elements such as <checkbox> or <button>,
	//		which can be children of a <form> node or a `dijit.form.Form` widget.
	//
	// description:
	//		Represents a single HTML element.
	//		All these widgets should have these attributes just like native HTML input elements.
	//		You can set them during widget construction or afterwards, via `dijit._Widget.attr`.
	//
	//	They also share some common methods.

	// baseClass: [protected] String
	//		Root CSS class of the widget (ex: dijitTextBox), used to add CSS classes of widget
	//		(ex: "dijitTextBox dijitTextBoxInvalid dijitTextBoxFocused dijitTextBoxInvalidFocused")
	//		See _setStateClass().
	baseClass: "",

	// name: String
	//		Name used when submitting form; same as "name" attribute or plain HTML elements
	name: "",

	// alt: String
	//		Corresponds to the native HTML <input> element's attribute.
	alt: "",

	// value: String
	//		Corresponds to the native HTML <input> element's attribute.
	value: "",

	// type: String
	//		Corresponds to the native HTML <input> element's attribute.
	type: "text",

	// tabIndex: Integer
	//		Order fields are traversed when user hits the tab key
	tabIndex: "0",

	// disabled: Boolean
	//		Should this widget respond to user input?
	//		In markup, this is specified as "disabled='disabled'", or just "disabled".
	disabled: false,

	// readOnly: Boolean
	//		Should this widget respond to user input?
	//		In markup, this is specified as "readOnly".
	//		Similar to disabled except readOnly form values are submitted.
	readOnly: false,

	// intermediateChanges: Boolean
	//		Fires onChange for each value change or only on demand
	intermediateChanges: false,

	// scrollOnFocus: Boolean
	//		On focus, should this widget scroll into view?
	scrollOnFocus: true,

	// These mixins assume that the focus node is an INPUT, as many but not all _FormWidgets are.
	attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
		value: "focusNode",
		disabled: "focusNode",
		readOnly: "focusNode",
		id: "focusNode",
		tabIndex: "focusNode",
		alt: "focusNode"
	}),

	postMixInProperties: function(){
		// Setup name=foo string to be referenced from the template (but only if a name has been specified)
		// Unfortunately we can't use attributeMap to set the name due to IE limitations, see #8660
		this.nameAttrSetting = this.name ? ("name='" + this.name + "'") : "";
		this.inherited(arguments);
	},

	_setDisabledAttr: function(/*Boolean*/ value){
		this.disabled = value;
		dojo.attr(this.focusNode, 'disabled', value);
		dijit.setWaiState(this.focusNode, "disabled", value);

				if(value){
					//reset those, because after the domNode is disabled, we can no longer receive
					//mouse related events, see #4200
					this._hovering = false;
					this._active = false;
					// remove the tabIndex, especially for FF
					this.focusNode.removeAttribute('tabIndex');
				}else{
					this.focusNode.setAttribute('tabIndex', this.tabIndex);
				}
				this._setStateClass();
	},

	setDisabled: function(/*Boolean*/ disabled){
		// summary:
		//		Deprecated.   Use attr('disabled', ...) instead.
		dojo.deprecated("setDisabled("+disabled+") is deprecated. Use attr('disabled',"+disabled+") instead.", "", "2.0");
		this.attr('disabled', disabled);
	},

	_onFocus: function(e){
		if(this.scrollOnFocus){
			dijit.scrollIntoView(this.domNode);
		}
		this.inherited(arguments);
	},

	_onMouse : function(/*Event*/ event){
		// summary:
		//	Sets _hovering, _active, and stateModifier properties depending on mouse state,
		//	then calls setStateClass() to set appropriate CSS classes for this.domNode.
		//
		//	To get a different CSS class for hover, send onmouseover and onmouseout events to this method.
		//	To get a different CSS class while mouse button is depressed, send onmousedown to this method.

		var mouseNode = event.currentTarget;
		if(mouseNode && mouseNode.getAttribute){
			this.stateModifier = mouseNode.getAttribute("stateModifier") || "";
		}

		if(!this.disabled){
			switch(event.type){
				case "mouseenter":
				case "mouseover":
					this._hovering = true;
					this._active = this._mouseDown;
					break;

				case "mouseout":
				case "mouseleave":
					this._hovering = false;
					this._active = false;
					break;

				case "mousedown" :
					this._active = true;
					this._mouseDown = true;
					// set a global event to handle mouseup, so it fires properly
					//	even if the cursor leaves the button
					var mouseUpConnector = this.connect(dojo.body(), "onmouseup", function(){
						//if user clicks on the button, even if the mouse is released outside of it,
						//this button should get focus (which mimics native browser buttons)
						if(this._mouseDown && this.isFocusable()){
							this.focus();
						}
						this._active = false;
						this._mouseDown = false;
						this._setStateClass();
						this.disconnect(mouseUpConnector);
					});
					break;
			}
			this._setStateClass();
		}
	},

	isFocusable: function(){
		// summary:
		//		Tells if this widget is focusable or not.   Used internally by dijit.
		// tags:
		//		protected
		return !this.disabled && !this.readOnly && this.focusNode && (dojo.style(this.domNode, "display") != "none");
	},

	focus: function(){
		// summary:
		//		Put focus on this widget
		dijit.focus(this.focusNode);
	},

	_setStateClass: function(){
		// summary:
		//		Update the visual state of the widget by setting the css classes on this.domNode
		//		(or this.stateNode if defined) by combining this.baseClass with
		//		various suffixes that represent the current widget state(s).
		//
		// description:
		//		In the case where a widget has multiple
		//		states, it sets the class based on all possible
		//	 	combinations.  For example, an invalid form widget that is being hovered
		//		will be "dijitInput dijitInputInvalid dijitInputHover dijitInputInvalidHover".
		//
		//		For complex widgets with multiple regions, there can be various hover/active states,
		//		such as "Hover" or "CloseButtonHover" (for tab buttons).
		//		This is controlled by a stateModifier="CloseButton" attribute on the close button node.
		//
		//		The widget may have one or more of the following states, determined
		//		by this.state, this.checked, this.valid, and this.selected:
		//			- Error - ValidationTextBox sets this.state to "Error" if the current input value is invalid
		//			- Checked - ex: a checkmark or a ToggleButton in a checked state, will have this.checked==true
		//			- Selected - ex: currently selected tab will have this.selected==true
		//
		//		In addition, it may have one or more of the following states,
		//		based on this.disabled and flags set in _onMouse (this._active, this._hovering, this._focused):
		//			- Disabled	- if the widget is disabled
		//			- Active		- if the mouse (or space/enter key?) is being pressed down
		//			- Focused		- if the widget has focus
		//			- Hover		- if the mouse is over the widget

		// Compute new set of classes
		var newStateClasses = this.baseClass.split(" ");

		function multiply(modifier){
			newStateClasses = newStateClasses.concat(dojo.map(newStateClasses, function(c){ return c+modifier; }), "dijit"+modifier);
		}

		if(this.checked){
			multiply("Checked");
		}
		if(this.state){
			multiply(this.state);
		}
		if(this.selected){
			multiply("Selected");
		}

		if(this.disabled){
			multiply("Disabled");
		}else if(this.readOnly){
			multiply("ReadOnly");
		}else if(this._active){
			multiply(this.stateModifier+"Active");
		}else{
			if(this._focused){
				multiply("Focused");
			}
			if(this._hovering){
				multiply(this.stateModifier+"Hover");
			}
		}

		// Remove old state classes and add new ones.
		// For performance concerns we only write into domNode.className once.
		var tn = this.stateNode || this.domNode,
			classHash = {};	// set of all classes (state and otherwise) for node

		dojo.forEach(tn.className.split(" "), function(c){ classHash[c] = true; });

		if("_stateClasses" in this){
			dojo.forEach(this._stateClasses, function(c){ delete classHash[c]; });
		}

		dojo.forEach(newStateClasses, function(c){ classHash[c] = true; });

		var newClasses = [];
		for(var c in classHash){
			newClasses.push(c);
		}
		tn.className = newClasses.join(" ");

		this._stateClasses = newStateClasses;
	},

	compare: function(/*anything*/val1, /*anything*/val2){
		// summary:
		//		Compare 2 values (as returned by attr('value') for this widget).
		// tags:
		//		protected
		if((typeof val1 == "number") && (typeof val2 == "number")){
			return (isNaN(val1) && isNaN(val2))? 0 : (val1-val2);
		}else if(val1 > val2){ return 1; }
		else if(val1 < val2){ return -1; }
		else { return 0; }
	},

	onChange: function(newValue){
		// summary:
		//		Callback when this widget's value is changed.
		// tags:
		//		callback
	},

	// _onChangeActive: [private] Boolean
	//		Indicates that changes to the value should call onChange() callback.
	//		This is false during widget initialization, to avoid calling onChange()
	//		when the initial value is set.
	_onChangeActive: false,

	_handleOnChange: function(/*anything*/ newValue, /* Boolean? */ priorityChange){
		// summary:
		//		Called when the value of the widget is set.  Calls onChange() if appropriate
		// newValue:
		//		the new value
		// priorityChange:
		//		For a slider, for example, dragging the slider is priorityChange==false,
		//		but on mouse up, it's priorityChange==true.  If intermediateChanges==true,
		//		onChange is only called form priorityChange=true events.
		// tags:
		//		private
		this._lastValue = newValue;
		if(this._lastValueReported == undefined && (priorityChange === null || !this._onChangeActive)){
			// this block executes not for a change, but during initialization,
			// and is used to store away the original value (or for ToggleButton, the original checked state)
			this._resetValue = this._lastValueReported = newValue;
		}
		if((this.intermediateChanges || priorityChange || priorityChange === undefined) &&
			((typeof newValue != typeof this._lastValueReported) ||
				this.compare(newValue, this._lastValueReported) != 0)){
			this._lastValueReported = newValue;
			if(this._onChangeActive){ this.onChange(newValue); }
		}
	},

	create: function(){
		// Overrides _Widget.create()
		this.inherited(arguments);
		this._onChangeActive = true;
		this._setStateClass();
	},

	destroy: function(){
		if(this._layoutHackHandle){
			clearTimeout(this._layoutHackHandle);
		}
		this.inherited(arguments);
	},

	setValue: function(/*String*/ value){
		// summary:
		//		Deprecated.   Use attr('value', ...) instead.
		dojo.deprecated("dijit.form._FormWidget:setValue("+value+") is deprecated.  Use attr('value',"+value+") instead.", "", "2.0");
		this.attr('value', value);
	},

	getValue: function(){
		// summary:
		//		Deprecated.   Use attr('value') instead.
		dojo.deprecated(this.declaredClass+"::getValue() is deprecated. Use attr('value') instead.", "", "2.0");
		return this.attr('value');
	},

	_layoutHack: function(){
		// summary:
		//		Work around table sizing bugs on FF2 by forcing redraw

		if(dojo.isFF == 2 && !this._layoutHackHandle){
			var node=this.domNode;
			var old = node.style.opacity;
			node.style.opacity = "0.999";
			this._layoutHackHandle = setTimeout(dojo.hitch(this, function(){
				this._layoutHackHandle = null;
				node.style.opacity = old;
			}), 0);
		}
	}
});

dojo.declare("dijit.form._FormValueWidget", dijit.form._FormWidget,
{
	// summary:
	//		Base class for widgets corresponding to native HTML elements such as <input> or <select> that have user changeable values.
	// description:
	//		Each _FormValueWidget represents a single input value, and has a (possibly hidden) <input> element,
	//		to which it serializes it's input value, so that form submission (either normal submission or via FormBind?)
	//		works as expected.

	// Don't attempt to mixin the 'type', 'name' attributes here programatically -- they must be declared
	// directly in the template as read by the parser in order to function. IE is known to specifically
	// require the 'name' attribute at element creation time.   See #8484, #8660.
	// TODO: unclear what that {value: ""} is for; FormWidget.attributeMap copies value to focusNode,
	// so maybe {value: ""} is so the value *doesn't* get copied to focusNode?
	// Seems like we really want value removed from attributeMap altogether
	// (although there's no easy way to do that now)
	attributeMap: dojo.delegate(dijit.form._FormWidget.prototype.attributeMap, { value: "" }),

	postCreate: function(){
		if(dojo.isIE || dojo.isWebKit){ // IE won't stop the event with keypress and Safari won't send an ESCAPE to keypress at all
			this.connect(this.focusNode || this.domNode, "onkeydown", this._onKeyDown);
		}
		// Update our reset value if it hasn't yet been set (because this.attr
		// is only called when there *is* a value
		if(this._resetValue === undefined){
			this._resetValue = this.value;
		}
	},

	_setValueAttr: function(/*anything*/ newValue, /*Boolean, optional*/ priorityChange){
		// summary:
		//		Hook so attr('value', value) works.
		// description:
		//		Sets the value of the widget.
		//		If the value has changed, then fire onChange event, unless priorityChange
		//		is specified as null (or false?)
		this.value = newValue;
		this._handleOnChange(newValue, priorityChange);
	},

	_getValueAttr: function(/*String*/ value){
		// summary:
		//		Hook so attr('value') works.
		return this._lastValue;
	},

	undo: function(){
		// summary:
		//		Restore the value to the last value passed to onChange
		this._setValueAttr(this._lastValueReported, false);
	},

	reset: function(){
		// summary:
		//		Reset the widget's value to what it was at initialization time
		this._hasBeenBlurred = false;
		this._setValueAttr(this._resetValue, true);
	},

	_onKeyDown: function(e){
		if(e.keyCode == dojo.keys.ESCAPE && !e.ctrlKey && !e.altKey){
			var te;
			if(dojo.isIE){ 
				e.preventDefault(); // default behavior needs to be stopped here since keypress is too late
				te = document.createEventObject();
				te.keyCode = dojo.keys.ESCAPE;
				te.shiftKey = e.shiftKey;
				e.srcElement.fireEvent('onkeypress', te);
			}else if(dojo.isWebKit){ // ESCAPE needs help making it into keypress
				te = document.createEvent('Events');
				te.initEvent('keypress', true, true);
				te.keyCode = dojo.keys.ESCAPE;
				te.shiftKey = e.shiftKey;
				e.target.dispatchEvent(te);
			}
		}
	}
});

}

if(!dojo._hasResource["dijit.form.Button"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.Button"] = true;
dojo.provide("dijit.form.Button");




dojo.declare("dijit.form.Button",
	dijit.form._FormWidget,
	{
	// summary:
	//		Basically the same thing as a normal HTML button, but with special styling.
	// description:
	//		Buttons can display a label, an icon, or both.
	//		A label should always be specified (through innerHTML) or the label
	//		attribute.  It can be hidden via showLabel=false.
	// example:
	// |	<button dojoType="dijit.form.Button" onClick="...">Hello world</button>
	// 
	// example:
	// |	var button1 = new dijit.form.Button({label: "hello world", onClick: foo});
	// |	dojo.body().appendChild(button1.domNode);

	// label: HTML String
	//		Text to display in button.
	//		If the label is hidden (showLabel=false) then and no title has
	//		been specified, then label is also set as title attribute of icon.
	label: "",

	// showLabel: Boolean
	//		Set this to true to hide the label text and display only the icon.
	//		(If showLabel=false then iconClass must be specified.)
	//		Especially useful for toolbars.  
	//		If showLabel=true, the label will become the title (a.k.a. tooltip/hint) of the icon.
	//
	//		The exception case is for computers in high-contrast mode, where the label
	//		will still be displayed, since the icon doesn't appear.
	showLabel: true,

	// iconClass: String
	//		Class to apply to div in button to make it display an icon
	iconClass: "",

	// type: String
	//		Defines the type of button.  "button", "submit", or "reset".
	type: "button",

	baseClass: "dijitButton",

	templateString:"<span class=\"dijit dijitReset dijitLeft dijitInline\"\n\tdojoAttachEvent=\"ondijitclick:_onButtonClick,onmouseenter:_onMouse,onmouseleave:_onMouse,onmousedown:_onMouse\"\n\t><span class=\"dijitReset dijitRight dijitInline\"\n\t\t><span class=\"dijitReset dijitInline dijitButtonNode\"\n\t\t\t><button class=\"dijitReset dijitStretch dijitButtonContents\"\n\t\t\t\tdojoAttachPoint=\"titleNode,focusNode\" \n\t\t\t\t${nameAttrSetting} type=\"${type}\" value=\"${value}\" waiRole=\"button\" waiState=\"labelledby-${id}_label\"\n\t\t\t\t><span class=\"dijitReset dijitInline\" dojoAttachPoint=\"iconNode\" \n\t\t\t\t\t><span class=\"dijitReset dijitToggleButtonIconChar\">&#10003;</span \n\t\t\t\t></span \n\t\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\" \n\t\t\t\t\tid=\"${id}_label\"  \n\t\t\t\t\tdojoAttachPoint=\"containerNode\"\n\t\t\t\t></span\n\t\t\t></button\n\t\t></span\n\t></span\n></span>\n",

	attributeMap: dojo.delegate(dijit.form._FormWidget.prototype.attributeMap, {
		label: { node: "containerNode", type: "innerHTML" },
		iconClass: { node: "iconNode", type: "class" }
	}),
		

	_onClick: function(/*Event*/ e){
		// summary:
		//		Internal function to handle click actions
		if(this.disabled || this.readOnly){
			return false;
		}
		this._clicked(); // widget click actions
		return this.onClick(e); // user click actions
	},

	_onButtonClick: function(/*Event*/ e){
		// summary:
		//		Handler when the user activates the button portion.
		//		If is activated via a keystroke, stop the event unless is submit or reset.
		if(e.type!='click' && !(this.type=="submit" || this.type=="reset")){
			dojo.stopEvent(e);
		}
		if(this._onClick(e) === false){ // returning nothing is same as true
			e.preventDefault(); // needed for checkbox
		}else if(this.type=="submit" && !this.focusNode.form){ // see if a nonform widget needs to be signalled
			for(var node=this.domNode; node.parentNode/*#5935*/; node=node.parentNode){
				var widget=dijit.byNode(node);
				if(widget && typeof widget._onSubmit == "function"){
					widget._onSubmit(e);
					break;
				}
			}
		}
	},

	_setValueAttr: function(/*String*/ value){
		// Verify that value cannot be set for BUTTON elements.
		var attr = this.attributeMap.value || '';
		if(this[attr.node||attr||'domNode'].tagName == 'BUTTON'){
			// On IE, setting value actually overrides innerHTML, so disallow for everyone for consistency
			if(value != this.value){
				console.debug('Cannot change the value attribute on a Button widget.');
			}
		}
	},

	_fillContent: function(/*DomNode*/ source){
		// Overrides _Templated._fillcContent().
		// If button label is specified as srcNodeRef.innerHTML rather than
		// this.params.label, handle it here.
		if(source && !("label" in this.params)){
			this.attr('label', source.innerHTML);
		}
	},

	postCreate: function(){
		if (this.showLabel == false){
			dojo.addClass(this.containerNode,"dijitDisplayNone");
		}
		dojo.setSelectable(this.focusNode, false);
		this.inherited(arguments);
	},

	onClick: function(/*Event*/ e){
		// summary:
		//		Callback for when button is clicked.
		//		If type="submit", return true to perform submit, or false to cancel it.
		// type:
		//		callback
		return true;		// Boolean
	},

	_clicked: function(/*Event*/ e){
		// summary:
		//		Internal overridable function for when the button is clicked
	},

	setLabel: function(/*String*/ content){
		// summary:
		//		Deprecated.  Use attr('label', ...) instead.
		dojo.deprecated("dijit.form.Button.setLabel() is deprecated.  Use attr('label', ...) instead.", "", "2.0");
		this.attr("label", content);
	},
	_setLabelAttr: function(/*String*/ content){
		// summary:
		//		Hook for attr('label', ...) to work.
		// description:
		//		Set the label (text) of the button; takes an HTML string.
		this.containerNode.innerHTML = this.label = content;
		this._layoutHack();
		if (this.showLabel == false && !this.params.title){
			this.titleNode.title = dojo.trim(this.containerNode.innerText || this.containerNode.textContent || '');
		}
	}		
});


dojo.declare("dijit.form.DropDownButton", [dijit.form.Button, dijit._Container], {
	// summary:
	//		A button with a drop down
	//
	// example:
	// |	<button dojoType="dijit.form.DropDownButton" label="Hello world">
	// |		<div dojotype="dijit.Menu">...</div>
	// |	</button>
	//
	// example:
	// |	var button1 = new dijit.form.DropDownButton({ label: "hi", dropDown: new dijit.Menu(...) });
	// |	dojo.body().appendChild(button1);
	// 	
	
	baseClass : "dijitDropDownButton",

	templateString:"<span class=\"dijit dijitReset dijitLeft dijitInline\"\n\tdojoAttachEvent=\"onmouseenter:_onMouse,onmouseleave:_onMouse,onmousedown:_onMouse,onclick:_onDropDownClick,onkeydown:_onDropDownKeydown,onblur:_onDropDownBlur,onkeypress:_onKey\"\n\t><span class='dijitReset dijitRight dijitInline'\n\t\t><span class='dijitReset dijitInline dijitButtonNode'\n\t\t\t><button class=\"dijitReset dijitStretch dijitButtonContents\" \n\t\t\t\t${nameAttrSetting} type=\"${type}\" value=\"${value}\"\n\t\t\t\tdojoAttachPoint=\"focusNode,titleNode\" \n\t\t\t\twaiRole=\"button\" waiState=\"haspopup-true,labelledby-${id}_label\"\n\t\t\t\t><span class=\"dijitReset dijitInline\" \n\t\t\t\t\tdojoAttachPoint=\"iconNode\"\n\t\t\t\t></span\n\t\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"  \n\t\t\t\t\tdojoAttachPoint=\"containerNode,popupStateNode\" \n\t\t\t\t\tid=\"${id}_label\"\n\t\t\t\t></span\n\t\t\t\t><span class=\"dijitReset dijitInline dijitArrowButtonInner\">&thinsp;</span\n\t\t\t\t><span class=\"dijitReset dijitInline dijitArrowButtonChar\">&#9660;</span\n\t\t\t></button\n\t\t></span\n\t></span\n></span>\n",

	_fillContent: function(){
		// Overrides Button._fillContent().
		//
		// My inner HTML contains both the button contents and a drop down widget, like
		// <DropDownButton>  <span>push me</span>  <Menu> ... </Menu> </DropDownButton>
		// The first node is assumed to be the button content. The widget is the popup.

		if(this.srcNodeRef){ // programatically created buttons might not define srcNodeRef
			//FIXME: figure out how to filter out the widget and use all remaining nodes as button
			//	content, not just nodes[0]
			var nodes = dojo.query("*", this.srcNodeRef);
			dijit.form.DropDownButton.superclass._fillContent.call(this, nodes[0]);

			// save pointer to srcNode so we can grab the drop down widget after it's instantiated
			this.dropDownContainer = this.srcNodeRef;
		}
	},

	startup: function(){
		if(this._started){ return; }

		// the child widget from srcNodeRef is the dropdown widget.  Insert it in the page DOM,
		// make it invisible, and store a reference to pass to the popup code.
		if(!this.dropDown){
			var dropDownNode = dojo.query("[widgetId]", this.dropDownContainer)[0];
			this.dropDown = dijit.byNode(dropDownNode);
			delete this.dropDownContainer;
		}
		dijit.popup.prepare(this.dropDown.domNode);

		this.inherited(arguments);
	},

	destroyDescendants: function(){
		if(this.dropDown){
			this.dropDown.destroyRecursive();
			delete this.dropDown;
		}
		this.inherited(arguments);
	},

	_onArrowClick: function(/*Event*/ e){
		// summary:
		//		Handler for when the user mouse clicks on menu popup node
		if(this.disabled || this.readOnly){ return; }
		this._toggleDropDown();
	},

	_onDropDownClick: function(/*Event*/ e){
		// on Firefox 2 on the Mac it is possible to fire onclick
		// by pressing enter down on a second element and transferring
		// focus to the DropDownButton;
		// we want to prevent opening our menu in this situation
		// and only do so if we have seen a keydown on this button;
		// e.detail != 0 means that we were fired by mouse
		var isMacFFlessThan3 = dojo.isFF && dojo.isFF < 3
			&& navigator.appVersion.indexOf("Macintosh") != -1;
		if(!isMacFFlessThan3 || e.detail != 0 || this._seenKeydown){
			this._onArrowClick(e);
		}
		this._seenKeydown = false;
	},

	_onDropDownKeydown: function(/*Event*/ e){
		this._seenKeydown = true;
	},

	_onDropDownBlur: function(/*Event*/ e){
		this._seenKeydown = false;
	},

	_onKey: function(/*Event*/ e){
		// summary:
		//		Handler when the user presses a key on drop down widget
		if(this.disabled || this.readOnly){ return; }
		if(e.charOrCode == dojo.keys.DOWN_ARROW){
			if(!this.dropDown || this.dropDown.domNode.style.visibility=="hidden"){
				dojo.stopEvent(e);
				this._toggleDropDown();
			}
		}
	},

	_onBlur: function(){
		// summary:
		//		Called magically when focus has shifted away from this widget and it's dropdown
		this._closeDropDown();
		// don't focus on button.  the user has explicitly focused on something else.
		this.inherited(arguments);
	},

	_toggleDropDown: function(){
		// summary:
		//		Toggle the drop-down widget; if it is up, close it; if not, open it.
		if(this.disabled || this.readOnly){ return; }
		dijit.focus(this.popupStateNode);
		var dropDown = this.dropDown;
		if(!dropDown){ return; }
		if(!this._opened){
			// If there's an href, then load that first, so we don't get a flicker
			if(dropDown.href && !dropDown.isLoaded){
				var self = this;
				var handler = dojo.connect(dropDown, "onLoad", function(){
					dojo.disconnect(handler);
					self._openDropDown();
				});
				dropDown.refresh();
				return;
			}else{
				this._openDropDown();
			}
		}else{
			this._closeDropDown();
		}
	},

	_openDropDown: function(){
		var dropDown = this.dropDown;
		var oldWidth=dropDown.domNode.style.width;
		var self = this;

		dijit.popup.open({
			parent: this,
			popup: dropDown,
			around: this.domNode,
			orient:
				// TODO: add user-defined positioning option, like in Tooltip.js
				this.isLeftToRight() ? {'BL':'TL', 'BR':'TR', 'TL':'BL', 'TR':'BR'}
				: {'BR':'TR', 'BL':'TL', 'TR':'BR', 'TL':'BL'},
			onExecute: function(){
				self._closeDropDown(true);
			},
			onCancel: function(){
				self._closeDropDown(true);
			},
			onClose: function(){
				dropDown.domNode.style.width = oldWidth;
				self.popupStateNode.removeAttribute("popupActive");
				self._opened = false;
			}
		});
		if(this.domNode.offsetWidth > dropDown.domNode.offsetWidth){
			var adjustNode = null;
			if(!this.isLeftToRight()){
				adjustNode = dropDown.domNode.parentNode;
				var oldRight = adjustNode.offsetLeft + adjustNode.offsetWidth;
			}
			// make menu at least as wide as the button
			dojo.marginBox(dropDown.domNode, {w: this.domNode.offsetWidth});
			if(adjustNode){
				adjustNode.style.left = oldRight - this.domNode.offsetWidth + "px";
			}
		}
		this.popupStateNode.setAttribute("popupActive", "true");
		this._opened=true;
		if(dropDown.focus){
			dropDown.focus();
		}
		// TODO: set this.checked and call setStateClass(), to affect button look while drop down is shown
	},
	
	_closeDropDown: function(/*Boolean*/ focus){
		if(this._opened){
			dijit.popup.close(this.dropDown);
			if(focus){ this.focus(); }
			this._opened = false;			
		}
	}
});

dojo.declare("dijit.form.ComboButton", dijit.form.DropDownButton, {
	// summary:
	//		A combination button and drop-down button.
	//		Users can click one side to "press" the button, or click an arrow
	//		icon to display the drop down.
	//
	// example:
	// |	<button dojoType="dijit.form.ComboButton" onClick="...">
	// |		<span>Hello world</span>
	// |		<div dojoType="dijit.Menu">...</div>
	// |	</button>
	//
	// example:
	// |	var button1 = new dijit.form.ComboButton({label: "hello world", onClick: foo, dropDown: "myMenu"});
	// |	dojo.body().appendChild(button1.domNode);
	// 

	templateString:"<table class='dijit dijitReset dijitInline dijitLeft'\n\tcellspacing='0' cellpadding='0' waiRole=\"presentation\"\n\t><tbody waiRole=\"presentation\"><tr waiRole=\"presentation\"\n\t\t><td class=\"dijitReset dijitStretch dijitButtonContents dijitButtonNode\"\n\t\t\tdojoAttachEvent=\"ondijitclick:_onButtonClick,onmouseenter:_onMouse,onmouseleave:_onMouse,onmousedown:_onMouse\"  dojoAttachPoint=\"titleNode\"\n\t\t\twaiRole=\"button\" waiState=\"labelledby-${id}_label\"\n\t\t\t><div class=\"dijitReset dijitInline\" dojoAttachPoint=\"iconNode\" waiRole=\"presentation\"></div\n\t\t\t><div class=\"dijitReset dijitInline dijitButtonText\" id=\"${id}_label\" dojoAttachPoint=\"containerNode\" waiRole=\"presentation\"></div\n\t\t></td\n\t\t><td class='dijitReset dijitRight dijitButtonNode dijitArrowButton dijitDownArrowButton'\n\t\t\tdojoAttachPoint=\"popupStateNode,focusNode\"\n\t\t\tdojoAttachEvent=\"ondijitclick:_onArrowClick, onkeypress:_onKey,onmouseenter:_onMouse,onmouseleave:_onMouse\"\n\t\t\tstateModifier=\"DownArrow\"\n\t\t\ttitle=\"${optionsTitle}\" ${nameAttrSetting}\n\t\t\twaiRole=\"button\" waiState=\"haspopup-true\"\n\t\t\t><div class=\"dijitReset dijitArrowButtonInner\" waiRole=\"presentation\">&thinsp;</div\n\t\t\t><div class=\"dijitReset dijitArrowButtonChar\" waiRole=\"presentation\">&#9660;</div\n\t\t></td\n\t></tr></tbody\n></table>\n",

	attributeMap: dojo.mixin(dojo.clone(dijit.form.Button.prototype.attributeMap), {
		id:"",
		tabIndex: ["focusNode", "titleNode"]
	}),

	// optionsTitle: String
	//		Text that describes the options menu (accessibility)
	optionsTitle: "",

	baseClass: "dijitComboButton",

	_focusedNode: null,

	postCreate: function(){
		this.inherited(arguments);
		this._focalNodes = [this.titleNode, this.popupStateNode];
		dojo.forEach(this._focalNodes, dojo.hitch(this, function(node){
			if(dojo.isIE){
				this.connect(node, "onactivate", this._onNodeFocus);
				this.connect(node, "ondeactivate", this._onNodeBlur);
			}else{
				this.connect(node, "onfocus", this._onNodeFocus);
				this.connect(node, "onblur", this._onNodeBlur);
			}
		}));
	},

	focusFocalNode: function(node){
		// summary:
		//		Focus the focal node node.
		// description:
		//		Called by _KeyNavContainer for (when example) this button is in a toolbar.
		// tags:
		//		protected
		this._focusedNode = node;
		dijit.focus(node);
	},

	hasNextFocalNode: function(){
		// summary:
		//		Returns true if this widget has no node currently
		//		focused or if there is a node following the focused one.
		//		False is returned if the last node has focus.
		// description:
		//		Called by _KeyNavContainer for (when example) this button is in a toolbar.
		// tags:
		//		protected
		return this._focusedNode !== this.getFocalNodes()[1];
	},

	focusNext: function(){
		// summary:
		//		Focus the focal node following the current node with focus,
		//		or the first one if no node currently has focus.
		// description:
		//		Called by _KeyNavContainer for (when example) this button is in a toolbar.
		// tags:
		//		protected
		this._focusedNode = this.getFocalNodes()[this._focusedNode ? 1 : 0];
		dijit.focus(this._focusedNode);
	},

	hasPrevFocalNode: function(){
		// summary:
		//		Returns true if this widget has no node currently
		//		focused or if there is a node before the focused one.
		//		False is returned if the first node has focus.
		// description:
		//		Called by _KeyNavContainer for (when example) this button is in a toolbar.
		// tags:
		//		protected
		return this._focusedNode !== this.getFocalNodes()[0];
	},

	focusPrev: function(){
		// summary:
		//		Focus the focal node before the current node with focus
		//		or the last one if no node currently has focus.
		// description:
		//		Called by _KeyNavContainer for (when example) this button is in a toolbar.
		// tags:
		//		protected
		this._focusedNode = this.getFocalNodes()[this._focusedNode ? 0 : 1];
		dijit.focus(this._focusedNode);
	},

	getFocalNodes: function(){
		// summary:
		//		Returns an array of focal nodes for this widget.
		// description:
		//		Called by _KeyNavContainer for (when example) this button is in a toolbar.
		// tags:
		//		protected
		return this._focalNodes;
	},

	_onNodeFocus: function(evt){
		this._focusedNode = evt.currentTarget;
		var fnc = this._focusedNode == this.focusNode ? "dijitDownArrowButtonFocused" : "dijitButtonContentsFocused";
		dojo.addClass(this._focusedNode, fnc);
	},

	_onNodeBlur: function(evt){
		var fnc = evt.currentTarget == this.focusNode ? "dijitDownArrowButtonFocused" : "dijitButtonContentsFocused";
		dojo.removeClass(evt.currentTarget, fnc);
	},

	_onBlur: function(){
		this.inherited(arguments);
		this._focusedNode = null;
	}
});

dojo.declare("dijit.form.ToggleButton", dijit.form.Button, {
	// summary:
	//		A button that can be in two states (checked or not).
	//		Can be base class for things like tabs or checkbox or radio buttons

	baseClass: "dijitToggleButton",

	// checked: Boolean
	//		Corresponds to the native HTML <input> element's attribute.
	//		In markup, specified as "checked='checked'" or just "checked".
	//		True if the button is depressed, or the checkbox is checked,
	//		or the radio button is selected, etc.
	checked: false,

	attributeMap: dojo.mixin(dojo.clone(dijit.form.Button.prototype.attributeMap),
		{checked:"focusNode"}),

	_clicked: function(/*Event*/ evt){
		this.attr('checked', !this.checked);
	},

	_setCheckedAttr: function(/*Boolean*/ value){
		this.checked = value;
		dojo.attr(this.focusNode || this.domNode, "checked", value);
		dijit.setWaiState(this.focusNode || this.domNode, "pressed", value);
		this._setStateClass();		
		this._handleOnChange(value, true);
	},

	setChecked: function(/*Boolean*/ checked){
		// summary:
		//		Deprecated.   Use attr('checked', true/false) instead.
		dojo.deprecated("setChecked("+checked+") is deprecated. Use attr('checked',"+checked+") instead.", "", "2.0");
		this.attr('checked', checked);
	},
	
	reset: function(){
		// summary:
		//		Reset the widget's value to what it was at initialization time

		this._hasBeenBlurred = false;

		// set checked state to original setting
		this.attr('checked', this.params.checked || false);
	}
});

}

if(!dojo._hasResource["dijit.form.TextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.TextBox"] = true;
dojo.provide("dijit.form.TextBox");



dojo.declare(
	"dijit.form.TextBox",
	dijit.form._FormValueWidget,
	{
		//	summary:
		//		A base class for textbox form inputs

		//	trim: Boolean
		//		Removes leading and trailing whitespace if true.  Default is false.
		trim: false,

		//	uppercase: Boolean
		//		Converts all characters to uppercase if true.  Default is false.
		uppercase: false,

		//	lowercase: Boolean
		//		Converts all characters to lowercase if true.  Default is false.
		lowercase: false,

		//	propercase: Boolean
		//		Converts the first character of each word to uppercase if true.
		propercase: false,

		//	maxLength: String
		//		HTML INPUT tag maxLength declaration.
		maxLength: "",

		templateString:"<input class=\"dijit dijitReset dijitLeft\" dojoAttachPoint='textbox,focusNode'\n\tdojoAttachEvent='onmouseenter:_onMouse,onmouseleave:_onMouse'\n\tautocomplete=\"off\" type=\"${type}\" ${nameAttrSetting}\n\t/>\n",
		baseClass: "dijitTextBox",

		attributeMap: dojo.delegate(dijit.form._FormValueWidget.prototype.attributeMap, {
			maxLength: "focusNode" 
		}),

		_getValueAttr: function(){
			// summary:
			//		Hook so attr('value') works as we like.
			// description:
			//		For `dijit.form.TextBox` this basically returns the value of the <input>.
			//
			//		For `dijit.form.MappedTextBox` subclasses, which have both
			//		a "displayed value" and a separate "submit value",
			//		This treats the "displayed value" as the master value, computing the
			//		submit value from it via this.parse().
			return this.parse(this.attr('displayedValue'), this.constraints);
		},

		_setValueAttr: function(value, /*Boolean?*/ priorityChange, /*String?*/ formattedValue){
			// summary:
			//		Hook so attr('value', ...) works.
			//
			// description: 
			//		Sets the value of the widget to "value" which can be of
			//		any type as determined by the widget.
			//
			// value:
			//		The visual element value is also set to a corresponding,
			//		but not necessarily the same, value.
			//
			// formattedValue:
			//		If specified, used to set the visual element value,
			//		otherwise a computed visual value is used.
			//
			// priorityChange:
			//		If true, an onChange event is fired immediately instead of 
			//		waiting for the next blur event.

			var filteredValue;
			if(value !== undefined){
				// TODO: this is calling filter() on both the display value and the actual value.
				// I added a comment to the filter() definition about this, but it should be changed.
				filteredValue = this.filter(value);
				if(typeof formattedValue != "string"){
					if(filteredValue !== null && ((typeof filteredValue != "number") || !isNaN(filteredValue))){
						formattedValue = this.filter(this.format(filteredValue, this.constraints));
					}else{ formattedValue = ''; }
				}
			}
			if(formattedValue != null && formattedValue != undefined && ((typeof formattedValue) != "number" || !isNaN(formattedValue)) && this.textbox.value != formattedValue){
				this.textbox.value = formattedValue;
			}
			this.inherited(arguments, [filteredValue, priorityChange]);
		},

		// displayedValue: String
		//		For subclasses like ComboBox where the displayed value
		//		(ex: Kentucky) and the serialized value (ex: KY) are different,
		//		this represents the displayed value.
		//
		//		Setting 'displayedValue' through attr('displayedValue', ...)
		//		updates 'value', and vice-versa.  Othewise 'value' is updated
		//		from 'displayedValue' periodically, like onBlur etc.
		//
		//		TODO: move declaration to MappedTextBox?
		//		Problem is that ComboBox references displayedValue,
		//		for benefit of FilteringSelect.
		displayedValue: "",

		getDisplayedValue: function(){
			// summary:
			//		Deprecated.   Use attr('displayedValue') instead.
			// tags:
			//		deprecated
			dojo.deprecated(this.declaredClass+"::getDisplayedValue() is deprecated. Use attr('displayedValue') instead.", "", "2.0");
			return this.attr('displayedValue');
		},

		_getDisplayedValueAttr: function(){
			// summary:
			//		Hook so attr('displayedValue') works.
			// description:
			//		Returns the displayed value (what the user sees on the screen),
			// 		after filtering (ie, trimming spaces etc.).
			//
			//		For some subclasses of TextBox (like ComboBox), the displayed value
			//		is different from the serialized value that's actually 
			//		sent to the server (see dijit.form.ValidationTextBox.serialize)
			
			return this.filter(this.textbox.value);
		},

		setDisplayedValue: function(/*String*/value){
			// summary:
			//		Deprecated.   Use attr('displayedValue', ...) instead.
			// tags:
			//		deprecated
			dojo.deprecated(this.declaredClass+"::setDisplayedValue() is deprecated. Use attr('displayedValue', ...) instead.", "", "2.0");
			this.attr('displayedValue', value);
		},
			
		_setDisplayedValueAttr: function(/*String*/value){
			// summary:
			//		Hook so attr('displayedValue', ...) works.
			//	description: 
			//		Sets the value of the visual element to the string "value".
			//		The widget value is also set to a corresponding,
			//		but not necessarily the same, value.

			if(value === null || value === undefined){ value = '' }
			else if(typeof value != "string"){ value = String(value) }
			this.textbox.value = value;
			this._setValueAttr(this.attr('value'), undefined, value);
		},

		format: function(/* String */ value, /* Object */ constraints){
			// summary:
			//		Replacable function to convert a value to a properly formatted string.
			// tags:
			//		protected extension
			return ((value == null || value == undefined) ? "" : (value.toString ? value.toString() : value));
		},

		parse: function(/* String */ value, /* Object */ constraints){
			// summary:
			//		Replacable function to convert a formatted string to a value
			// tags:
			//		protected extension

			return value;	// String
		},

		_refreshState: function(){
			// summary:
			//		After the user types some characters, etc., this method is
			//		called to check the field for validity etc.  The base method
			//		in `dijit.form.TextBox` does nothing, but subclasses override.
			// tags:
			//		protected
		},

		_onInput: function(e){
			if(e && e.type && /key/i.test(e.type) && e.keyCode){
				switch(e.keyCode){
					case dojo.keys.SHIFT:
					case dojo.keys.ALT:
					case dojo.keys.CTRL:
					case dojo.keys.TAB:
						return;
				}
			}
			if(this.intermediateChanges){
				var _this = this;
				// the setTimeout allows the key to post to the widget input box
				setTimeout(function(){ _this._handleOnChange(_this.attr('value'), false); }, 0);
			}
			this._refreshState();
		},

		postCreate: function(){
			// setting the value here is needed since value="" in the template causes "undefined"
			// and setting in the DOM (instead of the JS object) helps with form reset actions
			this.textbox.setAttribute("value", this.textbox.value); // DOM and JS values shuld be the same
			this.inherited(arguments);
			if(dojo.isMoz || dojo.isOpera){
				this.connect(this.textbox, "oninput", this._onInput);
			}else{
				this.connect(this.textbox, "onkeydown", this._onInput);
				this.connect(this.textbox, "onkeyup", this._onInput);
				this.connect(this.textbox, "onpaste", this._onInput);
				this.connect(this.textbox, "oncut", this._onInput);
			}

			/*#5297:if(this.srcNodeRef){
				dojo.style(this.textbox, "cssText", this.style);
				this.textbox.className += " " + this["class"];
			}*/
			this._layoutHack();
		},

		_blankValue: '', // if the textbox is blank, what value should be reported
		filter: function(val){
			// summary:
			//		Auto-corrections (such as trimming) that are applied to textbox
			//		value on blur or form submit.
			// description:
			//		For MappedTextBox subclasses, this is called twice
			// 			- once with the display value
			//			- once the value as set/returned by attr('value', ...)
			//		and attr('value'), ex: a Number for NumberTextBox.
			//
			//		In the latter case it does corrections like converting null to NaN.  In
			//		the former case the NumberTextBox.filter() method calls this.inherited()
			//		to execute standard trimming code in TextBox.filter().
			//
			//		TODO: break this into two methods in 2.0
			//
			// tags:
			//		protected extension
			if(val === null){ return this._blankValue; }
			if(typeof val != "string"){ return val; }
			if(this.trim){
				val = dojo.trim(val);
			}
			if(this.uppercase){
				val = val.toUpperCase();
			}
			if(this.lowercase){
				val = val.toLowerCase();
			}
			if(this.propercase){
				val = val.replace(/[^\s]+/g, function(word){
					return word.substring(0,1).toUpperCase() + word.substring(1);
				});
			}
			return val;
		},

		_setBlurValue: function(){
			this._setValueAttr(this.attr('value'), true);
		},

		_onBlur: function(e){
			if(this.disabled){ return; }
			this._setBlurValue();
			this.inherited(arguments);
		},

		_onFocus: function(e){
			if(this.disabled){ return; }
			this._refreshState();
			this.inherited(arguments);
		},

		reset: function(){
			// Overrides dijit._FormWidget.reset().
			// Additionally resets the displayed textbox value to ''
			this.textbox.value = '';
			this.inherited(arguments);
		}
	}
);

dijit.selectInputText = function(/*DomNode*/element, /*Number?*/ start, /*Number?*/ stop){
	// summary:
	//		Select text in the input element argument, from start (default 0), to stop (default end).

	// TODO: use functions in _editor/selection.js?
	var _window = dojo.global;
	var _document = dojo.doc;
	element = dojo.byId(element);
	if(isNaN(start)){ start = 0; }
	if(isNaN(stop)){ stop = element.value ? element.value.length : 0; }
	element.focus();
	if(_document["selection"] && dojo.body()["createTextRange"]){ // IE
		if(element.createTextRange){
			var range = element.createTextRange();
			with(range){
				collapse(true);
				moveStart("character", start);
				moveEnd("character", stop);
				select();
			}
		}
	}else if(_window["getSelection"]){
		var selection = _window.getSelection();	// TODO: unused, remove
		// FIXME: does this work on Safari?
		if(element.setSelectionRange){
			element.setSelectionRange(start, stop);
		}
	}
};

}

if(!dojo._hasResource["dijit.InlineEditBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.InlineEditBox"] = true;
dojo.provide("dijit.InlineEditBox");










dojo.declare("dijit.InlineEditBox",
	dijit._Widget,
	{
	// summary:
	//		An element with in-line edit capabilitites
	//
	// description:
	//		Behavior for an existing node (`<p>`, `<div>`, `<span>`, etc.) so that
	// 		when you click it, an editor shows up in place of the original
	//		text.  Optionally, Save and Cancel button are displayed below the edit widget.
	//		When Save is clicked, the text is pulled from the edit
	//		widget and redisplayed and the edit widget is again hidden.
	//		By default a plain Textarea widget is used as the editor (or for
	//		inline values a TextBox), but you can specify an editor such as
	//		dijit.Editor (for editing HTML) or a Slider (for adjusting a number).
	//		An edit widget must support the following API to be used:
	//			- displayedValue or value as initialization parameter,
	//			and available through attr('displayedValue') / attr('value')
	//			- void focus()
	//			- DOM-node focusNode = node containing editable text

	// editing: [readonly] Boolean
	//		Is the node currently in edit mode?
	editing: false,

	// autoSave: Boolean
	//		Changing the value automatically saves it; don't have to push save button
	//		(and save button isn't even displayed)
	autoSave: true,

	// buttonSave: String
	//		Save button label
	buttonSave: "",

	// buttonCancel: String
	//		Cancel button label
	buttonCancel: "",

	// renderAsHtml: Boolean
	//		Set this to true if the specified Editor's value should be interpreted as HTML
	//		rather than plain text (ex: `dijit.Editor`)
	renderAsHtml: false,

	// editor: String
	//		Class name for Editor widget
	editor: "dijit.form.TextBox",

	// editorParams: Object
	//		Set of parameters for editor, like {required: true}
	editorParams: {},

	onChange: function(value){
		// summary:
		//		Set this handler to be notified of changes to value.
		// tags:
		//		callback
	},
	
	onCancel: function(){
		// summary:
		//		Set this handler to be notified when editing is cancelled.
		// tags:
		//		callback
	},

	// width: String
	//		Width of editor.  By default it's width=100% (ie, block mode).
	width: "100%",

	// value: String
	//		The display value of the widget in read-only mode
	value: "",

	// noValueIndicator: [const] String
	//		The text that gets displayed when there is no value (so that the user has a place to click to edit)
	noValueIndicator: "<span style='font-family: wingdings; text-decoration: underline;'>&nbsp;&nbsp;&nbsp;&nbsp;&#x270d;&nbsp;&nbsp;&nbsp;&nbsp;</span>",

	constructor: function(){
		// summary:
		//		Sets up private arrays etc.
		// tags:
		//		private
		this.editorParams = {};
	},

	postMixInProperties: function(){
		this.inherited(arguments);

		// save pointer to original source node, since Widget nulls-out srcNodeRef
		this.displayNode = this.srcNodeRef;

		// connect handlers to the display node
		var events = {
			ondijitclick: "_onClick",
			onmouseover: "_onMouseOver",
			onmouseout: "_onMouseOut",
			onfocus: "_onMouseOver",
			onblur: "_onMouseOut"			
		};
		for(var name in events){
			this.connect(this.displayNode, name, events[name]);
		}
		dijit.setWaiRole(this.displayNode, "button");
		if(!this.displayNode.getAttribute("tabIndex")){
			this.displayNode.setAttribute("tabIndex", 0);
		}

		this.attr('value', this.value || this.displayNode.innerHTML);
	},

	setDisabled: function(/*Boolean*/ disabled){
		// summary:
		//		Deprecated.   Use attr('disable', ...) instead.
		// tags:
		//		deprecated
		dojo.deprecated("dijit.InlineEditBox.setDisabled() is deprecated.  Use attr('disabled', bool) instead.", "", "2.0");
		this.attr('disabled', disabled);
	},
	_setDisabledAttr: function(/*Boolean*/ disabled){
		// summary: 
		//		Hook to make attr("disabled", ...) work.
		//		Set disabled state of widget.
		this.disabled = disabled;
		dijit.setWaiState(this.domNode, "disabled", disabled);
	},

	_onMouseOver: function(){
		// summary:
		//		Handler for onmouseover event.
		// tags:
		//		private
		dojo.addClass(this.displayNode, this.disabled ? "dijitDisabledClickableRegion" : "dijitClickableRegion");
	},

	_onMouseOut: function(){
		// summary:
		//		Handler for onmouseout event.
		// tags:
		//		private
		dojo.removeClass(this.displayNode, this.disabled ? "dijitDisabledClickableRegion" : "dijitClickableRegion");
	},

	_onClick: function(/*Event*/ e){
		// summary:
		//		Handler for onclick event.
		// tags:
		//		private
		if(this.disabled){ return; }
		if(e){ dojo.stopEvent(e); }
		this._onMouseOut();

		// Since FF gets upset if you move a node while in an event handler for that node...
		setTimeout(dojo.hitch(this, "edit"), 0);
	},

	edit: function(){
		// summary:
		//		Display the editor widget in place of the original (read only) markup.
		// tags:
		//		private

		if(this.disabled || this.editing){ return; }
		this.editing = true;

		var editValue = 
				(this.renderAsHtml ?
				this.value :
				this.value.replace(/\s*\r?\n\s*/g,"").replace(/<br\/?>/gi,"\n").replace(/&gt;/g,">").replace(/&lt;/g,"<").replace(/&amp;/g,"&").replace(/&quot;/g,"\""));

		// Placeholder for edit widget
		// Put place holder (and eventually editWidget) before the display node so that it's positioned correctly
		// when Calendar dropdown appears, which happens automatically on focus.
		var placeholder = dojo.create("span", null, this.domNode, "before");

		var ew = this.editWidget = new dijit._InlineEditor({
			value: dojo.trim(editValue),
			autoSave: this.autoSave,
			buttonSave: this.buttonSave,
			buttonCancel: this.buttonCancel,
			renderAsHtml: this.renderAsHtml,
			editor: this.editor,
			editorParams: this.editorParams,
			sourceStyle: dojo.getComputedStyle(this.displayNode),
			save: dojo.hitch(this, "save"),
			cancel: dojo.hitch(this, "cancel"),
			width: this.width
		}, placeholder);

		// to avoid screen jitter, we first create the editor with position:absolute, visibility:hidden,
		// and then when it's finished rendering, we switch from display mode to editor
		var ews = ew.domNode.style;
		this.displayNode.style.display="none";
		ews.position = "static";
		ews.visibility = "visible";

		// Replace the display widget with edit widget, leaving them both displayed for a brief time so that
		// focus can be shifted without incident.  (browser may needs some time to render the editor.)
		this.domNode = ew.domNode;
		setTimeout(function(){
			ew.focus();
			ew._resetValue = ew.getValue();
		}, 100);
	},

	_showText: function(/*Boolean*/ focus){
		// summary:
		//		Revert to display mode, and optionally focus on display node
		// tags:
		//		private

		// display the read-only text and then quickly hide the editor (to avoid screen jitter)
		this.displayNode.style.display="";
		var ew = this.editWidget;
		var ews = ew.domNode.style;
		ews.position="absolute";
		ews.visibility="hidden";

		this.domNode = this.displayNode;

		if(focus){
			dijit.focus(this.displayNode);
		}
		ews.display = "none";
		// give the browser some time to render the display node and then shift focus to it
		// and hide the edit widget before garbage collecting the edit widget
		setTimeout(function(){
			ew.destroy();
			delete ew;
			if(dojo.isIE){
				// messing with the DOM tab order can cause IE to focus the body - so restore
				dijit.focus(dijit.getFocus());
			}
		}, 1000); // no hurry - wait for things to quiesce
	},

	save: function(/*Boolean*/ focus){
		// summary:
		//		Save the contents of the editor and revert to display mode.
		// focus: Boolean
		//		Focus on the display mode text
		// tags:
		//		private
		if(this.disabled || !this.editing){ return; }
		this.editing = false;

		var value = this.editWidget.getValue() + "";
		this.attr('value', this.renderAsHtml? value
			: value.replace(/&/gm, "&amp;").replace(/</gm, "&lt;").replace(/>/gm, "&gt;").replace(/"/gm, "&quot;").replace(/\n/g, "<br>")
		);

		// tell the world that we have changed
		this.onChange(value);

		this._showText(focus);	
	},

	setValue: function(/*String*/ val){
		// summary:
		//		Deprecated.   Use attr('value', ...) instead.
		// tags:
		//		deprecated
		dojo.deprecated("dijit.InlineEditBox.setValue() is deprecated.  Use attr('value', ...) instead.", "", "2.0");
		return this.attr("value", val);
	},
	_setValueAttr: function(/*String*/ val){
		// summary:
		// 		Hook to make attr("value", ...) work.
		//		Inserts specified HTML value into this node, or an "input needed" character if node is blank.
		this.value = val;
		this.displayNode.innerHTML = dojo.trim(val) || this.noValueIndicator;
	},

	getValue: function(){
		// summary:
		//		Deprecated.   Use attr('value') instead.
		// tags:
		//		deprecated
		dojo.deprecated("dijit.InlineEditBox.getValue() is deprecated.  Use attr('value') instead.", "", "2.0");
		return this.attr("value");
	},

	cancel: function(/*Boolean*/ focus){
		// summary:
		//		Revert to display mode, discarding any changes made in the editor
		// tags:
		//		private

		this.editing = false;
		
		// tell the world that we have no changes
		this.onCancel();
		
		this._showText(focus);
	}
});

dojo.declare(
	"dijit._InlineEditor",
	 [dijit._Widget, dijit._Templated],
{
	// summary:
	// 		Internal widget used by InlineEditBox, displayed when in editing mode
	//		to display the editor and maybe save/cancel buttons.  Calling code should
	//		connect to save/cancel methods to detect when editing is finished
	//
	//		Has mainly the same parameters as InlineEditBox, plus these values:
	//
	// style: Object
	//		Set of CSS attributes of display node, to replicate in editor
	//
	// value: String
	//		Value as an HTML string or plain text string, depending on renderAsHTML flag

	templateString:"<span dojoAttachPoint=\"editNode\" waiRole=\"presentation\" style=\"position: absolute; visibility:hidden\" class=\"dijitReset dijitInline\"\n\tdojoAttachEvent=\"onkeypress: _onKeyPress\" \n\t><span dojoAttachPoint=\"editorPlaceholder\"></span\n\t><span dojoAttachPoint=\"buttonContainer\"\n\t\t><button class='saveButton' dojoAttachPoint=\"saveButton\" dojoType=\"dijit.form.Button\" dojoAttachEvent=\"onClick:save\" disabled=\"true\" label=\"${buttonSave}\"></button\n\t\t><button class='cancelButton' dojoAttachPoint=\"cancelButton\" dojoType=\"dijit.form.Button\" dojoAttachEvent=\"onClick:cancel\" label=\"${buttonCancel}\"></button\n\t></span\n></span>\n",
	widgetsInTemplate: true,

	postMixInProperties: function(){
		this.inherited(arguments);
		this.messages = dojo.i18n.getLocalization("dijit", "common", this.lang);
		dojo.forEach(["buttonSave", "buttonCancel"], function(prop){
			if(!this[prop]){ this[prop] = this.messages[prop]; }
		}, this);
	},

	postCreate: function(){
		// Create edit widget in place in the template
		var cls = dojo.getObject(this.editor);

		// Copy the style from the source
		// Don't copy ALL properties though, just the necessary/applicable ones
		var srcStyle = this.sourceStyle;
		var editStyle = "line-height:" + srcStyle.lineHeight + ";";
		dojo.forEach(["Weight","Family","Size","Style"], function(prop){
			editStyle += "font-"+prop+":"+srcStyle["font"+prop]+";";
		}, this);
		dojo.forEach(["marginTop","marginBottom","marginLeft", "marginRight"], function(prop){
			this.domNode.style[prop] = srcStyle[prop];
		}, this);
		if(this.width=="100%"){
			// block mode
			editStyle += "width:100%;";
			this.domNode.style.display = "block";
		}else{
			// inline-block mode
			editStyle += "width:" + (this.width + (Number(this.width)==this.width ? "px" : "")) + ";";
		}
		this.editorParams.style = editStyle;
		this.editorParams[ "displayedValue" in cls.prototype ? "displayedValue" : "value"] = this.value;
		var ew = this.editWidget = new cls(this.editorParams, this.editorPlaceholder);

		this.connect(ew, "onChange", "_onChange");

		// Monitor keypress on the edit widget.   Note that edit widgets do a stopEvent() on ESC key (to
		// prevent Dialog from closing when the user just wants to revert the value in the edit widget),
		// so this is the only way we can see the key press event.
		this.connect(ew, "onKeyPress", "_onKeyPress");
		this.connect(ew, "onKeyUp", "_onKeyPress"); // in case ESC was eaten but changed value

		if(this.autoSave){
			this.buttonContainer.style.display="none";
		}
	},

	destroy: function(){
		this.editWidget.destroy();
		this.inherited(arguments);
	},

	getValue: function(){
		// summary:
		//		Return the [display] value of the edit widget
		var ew = this.editWidget;
		return ew.attr("displayedValue" in ew ? "displayedValue" : "value");
	},

	_onKeyPress: function(e){
		// summary:
		//		Handler for keypress in the edit box (see template).
		// description:
		//		For autoSave widgets, if Esc/Enter, call cancel/save.
		//		For non-autoSave widgets, enable save button if the text value is
		//		different than the original value.
		// tags:
		//		private

		if(this._exitInProgress){
			return;
		}
		if(this.autoSave){
			if(e.altKey || e.ctrlKey){ return; }
			// If Enter/Esc pressed, treat as save/cancel.
			if(e.charOrCode == dojo.keys.ESCAPE){
				dojo.stopEvent(e);
				this._exitInProgress = true;
				this.cancel(true);
			}else if(e.charOrCode == dojo.keys.ENTER && this.editWidget.focusNode.tagName == "INPUT"){
				dojo.stopEvent(e);
				this._exitInProgress = true;
				this.save(true);
			}else if(e.charOrCode === dojo.keys.TAB){
				this._exitInProgress = true;
				// allow the TAB to change focus before we mess with the DOM: #6227
				// Expounding by request:
				// 	The current focus is on the edit widget input field.
				//	save() will hide and destroy this widget.
				//	We want the focus to jump from the currently hidden
				//	displayNode, but since it's hidden, it's impossible to
				//	unhide it, focus it, and then have the browser focus
				//	away from it to the next focusable element since each
				//	of these events is asynchronous and the focus-to-next-element
				//	is already queued.
				//	So we allow the browser time to unqueue the move-focus event 
				//	before we do all the hide/show stuff.
				setTimeout(dojo.hitch(this, "save", false), 0);
			}
		}else{
			var _this = this;
			// Delay before calling getValue().
			// The delay gives the browser a chance to update the native value.
			setTimeout(
				function(){
					_this._onChange(); // handle save button
				}, 100);
		}
	},

	_onBlur: function(){
		// summary:
		//		Called when focus moves outside the editor
		// tags:
		//		private

		this.inherited(arguments);
		if(this._exitInProgress){
			// when user clicks the "save" button, focus is shifted back to display text, causing this
			// function to be called, but in that case don't do anything
			return;
		}
		if(this.autoSave){
			this._exitInProgress = true;
			if(this.getValue() == this._resetValue){
				this.cancel(false);
			}else{
				this.save(false);
			}
		}
	},

	_onChange: function(){
		// summary:
		//		Called when the underlying widget fires an onChange event,
		//		which means that the user has finished entering the value
		// tags:
		//		private

		if(this._exitInProgress){
			// TODO: the onChange event might happen after the return key for an async widget
			// like FilteringSelect.  Shouldn't be deleting the edit widget on end-of-edit
			return;
		}
		if(this.autoSave){
			this._exitInProgress = true;
			this.save(true);
		}else{
			// in case the keypress event didn't get through (old problem with Textarea that has been fixed
			// in theory) or if the keypress event comes too quickly and the value inside the Textarea hasn't
			// been updated yet)
			this.saveButton.attr("disabled", (this.getValue() == this._resetValue) || !this.enableSave());
		}
	},
	
	enableSave: function(){
		// summary:
		//		User overridable function returning a Boolean to indicate
		// 		if the Save button should be enabled or not - usually due to invalid conditions
		// tags:
		//		extension
		return this.editWidget.isValid ? this.editWidget.isValid() : true;
	},

	focus: function(){
		// summary:
		//		Focus on the edit widget.
		this.editWidget.focus();
		dijit.selectInputText(this.editWidget.focusNode);
	}
});

}

if(!dojo._hasResource["dijit._KeyNavContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._KeyNavContainer"] = true;
dojo.provide("dijit._KeyNavContainer");


dojo.declare("dijit._KeyNavContainer",
	[dijit._Container],
	{

		// summary:
		//		A _Container with keyboard navigation of its children.
		// description:
		//		To use this mixin, call connectKeyNavHandlers() in
		//		postCreate() and call startupKeyNavChildren() in startup().
		//		It provides normalized keyboard and focusing code for Container
		//		widgets.
/*=====
		// focusedChild: [protected] Widget
		//		The currently focused child widget, or null if there isn't one
		focusedChild: null,
=====*/

		// tabIndex: Integer
		//		Tab index of the container; same as HTML tabindex attribute.
		//		Note then when user tabs into the container, focus is immediately
		//		moved to the first item in the container.
		tabIndex: "0",


		_keyNavCodes: {},

		connectKeyNavHandlers: function(/*dojo.keys[]*/ prevKeyCodes, /*dojo.keys[]*/ nextKeyCodes){
			// summary:
			//		Call in postCreate() to attach the keyboard handlers
			//		to the container.
			// preKeyCodes: dojo.keys[]
			//		Key codes for navigating to the previous child.
			// nextKeyCodes: dojo.keys[]
			//		Key codes for navigating to the next child.
			// tags:
			//		protected

			var keyCodes = this._keyNavCodes = {};
			var prev = dojo.hitch(this, this.focusPrev);
			var next = dojo.hitch(this, this.focusNext);
			dojo.forEach(prevKeyCodes, function(code){ keyCodes[code] = prev; });
			dojo.forEach(nextKeyCodes, function(code){ keyCodes[code] = next; });
			this.connect(this.domNode, "onkeypress", "_onContainerKeypress");
			this.connect(this.domNode, "onfocus", "_onContainerFocus");
		},

		startupKeyNavChildren: function(){
			// summary:
			//		Call in startup() to set child tabindexes to -1
			// tags:
			//		protected
			dojo.forEach(this.getChildren(), dojo.hitch(this, "_startupChild"));
		},

		addChild: function(/*Widget*/ widget, /*int?*/ insertIndex){
			// summary:
			//		Add a child to our _Container
			dijit._KeyNavContainer.superclass.addChild.apply(this, arguments);
			this._startupChild(widget);
		},

		focus: function(){
			// summary:
			//		Default focus() implementation: focus the first child.
			this.focusFirstChild();
		},

		focusFirstChild: function(){
			// summary:
			//		Focus the first focusable child in the container.
			// tags:
			//		protected
			this.focusChild(this._getFirstFocusableChild());
		},

		focusNext: function(){
			// summary:
			//		Focus the next widget or focal node (for widgets
			//		with multiple focal nodes) within this container.
			// tags:
			//		protected
			if(this.focusedChild && this.focusedChild.hasNextFocalNode
					&& this.focusedChild.hasNextFocalNode()){
				this.focusedChild.focusNext();
				return;
			}
			var child = this._getNextFocusableChild(this.focusedChild, 1);
			if(child.getFocalNodes){
				this.focusChild(child, child.getFocalNodes()[0]);
			}else{
				this.focusChild(child);
			}
		},

		focusPrev: function(){
			// summary:
			//		Focus the previous widget or focal node (for widgets
			//		with multiple focal nodes) within this container.
			// tags:
			//		protected
			if(this.focusedChild && this.focusedChild.hasPrevFocalNode
					&& this.focusedChild.hasPrevFocalNode()){
				this.focusedChild.focusPrev();
				return;
			}
			var child = this._getNextFocusableChild(this.focusedChild, -1);
			if(child.getFocalNodes){
				var nodes = child.getFocalNodes();
				this.focusChild(child, nodes[nodes.length-1]);
			}else{
				this.focusChild(child);
			}
		},

		focusChild: function(/*Widget*/ widget, /*Node?*/ node){
			// summary:
			//		Focus widget. Optionally focus 'node' within widget.
			// tags:
			//		protected
			if(widget){
				if(this.focusedChild && widget !== this.focusedChild){
					this._onChildBlur(this.focusedChild);
				}
				this.focusedChild = widget;
				if(node && widget.focusFocalNode){
					widget.focusFocalNode(node);
				}else{
					widget.focus();
				}
			}
		},

		_startupChild: function(/*Widget*/ widget){
			// summary:
			//		Set tabindex="-1" on focusable widgets so that we
			// 		can focus them programmatically and by clicking.
			//		Connect focus and blur handlers.
			// tags:
			//		private
			if(widget.getFocalNodes){
				dojo.forEach(widget.getFocalNodes(), function(node){
					dojo.attr(node, "tabindex", -1);
					this._connectNode(node);
				}, this);
			}else{
				var node = widget.focusNode || widget.domNode;
				if(widget.isFocusable()){
					dojo.attr(node, "tabindex", -1);
				}
				this._connectNode(node);
			}
		},

		_connectNode: function(/*Element*/ node){
			// summary:
			//		Monitor focus and blur events on the node
			// tags:
			//		private
			this.connect(node, "onfocus", "_onNodeFocus");
			this.connect(node, "onblur", "_onNodeBlur");
		},

		_onContainerFocus: function(evt){
			// summary:
			//		Handler for when the container gets focus
			// description:
			//		Initially the container itself has a tabIndex, but when it gets
			//		focus, switch focus to first child...
			// tags:
			//		private

			// Note that we can't use _onFocus() because switching focus from the
			// _onFocus() handler confuses the focus.js code
			// (because it causes _onFocusNode() to be called recursively)

			// focus bubbles on Firefox,
			// so just make sure that focus has really gone to the container
			if(evt.target !== this.domNode){ return; }

			this.focusFirstChild();
			
			// and then remove the container's tabIndex,
			// so that tab or shift-tab will go to the fields after/before
			// the container, rather than the container itself
			dojo.removeAttr(this.domNode, "tabIndex");
		},

		_onBlur: function(evt){
			// When focus is moved away the container, and it's descendant (popup) widgets,
			// then restore the container's tabIndex so that user can tab to it again.
			// Note that using _onBlur() so that this doesn't happen when focus is shifted
			// to one of my child widgets (typically a popup)
			if(this.tabIndex){
				dojo.attr(this.domNode, "tabindex", this.tabIndex);
			}
			// TODO: this.inherited(arguments);
		},

		_onContainerKeypress: function(evt){
			// summary:
			//		When a key is pressed, if it's an arrow key etc. then
			//		it's handled here.
			// tags:
			//		private
			if(evt.ctrlKey || evt.altKey){ return; }
			var func = this._keyNavCodes[evt.charOrCode];
			if(func){
				func();
				dojo.stopEvent(evt);
			}
		},

		_onNodeFocus: function(evt){
			// summary:
			//		Handler for onfocus event on a child node
			// tags:
			//		private

			// record the child that has been focused
			var widget = dijit.getEnclosingWidget(evt.target);
			if(widget && widget.isFocusable()){
				this.focusedChild = widget;
			}
			dojo.stopEvent(evt);
		},

		_onNodeBlur: function(evt){
			// summary:
			//		Handler for onblur event on a child node
			// tags:
			//		private
			dojo.stopEvent(evt);
		},

		_onChildBlur: function(/*Widget*/ widget){
			// summary:
			//		Called when focus leaves a child widget to go
			//		to a sibling widget.
			// tags:
			//		protected
		},

		_getFirstFocusableChild: function(){
			// summary:
			//		Returns first child that can be focused
			return this._getNextFocusableChild(null, 1);
		},

		_getNextFocusableChild: function(child, dir){
			// summary:
			//		Returns the next or previous focusable child, compared
			//		to "child"
			// child: Widget
			//		The current widget
			// dir: Integer
			//		* 1 = after
			//		* -1 = before
			if(child){
				child = this._getSiblingOfChild(child, dir);
			}
			var children = this.getChildren();
			for(var i=0; i < children.length; i++){
				if(!child){
					child = children[(dir>0) ? 0 : (children.length-1)];
				}
				if(child.isFocusable()){
					return child;
				}
				child = this._getSiblingOfChild(child, dir);
			}
			// no focusable child found
			return null;
		}
	}
);

}

if(!dojo._hasResource["dijit.ToolbarSeparator"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.ToolbarSeparator"] = true;
dojo.provide("dijit.ToolbarSeparator");




dojo.declare("dijit.ToolbarSeparator",
		[ dijit._Widget, dijit._Templated ],
		{
		// summary:
		//		A spacer between two `dijit.Toolbar` items
		templateString: '<div class="dijitToolbarSeparator dijitInline"></div>',
		postCreate: function(){ dojo.setSelectable(this.domNode, false); },
		isFocusable: function(){ 
			// summary:
			//		This widget isn't focusable, so pass along that fact.
			// tags:
			//		protected
			return false; 
		}

	});



}

if(!dojo._hasResource["dijit.Toolbar"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.Toolbar"] = true;
dojo.provide("dijit.Toolbar");





dojo.declare("dijit.Toolbar",
	[dijit._Widget, dijit._Templated, dijit._KeyNavContainer],
	{
	// summary:
	//		A Toolbar widget, used to hold things like `dijit.Editor` buttons

	templateString:
		'<div class="dijit dijitToolbar" waiRole="toolbar" tabIndex="${tabIndex}" dojoAttachPoint="containerNode">' +
		//	'<table style="table-layout: fixed" class="dijitReset dijitToolbarTable">' + // factor out style
		//		'<tr class="dijitReset" dojoAttachPoint="containerNode"></tr>'+
		//	'</table>' +
		'</div>',

	postCreate: function(){
		this.connectKeyNavHandlers(
			this.isLeftToRight() ? [dojo.keys.LEFT_ARROW] : [dojo.keys.RIGHT_ARROW],
			this.isLeftToRight() ? [dojo.keys.RIGHT_ARROW] : [dojo.keys.LEFT_ARROW]
		);
	},

	startup: function(){
		if(this._started){ return; }

		this.startupKeyNavChildren();

		this.inherited(arguments);
	}
}
);

// For back-compat, remove for 2.0


}

if(!dojo._hasResource["dojo.dnd.common"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.common"] = true;
dojo.provide("dojo.dnd.common");

dojo.dnd._isMac = navigator.appVersion.indexOf("Macintosh") >= 0;
dojo.dnd._copyKey = dojo.dnd._isMac ? "metaKey" : "ctrlKey";

dojo.dnd.getCopyKeyState = function(e) {
	// summary: abstracts away the difference between selection on Mac and PC,
	//	and returns the state of the "copy" key to be pressed.
	// e: Event: mouse event
	return e[dojo.dnd._copyKey];	// Boolean
};

dojo.dnd._uniqueId = 0;
dojo.dnd.getUniqueId = function(){
	// summary: returns a unique string for use with any DOM element
	var id;
	do{
		id = dojo._scopeName + "Unique" + (++dojo.dnd._uniqueId);
	}while(dojo.byId(id));
	return id;
};

dojo.dnd._empty = {};

dojo.dnd.isFormElement = function(/*Event*/ e){
	// summary: returns true, if user clicked on a form element
	var t = e.target;
	if(t.nodeType == 3 /*TEXT_NODE*/){
		t = t.parentNode;
	}
	return " button textarea input select option ".indexOf(" " + t.tagName.toLowerCase() + " ") >= 0;	// Boolean
};

// doesn't take into account when multiple buttons are pressed
dojo.dnd._lmb = dojo.isIE ? 1 : 0;	// left mouse button

dojo.dnd._isLmbPressed = dojo.isIE ?
	function(e){ return e.button & 1; } : // intentional bit-and
	function(e){ return e.button === 0; };

}

if(!dojo._hasResource["dojo.dnd.autoscroll"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.autoscroll"] = true;
dojo.provide("dojo.dnd.autoscroll");

dojo.dnd.getViewport = function(){
	// summary: returns a viewport size (visible part of the window)

	// FIXME: need more docs!!
	var d = dojo.doc, dd = d.documentElement, w = window, b = dojo.body();
	if(dojo.isMozilla){
		return {w: dd.clientWidth, h: w.innerHeight};	// Object
	}else if(!dojo.isOpera && w.innerWidth){
		return {w: w.innerWidth, h: w.innerHeight};		// Object
	}else if (!dojo.isOpera && dd && dd.clientWidth){
		return {w: dd.clientWidth, h: dd.clientHeight};	// Object
	}else if (b.clientWidth){
		return {w: b.clientWidth, h: b.clientHeight};	// Object
	}
	return null;	// Object
};

dojo.dnd.V_TRIGGER_AUTOSCROLL = 32;
dojo.dnd.H_TRIGGER_AUTOSCROLL = 32;

dojo.dnd.V_AUTOSCROLL_VALUE = 16;
dojo.dnd.H_AUTOSCROLL_VALUE = 16;

dojo.dnd.autoScroll = function(e){
	// summary:
	//		a handler for onmousemove event, which scrolls the window, if
	//		necesary
	// e: Event:
	//		onmousemove event

	// FIXME: needs more docs!
	var v = dojo.dnd.getViewport(), dx = 0, dy = 0;
	if(e.clientX < dojo.dnd.H_TRIGGER_AUTOSCROLL){
		dx = -dojo.dnd.H_AUTOSCROLL_VALUE;
	}else if(e.clientX > v.w - dojo.dnd.H_TRIGGER_AUTOSCROLL){
		dx = dojo.dnd.H_AUTOSCROLL_VALUE;
	}
	if(e.clientY < dojo.dnd.V_TRIGGER_AUTOSCROLL){
		dy = -dojo.dnd.V_AUTOSCROLL_VALUE;
	}else if(e.clientY > v.h - dojo.dnd.V_TRIGGER_AUTOSCROLL){
		dy = dojo.dnd.V_AUTOSCROLL_VALUE;
	}
	window.scrollBy(dx, dy);
};

dojo.dnd._validNodes = {"div": 1, "p": 1, "td": 1};
dojo.dnd._validOverflow = {"auto": 1, "scroll": 1};

dojo.dnd.autoScrollNodes = function(e){
	// summary:
	//		a handler for onmousemove event, which scrolls the first avaialble
	//		Dom element, it falls back to dojo.dnd.autoScroll()
	// e: Event:
	//		onmousemove event

	// FIXME: needs more docs!
	for(var n = e.target; n;){
		if(n.nodeType == 1 && (n.tagName.toLowerCase() in dojo.dnd._validNodes)){
			var s = dojo.getComputedStyle(n);
			if(s.overflow.toLowerCase() in dojo.dnd._validOverflow){
				var b = dojo._getContentBox(n, s), t = dojo._abs(n, true);
				//console.log(b.l, b.t, t.x, t.y, n.scrollLeft, n.scrollTop);
				var w = Math.min(dojo.dnd.H_TRIGGER_AUTOSCROLL, b.w / 2), 
					h = Math.min(dojo.dnd.V_TRIGGER_AUTOSCROLL, b.h / 2),
					rx = e.pageX - t.x, ry = e.pageY - t.y, dx = 0, dy = 0;
				if(dojo.isWebKit || dojo.isOpera){
					// FIXME: this code should not be here, it should be taken into account 
					// either by the event fixing code, or the dojo._abs()
					// FIXME: this code doesn't work on Opera 9.5 Beta
					rx += dojo.body().scrollLeft, ry += dojo.body().scrollTop;
				}
				if(rx > 0 && rx < b.w){
					if(rx < w){
						dx = -w;
					}else if(rx > b.w - w){
						dx = w;
					}
				}
				//console.log("ry =", ry, "b.h =", b.h, "h =", h);
				if(ry > 0 && ry < b.h){
					if(ry < h){
						dy = -h;
					}else if(ry > b.h - h){
						dy = h;
					}
				}
				var oldLeft = n.scrollLeft, oldTop = n.scrollTop;
				n.scrollLeft = n.scrollLeft + dx;
				n.scrollTop  = n.scrollTop  + dy;
				if(oldLeft != n.scrollLeft || oldTop != n.scrollTop){ return; }
			}
		}
		try{
			n = n.parentNode;
		}catch(x){
			n = null;
		}
	}
	dojo.dnd.autoScroll(e);
};

}

if(!dojo._hasResource["dojo.dnd.Mover"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Mover"] = true;
dojo.provide("dojo.dnd.Mover");




dojo.declare("dojo.dnd.Mover", null, {
	constructor: function(node, e, host){
		// summary: an object, which makes a node follow the mouse, 
		//	used as a default mover, and as a base class for custom movers
		// node: Node: a node (or node's id) to be moved
		// e: Event: a mouse event, which started the move;
		//	only pageX and pageY properties are used
		// host: Object?: object which implements the functionality of the move,
		//	 and defines proper events (onMoveStart and onMoveStop)
		this.node = dojo.byId(node);
		this.marginBox = {l: e.pageX, t: e.pageY};
		this.mouseButton = e.button;
		var h = this.host = host, d = node.ownerDocument, 
			firstEvent = dojo.connect(d, "onmousemove", this, "onFirstMove");
		this.events = [
			dojo.connect(d, "onmousemove", this, "onMouseMove"),
			dojo.connect(d, "onmouseup",   this, "onMouseUp"),
			// cancel text selection and text dragging
			dojo.connect(d, "ondragstart",   dojo.stopEvent),
			dojo.connect(d.body, "onselectstart", dojo.stopEvent),
			firstEvent
		];
		// notify that the move has started
		if(h && h.onMoveStart){
			h.onMoveStart(this);
		}
	},
	// mouse event processors
	onMouseMove: function(e){
		// summary: event processor for onmousemove
		// e: Event: mouse event
		dojo.dnd.autoScroll(e);
		var m = this.marginBox;
		this.host.onMove(this, {l: m.l + e.pageX, t: m.t + e.pageY});
		dojo.stopEvent(e);
	},
	onMouseUp: function(e){
		if(dojo.isWebKit && dojo.dnd._isMac && this.mouseButton == 2 ? 
				e.button == 0 : this.mouseButton == e.button){
			this.destroy();
		}
		dojo.stopEvent(e);
	},
	// utilities
	onFirstMove: function(){
		// summary: makes the node absolute; it is meant to be called only once. 
		// 	relative and absolutely positioned nodes are assumed to use pixel units
		var s = this.node.style, l, t, h = this.host;
		switch(s.position){
			case "relative":
			case "absolute":
				// assume that left and top values are in pixels already
				l = Math.round(parseFloat(s.left));
				t = Math.round(parseFloat(s.top));
				break;
			default:
				s.position = "absolute";	// enforcing the absolute mode
				var m = dojo.marginBox(this.node);
				// event.pageX/pageY (which we used to generate the initial
				// margin box) includes padding and margin set on the body.
				// However, setting the node's position to absolute and then
				// doing dojo.marginBox on it *doesn't* take that additional
				// space into account - so we need to subtract the combined
				// padding and margin.  We use getComputedStyle and
				// _getMarginBox/_getContentBox to avoid the extra lookup of
				// the computed style. 
				var b = dojo.doc.body;
				var bs = dojo.getComputedStyle(b);
				var bm = dojo._getMarginBox(b, bs);
				var bc = dojo._getContentBox(b, bs);
				l = m.l - (bc.l - bm.l);
				t = m.t - (bc.t - bm.t);
				break;
		}
		this.marginBox.l = l - this.marginBox.l;
		this.marginBox.t = t - this.marginBox.t;
		if(h && h.onFirstMove){
			h.onFirstMove(this);
		}
		dojo.disconnect(this.events.pop());
	},
	destroy: function(){
		// summary: stops the move, deletes all references, so the object can be garbage-collected
		dojo.forEach(this.events, dojo.disconnect);
		// undo global settings
		var h = this.host;
		if(h && h.onMoveStop){
			h.onMoveStop(this);
		}
		// destroy objects
		this.events = this.node = this.host = null;
	}
});

}

if(!dojo._hasResource["dojo.dnd.Moveable"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Moveable"] = true;
dojo.provide("dojo.dnd.Moveable");



dojo.declare("dojo.dnd.Moveable", null, {
	// object attributes (for markup)
	handle: "",
	delay: 0,
	skip: false,
	
	constructor: function(node, params){
		// summary: an object, which makes a node moveable
		// node: Node: a node (or node's id) to be moved
		// params: Object: an optional object with additional parameters;
		//	following parameters are recognized:
		//		handle: Node: a node (or node's id), which is used as a mouse handle
		//			if omitted, the node itself is used as a handle
		//		delay: Number: delay move by this number of pixels
		//		skip: Boolean: skip move of form elements
		//		mover: Object: a constructor of custom Mover
		this.node = dojo.byId(node);
		if(!params){ params = {}; }
		this.handle = params.handle ? dojo.byId(params.handle) : null;
		if(!this.handle){ this.handle = this.node; }
		this.delay = params.delay > 0 ? params.delay : 0;
		this.skip  = params.skip;
		this.mover = params.mover ? params.mover : dojo.dnd.Mover;
		this.events = [
			dojo.connect(this.handle, "onmousedown", this, "onMouseDown"),
			// cancel text selection and text dragging
			dojo.connect(this.handle, "ondragstart",   this, "onSelectStart"),
			dojo.connect(this.handle, "onselectstart", this, "onSelectStart")
		];
	},

	// markup methods
	markupFactory: function(params, node){
		return new dojo.dnd.Moveable(node, params);
	},

	// methods
	destroy: function(){
		// summary: stops watching for possible move, deletes all references, so the object can be garbage-collected
		dojo.forEach(this.events, dojo.disconnect);
		this.events = this.node = this.handle = null;
	},
	
	// mouse event processors
	onMouseDown: function(e){
		// summary: event processor for onmousedown, creates a Mover for the node
		// e: Event: mouse event
		if(this.skip && dojo.dnd.isFormElement(e)){ return; }
		if(this.delay){
			this.events.push(
				dojo.connect(this.handle, "onmousemove", this, "onMouseMove"),
				dojo.connect(this.handle, "onmouseup", this, "onMouseUp")
			);
			this._lastX = e.pageX;
			this._lastY = e.pageY;
		}else{
			this.onDragDetected(e);
		}
		dojo.stopEvent(e);
	},
	onMouseMove: function(e){
		// summary: event processor for onmousemove, used only for delayed drags
		// e: Event: mouse event
		if(Math.abs(e.pageX - this._lastX) > this.delay || Math.abs(e.pageY - this._lastY) > this.delay){
			this.onMouseUp(e);
			this.onDragDetected(e);
		}
		dojo.stopEvent(e);
	},
	onMouseUp: function(e){
		// summary: event processor for onmouseup, used only for delayed drags
		// e: Event: mouse event
		for(var i = 0; i < 2; ++i){
			dojo.disconnect(this.events.pop());
		}
		dojo.stopEvent(e);
	},
	onSelectStart: function(e){
		// summary: event processor for onselectevent and ondragevent
		// e: Event: mouse event
		if(!this.skip || !dojo.dnd.isFormElement(e)){
			dojo.stopEvent(e);
		}
	},
	
	// local events
	onDragDetected: function(/* Event */ e){
		// summary: called when the drag is detected,
		// responsible for creation of the mover
		new this.mover(this.node, e, this);
	},
	onMoveStart: function(/* dojo.dnd.Mover */ mover){
		// summary: called before every move operation
		dojo.publish("/dnd/move/start", [mover]);
		dojo.addClass(dojo.body(), "dojoMove"); 
		dojo.addClass(this.node, "dojoMoveItem"); 
	},
	onMoveStop: function(/* dojo.dnd.Mover */ mover){
		// summary: called after every move operation
		dojo.publish("/dnd/move/stop", [mover]);
		dojo.removeClass(dojo.body(), "dojoMove");
		dojo.removeClass(this.node, "dojoMoveItem");
	},
	onFirstMove: function(/* dojo.dnd.Mover */ mover){
		// summary: called during the very first move notification,
		//	can be used to initialize coordinates, can be overwritten.
		
		// default implementation does nothing
	},
	onMove: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop){
		// summary: called during every move notification,
		//	should actually move the node, can be overwritten.
		this.onMoving(mover, leftTop);
		var s = mover.node.style;
		s.left = leftTop.l + "px";
		s.top  = leftTop.t + "px";
		this.onMoved(mover, leftTop);
	},
	onMoving: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop){
		// summary: called before every incremental move,
		//	can be overwritten.
		
		// default implementation does nothing
	},
	onMoved: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop){
		// summary: called after every incremental move,
		//	can be overwritten.
		
		// default implementation does nothing
	}
});

}

if(!dojo._hasResource["dojo.dnd.move"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.move"] = true;
dojo.provide("dojo.dnd.move");




dojo.declare("dojo.dnd.move.constrainedMoveable", dojo.dnd.Moveable, {
	// object attributes (for markup)
	constraints: function(){},
	within: false,
	
	// markup methods
	markupFactory: function(params, node){
		return new dojo.dnd.move.constrainedMoveable(node, params);
	},

	constructor: function(node, params){
		// summary: an object, which makes a node moveable
		// node: Node: a node (or node's id) to be moved
		// params: Object: an optional object with additional parameters;
		//	following parameters are recognized:
		//		constraints: Function: a function, which calculates a constraint box,
		//			it is called in a context of the moveable object.
		//		within: Boolean: restrict move within boundaries.
		//	the rest is passed to the base class
		if(!params){ params = {}; }
		this.constraints = params.constraints;
		this.within = params.within;
	},
	onFirstMove: function(/* dojo.dnd.Mover */ mover){
		// summary: called during the very first move notification,
		//	can be used to initialize coordinates, can be overwritten.
		var c = this.constraintBox = this.constraints.call(this, mover);
		c.r = c.l + c.w;
		c.b = c.t + c.h;
		if(this.within){
			var mb = dojo.marginBox(mover.node);
			c.r -= mb.w;
			c.b -= mb.h;
		}
	},
	onMove: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop){
		// summary: called during every move notification,
		//	should actually move the node, can be overwritten.
		var c = this.constraintBox, s = mover.node.style;
		s.left = (leftTop.l < c.l ? c.l : c.r < leftTop.l ? c.r : leftTop.l) + "px";
		s.top  = (leftTop.t < c.t ? c.t : c.b < leftTop.t ? c.b : leftTop.t) + "px";
	}
});

dojo.declare("dojo.dnd.move.boxConstrainedMoveable", dojo.dnd.move.constrainedMoveable, {
	// object attributes (for markup)
	box: {},
	
	// markup methods
	markupFactory: function(params, node){
		return new dojo.dnd.move.boxConstrainedMoveable(node, params);
	},

	constructor: function(node, params){
		// summary: an object, which makes a node moveable
		// node: Node: a node (or node's id) to be moved
		// params: Object: an optional object with additional parameters;
		//	following parameters are recognized:
		//		box: Object: a constraint box
		//	the rest is passed to the base class
		var box = params && params.box;
		this.constraints = function(){ return box; };
	}
});

dojo.declare("dojo.dnd.move.parentConstrainedMoveable", dojo.dnd.move.constrainedMoveable, {
	// object attributes (for markup)
	area: "content",

	// markup methods
	markupFactory: function(params, node){
		return new dojo.dnd.move.parentConstrainedMoveable(node, params);
	},

	constructor: function(node, params){
		// summary: an object, which makes a node moveable
		// node: Node: a node (or node's id) to be moved
		// params: Object: an optional object with additional parameters;
		//	following parameters are recognized:
		//		area: String: a parent's area to restrict the move,
		//			can be "margin", "border", "padding", or "content".
		//	the rest is passed to the base class
		var area = params && params.area;
		this.constraints = function(){
			var n = this.node.parentNode, 
				s = dojo.getComputedStyle(n), 
				mb = dojo._getMarginBox(n, s);
			if(area == "margin"){
				return mb;	// Object
			}
			var t = dojo._getMarginExtents(n, s);
			mb.l += t.l, mb.t += t.t, mb.w -= t.w, mb.h -= t.h;
			if(area == "border"){
				return mb;	// Object
			}
			t = dojo._getBorderExtents(n, s);
			mb.l += t.l, mb.t += t.t, mb.w -= t.w, mb.h -= t.h;
			if(area == "padding"){
				return mb;	// Object
			}
			t = dojo._getPadExtents(n, s);
			mb.l += t.l, mb.t += t.t, mb.w -= t.w, mb.h -= t.h;
			return mb;	// Object
		};
	}
});

// WARNING: below are obsolete objects, instead of custom movers use custom moveables (above)

dojo.dnd.move.constrainedMover = function(fun, within){
	// summary: returns a constrained version of dojo.dnd.Mover
	// description: this function produces n object, which will put a constraint on 
	//	the margin box of dragged object in absolute coordinates
	// fun: Function: called on drag, and returns a constraint box
	// within: Boolean: if true, constraints the whole dragged object withtin the rectangle, 
	//	otherwise the constraint is applied to the left-top corner
	dojo.deprecated("dojo.dnd.move.constrainedMover, use dojo.dnd.move.constrainedMoveable instead");
	var mover = function(node, e, notifier){
		dojo.dnd.Mover.call(this, node, e, notifier);
	};
	dojo.extend(mover, dojo.dnd.Mover.prototype);
	dojo.extend(mover, {
		onMouseMove: function(e){
			// summary: event processor for onmousemove
			// e: Event: mouse event
			dojo.dnd.autoScroll(e);
			var m = this.marginBox, c = this.constraintBox,
				l = m.l + e.pageX, t = m.t + e.pageY;
			l = l < c.l ? c.l : c.r < l ? c.r : l;
			t = t < c.t ? c.t : c.b < t ? c.b : t;
			this.host.onMove(this, {l: l, t: t});
		},
		onFirstMove: function(){
			// summary: called once to initialize things; it is meant to be called only once
			dojo.dnd.Mover.prototype.onFirstMove.call(this);
			var c = this.constraintBox = fun.call(this);
			c.r = c.l + c.w;
			c.b = c.t + c.h;
			if(within){
				var mb = dojo.marginBox(this.node);
				c.r -= mb.w;
				c.b -= mb.h;
			}
		}
	});
	return mover;	// Object
};

dojo.dnd.move.boxConstrainedMover = function(box, within){
	// summary: a specialization of dojo.dnd.constrainedMover, which constrains to the specified box
	// box: Object: a constraint box (l, t, w, h)
	// within: Boolean: if true, constraints the whole dragged object withtin the rectangle, 
	//	otherwise the constraint is applied to the left-top corner
	dojo.deprecated("dojo.dnd.move.boxConstrainedMover, use dojo.dnd.move.boxConstrainedMoveable instead");
	return dojo.dnd.move.constrainedMover(function(){ return box; }, within);	// Object
};

dojo.dnd.move.parentConstrainedMover = function(area, within){
	// summary: a specialization of dojo.dnd.constrainedMover, which constrains to the parent node
	// area: String: "margin" to constrain within the parent's margin box, "border" for the border box,
	//	"padding" for the padding box, and "content" for the content box; "content" is the default value.
	// within: Boolean: if true, constraints the whole dragged object withtin the rectangle, 
	//	otherwise the constraint is applied to the left-top corner
	dojo.deprecated("dojo.dnd.move.parentConstrainedMover, use dojo.dnd.move.parentConstrainedMoveable instead");
	var fun = function(){
		var n = this.node.parentNode, 
			s = dojo.getComputedStyle(n), 
			mb = dojo._getMarginBox(n, s);
		if(area == "margin"){
			return mb;	// Object
		}
		var t = dojo._getMarginExtents(n, s);
		mb.l += t.l, mb.t += t.t, mb.w -= t.w, mb.h -= t.h;
		if(area == "border"){
			return mb;	// Object
		}
		t = dojo._getBorderExtents(n, s);
		mb.l += t.l, mb.t += t.t, mb.w -= t.w, mb.h -= t.h;
		if(area == "padding"){
			return mb;	// Object
		}
		t = dojo._getPadExtents(n, s);
		mb.l += t.l, mb.t += t.t, mb.w -= t.w, mb.h -= t.h;
		return mb;	// Object
	};
	return dojo.dnd.move.constrainedMover(fun, within);	// Object
};

// patching functions one level up for compatibility

dojo.dnd.constrainedMover = dojo.dnd.move.constrainedMover;
dojo.dnd.boxConstrainedMover = dojo.dnd.move.boxConstrainedMover;
dojo.dnd.parentConstrainedMover = dojo.dnd.move.parentConstrainedMover;

}

if(!dojo._hasResource["dojo.dnd.TimedMoveable"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.TimedMoveable"] = true;
dojo.provide("dojo.dnd.TimedMoveable");



(function(){
	// precalculate long expressions
	var oldOnMove = dojo.dnd.Moveable.prototype.onMove;
		
	dojo.declare("dojo.dnd.TimedMoveable", dojo.dnd.Moveable, {
		// summary:
		//	A specialized version of Moveable to support an FPS throttling.
		//	This class puts an upper restriction on FPS, which may reduce 
		//	the CPU load. The additional parameter "timeout" regulates
		//	the delay before actually moving the moveable object.
		
		// object attributes (for markup)
		timeout: 40,	// in ms, 40ms corresponds to 25 fps
	
		constructor: function(node, params){
			// summary: an object, which makes a node moveable with a timer
			// node: Node: a node (or node's id) to be moved
			// params: Object: an optional object with additional parameters.
			//	See dojo.dnd.Moveable for details on general parameters.
			//	Following parameters are specific for this class:
			//		timeout: Number: delay move by this number of ms
			//			accumulating position changes during the timeout
			
			// sanitize parameters
			if(!params){ params = {}; }
			if(params.timeout && typeof params.timeout == "number" && params.timeout >= 0){
				this.timeout = params.timeout;
			}
		},
	
		// markup methods
		markupFactory: function(params, node){
			return new dojo.dnd.TimedMoveable(node, params);
		},
	
		onMoveStop: function(/* dojo.dnd.Mover */ mover){
			if(mover._timer){
				// stop timer
				clearTimeout(mover._timer)
				// reflect the last received position
				oldOnMove.call(this, mover, mover._leftTop)
			}
			dojo.dnd.Moveable.prototype.onMoveStop.apply(this, arguments);
		},
		onMove: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop){
			mover._leftTop = leftTop;
			if(!mover._timer){
				var _t = this;	// to avoid using dojo.hitch()
				mover._timer = setTimeout(function(){
					// we don't have any pending requests
					mover._timer = null;
					// reflect the last received position
					oldOnMove.call(_t, mover, mover._leftTop);
				}, this.timeout);
			}
		}
	});
})();

}

if(!dojo._hasResource["dojo.fx.Toggler"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.fx.Toggler"] = true;
dojo.provide("dojo.fx.Toggler");

dojo.declare("dojo.fx.Toggler", null, {
	// summary:
	//		class constructor for an animation toggler. It accepts a packed
	//		set of arguments about what type of animation to use in each
	//		direction, duration, etc.
	//
	// example:
	//	|	var t = new dojo.fx.Toggler({
	//	|		node: "nodeId",
	//	|		showDuration: 500,
	//	|		// hideDuration will default to "200"
	//	|		showFunc: dojo.wipeIn, 
	//	|		// hideFunc will default to "fadeOut"
	//	|	});
	//	|	t.show(100); // delay showing for 100ms
	//	|	// ...time passes...
	//	|	t.hide();

	// FIXME: need a policy for where the toggler should "be" the next
	// time show/hide are called if we're stopped somewhere in the
	// middle.

	constructor: function(args){
		var _t = this;

		dojo.mixin(_t, args);
		_t.node = args.node;
		_t._showArgs = dojo.mixin({}, args);
		_t._showArgs.node = _t.node;
		_t._showArgs.duration = _t.showDuration;
		_t.showAnim = _t.showFunc(_t._showArgs);

		_t._hideArgs = dojo.mixin({}, args);
		_t._hideArgs.node = _t.node;
		_t._hideArgs.duration = _t.hideDuration;
		_t.hideAnim = _t.hideFunc(_t._hideArgs);

		dojo.connect(_t.showAnim, "beforeBegin", dojo.hitch(_t.hideAnim, "stop", true));
		dojo.connect(_t.hideAnim, "beforeBegin", dojo.hitch(_t.showAnim, "stop", true));
	},

	// node: DomNode
	//	the node to toggle
	node: null,

	// showFunc: Function
	//	The function that returns the dojo._Animation to show the node
	showFunc: dojo.fadeIn,

	// hideFunc: Function	
	//	The function that returns the dojo._Animation to hide the node
	hideFunc: dojo.fadeOut,

	// showDuration:
	//	Time in milliseconds to run the show Animation
	showDuration: 200,

	// hideDuration:
	//	Time in milliseconds to run the hide Animation
	hideDuration: 200,

	/*=====
	_showArgs: null,
	_showAnim: null,

	_hideArgs: null,
	_hideAnim: null,

	_isShowing: false,
	_isHiding: false,
	=====*/

	show: function(delay){
		// summary: Toggle the node to showing
		return this.showAnim.play(delay || 0);
	},

	hide: function(delay){
		// summary: Toggle the node to hidden
		return this.hideAnim.play(delay || 0);
	}
});

}

if(!dojo._hasResource["dojo.fx"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.fx"] = true;
dojo.provide("dojo.fx");

/*=====
dojo.fx = {
	// summary: Effects library on top of Base animations
};
=====*/
(function(){
	
	var d = dojo, 
		_baseObj = {
			_fire: function(evt, args){
				if(this[evt]){
					this[evt].apply(this, args||[]);
				}
				return this;
			}
		};

	var _chain = function(animations){
		this._index = -1;
		this._animations = animations||[];
		this._current = this._onAnimateCtx = this._onEndCtx = null;

		this.duration = 0;
		d.forEach(this._animations, function(a){
			this.duration += a.duration;
			if(a.delay){ this.duration += a.delay; }
		}, this);
	};
	d.extend(_chain, {
		_onAnimate: function(){
			this._fire("onAnimate", arguments);
		},
		_onEnd: function(){
			d.disconnect(this._onAnimateCtx);
			d.disconnect(this._onEndCtx);
			this._onAnimateCtx = this._onEndCtx = null;
			if(this._index + 1 == this._animations.length){
				this._fire("onEnd");
			}else{
				// switch animations
				this._current = this._animations[++this._index];
				this._onAnimateCtx = d.connect(this._current, "onAnimate", this, "_onAnimate");
				this._onEndCtx = d.connect(this._current, "onEnd", this, "_onEnd");
				this._current.play(0, true);
			}
		},
		play: function(/*int?*/ delay, /*Boolean?*/ gotoStart){
			if(!this._current){ this._current = this._animations[this._index = 0]; }
			if(!gotoStart && this._current.status() == "playing"){ return this; }
			var beforeBegin = d.connect(this._current, "beforeBegin", this, function(){
					this._fire("beforeBegin");
				}),
				onBegin = d.connect(this._current, "onBegin", this, function(arg){
					this._fire("onBegin", arguments);
				}),
				onPlay = d.connect(this._current, "onPlay", this, function(arg){
					this._fire("onPlay", arguments);
					d.disconnect(beforeBegin);
					d.disconnect(onBegin);
					d.disconnect(onPlay);
				});
			if(this._onAnimateCtx){
				d.disconnect(this._onAnimateCtx);
			}
			this._onAnimateCtx = d.connect(this._current, "onAnimate", this, "_onAnimate");
			if(this._onEndCtx){
				d.disconnect(this._onEndCtx);
			}
			this._onEndCtx = d.connect(this._current, "onEnd", this, "_onEnd");
			this._current.play.apply(this._current, arguments);
			return this;
		},
		pause: function(){
			if(this._current){
				var e = d.connect(this._current, "onPause", this, function(arg){
						this._fire("onPause", arguments);
						d.disconnect(e);
					});
				this._current.pause();
			}
			return this;
		},
		gotoPercent: function(/*Decimal*/percent, /*Boolean?*/ andPlay){
			this.pause();
			var offset = this.duration * percent;
			this._current = null;
			d.some(this._animations, function(a){
				if(a.duration <= offset){
					this._current = a;
					return true;
				}
				offset -= a.duration;
				return false;
			});
			if(this._current){
				this._current.gotoPercent(offset / this._current.duration, andPlay);
			}
			return this;
		},
		stop: function(/*boolean?*/ gotoEnd){
			if(this._current){
				if(gotoEnd){
					for(; this._index + 1 < this._animations.length; ++this._index){
						this._animations[this._index].stop(true);
					}
					this._current = this._animations[this._index];
				}
				var e = d.connect(this._current, "onStop", this, function(arg){
						this._fire("onStop", arguments);
						d.disconnect(e);
					});
				this._current.stop();
			}
			return this;
		},
		status: function(){
			return this._current ? this._current.status() : "stopped";
		},
		destroy: function(){
			if(this._onAnimateCtx){ d.disconnect(this._onAnimateCtx); }
			if(this._onEndCtx){ d.disconnect(this._onEndCtx); }
		}
	});
	d.extend(_chain, _baseObj);

	dojo.fx.chain = function(/*dojo._Animation[]*/ animations){
		// summary: Chain a list of dojo._Animation s to run in sequence
		// example:
		//	|	dojo.fx.chain([
		//	|		dojo.fadeIn({ node:node }),
		//	|		dojo.fadeOut({ node:otherNode })
		//	|	]).play();
		//
		return new _chain(animations) // dojo._Animation
	};

	var _combine = function(animations){
		this._animations = animations||[];
		this._connects = [];
		this._finished = 0;

		this.duration = 0;
		d.forEach(animations, function(a){
			var duration = a.duration;
			if(a.delay){ duration += a.delay; }
			if(this.duration < duration){ this.duration = duration; }
			this._connects.push(d.connect(a, "onEnd", this, "_onEnd"));
		}, this);
		
		this._pseudoAnimation = new d._Animation({curve: [0, 1], duration: this.duration});
		var self = this;
		d.forEach(["beforeBegin", "onBegin", "onPlay", "onAnimate", "onPause", "onStop"], 
			function(evt){
				self._connects.push(d.connect(self._pseudoAnimation, evt,
					function(){ self._fire(evt, arguments); }
				));
			}
		);
	};
	d.extend(_combine, {
		_doAction: function(action, args){
			d.forEach(this._animations, function(a){
				a[action].apply(a, args);
			});
			return this;
		},
		_onEnd: function(){
			if(++this._finished == this._animations.length){
				this._fire("onEnd");
			}
		},
		_call: function(action, args){
			var t = this._pseudoAnimation;
			t[action].apply(t, args);
		},
		play: function(/*int?*/ delay, /*Boolean?*/ gotoStart){
			this._finished = 0;
			this._doAction("play", arguments);
			this._call("play", arguments);
			return this;
		},
		pause: function(){
			this._doAction("pause", arguments);
			this._call("pause", arguments);
			return this;
		},
		gotoPercent: function(/*Decimal*/percent, /*Boolean?*/ andPlay){
			var ms = this.duration * percent;
			d.forEach(this._animations, function(a){
				a.gotoPercent(a.duration < ms ? 1 : (ms / a.duration), andPlay);
			});
			this._call("gotoPercent", arguments);
			return this;
		},
		stop: function(/*boolean?*/ gotoEnd){
			this._doAction("stop", arguments);
			this._call("stop", arguments);
			return this;
		},
		status: function(){
			return this._pseudoAnimation.status();
		},
		destroy: function(){
			d.forEach(this._connects, dojo.disconnect);
		}
	});
	d.extend(_combine, _baseObj);

	dojo.fx.combine = function(/*dojo._Animation[]*/ animations){
		// summary: Combine an array of `dojo._Animation`s to run in parallel
		//
		// description:
		//		Combine an array of `dojo._Animation`s to run in parallel, 
		//		providing a new `dojo._Animation` instance encompasing each
		//		animation, firing standard animation events.
		//
		// example:
		//	|	dojo.fx.combine([
		//	|		dojo.fadeIn({ node:node }),
		//	|		dojo.fadeOut({ node:otherNode })
		//	|	]).play();
		//
		// example:
		//	When the longest animation ends, execute a function:
		//	| 	var anim = dojo.fx.combine([
		//	|		dojo.fadeIn({ node: n, duration:700 }),
		//	|		dojo.fadeOut({ node: otherNode, duration: 300 })
		//	|	]);
		//	|	dojo.connect(anim, "onEnd", function(){
		//	|		// overall animation is done.
		//	|	});
		//	|	anim.play(); // play the animation
		//
		return new _combine(animations); // dojo._Animation
	};

	dojo.fx.wipeIn = function(/*Object*/ args){
		// summary:
		//		Returns an animation that will expand the
		//		node defined in 'args' object from it's current height to
		//		it's natural height (with no scrollbar).
		//		Node must have no margin/border/padding.
		args.node = d.byId(args.node);
		var node = args.node, s = node.style, o;

		var anim = d.animateProperty(d.mixin({
			properties: {
				height: {
					// wrapped in functions so we wait till the last second to query (in case value has changed)
					start: function(){
						// start at current [computed] height, but use 1px rather than 0
						// because 0 causes IE to display the whole panel
						o = s.overflow;
						s.overflow="hidden";
						if(s.visibility=="hidden"||s.display=="none"){
							s.height="1px";
							s.display="";
							s.visibility="";
							return 1;
						}else{
							var height = d.style(node, "height");
							return Math.max(height, 1);
						}
					},
					end: function(){
						return node.scrollHeight;
					}
				}
			}
		}, args));

		d.connect(anim, "onEnd", function(){ 
			s.height = "auto";
			s.overflow = o;
		});

		return anim; // dojo._Animation
	}

	dojo.fx.wipeOut = function(/*Object*/ args){
		// summary:
		//		Returns an animation that will shrink node defined in "args"
		//		from it's current height to 1px, and then hide it.
		var node = args.node = d.byId(args.node), s = node.style, o;
		
		var anim = d.animateProperty(d.mixin({
			properties: {
				height: {
					end: 1 // 0 causes IE to display the whole panel
				}
			}
		}, args));

		d.connect(anim, "beforeBegin", function(){
			o = s.overflow;
			s.overflow = "hidden";
			s.display = "";
		});
		d.connect(anim, "onEnd", function(){
			s.overflow = o;
			s.height = "auto";
			s.display = "none";
		});

		return anim; // dojo._Animation
	}

	dojo.fx.slideTo = function(/*Object?*/ args){
		// summary:
		//		Returns an animation that will slide "node" 
		//		defined in args Object from its current position to
		//		the position defined by (args.left, args.top).
		// example:
		//	|	dojo.fx.slideTo({ node: node, left:"40", top:"50", unit:"px" }).play()

		var node = args.node = d.byId(args.node), 
			top = null, left = null;

		var init = (function(n){
			return function(){
				var cs = d.getComputedStyle(n);
				var pos = cs.position;
				top = (pos == 'absolute' ? n.offsetTop : parseInt(cs.top) || 0);
				left = (pos == 'absolute' ? n.offsetLeft : parseInt(cs.left) || 0);
				if(pos != 'absolute' && pos != 'relative'){
					var ret = d.coords(n, true);
					top = ret.y;
					left = ret.x;
					n.style.position="absolute";
					n.style.top=top+"px";
					n.style.left=left+"px";
				}
			};
		})(node);
		init();

		var anim = d.animateProperty(d.mixin({
			properties: {
				top: args.top || 0,
				left: args.left || 0
			}
		}, args));
		d.connect(anim, "beforeBegin", anim, init);

		return anim; // dojo._Animation
	}

})();

}

if(!dojo._hasResource["dijit.form._FormMixin"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form._FormMixin"] = true;
dojo.provide("dijit.form._FormMixin");

dojo.declare("dijit.form._FormMixin", null,
	{
	// summary:
	//		Mixin for containers of form widgets (i.e. widgets that represent a single value
	//		and can be children of a <form> node or dijit.form.Form widget)
	// description:
	//		Can extract all the form widgets
	//		values and combine them into a single javascript object, or alternately
	//		take such an object and set the values for all the contained
	//		form widgets

/*=====
    // value: Object
	//		Name/value hash for each form element.
	//		If there are multiple elements w/the same name, value is an array,
	//		unless they are radio buttons in which case value is a scalar since only
	//		one can be checked at a time.
	//
	//		If the name is a dot separated list (like a.b.c.d), it's a nested structure.
	//		Only works on widget form elements.
	// example:
	//	| { name: "John Smith", interests: ["sports", "movies"] }
=====*/
	
	//	TODO:
	//	* Repeater
	//	* better handling for arrays.  Often form elements have names with [] like
	//	* people[3].sex (for a list of people [{name: Bill, sex: M}, ...])
	//
	//	

		reset: function(){
			dojo.forEach(this.getDescendants(), function(widget){
				if(widget.reset){
					widget.reset();
				}
			});
		},

		validate: function(){
			// summary: returns if the form is valid - same as isValid - but
			//			provides a few additional (ui-specific) features.
			//			1 - it will highlight any sub-widgets that are not
			//				valid
			//			2 - it will call focus() on the first invalid 
			//				sub-widget
			var didFocus = false;
			return dojo.every(dojo.map(this.getDescendants(), function(widget){
				// Need to set this so that "required" widgets get their 
				// state set.
				widget._hasBeenBlurred = true;
				var valid = widget.disabled || !widget.validate || widget.validate();
				if (!valid && !didFocus) {
					// Set focus of the first non-valid widget
					dijit.scrollIntoView(widget.containerNode||widget.domNode);
					widget.focus();
					didFocus = true;
				}
	 			return valid;
	 		}), function(item) { return item; });
		},
	
		setValues: function(val){
			dojo.deprecated(this.declaredClass+"::setValues() is deprecated. Use attr('value', val) instead.", "", "2.0");
			return this.attr('value', val);
		},
		_setValueAttr: function(/*object*/obj){
			// summary: Fill in form values from according to an Object (in the format returned by attr('value'))

			// generate map from name --> [list of widgets with that name]
			var map = { };
			dojo.forEach(this.getDescendants(), function(widget){
				if(!widget.name){ return; }
				var entry = map[widget.name] || (map[widget.name] = [] );
				entry.push(widget);
			});

			for(var name in map){
				if(!map.hasOwnProperty(name)){
					continue;
				}
				var widgets = map[name],						// array of widgets w/this name
					values = dojo.getObject(name, false, obj);	// list of values for those widgets

				if(values===undefined){
					continue;
				}
				if(!dojo.isArray(values)){
					values = [ values ];
				}
				if(typeof widgets[0].checked == 'boolean'){
					// for checkbox/radio, values is a list of which widgets should be checked
					dojo.forEach(widgets, function(w, i){
						w.attr('value', dojo.indexOf(values, w.value) != -1);
					});
				}else if(widgets[0]._multiValue){
					// it takes an array (e.g. multi-select)
					widgets[0].attr('value', values);
				}else{
					// otherwise, values is a list of values to be assigned sequentially to each widget
					dojo.forEach(widgets, function(w, i){
						w.attr('value', values[i]);
					});					
				}
			}

			/***
			 * 	TODO: code for plain input boxes (this shouldn't run for inputs that are part of widgets)

			dojo.forEach(this.containerNode.elements, function(element){
				if (element.name == ''){return};	// like "continue"	
				var namePath = element.name.split(".");
				var myObj=obj;
				var name=namePath[namePath.length-1];
				for(var j=1,len2=namePath.length;j<len2;++j){
					var p=namePath[j - 1];
					// repeater support block
					var nameA=p.split("[");
					if (nameA.length > 1){
						if(typeof(myObj[nameA[0]]) == "undefined"){
							myObj[nameA[0]]=[ ];
						} // if

						nameIndex=parseInt(nameA[1]);
						if(typeof(myObj[nameA[0]][nameIndex]) == "undefined"){
							myObj[nameA[0]][nameIndex] = { };
						}
						myObj=myObj[nameA[0]][nameIndex];
						continue;
					} // repeater support ends

					if(typeof(myObj[p]) == "undefined"){
						myObj=undefined;
						break;
					};
					myObj=myObj[p];
				}

				if (typeof(myObj) == "undefined"){
					return;		// like "continue"
				}
				if (typeof(myObj[name]) == "undefined" && this.ignoreNullValues){
					return;		// like "continue"
				}

				// TODO: widget values (just call attr('value', ...) on the widget)

				switch(element.type){
					case "checkbox":
						element.checked = (name in myObj) &&
							dojo.some(myObj[name], function(val){ return val==element.value; });
						break;
					case "radio":
						element.checked = (name in myObj) && myObj[name]==element.value;
						break;
					case "select-multiple":
						element.selectedIndex=-1;
						dojo.forEach(element.options, function(option){
							option.selected = dojo.some(myObj[name], function(val){ return option.value == val; });
						});
						break;
					case "select-one":
						element.selectedIndex="0";
						dojo.forEach(element.options, function(option){
							option.selected = option.value == myObj[name];
						});
						break;
					case "hidden":
					case "text":
					case "textarea":
					case "password":
						element.value = myObj[name] || "";
						break;
				}
	  		});
	  		*/
		},

		getValues: function(){
			dojo.deprecated(this.declaredClass+"::getValues() is deprecated. Use attr('value') instead.", "", "2.0");
			return this.attr('value');
		},
		_getValueAttr: function(){
			// summary:
			// 		Returns Object representing form values.
			// description:
			//		Returns name/value hash for each form element.
			//		If there are multiple elements w/the same name, value is an array,
			//		unless they are radio buttons in which case value is a scalar since only
			//		one can be checked at a time.
			//
			//		If the name is a dot separated list (like a.b.c.d), creates a nested structure.
			//		Only works on widget form elements.
			// example:
			//		| { name: "John Smith", interests: ["sports", "movies"] }

			// get widget values
			var obj = { };
			dojo.forEach(this.getDescendants(), function(widget){
				var name = widget.name;
				if(!name||widget.disabled){ return; }

				// Single value widget (checkbox, radio, or plain <input> type widget
				var value = widget.attr('value');

				// Store widget's value(s) as a scalar, except for checkboxes which are automatically arrays
				if(typeof widget.checked == 'boolean'){
					if(/Radio/.test(widget.declaredClass)){
						// radio button
						if(value !== false){
							dojo.setObject(name, value, obj);
						}else{
							// give radio widgets a default of null
							value = dojo.getObject(name, false, obj);
							if(value === undefined){
								dojo.setObject(name, null, obj);
							}
						}
					}else{
						// checkbox/toggle button
						var ary=dojo.getObject(name, false, obj);
						if(!ary){
							ary=[];
							dojo.setObject(name, ary, obj);
						}
						if(value !== false){
							ary.push(value);
						}
					}
				}else{
					// plain input
					dojo.setObject(name, value, obj);
				}
			});

			/***
			 * code for plain input boxes (see also dojo.formToObject, can we use that instead of this code?
			 * but it doesn't understand [] notation, presumably)
			var obj = { };
			dojo.forEach(this.containerNode.elements, function(elm){
				if (!elm.name)	{
					return;		// like "continue"
				}
				var namePath = elm.name.split(".");
				var myObj=obj;
				var name=namePath[namePath.length-1];
				for(var j=1,len2=namePath.length;j<len2;++j){
					var nameIndex = null;
					var p=namePath[j - 1];
					var nameA=p.split("[");
					if (nameA.length > 1){
						if(typeof(myObj[nameA[0]]) == "undefined"){
							myObj[nameA[0]]=[ ];
						} // if
						nameIndex=parseInt(nameA[1]);
						if(typeof(myObj[nameA[0]][nameIndex]) == "undefined"){
							myObj[nameA[0]][nameIndex] = { };
						}
					} else if(typeof(myObj[nameA[0]]) == "undefined"){
						myObj[nameA[0]] = { }
					} // if

					if (nameA.length == 1){
						myObj=myObj[nameA[0]];
					} else{
						myObj=myObj[nameA[0]][nameIndex];
					} // if
				} // for

				if ((elm.type != "select-multiple" && elm.type != "checkbox" && elm.type != "radio") || (elm.type=="radio" && elm.checked)){
					if(name == name.split("[")[0]){
						myObj[name]=elm.value;
					} else{
						// can not set value when there is no name
					}
				} else if (elm.type == "checkbox" && elm.checked){
					if(typeof(myObj[name]) == 'undefined'){
						myObj[name]=[ ];
					}
					myObj[name].push(elm.value);
				} else if (elm.type == "select-multiple"){
					if(typeof(myObj[name]) == 'undefined'){
						myObj[name]=[ ];
					}
					for (var jdx=0,len3=elm.options.length; jdx<len3; ++jdx){
						if (elm.options[jdx].selected){
							myObj[name].push(elm.options[jdx].value);
						}
					}
				} // if
				name=undefined;
			}); // forEach
			***/
			return obj;
		},

		// TODO: ComboBox might need time to process a recently input value.  This should be async?
	 	isValid: function(){
	 		// summary:
	 		//		Returns true if all of the widgets are valid
	 		
	 		// This also populate this._invalidWidgets[] array with list of invalid widgets...
	 		// TODO: put that into separate function?   It's confusing to have that as a side effect
	 		// of a method named isValid().

			this._invalidWidgets = dojo.filter(this.getDescendants(), function(widget){
				return !widget.disabled && widget.isValid && !widget.isValid();
	 		});
			return !this._invalidWidgets.length;
		},
		
		
		onValidStateChange: function(isValid){
			// summary:
			//		Stub function to connect to if you want to do something
			//		(like disable/enable a submit button) when the valid 
			//		state changes on the form as a whole.
		},
		
		_widgetChange: function(widget){
			// summary:
			//		Connected to a widget's onChange function - update our 
			//		valid state, if needed.
			var isValid = this._lastValidState;
			if(!widget || this._lastValidState===undefined){
				// We have passed a null widget, or we haven't been validated
				// yet - let's re-check all our children
				// This happens when we connect (or reconnect) our children
				isValid = this.isValid();
				if(this._lastValidState===undefined){
					// Set this so that we don't fire an onValidStateChange 
					// the first time
					this._lastValidState = isValid;
				}
			}else if(widget.isValid){
				this._invalidWidgets = dojo.filter(this._invalidWidgets||[], function(w){
					return (w != widget);
				}, this);
				if(!widget.isValid() && !widget.attr("disabled")){
					this._invalidWidgets.push(widget);
				}
				isValid = (this._invalidWidgets.length === 0);
			}
			if (isValid !== this._lastValidState){
				this._lastValidState = isValid;
				this.onValidStateChange(isValid);
			}
		},
		
		connectChildren: function(){
			// summary:
			//		Connects to the onChange function of all children to
			//		track valid state changes.  You can call this function
			//		directly, ex. in the event that you programmatically
			//		add a widget to the form *after* the form has been
			//		initialized.
			dojo.forEach(this._changeConnections, dojo.hitch(this, "disconnect"));
			var _this = this;
			
			// we connect to validate - so that it better reflects the states
			// of the widgets - also, we only connect if it has a validate
			// function (to avoid too many unneeded connections)
			var conns = this._changeConnections = [];
			dojo.forEach(dojo.filter(this.getDescendants(),
				function(item){ return item.validate; }
			),
			function(widget){
				// We are interested in whenever the widget is validated - or
				// whenever the disabled attribute on that widget is changed
				conns.push(_this.connect(widget, "validate", 
									dojo.hitch(_this, "_widgetChange", widget)));
				conns.push(_this.connect(widget, "_setDisabledAttr", 
									dojo.hitch(_this, "_widgetChange", widget)));
			});

			// Call the widget change function to update the valid state, in 
			// case something is different now.
			this._widgetChange(null);
		},
		
		startup: function(){
			this.inherited(arguments);
			// Initialize our valid state tracking.  Needs to be done in startup
			// because it's not guaranteed that our children are initialized 
			// yet.
			this._changeConnections = [];
			this.connectChildren();
		}
	});

}

if(!dojo._hasResource["dijit._DialogMixin"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._DialogMixin"] = true;
dojo.provide("dijit._DialogMixin");

dojo.declare("dijit._DialogMixin", null,
	{
		// summary:
		//		This provides functions useful to Dialog and TooltipDialog

		attributeMap: dijit._Widget.prototype.attributeMap,

		execute: function(/*Object*/ formContents){
			// summary:
			//		Callback when the user hits the submit button.
			//		Override this method to handle Dialog execution.
			// description:
			//		After the user has pressed the submit button, the Dialog
			//		first calls onExecute() to notify the container to hide the
			//		dialog and restore focus to wherever it used to be.
			//
			//		*Then* this method is called.
			// type:
			//		callback
		},

		onCancel: function(){
			// summary:
			//	    Called when user has pressed the Dialog's cancel button, to notify container.
			// description:
			//	    Developer shouldn't override or connect to this method;
			//		it's a private communication device between the TooltipDialog
			//		and the thing that opened it (ex: `dijit.form.DropDownButton`)
			// type:
			//		protected
		},

		onExecute: function(){
			// summary:
			//	    Called when user has pressed the dialog's OK button, to notify container.
			// description:
			//	    Developer shouldn't override or connect to this method;
			//		it's a private communication device between the TooltipDialog
			//		and the thing that opened it (ex: `dijit.form.DropDownButton`)
			// type:
			//		protected
		},

		_onSubmit: function(){
			// summary:
			//		Callback when user hits submit button
			// type:
			//		protected
			this.onExecute();	// notify container that we are about to execute
			this.execute(this.attr('value'));
		},

		_getFocusItems: function(/*Node*/ dialogNode){
			// summary:
			//		Find focusable Items each time a dialog is opened,
			//		setting _firstFocusItem and _lastFocusItem
			// tags:
			//		protected
			
			var elems = dijit._getTabNavigable(dojo.byId(dialogNode));
			this._firstFocusItem = elems.lowest || elems.first || dialogNode;
			this._lastFocusItem = elems.last || elems.highest || this._firstFocusItem;
			if(dojo.isMoz && this._firstFocusItem.tagName.toLowerCase() == "input" && dojo.attr(this._firstFocusItem, "type").toLowerCase() == "file"){
					//FF doesn't behave well when first element is input type=file, set first focusable to dialog container
					dojo.attr(dialogNode, "tabindex", "0");
					this._firstFocusItem = dialogNode;
			}
		}
	}
);

}

if(!dojo._hasResource["dijit.DialogUnderlay"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.DialogUnderlay"] = true;
dojo.provide("dijit.DialogUnderlay");




dojo.declare(
	"dijit.DialogUnderlay",
	[dijit._Widget, dijit._Templated],
	{
		// summary: The component that blocks the screen behind a `dijit.Dialog`
		//
		// description:
		// 		A component used to block input behind a `dijit.Dialog`. Only a single
		//		instance of this widget is created by `dijit.Dialog`, and saved as 
		//		a reference to be shared between all Dialogs as `dijit._underlay`
		//	
		//		The underlay itself can be styled based on and id:
		//	|	#myDialog_underlay { background-color:red; }
		//
		//		In the case of `dijit.Dialog`, this id is based on the id of the Dialog,
		//		suffixed with _underlay. 
		
		// Template has two divs; outer div is used for fade-in/fade-out, and also to hold background iframe.
		// Inner div has opacity specified in CSS file.
		templateString: "<div class='dijitDialogUnderlayWrapper'><div class='dijitDialogUnderlay' dojoAttachPoint='node'></div></div>",

		// Parameters on creation or updatable later

		// dialogId: String
		//		Id of the dialog.... DialogUnderlay's id is based on this id
		dialogId: "",

		// class: String
		//		This class name is used on the DialogUnderlay node, in addition to dijitDialogUnderlay
		"class": "",

		attributeMap: { id: "domNode" },

		_setDialogIdAttr: function(id){
			dojo.attr(this.node, "id", id + "_underlay");
		},

		_setClassAttr: function(clazz){
			this.node.className = "dijitDialogUnderlay " + clazz;
		},

		postCreate: function(){
			// summary:
			//		Append the underlay to the body
			dojo.body().appendChild(this.domNode);
			this.bgIframe = new dijit.BackgroundIframe(this.domNode);
		},

		layout: function(){
			// summary:
			//		Sets the background to the size of the viewport
			//
			// description:
			//		Sets the background to the size of the viewport (rather than the size
			//		of the document) since we need to cover the whole browser window, even
			//		if the document is only a few lines long.
			// tags:
			//		private

			var is = this.node.style,
				os = this.domNode.style;

			// hide the background temporarily, so that the background itself isn't
			// causing scrollbars to appear (might happen when user shrinks browser
			// window and then we are called to resize)
			os.display = "none";

			// then resize and show
			var viewport = dijit.getViewport();
			os.top = viewport.t + "px";
			os.left = viewport.l + "px";
			is.width = viewport.w + "px";
			is.height = viewport.h + "px";
			os.display = "block";
		},

		show: function(){
			// summary:
			//		Show the dialog underlay
			this.domNode.style.display = "block";
			this.layout();
			if(this.bgIframe.iframe){
				this.bgIframe.iframe.style.display = "block";
			}
		},

		hide: function(){
			// summary:
			//		Hides the dialog underlay
			this.domNode.style.display = "none";
			if(this.bgIframe.iframe){
				this.bgIframe.iframe.style.display = "none";
			}
		},

		uninitialize: function(){
			if(this.bgIframe){
				this.bgIframe.destroy();
			}
		}
	}
);

}

if(!dojo._hasResource["dijit._Contained"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._Contained"] = true;
dojo.provide("dijit._Contained");

dojo.declare("dijit._Contained",
		null,
		{
			// summary
			//		Mixin for widgets that are children of a container widget
			//
			// example:
			// | 	// make a basic custom widget that knows about it's parents
			// |	dojo.declare("my.customClass",[dijit._Widget,dijit._Contained],{});
			// 
			getParent: function(){
				// summary:
				//		Returns the parent widget of this widget, assuming the parent
				//		implements dijit._Container
				for(var p=this.domNode.parentNode; p; p=p.parentNode){
					var id = p.getAttribute && p.getAttribute("widgetId");
					if(id){
						var parent = dijit.byId(id);
						return parent.isContainer ? parent : null;
					}
				}
				return null;
			},

			_getSibling: function(which){
				// summary:
				//      Returns next or previous sibling
				// which:
				//      Either "next" or "previous"
				// tags:
				//      private
				var node = this.domNode;
				do{
					node = node[which+"Sibling"];
				}while(node && node.nodeType != 1);
				if(!node){ return null; } // null
				var id = node.getAttribute("widgetId");
				return dijit.byId(id);
			},

			getPreviousSibling: function(){
				// summary:
				//		Returns null if this is the first child of the parent,
				//		otherwise returns the next element sibling to the "left".

				return this._getSibling("previous"); // Mixed
			},

			getNextSibling: function(){
				// summary:
				//		Returns null if this is the last child of the parent,
				//		otherwise returns the next element sibling to the "right".

				return this._getSibling("next"); // Mixed
			},
			
			getIndexInParent: function(){
				// summary:
				//		Returns the index of this widget within its container parent.
				//		It returns -1 if the parent does not exist, or if the parent
				//		is not a dijit._Container
				
				var p = this.getParent();
				if(!p || !p.getIndexOfChild){
					return -1; // int
				}
				return p.getIndexOfChild(this); // int
			}
		}
	);


}

if(!dojo._hasResource["dijit.layout._LayoutWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout._LayoutWidget"] = true;
dojo.provide("dijit.layout._LayoutWidget");





dojo.declare("dijit.layout._LayoutWidget",
	[dijit._Widget, dijit._Container, dijit._Contained],
	{
		// summary:
		//		Base class for a _Container widget which is responsible for laying out its children.
		//		Widgets which mixin this code must define layout() to lay out the children.

		// baseClass: [protected extension] String
		//		This class name is applied to the widget's domNode
		//		and also may be used to generate names for sub nodes,
		//		like for example dijitTabContainer-content.
		baseClass: "dijitLayoutContainer",

		// isLayoutContainer: [private deprecated] Boolean
		//		TODO: this is unused, but maybe it *should* be used for a child to
		//		detect whether the parent is going to call resize() on it or not
		//		(see calls to getParent() and resize() in this file)
		isLayoutContainer: true,

		postCreate: function(){
			dojo.addClass(this.domNode, "dijitContainer");
			dojo.addClass(this.domNode, this.baseClass);
			
			// TODO: this.inherited()
		},

		startup: function(){
			// summary:
			//		Called after all the widgets have been instantiated and their
			//		dom nodes have been inserted somewhere under dojo.doc.body.
			//
			//		Widgets should override this method to do any initialization
			//		dependent on other widgets existing, and then call
			//		this superclass method to finish things off.
			//
			//		startup() in subclasses shouldn't do anything
			//		size related because the size of the widget hasn't been set yet.

			if(this._started){ return; }

			// TODO: seems like this code should be in _Container.startup().
			// Then things that don't extend LayoutContainer (like GridContainer)
			// would get the behavior for free.
			dojo.forEach(this.getChildren(), function(child){ child.startup(); });

			// If I am a top level widget
			if(!this.getParent || !this.getParent()){
				// Do recursive sizing and layout of all my descendants
				// (passing in no argument to resize means that it has to glean the size itself)
				this.resize();

				// Since my parent isn't a layout container, and my style is width=height=100% (or something similar),
				// then I need to watch when the window resizes, and size myself accordingly.
				// (Passing in no arguments to resize means that it has to glean the size itself.)
				// TODO: make one global listener to avoid getViewport() per widget.
				this._viewport = dijit.getViewport();
				this.connect(dojo.global, 'onresize', function(){
					var newViewport = dijit.getViewport();
					if(newViewport.w != this._viewport.w ||  newViewport.h != this._viewport.h){
						this._viewport = newViewport;
						this.resize();
					}
				});
			}
			
			this.inherited(arguments);
		},

		resize: function(changeSize, resultSize){
			// summary:
			//		Call this to resize a widget, or after its size has changed.
			// description:
			//		Change size mode:
			//			When changeSize is specified, changes the marginBox of this widget
			//			 and forces it to relayout its contents accordingly.
			//			changeSize may specify height, width, or both.
			//
			//			If resultSize is specified it indicates the size the widget will
			//			become after changeSize has been applied.
			//
			//		Notification mode:
			//			When changeSize is null, indicates that the caller has already changed
			//			the size of the widget, or perhaps it changed because the browser
			//			window was resized.  Tells widget to relayout it's contents accordingly.
			//
			//			If resultSize is also specified it indicates the size the widget has
			//			become.
			//
			//		In either mode, this method also:
			//			1. Sets this._borderBox and this._contentBox to the new size of
			//				the widget.  Queries the current domNode size if necessary.
			//			2. Calls layout() to resize contents (and maybe adjust child widgets).	
			//
			// changeSize: Object?
			//		Sets the widget to this margin-box size and position.
			//		May include any/all of the following properties:
			//	|	{w: int, h: int, l: int, t: int}
			//
			// resultSize: Object?
			//		The margin-box size of this widget after applying changeSize (if 
			//		changeSize is specified).  If caller knows this size and
			//		passes it in, we don't need to query the browser to get the size.
			//	|	{w: int, h: int}

			var node = this.domNode;

			// set margin box size, unless it wasn't specified, in which case use current size
			if(changeSize){
				dojo.marginBox(node, changeSize);

				// set offset of the node
				if(changeSize.t){ node.style.top = changeSize.t + "px"; }
				if(changeSize.l){ node.style.left = changeSize.l + "px"; }
			}

			// If either height or width wasn't specified by the user, then query node for it.
			// But note that setting the margin box and then immediately querying dimensions may return
			// inaccurate results, so try not to depend on it.
			var mb = resultSize || {};
			dojo.mixin(mb, changeSize || {});	// changeSize overrides resultSize
			if ( !("h" in mb) || !("w" in mb) ){
				mb = dojo.mixin(dojo.marginBox(node), mb);	// just use dojo.marginBox() to fill in missing values
			}

			// Compute and save the size of my border box and content box
			// (w/out calling dojo.contentBox() since that may fail if size was recently set)
			var cs = dojo.getComputedStyle(node);
			var me = dojo._getMarginExtents(node, cs);
			var be = dojo._getBorderExtents(node, cs);
			var bb = (this._borderBox = {
				w: mb.w - (me.w + be.w),
				h: mb.h - (me.h + be.h)
			});
			var pe = dojo._getPadExtents(node, cs);
			this._contentBox = {
				l: dojo._toPixelValue(node, cs.paddingLeft),
				t: dojo._toPixelValue(node, cs.paddingTop),
				w: bb.w - pe.w,
				h: bb.h - pe.h
			};

			// Callback for widget to adjust size of it's children
			this.layout();
		},

		layout: function(){
			// summary:
			//		Widgets override this method to size and position their contents/children.
			//		When this is called this._contentBox is guaranteed to be set (see resize()).
			//
			//		This is called after startup(), and also when the widget's size has been
			//		changed.
			// tags:
			//		protected extension
		},

		_setupChild: function(/*Widget*/child){
			// summary:
			//		Common setup for initial children and children which are added after startup
			// tags:
			//		protected extension

			dojo.addClass(child.domNode, this.baseClass+"-child");
			if(child.baseClass){
				dojo.addClass(child.domNode, this.baseClass+"-"+child.baseClass);
			}
		},

		addChild: function(/*Widget*/ child, /*Integer?*/ insertIndex){
			// Overrides _Container.addChild() to call _setupChild()
			this.inherited(arguments);
			if(this._started){
				this._setupChild(child);
			}
		},

		removeChild: function(/*Widget*/ child){
			// Overrides _Container.removeChild() to remove class added by _setupChild()
			dojo.removeClass(child.domNode, this.baseClass+"-child");
			if(child.baseClass){
				dojo.removeClass(child.domNode, this.baseClass+"-"+child.baseClass);
			}
			this.inherited(arguments);
		}
	}
);

dijit.layout.marginBox2contentBox = function(/*DomNode*/ node, /*Object*/ mb){
	// summary:
	//		Given the margin-box size of a node, return its content box size.
	//		Functions like dojo.contentBox() but is more reliable since it doesn't have
	//		to wait for the browser to compute sizes.
	var cs = dojo.getComputedStyle(node);
	var me = dojo._getMarginExtents(node, cs);
	var pb = dojo._getPadBorderExtents(node, cs);
	return {
		l: dojo._toPixelValue(node, cs.paddingLeft),
		t: dojo._toPixelValue(node, cs.paddingTop),
		w: mb.w - (me.w + pb.w),
		h: mb.h - (me.h + pb.h)
	};
};

(function(){
	var capitalize = function(word){
		return word.substring(0,1).toUpperCase() + word.substring(1);
	};

	var size = function(widget, dim){
		// size the child
		widget.resize ? widget.resize(dim) : dojo.marginBox(widget.domNode, dim);

		// record child's size, but favor our own numbers when we have them.
		// the browser lies sometimes
		dojo.mixin(widget, dojo.marginBox(widget.domNode));
		dojo.mixin(widget, dim);
	};

	dijit.layout.layoutChildren = function(/*DomNode*/ container, /*Object*/ dim, /*Object[]*/ children){
		// summary
		//		Layout a bunch of child dom nodes within a parent dom node
		// container:
		//		parent node
		// dim:
		//		{l, t, w, h} object specifying dimensions of container into which to place children
		// children:
		//		an array like [ {domNode: foo, layoutAlign: "bottom" }, {domNode: bar, layoutAlign: "client"} ]

		// copy dim because we are going to modify it
		dim = dojo.mixin({}, dim);

		dojo.addClass(container, "dijitLayoutContainer");

		// Move "client" elements to the end of the array for layout.  a11y dictates that the author
		// needs to be able to put them in the document in tab-order, but this algorithm requires that
		// client be last.
		children = dojo.filter(children, function(item){ return item.layoutAlign != "client"; })
			.concat(dojo.filter(children, function(item){ return item.layoutAlign == "client"; }));

		// set positions/sizes
		dojo.forEach(children, function(child){
			var elm = child.domNode,
				pos = child.layoutAlign;

			// set elem to upper left corner of unused space; may move it later
			var elmStyle = elm.style;
			elmStyle.left = dim.l+"px";
			elmStyle.top = dim.t+"px";
			elmStyle.bottom = elmStyle.right = "auto";

			dojo.addClass(elm, "dijitAlign" + capitalize(pos));

			// set size && adjust record of remaining space.
			// note that setting the width of a <div> may affect it's height.
			if(pos == "top" || pos == "bottom"){
				size(child, { w: dim.w });
				dim.h -= child.h;
				if(pos=="top"){
					dim.t += child.h;
				}else{
					elmStyle.top = dim.t + dim.h + "px";
				}
			}else if(pos == "left" || pos == "right"){
				size(child, { h: dim.h });
				dim.w -= child.w;
				if(pos == "left"){
					dim.l += child.w;
				}else{
					elmStyle.left = dim.l + dim.w + "px";
				}
			}else if(pos == "client"){
				size(child, dim);
			}
		});
	};

})();

}

if(!dojo._hasResource["dojo.html"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.html"] = true;
dojo.provide("dojo.html");

// the parser might be needed..
 

(function(){ // private scope, sort of a namespace

	// idCounter is incremented with each instantiation to allow asignment of a unique id for tracking, logging purposes
	var idCounter = 0; 

	dojo.html._secureForInnerHtml = function(/*String*/ cont){
		// summary:
		//		removes !DOCTYPE and title elements from the html string.
		// 
		//		khtml is picky about dom faults, you can't attach a style or <title> node as child of body
		//		must go into head, so we need to cut out those tags
		//	cont:
		//		An html string for insertion into the dom
		//	
		return cont.replace(/(?:\s*<!DOCTYPE\s[^>]+>|<title[^>]*>[\s\S]*?<\/title>)/ig, ""); // String
	};

/*====
	dojo.html._emptyNode = function(node){
		// summary:
		//		removes all child nodes from the given node
		//	node: DOMNode
		//		the parent element
	};
=====*/
	dojo.html._emptyNode = dojo.empty;

	dojo.html._setNodeContent = function(/* DomNode */ node, /* String|DomNode|NodeList */ cont, /* Boolean? */ shouldEmptyFirst){
		// summary:
		//		inserts the given content into the given node
		//		overlaps similiar functionality in dijit.layout.ContentPane._setContent
		//	node:
		//		the parent element
		//	content:
		//		the content to be set on the parent element. 
		//		This can be an html string, a node reference or a NodeList, dojo.NodeList, Array or other enumerable list of nodes
		// shouldEmptyFirst
		//		if shouldEmptyFirst is true, the node will first be emptied of all content before the new content is inserted
		//		defaults to false
		if(shouldEmptyFirst){
			dojo.html._emptyNode(node); 
		}

		if(typeof cont == "string"){
			// there's some hoops to jump through before we can set innerHTML on the would-be parent element. 
	
			// rationale for this block:
			// if node is a table derivate tag, some browsers dont allow innerHTML on those
			// TODO: <select>, <dl>? what other elements will give surprises if you naively set innerHTML?
			
			var pre = '', post = '', walk = 0, name = node.nodeName.toLowerCase();
			switch(name){
				case 'tr':
					pre = '<tr>'; post = '</tr>';
					walk += 1;//fallthrough
				case 'tbody': case 'thead':// children of THEAD is of same type as TBODY
					pre = '<tbody>' + pre; post += '</tbody>';
					walk += 1;// falltrough
				case 'table':
					pre = '<table>' + pre; post += '</table>';
					walk += 1;
					break;
			}
			if(walk){
				var n = node.ownerDocument.createElement('div');
				n.innerHTML = pre + cont + post;
				do{
					n = n.firstChild;
				}while(--walk);
				// now we can safely add the child nodes...
				dojo.forEach(n.childNodes, function(n){
					node.appendChild(n.cloneNode(true));
				});
			}else{
				// innerHTML the content as-is into the node (element)
				// should we ever support setting content on non-element node types? 
				// e.g. text nodes, comments, etc.?
				node.innerHTML = cont;
			}

		}else{
			// DomNode or NodeList
			if(cont.nodeType){ // domNode (htmlNode 1 or textNode 3)
				node.appendChild(cont);
			}else{// nodelist or array such as dojo.Nodelist
				dojo.forEach(cont, function(n){
					node.appendChild(n.cloneNode(true));
				});
			}
		}
		// return DomNode
		return node;
	};

	// we wrap up the content-setting operation in a object
	dojo.declare("dojo.html._ContentSetter", null, 
		{
			// node: DomNode|String
			//		An node which will be the parent element that we set content into
			node: "",

			// content: String|DomNode|DomNode[]
			//		The content to be placed in the node. Can be an HTML string, a node reference, or a enumerable list of nodes
			content: "",
			
			// id: String?
			//		Usually only used internally, and auto-generated with each instance 
			id: "",

			// cleanContent: Boolean
			//		Should the content be treated as a full html document, 
			//		and the real content stripped of <html>, <body> wrapper before injection
			cleanContent: false,
			
			// extractContent: Boolean
			//		Should the content be treated as a full html document, and the real content stripped of <html>, <body> wrapper before injection
			extractContent: false,

			// parseContent: Boolean
			//		Should the node by passed to the parser after the new content is set
			parseContent: false,
			
			// lifecyle methods
			constructor: function(/* Object */params, /* String|DomNode */node){
				//	summary:
				//		Provides a configurable, extensible object to wrap the setting on content on a node
				//		call the set() method to actually set the content..
 
				// the original params are mixed directly into the instance "this"
				dojo.mixin(this, params || {});

				// give precedence to params.node vs. the node argument
				// and ensure its a node, not an id string
				node = this.node = dojo.byId( this.node || node );
	
				if(!this.id){
					this.id = [
						"Setter",
						(node) ? node.id || node.tagName : "", 
						idCounter++
					].join("_");
				}

				if(! (this.node || node)){
					new Error(this.declaredClass + ": no node provided to " + this.id);
				}
			},
			set: function(/* String|DomNode|NodeList? */ cont, /* Object? */ params){
				// summary:
				//		front-end to the set-content sequence 
				//	cont:
				//		An html string, node or enumerable list of nodes for insertion into the dom
				//		If not provided, the object's content property will be used
				if(undefined !== cont){
					this.content = cont;
				}
				// in the re-use scenario, set needs to be able to mixin new configuration
				if(params){
					this._mixin(params);
				}

				this.onBegin();
				this.setContent();
				this.onEnd();

				return this.node;
			},
			setContent: function(){
				// summary:
				//		sets the content on the node 

				var node = this.node; 
				if(!node) {
					console.error("setContent given no node");
				}
				try{
					node = dojo.html._setNodeContent(node, this.content);
				}catch(e){
					// check if a domfault occurs when we are appending this.errorMessage
					// like for instance if domNode is a UL and we try append a DIV
	
					// FIXME: need to allow the user to provide a content error message string
					var errMess = this.onContentError(e); 
					try{
						node.innerHTML = errMess;
					}catch(e){
						console.error('Fatal ' + this.declaredClass + '.setContent could not change content due to '+e.message, e);
					}
				}
				// always put back the node for the next method
				this.node = node; // DomNode
			},
			
			empty: function() {
				// summary
				//	cleanly empty out existing content

				// destroy any widgets from a previous run
				// NOTE: if you dont want this you'll need to empty 
				// the parseResults array property yourself to avoid bad things happenning
				if(this.parseResults && this.parseResults.length) {
					dojo.forEach(this.parseResults, function(w) {
						if(w.destroy){
							w.destroy();
						}
					});
					delete this.parseResults;
				}
				// this is fast, but if you know its already empty or safe, you could 
				// override empty to skip this step
				dojo.html._emptyNode(this.node);
			},
	
			onBegin: function(){
				// summary
				//		Called after instantiation, but before set(); 
				//		It allows modification of any of the object properties 
				//		- including the node and content provided - before the set operation actually takes place
				//		This default implementation checks for cleanContent and extractContent flags to 
				//		optionally pre-process html string content
				var cont = this.content;
	
				if(dojo.isString(cont)){
					if(this.cleanContent){
						cont = dojo.html._secureForInnerHtml(cont);
					}
  
					if(this.extractContent){
						var match = cont.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
						if(match){ cont = match[1]; }
					}
				}

				// clean out the node and any cruft associated with it - like widgets
				this.empty();
				
				this.content = cont;
				return this.node; /* DomNode */
			},
	
			onEnd: function(){
				// summary
				//		Called after set(), when the new content has been pushed into the node
				//		It provides an opportunity for post-processing before handing back the node to the caller
				//		This default implementation checks a parseContent flag to optionally run the dojo parser over the new content
				if(this.parseContent){
					// populates this.parseResults if you need those..
					this._parse();
				}
				return this.node; /* DomNode */
			},
	
			tearDown: function(){
				// summary
				//		manually reset the Setter instance if its being re-used for example for another set()
				// description
				//		tearDown() is not called automatically. 
				//		In normal use, the Setter instance properties are simply allowed to fall out of scope
				//		but the tearDown method can be called to explicitly reset this instance.
				delete this.parseResults; 
				delete this.node; 
				delete this.content; 
			},
  
			onContentError: function(err){
				return "Error occured setting content: " + err; 
			},
			
			_mixin: function(params){
				// mix properties/methods into the instance
				// TODO: the intention with tearDown is to put the Setter's state 
				// back to that of the original constructor (vs. deleting/resetting everything regardless of ctor params)
				// so we could do something here to move the original properties aside for later restoration
				var empty = {}, key;
				for(key in params){
					if(key in empty){ continue; }
					// TODO: here's our opportunity to mask the properties we dont consider configurable/overridable
					// .. but history shows we'll almost always guess wrong
					this[key] = params[key]; 
				}
			},
			_parse: function(){
				// summary: 
				//		runs the dojo parser over the node contents, storing any results in this.parseResults
				//		Any errors resulting from parsing are passed to _onError for handling

				var rootNode = this.node;
				try{
					// store the results (widgets, whatever) for potential retrieval
					this.parseResults = dojo.parser.parse(rootNode, true);
				}catch(e){
					this._onError('Content', e, "Error parsing in _ContentSetter#"+this.id);
				}
			},
  
			_onError: function(type, err, consoleText){
				// summary:
				//		shows user the string that is returned by on[type]Error
				//		overide/implement on[type]Error and return your own string to customize
				var errText = this['on' + type + 'Error'].call(this, err);
				if(consoleText){
					console.error(consoleText, err);
				}else if(errText){ // a empty string won't change current content
					dojo.html._setNodeContent(this.node, errText, true);
				}
			}
	}); // end dojo.declare()

	dojo.html.set = function(/* DomNode */ node, /* String|DomNode|NodeList */ cont, /* Object? */ params){
			// summary:
			//		inserts (replaces) the given content into the given node. dojo.place(cont, node, "only")
			//		may be a better choice for simple HTML insertion.
			// description:
			//		Unless you need to use the params capabilities of this method, you should use
			//		dojo.place(cont, node, "only"). dojo.place() has more robust support for injecting
			//		an HTML string into the DOM, but it only handles inserting an HTML string as DOM
			//		elements, or inserting a DOM node. dojo.place does not handle NodeList insertions
			//		or the other capabilities as defined by the params object for this method.
			//	node:
			//		the parent element that will receive the content
			//	cont:
			//		the content to be set on the parent element. 
			//		This can be an html string, a node reference or a NodeList, dojo.NodeList, Array or other enumerable list of nodes
			//	params: 
			//		Optional flags/properties to configure the content-setting. See dojo.html._ContentSetter
			//	example:
			//		A safe string/node/nodelist content replacement/injection with hooks for extension
			//		Example Usage: 
			//		dojo.html.set(node, "some string"); 
			//		dojo.html.set(node, contentNode, {options}); 
			//		dojo.html.set(node, myNode.childNodes, {options}); 
		if(undefined == cont){
			console.warn("dojo.html.set: no cont argument provided, using empty string");
			cont = "";
		}	
		if(!params){
			// simple and fast
			return dojo.html._setNodeContent(node, cont, true);
		}else{ 
			// more options but slower
			// note the arguments are reversed in order, to match the convention for instantiation via the parser
			var op = new dojo.html._ContentSetter(dojo.mixin( 
					params, 
					{ content: cont, node: node } 
			));
			return op.set();
		}
	};
})();

}

if(!dojo._hasResource["dijit.layout.ContentPane"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout.ContentPane"] = true;
dojo.provide("dijit.layout.ContentPane");



	// for dijit.layout.marginBox2contentBox()






dojo.declare(
	"dijit.layout.ContentPane", dijit._Widget,
{
	// summary:
	//		A widget that acts as a container for mixed HTML and widgets, and includes an Ajax interface
	// description:
	//		A widget that can be used as a standalone widget
	//		or as a baseclass for other widgets
	//		Handles replacement of document fragment using either external uri or javascript
	//		generated markup or DOM content, instantiating widgets within that content.
	//		Don't confuse it with an iframe, it only needs/wants document fragments.
	//		It's useful as a child of LayoutContainer, SplitContainer, or TabContainer.
	//		But note that those classes can contain any widget as a child.
	// example:
	//		Some quick samples:
	//		To change the innerHTML use .attr('content', '<b>new content</b>')
	//
	//		Or you can send it a NodeList, .attr('content', dojo.query('div [class=selected]', userSelection))
	//		please note that the nodes in NodeList will copied, not moved
	//
	//		To do a ajax update use .attr('href', url)

	// href: String
	//		The href of the content that displays now.
	//		Set this at construction if you want to load data externally when the
	//		pane is shown.	(Set preload=true to load it immediately.)
	//		Changing href after creation doesn't have any effect; use attr('href', ...);
	href: "",

/*=====
	// content: String || DomNode || NodeList || dijit._Widget
	//		The innerHTML of the ContentPane.
	//		Note that the initialization parameter / argument to attr("content", ...)
	//		can be a String, DomNode, Nodelist, or _Widget.
	content: "",
=====*/

	// extractContent: Boolean
	//		Extract visible content from inside of <body> .... </body>.
	//		I.e., strip <html> and <head> (and it's contents) from the href
	extractContent: false,

	// parseOnLoad: Boolean
	//		Parse content and create the widgets, if any.
	parseOnLoad:	true,

	// preventCache: Boolean
	//		Prevent caching of data from href's by appending a timestamp to the href.
	preventCache:	false,

	// preload: Boolean
	//		Force load of data on initialization even if pane is hidden.
	preload: false,

	// refreshOnShow: Boolean
	//		Refresh (re-download) content when pane goes from hidden to shown
	refreshOnShow: false,

	// loadingMessage: String
	//		Message that shows while downloading
	loadingMessage: "<span class='dijitContentPaneLoading'>${loadingState}</span>", 

	// errorMessage: String
	//		Message that shows if an error occurs
	errorMessage: "<span class='dijitContentPaneError'>${errorState}</span>", 

	// isLoaded: [readonly] Boolean
	//		True if the ContentPane has data in it, either specified
	//		during initialization (via href or inline content), or set
	//		via attr('content', ...) / attr('href', ...)
	//
	//		False if it doesn't have any content, or if ContentPane is
	//		still in the process of downloading href.
	isLoaded: false,

	baseClass: "dijitContentPane",

	// doLayout: Boolean
	//		- false - don't adjust size of children
	//		- true - if there is a single visible child widget, set it's size to
	//				however big the ContentPane is
	doLayout: true,

	// ioArgs: Object
	//		Parameters to pass to xhrGet() request, for example:
	// |	<div dojoType="dijit.layout.ContentPane" href="./bar" ioArgs="{timeout: 500}">
	ioArgs: {},

	// isContainer: [protected] Boolean
	//		Just a flag indicating that this widget will call resize() on
	//		its children.   _LayoutWidget based widgets check for
	//
	//	|		if(!this.getParent || !this.getParent()){
	//
	//		and if getParent() returns false because !parent.isContainer,
	//		then they resize themselves on initialization.
	isContainer: true,

	postMixInProperties: function(){
		this.inherited(arguments);
		var messages = dojo.i18n.getLocalization("dijit", "loading", this.lang);
		this.loadingMessage = dojo.string.substitute(this.loadingMessage, messages);
		this.errorMessage = dojo.string.substitute(this.errorMessage, messages);
		
		// Detect if we were initialized with data
		if(!this.href && this.srcNodeRef && this.srcNodeRef.innerHTML){
			this.isLoaded = true;
		}
	},

	buildRendering: function(){
		// Overrides Widget.buildRendering().
		// Since we have no template we need to set this.containerNode ourselves.
		// For subclasses of ContentPane do have a template, does nothing.
		this.inherited(arguments);
		if(!this.containerNode){
			// make getDescendants() work
			this.containerNode = this.domNode;
		}
	},

	postCreate: function(){
		// remove the title attribute so it doesn't show up when hovering
		// over a node
		this.domNode.title = "";

		if (!dojo.attr(this.domNode,"role")){
			dijit.setWaiRole(this.domNode, "group");
		}

		dojo.addClass(this.domNode, this.baseClass);
	},

	startup: function(){
		// summary:
		//		See `dijit.layout._LayoutWidget.startup` for description.
		//		Although ContentPane doesn't extend _LayoutWidget, it does implement
		//		the same API.
		if(this._started){ return; }

		if(this.isLoaded){
			dojo.forEach(this.getChildren(), function(child){
				child.startup();
			});

			// If we have static content in the content pane (specified during
			// initialization) then we need to do layout now... unless we are
			// a child of a TabContainer etc. in which case wait until the TabContainer
			// calls resize() on us.
			if(this.doLayout){
				this._checkIfSingleChild();
			}
			if(!this._singleChild || !dijit._Contained.prototype.getParent.call(this)){
				this._scheduleLayout();
			}
		}
		
		// If we have an href then check if we should load it now
		this._loadCheck();

		this.inherited(arguments);
	},

	_checkIfSingleChild: function(){
		// summary:
		//		Test if we have exactly one visible widget as a child,
		//		and if so assume that we are a container for that widget,
		//		and should propogate startup() and resize() calls to it.
		//		Skips over things like data stores since they aren't visible.

		var childNodes = dojo.query(">", this.containerNode),
			childWidgetNodes = childNodes.filter(function(node){
				return dojo.hasAttr(node, "dojoType") || dojo.hasAttr(node, "widgetId");
			}),
			candidateWidgets = dojo.filter(childWidgetNodes.map(dijit.byNode), function(widget){
				return widget && widget.domNode && widget.resize;
			});

		if(
			// all child nodes are widgets
			childNodes.length == childWidgetNodes.length &&

			// all but one are invisible (like dojo.data)
			candidateWidgets.length == 1
		){
			this._singleChild = candidateWidgets[0];
		}else{
			delete this._singleChild;
		}
	},

	setHref: function(/*String|Uri*/ href){
		// summary:
		//		Deprecated.   Use attr('href', ...) instead.
		dojo.deprecated("dijit.layout.ContentPane.setHref() is deprecated. Use attr('href', ...) instead.", "", "2.0");
		return this.attr("href", href);
	},
	_setHrefAttr: function(/*String|Uri*/ href){
		// summary:
		//		Hook so attr("href", ...) works.
		// description:
		//		Reset the (external defined) content of this pane and replace with new url
		//		Note: It delays the download until widget is shown if preload is false.
		//	href:
		//		url to the page you want to get, must be within the same domain as your mainpage

		// Cancel any in-flight requests (an attr('href') will cancel any in-flight attr('href', ...))
		this.cancel();

		this.href = href;

		// _setHrefAttr() is called during creation and by the user, after creation.
		// only in the second case do we actually load the URL; otherwise it's done in startup()
		if(this._created && (this.preload || this._isShown())){
			// we return result of refresh() here to avoid code dup. in dojox.layout.ContentPane
			return this.refresh();
		}else{
			// Set flag to indicate that href needs to be loaded the next time the
			// ContentPane is made visible
			this._hrefChanged = true;
		}
	},

	setContent: function(/*String|DomNode|Nodelist*/data){
		// summary:
		//		Deprecated.   Use attr('content', ...) instead.
		dojo.deprecated("dijit.layout.ContentPane.setContent() is deprecated.  Use attr('content', ...) instead.", "", "2.0");
		this.attr("content", data);
	},
	_setContentAttr: function(/*String|DomNode|Nodelist*/data){
		// summary:
		//		Hook to make attr("content", ...) work.
		//		Replaces old content with data content, include style classes from old content
		//	data:
		//		the new Content may be String, DomNode or NodeList
		//
		//		if data is a NodeList (or an array of nodes) nodes are copied
		//		so you can import nodes from another document implicitly

		// clear href so we can't run refresh and clear content
		// refresh should only work if we downloaded the content
		this.href = "";

		// Cancel any in-flight requests (an attr('content') will cancel any in-flight attr('href', ...))
		this.cancel();

		this._setContent(data || "");

		this._isDownloaded = false; // mark that content is from a attr('content') not an attr('href')
	},
	_getContentAttr: function(){
		// summary:
		//		Hook to make attr("content") work
		return this.containerNode.innerHTML;
	},

	cancel: function(){
		// summary:
		//		Cancels an in-flight download of content
		if(this._xhrDfd && (this._xhrDfd.fired == -1)){
			this._xhrDfd.cancel();
		}
		delete this._xhrDfd; // garbage collect
	},

	uninitialize: function(){
		if(this._beingDestroyed){
			this.cancel();
		}
	},

	destroyRecursive: function(/*Boolean*/ preserveDom){
		// summary:
		//		Destroy the ContentPane and its contents

		// if we have multiple controllers destroying us, bail after the first
		if(this._beingDestroyed){
			return;
		}
		this._beingDestroyed = true;
		this.inherited(arguments);
	},

	resize: function(size){
		// summary:
		//		See `dijit.layout._LayoutWidget.resize` for description.
		//		Although ContentPane doesn't extend _LayoutWidget, it does implement
		//		the same API.

		dojo.marginBox(this.domNode, size);

		// Compute content box size in case we [later] need to size child
		// If either height or width wasn't specified by the user, then query node for it.
		// But note that setting the margin box and then immediately querying dimensions may return
		// inaccurate results, so try not to depend on it.
		var node = this.containerNode,
			mb = dojo.mixin(dojo.marginBox(node), size||{});

		var cb = (this._contentBox = dijit.layout.marginBox2contentBox(node, mb));

		// If we have a single widget child then size it to fit snugly within my borders
		if(this._singleChild && this._singleChild.resize){
			// note: if widget has padding this._contentBox will have l and t set,
			// but don't pass them to resize() or it will doubly-offset the child
			this._singleChild.resize({w: cb.w, h: cb.h});
		}
	},

	_isShown: function(){
		// summary:
		//		Returns true if the content is currently shown
		if("open" in this){
			return this.open;		// for TitlePane, etc.
		}else{
			var node = this.domNode;
			return (node.style.display != 'none')  && (node.style.visibility != 'hidden') && !dojo.hasClass(node, "dijitHidden");
		}
	},

	_onShow: function(){
		// summary:
		//		Called when the ContentPane is made visible
		// description:
		//		For a plain ContentPane, this is called on initialization, from startup().
		//		If the ContentPane is a hidden pane of a TabContainer etc., then it's
		//		called whever the pane is made visible.
		//
		//		Does processing necessary, including href download and layout/resize of
		//		child widget(s)

		if(this._needLayout){
			// If a layout has been scheduled for when we become visible, do it now
			this._layoutChildren();
		}

		// Do lazy-load of URL
		this._loadCheck();

		// call onShow, if we have one
		if(this.onShow){
			this.onShow();
		}
	},

	_loadCheck: function(){
		// summary:
		//		Call this to load href contents if necessary.
		// description:
		//		Call when !ContentPane has been made visible [from prior hidden state],
		//		or href has been changed, or on startup, etc.

		if(
			(this.href && !this._xhrDfd) &&		// if there's an href that isn't already being loaded
			(!this.isLoaded || this._hrefChanged || this.refreshOnShow) && 	// and we need a [re]load
			(this.preload || this._isShown())	// and now is the time to [re]load
		){
			delete this._hrefChanged;
			this.refresh();
		}
	},

	refresh: function(){
		// summary:
		//		[Re]download contents of href and display
		// description:
		//		1. cancels any currently in-flight requests
		//		2. posts "loading..." message
		//		3. sends XHR to download new data

		// cancel possible prior inflight request
		this.cancel();

		// display loading message
		this._setContent(this.onDownloadStart(), true);

		var self = this;
		var getArgs = {
			preventCache: (this.preventCache || this.refreshOnShow),
			url: this.href,
			handleAs: "text"
		};
		if(dojo.isObject(this.ioArgs)){
			dojo.mixin(getArgs, this.ioArgs);
		}

		var hand = (this._xhrDfd = (this.ioMethod || dojo.xhrGet)(getArgs));

		hand.addCallback(function(html){
			try{
				self._isDownloaded = true;
				self._setContent(html, false);
				self.onDownloadEnd();
			}catch(err){
				self._onError('Content', err); // onContentError
			}
			delete self._xhrDfd;
			return html;
		});

		hand.addErrback(function(err){
			if(!hand.canceled){
				// show error message in the pane
				self._onError('Download', err); // onDownloadError
			}
			delete self._xhrDfd;
			return err;
		});
	},

	_onLoadHandler: function(data){
		// summary:
		//		This is called whenever new content is being loaded
		this.isLoaded = true;
		try{
			this.onLoad(data);			
		}catch(e){
			console.error('Error '+this.widgetId+' running custom onLoad code: ' + e.message);
		}
	},

	_onUnloadHandler: function(){
		// summary:
		//		This is called whenever the content is being unloaded
		this.isLoaded = false;
		try{
			this.onUnload();
		}catch(e){
			console.error('Error '+this.widgetId+' running custom onUnload code: ' + e.message);
		}
	},

	destroyDescendants: function(){
		// summary:
		//		Destroy all the widgets inside the ContentPane and empty containerNode

		// Make sure we call onUnload (but only when the ContentPane has real content)
		if(this.isLoaded){
			this._onUnloadHandler();
		}

		// Even if this.isLoaded == false there might still be a "Loading..." message
		// to erase, so continue...

		// For historical reasons we need to delete all widgets under this.containerNode,
		// even ones that the user has created manually.
		var setter = this._contentSetter;
		dojo.forEach(this.getChildren(), function(widget){
			if(widget.destroyRecursive){
				widget.destroyRecursive();
			}
		});
		if(setter){
			// Most of the widgets in setter.parseResults have already been destroyed, but
			// things like Menu that have been moved to <body> haven't yet
			dojo.forEach(setter.parseResults, function(widget){
				if(widget.destroyRecursive && widget.domNode && widget.domNode.parentNode == dojo.body()){
					widget.destroyRecursive();
				}
			});
			delete setter.parseResults;
		}
		
		// And then clear away all the DOM nodes
		dojo.html._emptyNode(this.containerNode);
	},

	_setContent: function(cont, isFakeContent){
		// summary: 
		//		Insert the content into the container node

		// first get rid of child widgets
		this.destroyDescendants();

		// Delete any state information we have about current contents
		delete this._singleChild;

		// dojo.html.set will take care of the rest of the details
		// we provide an overide for the error handling to ensure the widget gets the errors 
		// configure the setter instance with only the relevant widget instance properties
		// NOTE: unless we hook into attr, or provide property setters for each property, 
		// we need to re-configure the ContentSetter with each use
		var setter = this._contentSetter; 
		if(! (setter && setter instanceof dojo.html._ContentSetter)) {
			setter = this._contentSetter = new dojo.html._ContentSetter({
				node: this.containerNode,
				_onError: dojo.hitch(this, this._onError),
				onContentError: dojo.hitch(this, function(e){
					// fires if a domfault occurs when we are appending this.errorMessage
					// like for instance if domNode is a UL and we try append a DIV
					var errMess = this.onContentError(e);
					try{
						this.containerNode.innerHTML = errMess;
					}catch(e){
						console.error('Fatal '+this.id+' could not change content due to '+e.message, e);
					}
				})/*,
				_onError */
			});
		};

		var setterParams = dojo.mixin({
			cleanContent: this.cleanContent, 
			extractContent: this.extractContent, 
			parseContent: this.parseOnLoad 
		}, this._contentSetterParams || {});
		
		dojo.mixin(setter, setterParams); 

		setter.set( (dojo.isObject(cont) && cont.domNode) ? cont.domNode : cont );

		// setter params must be pulled afresh from the ContentPane each time
		delete this._contentSetterParams;

		if(!isFakeContent){
			dojo.forEach(this.getChildren(), function(child){
				child.startup();
			});

			if(this.doLayout){
				this._checkIfSingleChild();
			}

			// Call resize() on each of my child layout widgets,
			// or resize() on my single child layout widget...
			// either now (if I'm currently visible)
			// or when I become visible
			this._scheduleLayout();
			
			this._onLoadHandler(cont);
		}
	},

	_onError: function(type, err, consoleText){
		// shows user the string that is returned by on[type]Error
		// overide on[type]Error and return your own string to customize
		var errText = this['on' + type + 'Error'].call(this, err);
		if(consoleText){
			console.error(consoleText, err);
		}else if(errText){// a empty string won't change current content
			this._setContent(errText, true);
		}
	},
	
	_scheduleLayout: function(){
		// summary:
		//		Call resize() on each of my child layout widgets, either now
		//		(if I'm currently visible) or when I become visible
		if(this._isShown()){
			this._layoutChildren();
		}else{
			this._needLayout = true;
		}
	},

	_layoutChildren: function(){
		// summary:
		//		Since I am a Container widget, each of my children expects me to
		//		call resize() or layout() on them.
		// description:
		//		Should be called on initialization and also whenever we get new content
		//		(from an href, or from attr('content', ...))... but deferred until
		//		the ContentPane is visible

		if(this._singleChild && this._singleChild.resize){
			var cb = this._contentBox || dojo.contentBox(this.containerNode);
			this._singleChild.resize({w: cb.w, h: cb.h});
		}else{
			// All my child widgets are independently sized (rather than matching my size),
			// but I still need to call resize() on each child to make it layout.
			dojo.forEach(this.getChildren(), function(widget){
				if(widget.resize){
					widget.resize();
				}
			});
		}
		delete this._needLayout;
	},

	// EVENT's, should be overide-able
	onLoad: function(data){
		// summary:
		//		Event hook, is called after everything is loaded and widgetified
		// tags:
		//		callback
	},

	onUnload: function(){
		// summary:
		//		Event hook, is called before old content is cleared
		// tags:
		//		callback
	},

	onDownloadStart: function(){
		// summary:
		//		Called before download starts.
		// description:
		//		The string returned by this function will be the html
		//		that tells the user we are loading something.
		//		Override with your own function if you want to change text.
		// tags:
		//		extension
		return this.loadingMessage;
	},

	onContentError: function(/*Error*/ error){
		// summary:
		//		Called on DOM faults, require faults etc. in content.
		//
		//		In order to display an error message in the pane, return
		//		the error message from this method, as an HTML string.
		//
		//		By default (if this method is not overriden), it returns
		//		nothing, so the error message is just printed to the console.
		// tags:
		//		extension
	},

	onDownloadError: function(/*Error*/ error){
		// summary:
		//		Called when download error occurs.
		//
		//		In order to display an error message in the pane, return
		//		the error message from this method, as an HTML string.
		//
		//		Default behavior (if this method is not overriden) is to display
		//		the error message inside the pane.
		// tags:
		//		extension
		return this.errorMessage;
	},

	onDownloadEnd: function(){
		// summary:
		//		Called when download is finished.
		// tags:
		//		callback
	}
});

}

if(!dojo._hasResource["dijit.TooltipDialog"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.TooltipDialog"] = true;
dojo.provide("dijit.TooltipDialog");






dojo.declare(
		"dijit.TooltipDialog",
		[dijit.layout.ContentPane, dijit._Templated, dijit.form._FormMixin, dijit._DialogMixin],
		{
			// summary:
			//		Pops up a dialog that appears like a Tooltip

			// title: String
			// 		Description of tooltip dialog (required for a11y)
			title: "",

			// doLayout: [protected] Boolean
			//		Don't change this parameter from the default value.
			//		This ContentPane parameter doesn't make sense for TooltipDialog, since TooltipDialog
			//		is never a child of a layout container, nor can you specify the size of
			//		TooltipDialog in order to control the size of an inner widget. 
			doLayout: false,

			// autofocus: Boolean
			// 		A Toggle to modify the default focus behavior of a Dialog, which
			// 		is to focus on the first dialog element after opening the dialog.
			//		False will disable autofocusing. Default: true
			autofocus: true,

			// baseClass: [protected] String
			//		The root className to use for the various states of this widget
			baseClass: "dijitTooltipDialog",

			// _firstFocusItem: [private] [readonly] DomNode
			//		The pointer to the first focusable node in the dialog.
			//		Set by `dijit._DialogMixin._getFocusItems`.
			_firstFocusItem: null,

			// _lastFocusItem: [private] [readonly] DomNode
			//		The pointer to which node has focus prior to our dialog.
			//		Set by `dijit._DialogMixin._getFocusItems`.
			_lastFocusItem: null,

			templateString: null,
			templateString:"<div waiRole=\"presentation\">\n\t<div class=\"dijitTooltipContainer\" waiRole=\"presentation\">\n\t\t<div class =\"dijitTooltipContents dijitTooltipFocusNode\" dojoAttachPoint=\"containerNode\" tabindex=\"-1\" waiRole=\"dialog\"></div>\n\t</div>\n\t<div class=\"dijitTooltipConnector\" waiRole=\"presentation\"></div>\n</div>\n",

			postCreate: function(){
				this.inherited(arguments);
				this.connect(this.containerNode, "onkeypress", "_onKey");
				this.containerNode.title = this.title;
			},

			orient: function(/*DomNode*/ node, /*String*/ aroundCorner, /*String*/ corner){
				// summary:
				//		Configure widget to be displayed in given position relative to the button.
				//		This is called from the dijit.popup code, and should not be called
				//		directly.
				// tags:
				//		protected
				var c = this._currentOrientClass;
				if(c){
					dojo.removeClass(this.domNode, c);
				}
				c = "dijitTooltipAB"+(corner.charAt(1)=='L'?"Left":"Right")+" dijitTooltip"+(corner.charAt(0)=='T' ? "Below" : "Above");
				dojo.addClass(this.domNode, c);
				this._currentOrientClass = c;
			},

			onOpen: function(/*Object*/ pos){
				// summary:
				//		Called when dialog is displayed.
				//		This is called from the dijit.popup code, and should not be called directly.
				// tags:
				//		protected
			
				this.orient(this.domNode,pos.aroundCorner, pos.corner);
				this._onShow(); // lazy load trigger
				
				if(this.autofocus){
					this._getFocusItems(this.containerNode);
					dijit.focus(this._firstFocusItem);
				}
			},
			
			_onKey: function(/*Event*/ evt){
				// summary:
				//		Handler for keyboard events
				// description:
				//		Keep keyboard focus in dialog; close dialog on escape key
				// tags:
				//		private

				var node = evt.target;
				var dk = dojo.keys;
				if (evt.charOrCode === dk.TAB){
					this._getFocusItems(this.containerNode);
				}
				var singleFocusItem = (this._firstFocusItem == this._lastFocusItem);
				if(evt.charOrCode == dk.ESCAPE){
					this.onCancel();
					dojo.stopEvent(evt);
				}else if(node == this._firstFocusItem && evt.shiftKey && evt.charOrCode === dk.TAB){
					if(!singleFocusItem){
						dijit.focus(this._lastFocusItem); // send focus to last item in dialog
					}
					dojo.stopEvent(evt);
				}else if(node == this._lastFocusItem && evt.charOrCode === dk.TAB && !evt.shiftKey){
					if(!singleFocusItem){
						dijit.focus(this._firstFocusItem); // send focus to first item in dialog
					}
					dojo.stopEvent(evt);
				}else if(evt.charOrCode === dk.TAB){
					// we want the browser's default tab handling to move focus
					// but we don't want the tab to propagate upwards
					evt.stopPropagation();
				}
			}
		}	
	);

}

if(!dojo._hasResource["dijit.Dialog"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.Dialog"] = true;
dojo.provide("dijit.Dialog");













/*=====
dijit._underlay = function(kwArgs){
	// summary:
	//		A shared instance of a `dijit.DialogUnderlay`
	//
	// description: 
	//		A shared instance of a `dijit.DialogUnderlay` created and
	//		used by `dijit.Dialog`, though never created until some Dialog
	//		or subclass thereof is shown.
};
=====*/

dojo.declare(
	"dijit.Dialog",
	[dijit.layout.ContentPane, dijit._Templated, dijit.form._FormMixin, dijit._DialogMixin],
	{
		// summary:
		//		A modal dialog Widget
		//
		// description:
		//		Pops up a modal dialog window, blocking access to the screen
		//		and also graying out the screen Dialog is extended from
		//		ContentPane so it supports all the same parameters (href, etc.)
		//
		// example:
		// |	<div dojoType="dijit.Dialog" href="test.html"></div>
		//
		// example:
		// |	var foo = new dijit.Dialog({ title: "test dialog", content: "test content" };
		// |	dojo.body().appendChild(foo.domNode);
		// |	foo.startup();
		
		templateString: null,
		templateString:"<div class=\"dijitDialog\" tabindex=\"-1\" waiRole=\"dialog\" waiState=\"labelledby-${id}_title\">\n\t<div dojoAttachPoint=\"titleBar\" class=\"dijitDialogTitleBar\">\n\t<span dojoAttachPoint=\"titleNode\" class=\"dijitDialogTitle\" id=\"${id}_title\"></span>\n\t<span dojoAttachPoint=\"closeButtonNode\" class=\"dijitDialogCloseIcon\" dojoAttachEvent=\"onclick: onCancel, onmouseenter: _onCloseEnter, onmouseleave: _onCloseLeave\" title=\"${buttonCancel}\">\n\t\t<span dojoAttachPoint=\"closeText\" class=\"closeText\" title=\"${buttonCancel}\">x</span>\n\t</span>\n\t</div>\n\t\t<div dojoAttachPoint=\"containerNode\" class=\"dijitDialogPaneContent\"></div>\n</div>\n",
		attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
			title: [
				{ node: "titleNode", type: "innerHTML" }, 
				{ node: "titleBar", type: "attribute" }
			]
		}),

		// open: Boolean
		//		True if Dialog is currently displayed on screen.
		open: false,

		// duration: Integer
		//		The time in milliseconds it takes the dialog to fade in and out
		duration: dijit.defaultDuration,

		// refocus: Boolean
		// 		A Toggle to modify the default focus behavior of a Dialog, which
		// 		is to re-focus the element which had focus before being opened.
		//		False will disable refocusing. Default: true
		refocus: true,
		
		// autofocus: Boolean
		// 		A Toggle to modify the default focus behavior of a Dialog, which
		// 		is to focus on the first dialog element after opening the dialog.
		//		False will disable autofocusing. Default: true
		autofocus: true,

		// _firstFocusItem: [private] [readonly] DomNode
		//		The pointer to the first focusable node in the dialog.
		//		Set by `dijit._DialogMixin._getFocusItems`.
		_firstFocusItem: null,
		
		// _lastFocusItem: [private] [readonly] DomNode
		//		The pointer to which node has focus prior to our dialog.
		//		Set by `dijit._DialogMixin._getFocusItems`.
		_lastFocusItem: null,

		// doLayout: [protected] Boolean
		//		Don't change this parameter from the default value.
		//		This ContentPane parameter doesn't make sense for Dialog, since Dialog
		//		is never a child of a layout container, nor can you specify the size of
		//		Dialog in order to control the size of an inner widget. 
		doLayout: false,

		// draggable: Boolean
		//		Toggles the moveable aspect of the Dialog. If true, Dialog
		//		can be dragged by it's title. If false it will remain centered
		//		in the viewport.
		draggable: true,

		// _fixSizes: Boolean
		//		Does this Dialog attempt to restore the width and height after becoming too small?
		_fixSizes: true,

		postMixInProperties: function(){
			var _nlsResources = dojo.i18n.getLocalization("dijit", "common");
			dojo.mixin(this, _nlsResources);
			this.inherited(arguments);
		},

		postCreate: function(){
			dojo.style(this.domNode, {
				visibility:"hidden",
				position:"absolute",
				display:"",
				top:"-9999px"
			});
			dojo.body().appendChild(this.domNode);

			this.inherited(arguments);

			this.connect(this, "onExecute", "hide");
			this.connect(this, "onCancel", "hide");
			this._modalconnects = [];
		},

		onLoad: function(){
			// summary:
			//		Called when data has been loaded from an href.
			//		Unlike most other callbacks, this function can be connected to (via `dojo.connect`)
			//		but should *not* be overriden.
			// tags:
			//		callback
			
			// when href is specified we need to reposition the dialog after the data is loaded
			this._position();
			this.inherited(arguments);
		},

		_endDrag: function(e){
			// summary:
			//		Called after dragging the Dialog. Calculates the relative offset
			//		of the Dialog in relation to the viewport.
			// tags:
			//		private
			if(e && e.node && e.node === this.domNode){
				var vp = dijit.getViewport(); 
				var p = e._leftTop || dojo.coords(e.node,true);
				this._relativePosition = {
					t: p.t - vp.t,
					l: p.l - vp.l
				}			
			}
		},
		
		_setup: function(){
			// summary: 
			//		Stuff we need to do before showing the Dialog for the first
			//		time (but we defer it until right beforehand, for
			//		performance reasons).
			// tags:
			//		private

			var node = this.domNode;

			if(this.titleBar && this.draggable){
				this._moveable = (dojo.isIE == 6) ?
					new dojo.dnd.TimedMoveable(node, { handle: this.titleBar }) :	// prevent overload, see #5285
					new dojo.dnd.Moveable(node, { handle: this.titleBar, timeout: 0 });
				dojo.subscribe("/dnd/move/stop",this,"_endDrag");
			}else{
				dojo.addClass(node,"dijitDialogFixed"); 
			}
			
			var underlayAttrs = {
				dialogId: this.id,
				"class": dojo.map(this["class"].split(/\s/), function(s){ return s+"_underlay"; }).join(" ")
			};
			
			var underlay = dijit._underlay;
			if(!underlay){ 
				underlay = dijit._underlay = new dijit.DialogUnderlay(underlayAttrs); 
			}
			
			this._fadeIn = dojo.fadeIn({
				node: node,
				duration: this.duration,
				beforeBegin: function(){
					underlay.attr(underlayAttrs);
					underlay.show();
				},
				onEnd:	dojo.hitch(this, function(){
					if(this.autofocus){
						// find focusable Items each time dialog is shown since if dialog contains a widget the 
						// first focusable items can change
						this._getFocusItems(this.domNode);
						dijit.focus(this._firstFocusItem);
					}
				})
			 });

			this._fadeOut = dojo.fadeOut({
				node: node,
				duration: this.duration,
				onEnd: function(){
					node.style.visibility="hidden";
					node.style.top = "-9999px";
					dijit._underlay.hide();
				}
			 });
		},

		uninitialize: function(){
			var wasPlaying = false;
			if(this._fadeIn && this._fadeIn.status() == "playing"){
				wasPlaying = true;
				this._fadeIn.stop();
			}
			if(this._fadeOut && this._fadeOut.status() == "playing"){
				wasPlaying = true;
				this._fadeOut.stop();
			}
			if(this.open || wasPlaying){
				dijit._underlay.hide();
			}
			if(this._moveable){
				this._moveable.destroy();
			}
		},

		_size: function(){
			// summary:
			// 		Make sure the dialog is small enough to fit in viewport.
			// tags:
			//		private

			var mb = dojo.marginBox(this.domNode);
			var viewport = dijit.getViewport();
			if(mb.w >= viewport.w || mb.h >= viewport.h){
				dojo.style(this.containerNode, {
					width: Math.min(mb.w, Math.floor(viewport.w * 0.75))+"px",
					height: Math.min(mb.h, Math.floor(viewport.h * 0.75))+"px",
					overflow: "auto",
					position: "relative"	// workaround IE bug moving scrollbar or dragging dialog
				});
			}
		},

		_position: function(){
			// summary:
			//		Position modal dialog in the viewport. If no relative offset
			//		in the viewport has been determined (by dragging, for instance),
			//		center the node. Otherwise, use the Dialog's stored relative offset,
			//		and position the node to top: left: values based on the viewport.
			// tags:
			//		private
			if(!dojo.hasClass(dojo.body(),"dojoMove")){
				var node = this.domNode;
				var viewport = dijit.getViewport();
					var p = this._relativePosition;
					var mb = p ? null : dojo.marginBox(node);
					dojo.style(node,{
						left: Math.floor(viewport.l + (p ? p.l : (viewport.w - mb.w) / 2)) + "px",
						top: Math.floor(viewport.t + (p ? p.t : (viewport.h - mb.h) / 2)) + "px"
					});
				}

		},

		_onKey: function(/*Event*/ evt){
			// summary:
			//		Handles the keyboard events for accessibility reasons
			// tags:
			//		private
			if(evt.charOrCode){
				var dk = dojo.keys;
				var node = evt.target;
				if (evt.charOrCode === dk.TAB){
					this._getFocusItems(this.domNode);
				}
				var singleFocusItem = (this._firstFocusItem == this._lastFocusItem);
				// see if we are shift-tabbing from first focusable item on dialog
				if(node == this._firstFocusItem && evt.shiftKey && evt.charOrCode === dk.TAB){
					if(!singleFocusItem){
						dijit.focus(this._lastFocusItem); // send focus to last item in dialog
					}
					dojo.stopEvent(evt);
				}else if(node == this._lastFocusItem && evt.charOrCode === dk.TAB && !evt.shiftKey){
					if (!singleFocusItem){
						dijit.focus(this._firstFocusItem); // send focus to first item in dialog
					}
					dojo.stopEvent(evt);
				}else{
					// see if the key is for the dialog
					while(node){
						if(node == this.domNode){
							if(evt.charOrCode == dk.ESCAPE){
								this.onCancel(); 
							}else{
								return; // just let it go
							}
						}
						node = node.parentNode;
					}
					// this key is for the disabled document window
					if(evt.charOrCode !== dk.TAB){ // allow tabbing into the dialog for a11y
						dojo.stopEvent(evt);
					// opera won't tab to a div
					}else if(!dojo.isOpera){
						try{
							this._firstFocusItem.focus();
						}catch(e){ /*squelch*/ }
					}
				}
			}
		},

		show: function(){
			// summary:
			//		Display the dialog
			if(this.open){ return; }
			
			// first time we show the dialog, there's some initialization stuff to do			
			if(!this._alreadyInitialized){
				this._setup();
				this._alreadyInitialized=true;
			}

			if(this._fadeOut.status() == "playing"){
				this._fadeOut.stop();
			}

			this._modalconnects.push(dojo.connect(window, "onscroll", this, "layout"));
			this._modalconnects.push(dojo.connect(window, "onresize", this, function(){
				// IE gives spurious resize events and can actually get stuck
				// in an infinite loop if we don't ignore them
				var viewport = dijit.getViewport();
				if(!this._oldViewport ||
						viewport.h != this._oldViewport.h ||
						viewport.w != this._oldViewport.w){
					this.layout();
					this._oldViewport = viewport;
				}
			}));
			this._modalconnects.push(dojo.connect(dojo.doc.documentElement, "onkeypress", this, "_onKey"));

			dojo.style(this.domNode, {
				opacity:0,
				visibility:""
			});
			
			if(this._fixSizes){
				dojo.style(this.containerNode, { // reset width and height so that _size():marginBox works correctly
					width:"auto",
					height:"auto"
				});
			}
			
			this.open = true;
			this._onShow(); // lazy load trigger

			this._size();
			this._position();

			this._fadeIn.play();

			this._savedFocus = dijit.getFocus(this);
		},

		hide: function(){
			// summary:
			//		Hide the dialog

			// if we haven't been initialized yet then we aren't showing and we can just return		
			if(!this._alreadyInitialized){
				return;
			}

			if(this._fadeIn.status() == "playing"){
				this._fadeIn.stop();
			}
			this._fadeOut.play();

			if (this._scrollConnected){
				this._scrollConnected = false;
			}
			dojo.forEach(this._modalconnects, dojo.disconnect);
			this._modalconnects = [];
			if(this.refocus){
				this.connect(this._fadeOut,"onEnd",dojo.hitch(dijit,"focus",this._savedFocus));
			}
			if(this._relativePosition){
				delete this._relativePosition;	
			}
			this.open = false;
		},

		layout: function() {
			// summary:
			//		Position the Dialog and the underlay
			// tags:
			//		private
			if(this.domNode.style.visibility != "hidden"){
				dijit._underlay.layout();
				this._position();
			}
		},
		
		destroy: function(){
			dojo.forEach(this._modalconnects, dojo.disconnect);
			if(this.refocus && this.open){
				setTimeout(dojo.hitch(dijit,"focus",this._savedFocus), 25);
			}
			this.inherited(arguments);			
		},

		_onCloseEnter: function(){
			// summary:
			//		Called when user hovers over close icon
			// tags:
			//		private
			dojo.addClass(this.closeButtonNode, "dijitDialogCloseIcon-hover");
		},

		_onCloseLeave: function(){
			// summary:
			//		Called when user stops hovering over close icon
			// tags:
			//		private
			dojo.removeClass(this.closeButtonNode, "dijitDialogCloseIcon-hover");
		}
	}
);

// For back-compat.  TODO: remove in 2.0



}

if(!dojo._hasResource["dijit.MenuItem"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.MenuItem"] = true;
dojo.provide("dijit.MenuItem");





dojo.declare("dijit.MenuItem",
		[dijit._Widget, dijit._Templated, dijit._Contained],
		{
		// summary:
		//		A line item in a Menu Widget

		// Make 3 columns
		// icon, label, and expand arrow (BiDi-dependent) indicating sub-menu
		templateString:"<tr class=\"dijitReset dijitMenuItem\" dojoAttachPoint=\"focusNode\" waiRole=\"menuitem\" tabIndex=\"-1\"\n\t\tdojoAttachEvent=\"onmouseenter:_onHover,onmouseleave:_onUnhover,ondijitclick:_onClick\">\n\t<td class=\"dijitReset\" waiRole=\"presentation\">\n\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitMenuItemIcon\" dojoAttachPoint=\"iconNode\">\n\t</td>\n\t<td class=\"dijitReset dijitMenuItemLabel\" colspan=\"2\" dojoAttachPoint=\"containerNode\"></td>\n\t<td class=\"dijitReset dijitMenuItemAccelKey\" style=\"display: none\" dojoAttachPoint=\"accelKeyNode\"></td>\n\t<td class=\"dijitReset dijitMenuArrowCell\" waiRole=\"presentation\">\n\t\t<div dojoAttachPoint=\"arrowWrapper\" style=\"visibility: hidden\">\n\t\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitMenuExpand\">\n\t\t\t<span class=\"dijitMenuExpandA11y\">+</span>\n\t\t</div>\n\t</td>\n</tr>\n",

		attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
			label: { node: "containerNode", type: "innerHTML" },
			iconClass: { node: "iconNode", type: "class" }
		}),

		// label: String
		//		Menu text
		label: '',

		// iconClass: String
		//		Class to apply to DOMNode to make it display an icon.
		iconClass: "",

		// accelKey: String
		//		Text for the accelerator (shortcut) key combination.
		//		Note that although Menu can display accelerator keys there
		//		is no infrastructure to actually catch and execute these
		//		accelerators.
		accelKey: "",

		// disabled: Boolean
		//		If true, the menu item is disabled.
		//		If false, the menu item is enabled.
		disabled: false,

		_fillContent: function(/*DomNode*/ source){
			// If button label is specified as srcNodeRef.innerHTML rather than
			// this.params.label, handle it here.
			if(source && !("label" in this.params)){
				this.attr('label', source.innerHTML);
			}
		},

		postCreate: function(){
			dojo.setSelectable(this.domNode, false);
			dojo.attr(this.containerNode, "id", this.id+"_text");
			dijit.setWaiState(this.domNode, "labelledby", this.id+"_text");
		},

		_onHover: function(){
			// summary:
			//		Handler when mouse is moved onto menu item
			// tags:
			//		protected
			dojo.addClass(this.domNode, 'dijitMenuItemHover');
			this.getParent().onItemHover(this);
		},

		_onUnhover: function(){
			// summary:
			//		Handler when mouse is moved off of menu item,
			//		possibly to a child menu, or maybe to a sibling
			//		menuitem or somewhere else entirely.
			// tags:
			//		protected

			// if we are unhovering the currently selected item
			// then unselect it
			dojo.removeClass(this.domNode, 'dijitMenuItemHover');
			this.getParent().onItemUnhover(this);
		},

		_onClick: function(evt){
			// summary:
			//		Internal handler for click events on MenuItem.
			// tags:
			//		private
			this.getParent().onItemClick(this, evt);
			dojo.stopEvent(evt);
		},

		onClick: function(/*Event*/ evt){
			// summary:
			//		User defined function to handle clicks
			// tags:
			//		callback
		},

		focus: function(){
			// summary:
			//		Focus on this MenuItem
			try{
				dijit.focus(this.focusNode);
			}catch(e){
				// this throws on IE (at least) in some scenarios
			}
		},

		_onFocus: function(){
			// summary:
			//		This is called by the focus manager when focus
			//		goes to this MenuItem or a child menu.
			// tags:
			//		protected
			this._setSelected(true);

			// TODO: this.inherited(arguments);
		},

		_setSelected: function(selected){
			// summary:
			//		Indicate that this node is the currently selected one
			// tags:
			//		private

			/***
			 * TODO: remove this method and calls to it, when _onBlur() is working for MenuItem.
			 * Currently _onBlur() gets called when focus is moved from the MenuItem to a child menu.
			 * That's not supposed to happen, but the problem is:
			 * In order to allow dijit.popup's getTopPopup() to work,a sub menu's popupParent
			 * points to the parent Menu, bypassing the parent MenuItem... thus the
			 * MenuItem is not in the chain of active widgets and gets a premature call to
			 * _onBlur()
			 */
			
			dojo.toggleClass(this.domNode, "dijitMenuItemSelected", selected);
		},

		setLabel: function(/*String*/ content){
			// summary:
			//		Deprecated.   Use attr('label', ...) instead.
			// tags:
			//		deprecated
			dojo.deprecated("dijit.MenuItem.setLabel() is deprecated.  Use attr('label', ...) instead.", "", "2.0");
			this.attr("label", content);
		},

		setDisabled: function(/*Boolean*/ disabled){
			// summary:
			//		Deprecated.   Use attr('disabled', bool) instead.
			// tags:
			//		deprecated
			dojo.deprecated("dijit.Menu.setDisabled() is deprecated.  Use attr('disabled', bool) instead.", "", "2.0");
			this.attr('disabled', disabled);
		},
		_setDisabledAttr: function(/*Boolean*/ value){
			// summary:
			//		Hook for attr('disabled', ...) to work.
			//		Enable or disable this menu item.
			this.disabled = value;
			dojo[value ? "addClass" : "removeClass"](this.domNode, 'dijitMenuItemDisabled');
			dijit.setWaiState(this.focusNode, 'disabled', value ? 'true' : 'false');
		},
		_setAccelKeyAttr: function(/*String*/ value){
			// summary:
			//		Hook for attr('accelKey', ...) to work.
			//		Set accelKey on this menu item.
			this.accelKey=value;

			this.accelKeyNode.style.display=value?"":"none";
			this.accelKeyNode.innerHTML=value;
			//have to use colSpan to make it work in IE
			dojo.attr(this.containerNode,'colSpan',value?"1":"2");
		}
	});

}

if(!dojo._hasResource["dijit.PopupMenuItem"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.PopupMenuItem"] = true;
dojo.provide("dijit.PopupMenuItem");



dojo.declare("dijit.PopupMenuItem",
		dijit.MenuItem,
		{
		_fillContent: function(){
			// summary: 
			//		When Menu is declared in markup, this code gets the menu label and
			//		the popup widget from the srcNodeRef.
			// description:
			//		srcNodeRefinnerHTML contains both the menu item text and a popup widget
			//		The first part holds the menu item text and the second part is the popup
			// example: 
			// |	<div dojoType="dijit.PopupMenuItem">
			// |		<span>pick me</span>
			// |		<popup> ... </popup>
			// |	</div>
			// tags:
			//		protected

			if(this.srcNodeRef){
				var nodes = dojo.query("*", this.srcNodeRef);
				dijit.PopupMenuItem.superclass._fillContent.call(this, nodes[0]);

				// save pointer to srcNode so we can grab the drop down widget after it's instantiated
				this.dropDownContainer = this.srcNodeRef;
			}
		},

		startup: function(){
			if(this._started){ return; }
			this.inherited(arguments);

			// we didn't copy the dropdown widget from the this.srcNodeRef, so it's in no-man's
			// land now.  move it to dojo.doc.body.
			if(!this.popup){
				var node = dojo.query("[widgetId]", this.dropDownContainer)[0];
				this.popup = dijit.byNode(node);
			}
			dojo.body().appendChild(this.popup.domNode);

			this.popup.domNode.style.display="none";
			if(this.arrowWrapper){
				dojo.style(this.arrowWrapper, "visibility", "");
			}
			dijit.setWaiState(this.focusNode, "haspopup", "true");
		},
		
		destroyDescendants: function(){
			if(this.popup){
				this.popup.destroyRecursive();
				delete this.popup;
			}
			this.inherited(arguments);
		}
	});


}

if(!dojo._hasResource["dijit.CheckedMenuItem"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.CheckedMenuItem"] = true;
dojo.provide("dijit.CheckedMenuItem");



dojo.declare("dijit.CheckedMenuItem",
		dijit.MenuItem,
		{
		// summary:
		//		A checkbox-like menu item for toggling on and off
		
		templateString:"<tr class=\"dijitReset dijitMenuItem\" dojoAttachPoint=\"focusNode\" waiRole=\"menuitemcheckbox\" tabIndex=\"-1\"\n\t\tdojoAttachEvent=\"onmouseenter:_onHover,onmouseleave:_onUnhover,ondijitclick:_onClick\">\n\t<td class=\"dijitReset\" waiRole=\"presentation\">\n\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitMenuItemIcon dijitCheckedMenuItemIcon\" dojoAttachPoint=\"iconNode\">\n\t\t<span class=\"dijitCheckedMenuItemIconChar\">&#10003;</span>\n\t</td>\n\t<td class=\"dijitReset dijitMenuItemLabel\" colspan=\"2\" dojoAttachPoint=\"containerNode,labelNode\"></td>\n\t<td class=\"dijitReset dijitMenuItemAccelKey\" style=\"display: none\" dojoAttachPoint=\"accelKeyNode\"></td>\n\t<td class=\"dijitReset dijitMenuArrowCell\" waiRole=\"presentation\">\n\t</td>\n</tr>\n",

		// checked: Boolean
		//		Our checked state
		checked: false,
		_setCheckedAttr: function(/*Boolean*/ checked){
			// summary:
			//		Hook so attr('checked', bool) works.
			//		Sets the class and state for the check box.
			dojo.toggleClass(this.domNode, "dijitCheckedMenuItemChecked", checked);
			dijit.setWaiState(this.domNode, "checked", checked);
			this.checked = checked;
		},

		onChange: function(/*Boolean*/ checked){
			// summary:
			//		User defined function to handle check/uncheck events
			// tags:
			//		callback
		},

		_onClick: function(/*Event*/ e){
			// summary:
			//		Clicking this item just toggles its state
			// tags:
			//		private
			if(!this.disabled){
				this.attr("checked", !this.checked);
				this.onChange(this.checked);
			}
			this.inherited(arguments);
		}
	});

}

if(!dojo._hasResource["dijit.MenuSeparator"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.MenuSeparator"] = true;
dojo.provide("dijit.MenuSeparator");





dojo.declare("dijit.MenuSeparator",
		[dijit._Widget, dijit._Templated, dijit._Contained],
		{
		// summary:
		//		A line between two menu items

		templateString:"<tr class=\"dijitMenuSeparator\">\n\t<td colspan=\"4\">\n\t\t<div class=\"dijitMenuSeparatorTop\"></div>\n\t\t<div class=\"dijitMenuSeparatorBottom\"></div>\n\t</td>\n</tr>\n",

		postCreate: function(){
			dojo.setSelectable(this.domNode, false);
		},
		
		isFocusable: function(){
			// summary:
			//		Override to always return false
			// tags:
			//		protected

			return false; // Boolean
		}
	});


}

if(!dojo._hasResource["dijit.Menu"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.Menu"] = true;
dojo.provide("dijit.Menu");





dojo.declare("dijit._MenuBase",
	[dijit._Widget, dijit._Templated, dijit._KeyNavContainer],
{
	// summary:
	//		Base class for Menu and MenuBar

	// parentMenu: [readonly] Widget
	//		pointer to menu that displayed me
	parentMenu: null,

	// popupDelay: Integer
	//		number of milliseconds before hovering (without clicking) causes the popup to automatically open.
	popupDelay: 500,

	startup: function(){
		if(this._started){ return; }

		dojo.forEach(this.getChildren(), function(child){ child.startup(); });
		this.startupKeyNavChildren();

		this.inherited(arguments);
	},

	onExecute: function(){
		// summary:
		//		Attach point for notification about when a menu item has been executed.
		//		This is an internal mechanism used for Menus to signal to their parent to
		//		close them, because they are about to execute the onClick handler.   In
		//		general developers should not attach to or override this method.
		// tags:
		//		protected
	},

	onCancel: function(/*Boolean*/ closeAll){
		// summary:
		//		Attach point for notification about when the user cancels the current menu
		//		This is an internal mechanism used for Menus to signal to their parent to
		//		close them.  In general developers should not attach to or override this method.
		// tags:
		//		protected
	},

	_moveToPopup: function(/*Event*/ evt){
		// summary:
		//		This handles the right arrow key (left arrow key on RTL systems),
		//		which will either open a submenu, or move to the next item in the
		//		ancestor MenuBar
		// tags:
		//		private

		if(this.focusedChild && this.focusedChild.popup && !this.focusedChild.disabled){
			this.focusedChild._onClick(evt);
		}else{
			var topMenu = this._getTopMenu();
			if(topMenu && topMenu._isMenuBar){
				topMenu.focusNext();
			}
		}
	},

	onItemHover: function(/*MenuItem*/ item){
		// summary:
		//		Called when cursor is over a MenuItem.
		// tags:
		//		protected

		// Don't do anything unless user has "activated" the menu by:
		//		1) clicking it
		//		2) tabbing into it
		//		3) opening it from a parent menu (which automatically focuses it)
		if(this.isActive){
			this.focusChild(item);
	
			if(this.focusedChild.popup && !this.focusedChild.disabled && !this.hover_timer){
				this.hover_timer = setTimeout(dojo.hitch(this, "_openPopup"), this.popupDelay);
			}
		}
	},

	_onChildBlur: function(item){
		// summary:
		//		Called when a child MenuItem becomes inactive because focus
		//		has been removed from the MenuItem *and* it's descendant menus.
		// tags:
		//		private

		item._setSelected(false);

		// Close all popups that are open and descendants of this menu
		dijit.popup.close(item.popup);
		this._stopPopupTimer();
	},

	onItemUnhover: function(/*MenuItem*/ item){
		// summary:
		//		Callback fires when mouse exits a MenuItem
		// tags:
		//		protected
		if(this.isActive){
			this._stopPopupTimer();
		}
	},

	_stopPopupTimer: function(){
		// summary:
		//		Cancels the popup timer because the user has stop hovering
		//		on the MenuItem, etc.
		// tags:
		//		private
		if(this.hover_timer){
			clearTimeout(this.hover_timer);
			this.hover_timer = null;
		}
	},

	_getTopMenu: function(){
		// summary:
		//		Returns the top menu in this chain of Menus
		// tags:
		//		private
		for(var top=this; top.parentMenu; top=top.parentMenu);
		return top;
	},

	onItemClick: function(/*Widget*/ item, /*Event*/ evt){
		// summary:
		//		Handle clicks on an item.
		// tags:
		//		private
		if(item.disabled){ return false; }

		this.focusChild(item);

		if(item.popup){
			if(!this.is_open){
				this._openPopup();
			}
		}else{
			// before calling user defined handler, close hierarchy of menus
			// and restore focus to place it was when menu was opened
			this.onExecute();

			// user defined handler for click
			item.onClick(evt);
		}
	},

	_openPopup: function(){
		// summary:
		//		Open the popup to the side of/underneath the current menu item
		// tags:
		//		protected

		this._stopPopupTimer();
		var from_item = this.focusedChild;
		var popup = from_item.popup;

		if(popup.isShowingNow){ return; }
		popup.parentMenu = this;
		var self = this;
		dijit.popup.open({
			parent: this,
			popup: popup,
			around: from_item.domNode,
			orient: this._orient || (this.isLeftToRight() ? 
									{'TR': 'TL', 'TL': 'TR', 'BR': 'BL', 'BL': 'BR'} : 
									{'TL': 'TR', 'TR': 'TL', 'BL': 'BR', 'BR': 'BL'}),
			onCancel: function(){
				// called when the child menu is canceled
				dijit.popup.close(popup);
				from_item.focus();	// put focus back on my node
				self.currentPopup = null;
			},
			onExecute: dojo.hitch(this, "_onDescendantExecute")
		});

		this.currentPopup = popup;

		if(popup.focus){
			// If user is opening the popup via keyboard (right arrow, or down arrow for MenuBar),
			// if the cursor happens to collide with the popup, it will generate an onmouseover event
			// even though the mouse wasn't moved.   Use a setTimeout() to call popup.focus so that
			// our focus() call overrides the onmouseover event, rather than vice-versa.  (#8742)
			setTimeout(dojo.hitch(popup, "focus"), 0);
		}
	},

	onOpen: function(/*Event*/ e){
		// summary:
		//		Callback when this menu is opened.
		//		This is called by the popup manager as notification that the menu
		//		was opened.
		// tags:
		//		private

		this.isShowingNow = true;
	},

	onClose: function(){
		// summary:
		//		Callback when this menu is closed.
		//		This is called by the popup manager as notification that the menu
		//		was closed.
		// tags:
		//		private

		this._stopPopupTimer();
		this.parentMenu = null;
		this.isShowingNow = false;
		this.currentPopup = null;
		if(this.focusedChild){
			this._onChildBlur(this.focusedChild);
			this.focusedChild = null;
		}
	},

	_onFocus: function(){
		// summary:
		//		Called when this Menu gets focus from:
		//			1) clicking it
		//			2) tabbing into it
		//			3) being opened by a parent menu.
		//		This is not called just from mouse hover.
		// tags:
		//		protected
		this.isActive = true;
		dojo.addClass(this.domNode, "dijitMenuActive");
		dojo.removeClass(this.domNode, "dijitMenuPassive");
		this.inherited(arguments);
	},
	
	_onBlur: function(){
		// summary:
		//		Called when focus is moved away from this Menu and it's submenus.
		// tags:
		//		protected
		this.isActive = false;
		dojo.removeClass(this.domNode, "dijitMenuActive");
		dojo.addClass(this.domNode, "dijitMenuPassive");

		// If user blurs/clicks away from a MenuBar (or always visible Menu), then close all popped up submenus etc.
		this.onClose();

		this.inherited(arguments);
	},

	_onDescendantExecute: function(){
		// summary:
		//		Called when submenu is clicked.  Close hierarchy of menus.
		// tags:
		//		private
		this.onClose();
	}
});

dojo.declare("dijit.Menu",
	dijit._MenuBase,
	{
	// summary
	//		A context menu you can assign to multiple elements

	// TODO: most of the code in here is just for context menu (right-click menu)
	// support.  In retrospect that should have been a separate class (dijit.ContextMenu).
	// Split them for 2.0

	constructor: function(){
		this._bindings = [];
	},

	templateString:"<table class=\"dijit dijitMenu dijitMenuPassive dijitReset dijitMenuTable\" waiRole=\"menu\" tabIndex=\"${tabIndex}\" dojoAttachEvent=\"onkeypress:_onKeyPress\">\n\t<tbody class=\"dijitReset\" dojoAttachPoint=\"containerNode\"></tbody>\n</table>\n",

	// targetNodeIds: [const] String[]
	//		Array of dom node ids of nodes to attach to.
	//		Fill this with nodeIds upon widget creation and it becomes context menu for those nodes.
	targetNodeIds: [],

	// contextMenuForWindow: [const] Boolean
	//		If true, right clicking anywhere on the window will cause this context menu to open.
	//		If false, must specify targetNodeIds.
	contextMenuForWindow: false,

	// leftClickToOpen: [const] Boolean
	//		If true, menu will open on left click instead of right click, similiar to a file menu.
	leftClickToOpen: false,
	
	// _contextMenuWithMouse: [private] Boolean
	//		Used to record mouse and keyboard events to determine if a context
	//		menu is being opened with the keyboard or the mouse.
	_contextMenuWithMouse: false,

	postCreate: function(){
		if(this.contextMenuForWindow){
			this.bindDomNode(dojo.body());
		}else{
			// TODO: should have _setTargetNodeIds() method to handle initialization and a possible
			// later attr('targetNodeIds', ...) call.   There's also a problem that targetNodeIds[]
			// gets stale after calls to bindDomNode()/unBindDomNode() as it still is just the original list (see #9610)
			dojo.forEach(this.targetNodeIds, this.bindDomNode, this);
		}
		var k = dojo.keys, l = this.isLeftToRight();
		this._openSubMenuKey = l ? k.RIGHT_ARROW : k.LEFT_ARROW;
		this._closeSubMenuKey = l ? k.LEFT_ARROW : k.RIGHT_ARROW;
		this.connectKeyNavHandlers([k.UP_ARROW], [k.DOWN_ARROW]);
	},

	_onKeyPress: function(/*Event*/ evt){
		// summary:
		//		Handle keyboard based menu navigation.
		// tags:
		//		protected

		if(evt.ctrlKey || evt.altKey){ return; }

		switch(evt.charOrCode){
			case this._openSubMenuKey:
				this._moveToPopup(evt);
				dojo.stopEvent(evt);
				break;
			case this._closeSubMenuKey:
				if(this.parentMenu){
					if(this.parentMenu._isMenuBar){
						this.parentMenu.focusPrev();
					}else{
						this.onCancel(false);
					}
				}else{
					dojo.stopEvent(evt);
				}
				break;
		}
	},

	// thanks burstlib!
	_iframeContentWindow: function(/* HTMLIFrameElement */iframe_el){
		// summary:
		//		Returns the window reference of the passed iframe
		// tags:
		//		private
		var win = dijit.getDocumentWindow(this._iframeContentDocument(iframe_el)) ||
			// Moz. TODO: is this available when defaultView isn't?
			this._iframeContentDocument(iframe_el)['__parent__'] ||
			(iframe_el.name && dojo.doc.frames[iframe_el.name]) || null;
		return win;	//	Window
	},

	_iframeContentDocument: function(/* HTMLIFrameElement */iframe_el){
		// summary:
		//		Returns a reference to the document object inside iframe_el
		// tags:
		//		protected
		var doc = iframe_el.contentDocument // W3
			|| (iframe_el.contentWindow && iframe_el.contentWindow.document) // IE
			|| (iframe_el.name && dojo.doc.frames[iframe_el.name] && dojo.doc.frames[iframe_el.name].document)
			|| null;
		return doc;	//	HTMLDocument
	},

	bindDomNode: function(/*String|DomNode*/ node){
		// summary:
		//		Attach menu to given node
		node = dojo.byId(node);

		var cn;	// Connect node

		// Support context menus on iframes.   Rather than binding to the iframe itself we need
		// to bind to the <body> node inside the iframe.
		if(node.tagName.toLowerCase() == "iframe"){
			var iframe = node,
				win = this._iframeContentWindow(iframe);
			cn = dojo.withGlobal(win, dojo.body);
		}else{
			// to capture these events at the top level,
			// attach to document, not body
			cn = (node == dojo.body() ? dojo.doc : node);
		}

		// "binding" is the object to track our connection to the node (ie, the parameter to bindDomNode())
		var binding = {
			node: cn,
			iframe: iframe
		};
		node[this.id] = this._bindings.push(binding);

		// Setup the connections to monitor click etc., unless we are connecting to an iframe which hasn't finished
		// loading yet, in which case we need to wait for the onload event first, and then connect
		var doConnects = dojo.hitch(this, function(cn){
			return [
				dojo.connect(cn, (this.leftClickToOpen)?"onclick":"oncontextmenu", this, function(evt){
					this._openMyself(evt, cn, iframe);
				}),
				dojo.connect(cn, "onkeydown", this, "_contextKey"),
				dojo.connect(cn, "onmousedown", this, "_contextMouse")
			];
		});
		binding.connects = cn ? doConnects(cn) : [];

		if(iframe){
			// Setup handler to [re]bind to the iframe when the contents are initially loaded,
			// and every time the contents change.
			// Need to do this b/c we are actually binding to the iframe's <body> node.
			// Note: can't use dojo.connect(), see #9609.
			
			binding.onloadHandler = dojo.hitch(this, function(){
				// want to remove old connections, but IE throws exceptions when trying to
				// access the <body> node because it's already gone, or at least in a state of limbo

				var win = this._iframeContentWindow(iframe);
					cn = dojo.withGlobal(win, dojo.body);
				binding.connects = doConnects(cn);
			});
			if(iframe.addEventListener){
				iframe.addEventListener("load", binding.onloadHandler, false);
			}else{
				iframe.attachEvent("onload", binding.onloadHandler);
			}
		}
	},

	unBindDomNode: function(/*String|DomNode*/ nodeName){
		// summary:
		//		Detach menu from given node

		var node;
		try {
			node = dojo.byId(nodeName);
		}catch(e){
			// On IE the dojo.byId() call will get an exception if the attach point was
			// the <body> node of an <iframe> that has since been reloaded (and thus the
			// <body> node is in a limbo state of destruction.
			return;
		}

		if(node && node[this.id]){
			var bid = node[this.id]-1, b = this._bindings[bid];
			dojo.forEach(b.connects, dojo.disconnect);

			// Remove listener for iframe onload events
			var iframe = b.iframe;
			if(iframe){
				if(iframe.removeEventListener){
					iframe.removeEventListener("load", b.onloadHandler, false);
				}else{
					iframe.detachEvent("onload", b.onloadHandler);
				}
			}

			delete this._bindings[bid];
		}
	},

	_contextKey: function(e){
		// summary:
		//		Code to handle popping up editor using F10 key rather than mouse
		// tags:
		//		private
		this._contextMenuWithMouse = false;
		if(e.keyCode == dojo.keys.F10){
			dojo.stopEvent(e);
			if(e.shiftKey && e.type=="keydown"){
				// FF: copying the wrong property from e will cause the system
				// context menu to appear in spite of stopEvent. Don't know
				// exactly which properties cause this effect.
				var _e = { target: e.target, pageX: e.pageX, pageY: e.pageY };
				_e.preventDefault = _e.stopPropagation = function(){};
				// IE: without the delay, focus work in "open" causes the system
				// context menu to appear in spite of stopEvent.
				window.setTimeout(dojo.hitch(this, function(){ this._openMyself(_e); }), 1);
			}
		}
	},

	_contextMouse: function(e){
		// summary:
		//		Helper to remember when we opened the context menu with the mouse instead
		//		of with the keyboard
		// tags:
		//		private
		this._contextMenuWithMouse = true;
	},

	_openMyself: function(/*Event*/ e, /*DomNode?*/ node, /*DomNode?*/ iframe){
		// summary:
		//		Internal function for opening myself when the user
		//		does a right-click or something similar.
		// node:
		//		The node that is being clicked
		// iframe:
		//		If an <iframe> is being clicked, iframe points to that iframe and node
		//		points to the iframe's body.
		// tags:
		//		private

		if(this.leftClickToOpen&&e.button>0){
			return;
		}
		dojo.stopEvent(e);

		// Get coordinates.
		// If we are opening the menu with the mouse or on safari open
		// the menu at the mouse cursor
		// (Safari does not have a keyboard command to open the context menu
		// and we don't currently have a reliable way to determine
		// _contextMenuWithMouse on Safari)
		var x,y;
		if(dojo.isSafari || this._contextMenuWithMouse){
			x=e.pageX;
			y=e.pageY;
			
			if(iframe){
				// Event is on <body> node of an <iframe>, convert coordinates to match main document
				var od = e.target.ownerDocument,
					ifc = dojo.coords(iframe),
					win = this._iframeContentWindow(iframe),
					scroll = dojo.withGlobal(win, "_docScroll", dojo); 

				var cs = dojo.getComputedStyle(iframe),
					tp = dojo._toPixelValue,
					left = (dojo.isIE && dojo.isQuirks ? 0 : tp(iframe, cs.paddingLeft)) + (dojo.isIE && dojo.isQuirks ? tp(iframe, cs.borderLeftWidth) : 0) + tp(iframe, cs.marginLeft),
					top = (dojo.isIE && dojo.isQuirks ? 0 : tp(iframe, cs.paddingTop)) + (dojo.isIE && dojo.isQuirks ? tp(iframe, cs.borderTopWidth) : 0) + tp(iframe, cs.marginTop);

				x += ifc.l + left - scroll.x;
				y += ifc.t + top - scroll.y;
			}
		}else{
			// otherwise open near e.target
			var coords = dojo.coords(e.target, true);
			x = coords.x + 10;
			y = coords.y + 10;
		}

		var self=this;
		var savedFocus = dijit.getFocus(this);
		function closeAndRestoreFocus(){
			// user has clicked on a menu or popup
			dijit.focus(savedFocus);
			dijit.popup.close(self);
		}
		dijit.popup.open({
			popup: this,
			x: x,
			y: y,
			onExecute: closeAndRestoreFocus,
			onCancel: closeAndRestoreFocus,
			orient: this.isLeftToRight() ? 'L' : 'R'
		});
		this.focus();

		this._onBlur = function(){
			this.inherited('_onBlur', arguments);
			// Usually the parent closes the child widget but if this is a context
			// menu then there is no parent
			dijit.popup.close(this);
			// don't try to restore focus; user has clicked another part of the screen
			// and set focus there
		};
	},

	uninitialize: function(){
 		dojo.forEach(this._bindings, function(b){ if(b){ this.unBindDomNode(b.node); } }, this);
 		this.inherited(arguments);
	}
}
);

// Back-compat (TODO: remove in 2.0)






}

if(!dojo._hasResource["dijit.TitlePane"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.TitlePane"] = true;
dojo.provide("dijit.TitlePane");






dojo.declare(
	"dijit.TitlePane",
	[dijit.layout.ContentPane, dijit._Templated],
{
	// summary:
	//		A pane with a title on top, that can be expanded or collapsed.
	//
	// description:
	//		An accessible container with a Title Heading, and a content
	//		section that slides open and closed. TitlePane is an extension to 
	//		`dijit.layout.ContentPane`, providing all the usesful content-control aspects from it.
	//
	// example:
	// | 	// load a TitlePane from remote file:
	// |	var foo = new dijit.TitlePane({ href: "foobar.html", title:"Title" });
	// |	foo.startup();
	//
	// example:
	// |	<!-- markup href example: -->
	// |	<div dojoType="dijit.TitlePane" href="foobar.html" title="Title"></div>
	// 
	// example:
	// |	<!-- markup with inline data -->
	// | 	<div dojoType="dijit.TitlePane" title="Title">
	// |		<p>I am content</p>
	// |	</div>

	// title: String
	//		Title of the pane
	title: "",

	// open: Boolean
	//		Whether pane is opened or closed.
	open: true,

	// duration: Integer
	//		Time in milliseconds to fade in/fade out
	duration: dijit.defaultDuration,

	// baseClass: [protected] String
	//		The root className to use for the various states of this widget
	baseClass: "dijitTitlePane",

	templateString:"<div class=\"${baseClass}\">\n\t<div dojoAttachEvent=\"onclick:toggle, onkeypress:_onTitleKey, onfocus:_handleFocus, onblur:_handleFocus, onmouseenter:_onTitleEnter, onmouseleave:_onTitleLeave\" tabindex=\"0\"\n\t\t\twaiRole=\"button\" class=\"dijitTitlePaneTitle\" dojoAttachPoint=\"titleBarNode,focusNode\">\n\t\t<img src=\"${_blankGif}\" alt=\"\" dojoAttachPoint=\"arrowNode\" class=\"dijitArrowNode\" waiRole=\"presentation\"\n\t\t><span dojoAttachPoint=\"arrowNodeInner\" class=\"dijitArrowNodeInner\"></span\n\t\t><span dojoAttachPoint=\"titleNode\" class=\"dijitTitlePaneTextNode\"></span>\n\t</div>\n\t<div class=\"dijitTitlePaneContentOuter\" dojoAttachPoint=\"hideNode\">\n\t\t<div class=\"dijitReset\" dojoAttachPoint=\"wipeNode\">\n\t\t\t<div class=\"dijitTitlePaneContentInner\" dojoAttachPoint=\"containerNode\" waiRole=\"region\" tabindex=\"-1\">\n\t\t\t\t<!-- nested divs because wipeIn()/wipeOut() doesn't work right on node w/padding etc.  Put padding on inner div. -->\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</div>\n",

	attributeMap: dojo.delegate(dijit.layout.ContentPane.prototype.attributeMap, {
		title: { node: "titleNode", type: "innerHTML" }
	}),

	postCreate: function(){
		if(!this.open){
			this.hideNode.style.display = this.wipeNode.style.display = "none";
		}
		this._setCss();
		dojo.setSelectable(this.titleNode, false);
		dijit.setWaiState(this.containerNode, "labelledby", this.titleNode.id);
		dijit.setWaiState(this.focusNode, "haspopup", "true");

		// setup open/close animations
		var hideNode = this.hideNode, wipeNode = this.wipeNode;
		this._wipeIn = dojo.fx.wipeIn({
			node: this.wipeNode,
			duration: this.duration,
			beforeBegin: function(){
				hideNode.style.display="";
			}
		});
		this._wipeOut = dojo.fx.wipeOut({
			node: this.wipeNode,
			duration: this.duration,
			onEnd: function(){
				hideNode.style.display="none";
			}
		});
		this.inherited(arguments);
	},

	_setOpenAttr: function(/* Boolean */ open){
		// summary:
		//		Hook to make attr("open", boolean) control the open/closed state of the pane.
		// open: Boolean
		//		True if you want to open the pane, false if you want to close it.
		if(this.open !== open){ this.toggle(); }
	},

	_setContentAttr: function(content){
		// summary:
		//		Hook to make attr("content", ...) work.
		// 		Typically called when an href is loaded.  Our job is to make the animation smooth.

		if(!this.open || !this._wipeOut || this._wipeOut.status() == "playing"){
			// we are currently *closing* the pane (or the pane is closed), so just let that continue
			this.inherited(arguments);
		}else{
			if(this._wipeIn && this._wipeIn.status() == "playing"){
				this._wipeIn.stop();
			}

			// freeze container at current height so that adding new content doesn't make it jump
			dojo.marginBox(this.wipeNode, { h: dojo.marginBox(this.wipeNode).h });

			// add the new content (erasing the old content, if any)
			this.inherited(arguments);

			// call _wipeIn.play() to animate from current height to new height
			if(this._wipeIn){
				this._wipeIn.play();
			}else{
				this.hideNode.style.display = "";
			}
		}
	},

	toggle: function(){
		// summary:
		//		Switches between opened and closed state
		// tags:
		//		private

		dojo.forEach([this._wipeIn, this._wipeOut], function(animation){
			if(animation && animation.status() == "playing"){
				animation.stop();
			}
		});

		var anim = this[this.open ? "_wipeOut" : "_wipeIn"]
		if(anim){
			anim.play();
		}else{
			this.hideNode.style.display = this.open ? "" : "none";
		}
		this.open =! this.open;

		// load content (if this is the first time we are opening the TitlePane
		// and content is specified as an href, or href was set when hidden)
		this._onShow();

		this._setCss();
	},

	_setCss: function(){
		// summary:
		//		Set the open/close css state for the TitlePane
		// tags:
		//		private

		var classes = ["dijitClosed", "dijitOpen"];
		var boolIndex = this.open;
		var node = this.titleBarNode || this.focusNode;
		dojo.removeClass(node, classes[!boolIndex+0]);
		node.className += " " + classes[boolIndex+0];

		// provide a character based indicator for images-off mode
		this.arrowNodeInner.innerHTML = this.open ? "-" : "+";
	},

	_onTitleKey: function(/*Event*/ e){
		// summary:
		//		Handler for when user hits a key
		// tags:
		//		private

		if(e.charOrCode == dojo.keys.ENTER || e.charOrCode == ' '){
			this.toggle();
		}else if(e.charOrCode == dojo.keys.DOWN_ARROW && this.open){
			this.containerNode.focus();
			e.preventDefault();
	 	}
	},
	
	_onTitleEnter: function(){
		// summary:
		//		Handler for when someone hovers over my title
		// tags:
		//		private
		dojo.addClass(this.focusNode, "dijitTitlePaneTitle-hover");
	},

	_onTitleLeave: function(){
		// summary:
		//		Handler when someone stops hovering over my title
		// tags:
		//		private
		dojo.removeClass(this.focusNode, "dijitTitlePaneTitle-hover");
	},

	_handleFocus: function(/*Event*/ e){
		// summary:
		//		Handle blur and focus for this widget
		// tags:
		//		private
		
		// add/removeClass is safe to call without hasClass in this case
		dojo[(e.type == "focus" ? "addClass" : "removeClass")](this.focusNode, this.baseClass + "Focused");
	},

	setTitle: function(/*String*/ title){
		// summary:
		//		Deprecated.  Use attr('title', ...) instead.
		// tags:
		//		deprecated
		dojo.deprecated("dijit.TitlePane.setTitle() is deprecated.  Use attr('title', ...) instead.", "", "2.0");
		this.titleNode.innerHTML = title;
	}
});

}

if(!dojo._hasResource["dojo.regexp"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.regexp"] = true;
dojo.provide("dojo.regexp");

/*=====
dojo.regexp = {
	// summary: Regular expressions and Builder resources
};
=====*/

dojo.regexp.escapeString = function(/*String*/str, /*String?*/except){
	//	summary:
	//		Adds escape sequences for special characters in regular expressions
	// except:
	//		a String with special characters to be left unescaped

	return str.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, function(ch){
		if(except && except.indexOf(ch) != -1){
			return ch;
		}
		return "\\" + ch;
	}); // String
}

dojo.regexp.buildGroupRE = function(/*Object|Array*/arr, /*Function*/re, /*Boolean?*/nonCapture){
	//	summary:
	//		Builds a regular expression that groups subexpressions
	//	description:
	//		A utility function used by some of the RE generators. The
	//		subexpressions are constructed by the function, re, in the second
	//		parameter.  re builds one subexpression for each elem in the array
	//		a, in the first parameter. Returns a string for a regular
	//		expression that groups all the subexpressions.
	// arr:
	//		A single value or an array of values.
	// re:
	//		A function. Takes one parameter and converts it to a regular
	//		expression. 
	// nonCapture:
	//		If true, uses non-capturing match, otherwise matches are retained
	//		by regular expression. Defaults to false

	// case 1: a is a single value.
	if(!(arr instanceof Array)){
		return re(arr); // String
	}

	// case 2: a is an array
	var b = [];
	for(var i = 0; i < arr.length; i++){
		// convert each elem to a RE
		b.push(re(arr[i]));
	}

	 // join the REs as alternatives in a RE group.
	return dojo.regexp.group(b.join("|"), nonCapture); // String
}

dojo.regexp.group = function(/*String*/expression, /*Boolean?*/nonCapture){
	// summary:
	//		adds group match to expression
	// nonCapture:
	//		If true, uses non-capturing match, otherwise matches are retained
	//		by regular expression. 
	return "(" + (nonCapture ? "?:":"") + expression + ")"; // String
}

}

if(!dojo._hasResource["dojo.cookie"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.cookie"] = true;
dojo.provide("dojo.cookie");



/*=====
dojo.__cookieProps = function(){
	//	expires: Date|String|Number?
	//		If a number, the number of days from today at which the cookie
	//		will expire. If a date, the date past which the cookie will expire.
	//		If expires is in the past, the cookie will be deleted.
	//		If expires is omitted or is 0, the cookie will expire when the browser closes. << FIXME: 0 seems to disappear right away? FF3.
	//	path: String?
	//		The path to use for the cookie.
	//	domain: String?
	//		The domain to use for the cookie.
	//	secure: Boolean?
	//		Whether to only send the cookie on secure connections
	this.expires = expires;
	this.path = path;
	this.domain = domain;
	this.secure = secure;
}
=====*/


dojo.cookie = function(/*String*/name, /*String?*/value, /*dojo.__cookieProps?*/props){
	//	summary: 
	//		Get or set a cookie.
	//	description:
	// 		If one argument is passed, returns the value of the cookie
	// 		For two or more arguments, acts as a setter.
	//	name:
	//		Name of the cookie
	//	value:
	//		Value for the cookie
	//	props: 
	//		Properties for the cookie
	//	example:
	//		set a cookie with the JSON-serialized contents of an object which
	//		will expire 5 days from now:
	//	|	dojo.cookie("configObj", dojo.toJson(config), { expires: 5 });
	//	
	//	example:
	//		de-serialize a cookie back into a JavaScript object:
	//	|	var config = dojo.fromJson(dojo.cookie("configObj"));
	//	
	//	example:
	//		delete a cookie:
	//	|	dojo.cookie("configObj", null, {expires: -1});
	var c = document.cookie;
	if(arguments.length == 1){
		var matches = c.match(new RegExp("(?:^|; )" + dojo.regexp.escapeString(name) + "=([^;]*)"));
		return matches ? decodeURIComponent(matches[1]) : undefined; // String or undefined
	}else{
		props = props || {};
// FIXME: expires=0 seems to disappear right away, not on close? (FF3)  Change docs?
		var exp = props.expires;
		if(typeof exp == "number"){ 
			var d = new Date();
			d.setTime(d.getTime() + exp*24*60*60*1000);
			exp = props.expires = d;
		}
		if(exp && exp.toUTCString){ props.expires = exp.toUTCString(); }

		value = encodeURIComponent(value);
		var updatedCookie = name + "=" + value, propName;
		for(propName in props){
			updatedCookie += "; " + propName;
			var propValue = props[propName];
			if(propValue !== true){ updatedCookie += "=" + propValue; }
		}
		document.cookie = updatedCookie;
	}
};

dojo.cookie.isSupported = function(){
	//	summary:
	//		Use to determine if the current browser supports cookies or not.
	//		
	//		Returns true if user allows cookies.
	//		Returns false if user doesn't allow cookies.

	if(!("cookieEnabled" in navigator)){
		this("__djCookieTest__", "CookiesAllowed");
		navigator.cookieEnabled = this("__djCookieTest__") == "CookiesAllowed";
		if(navigator.cookieEnabled){
			this("__djCookieTest__", "", {expires: -1});
		}
	}
	return navigator.cookieEnabled;
};

}

if(!dojo._hasResource["dijit.form.ToggleButton"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.ToggleButton"] = true;
dojo.provide("dijit.form.ToggleButton");


}

if(!dojo._hasResource["dijit.layout.StackController"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout.StackController"] = true;
dojo.provide("dijit.layout.StackController");








dojo.declare(
		"dijit.layout.StackController",
		[dijit._Widget, dijit._Templated, dijit._Container],
		{
		// summary:
		//		Set of buttons to select a page in a page list.
		// description:
		//		Monitors the specified StackContainer, and whenever a page is
		//		added, deleted, or selected, updates itself accordingly.

			templateString: "<span wairole='tablist' dojoAttachEvent='onkeypress' class='dijitStackController'></span>",

			// containerId: [const] String
			//		The id of the page container that I point to
			containerId: "",

			// buttonWidget: [const] String
			//		The name of the button widget to create to correspond to each page
			buttonWidget: "dijit.layout._StackButton",

			postCreate: function(){
				dijit.setWaiRole(this.domNode, "tablist");

				// TODO: change key from object to id, to get more separation from StackContainer
				this.pane2button = {};		// mapping from panes to buttons
				this.pane2handles = {};		// mapping from panes to dojo.connect() handles
				this.pane2menu = {};		// mapping from panes to close menu

				this._subscriptions=[
					dojo.subscribe(this.containerId+"-startup", this, "onStartup"),
					dojo.subscribe(this.containerId+"-addChild", this, "onAddChild"),
					dojo.subscribe(this.containerId+"-removeChild", this, "onRemoveChild"),
					dojo.subscribe(this.containerId+"-selectChild", this, "onSelectChild"),
					dojo.subscribe(this.containerId+"-containerKeyPress", this, "onContainerKeyPress")
				];
			},

			onStartup: function(/*Object*/ info){
				// summary:
				//		Called after StackContainer has finished initializing
				// tags:
				//		private
				dojo.forEach(info.children, this.onAddChild, this);
				this.onSelectChild(info.selected);
			},

			destroy: function(){
				for(var pane in this.pane2button){
					this.onRemoveChild(pane);
				}
				dojo.forEach(this._subscriptions, dojo.unsubscribe);
				this.inherited(arguments);
			},

			onAddChild: function(/*Widget*/ page, /*Integer?*/ insertIndex){
				// summary:
				//		Called whenever a page is added to the container.
				//		Create button corresponding to the page.
				// tags:
				//		private

				// add a node that will be promoted to the button widget
				var refNode = dojo.doc.createElement("span");
				this.domNode.appendChild(refNode);
				// create an instance of the button widget
				var cls = dojo.getObject(this.buttonWidget);
				var button = new cls({label: page.title, closeButton: page.closable}, refNode);
				this.addChild(button, insertIndex);
				this.pane2button[page] = button;
				page.controlButton = button;	// this value might be overwritten if two tabs point to same container

				var handles = [];
				handles.push(dojo.connect(button, "onClick", dojo.hitch(this,"onButtonClick",page)));
				if(page.closable){
					handles.push(dojo.connect(button, "onClickCloseButton", dojo.hitch(this,"onCloseButtonClick",page)));
					// add context menu onto title button
					var _nlsResources = dojo.i18n.getLocalization("dijit", "common");
					var closeMenu = new dijit.Menu({targetNodeIds:[button.id], id:button.id+"_Menu"});
					var mItem = new dijit.MenuItem({label:_nlsResources.itemClose});
					handles.push(dojo.connect(mItem, "onClick", dojo.hitch(this, "onCloseButtonClick", page)));
					closeMenu.addChild(mItem);
					this.pane2menu[page] = closeMenu;
				}
				this.pane2handles[page] = handles;
				if(!this._currentChild){ // put the first child into the tab order
					button.focusNode.setAttribute("tabIndex", "0");
					this._currentChild = page;
				}
				//make sure all tabs have the same length
				if(!this.isLeftToRight() && dojo.isIE && this._rectifyRtlTabList){
					this._rectifyRtlTabList();
				}
			},

			onRemoveChild: function(/*Widget*/ page){
				// summary:
				//		Called whenever a page is removed from the container.
				//		Remove the button corresponding to the page.
				// tags:
				//		private

				if(this._currentChild === page){ this._currentChild = null; }
				dojo.forEach(this.pane2handles[page], dojo.disconnect);
				delete this.pane2handles[page];
				var menu = this.pane2menu[page];
				if (menu){
					menu.destroyRecursive();
					delete this.pane2menu[page];
				}
				var button = this.pane2button[page];
				if(button){
					// TODO? if current child { reassign }
					button.destroy();
					delete this.pane2button[page];
				}
			},

			onSelectChild: function(/*Widget*/ page){
				// summary:
				//		Called when a page has been selected in the StackContainer, either by me or by another StackController
				// tags:
				//		private

				if(!page){ return; }

				if(this._currentChild){
					var oldButton=this.pane2button[this._currentChild];
					oldButton.attr('checked', false);
					oldButton.focusNode.setAttribute("tabIndex", "-1");
				}

				var newButton=this.pane2button[page];
				newButton.attr('checked', true);
				this._currentChild = page;
				newButton.focusNode.setAttribute("tabIndex", "0");
				var container = dijit.byId(this.containerId);
				dijit.setWaiState(container.containerNode, "labelledby", newButton.id);
			},

			onButtonClick: function(/*Widget*/ page){
				// summary:
				//		Called whenever one of my child buttons is pressed in an attempt to select a page
				// tags:
				//		private

				var container = dijit.byId(this.containerId);	// TODO: do this via topics?
				container.selectChild(page); 
			},

			onCloseButtonClick: function(/*Widget*/ page){
				// summary:
				//		Called whenever one of my child buttons [X] is pressed in an attempt to close a page
				// tags:
				//		private

				var container = dijit.byId(this.containerId);
				container.closeChild(page);
				var b = this.pane2button[this._currentChild];
				if(b){
					dijit.focus(b.focusNode || b.domNode);
				}
			},
			
			// TODO: this is a bit redundant with forward, back api in StackContainer
			adjacent: function(/*Boolean*/ forward){
				// summary:
				//		Helper for onkeypress to find next/previous button
				// tags:
				//		private

				if(!this.isLeftToRight() && (!this.tabPosition || /top|bottom/.test(this.tabPosition))){ forward = !forward; }
				// find currently focused button in children array
				var children = this.getChildren();
				var current = dojo.indexOf(children, this.pane2button[this._currentChild]);
				// pick next button to focus on
				var offset = forward ? 1 : children.length - 1;
				return children[ (current + offset) % children.length ]; // dijit._Widget
			},

			onkeypress: function(/*Event*/ e){
				// summary:
				//		Handle keystrokes on the page list, for advancing to next/previous button
				//		and closing the current page if the page is closable.
				// tags:
				//		private

				if(this.disabled || e.altKey ){ return; }
				var forward = null;
				if(e.ctrlKey || !e._djpage){
					var k = dojo.keys;
					switch(e.charOrCode){
						case k.LEFT_ARROW:
						case k.UP_ARROW:
							if(!e._djpage){ forward = false; }
							break;
						case k.PAGE_UP:
							if(e.ctrlKey){ forward = false; }
							break;
						case k.RIGHT_ARROW:
						case k.DOWN_ARROW:
							if(!e._djpage){ forward = true; }
							break;
						case k.PAGE_DOWN:
							if(e.ctrlKey){ forward = true; }
							break;
						case k.DELETE:
							if(this._currentChild.closable){
								this.onCloseButtonClick(this._currentChild);
							}
							dojo.stopEvent(e);
							break;
						default:
							if(e.ctrlKey){
								if(e.charOrCode === k.TAB){
									this.adjacent(!e.shiftKey).onClick();
									dojo.stopEvent(e);
								}else if(e.charOrCode == "w"){
									if(this._currentChild.closable){
										this.onCloseButtonClick(this._currentChild);
									}
									dojo.stopEvent(e); // avoid browser tab closing.
								}
							}
					}
					// handle page navigation
					if(forward !== null){
						this.adjacent(forward).onClick();
						dojo.stopEvent(e);
					}
				}
			},

			onContainerKeyPress: function(/*Object*/ info){
				// summary:
				//		Called when there was a keypress on the container
				// tags:
				//		private
				info.e._djpage = info.page;
				this.onkeypress(info.e);
			}
	});


dojo.declare("dijit.layout._StackButton",
		dijit.form.ToggleButton,
		{
		// summary:
		//		Internal widget used by StackContainer.
		// description:
		//		The button-like or tab-like object you click to select or delete a page
		// tags:
		//		private

		// Override _FormWidget.tabIndex.
		// StackContainer buttons are not in the tab order by default.
		// TODO: unclear if we need this; doesn't _KeyNavContainer (superclass of StackController) do it for us?
		tabIndex: "-1",
		
		postCreate: function(/*Event*/ evt){
			dijit.setWaiRole((this.focusNode || this.domNode), "tab");
			this.inherited(arguments);
		},
		
		onClick: function(/*Event*/ evt){
			// summary:
			//		This is for TabContainer where the tabs are <span> rather than button,
			//		so need to set focus explicitly (on some browsers)
			//		Note that you shouldn't override this method, but you can connect to it.
			dijit.focus(this.focusNode);

			// ... now let StackController catch the event and tell me what to do
		},

		onClickCloseButton: function(/*Event*/ evt){
			// summary:
			//		StackContainer connects to this function; if your widget contains a close button
			//		then clicking it should call this function.
			//		Note that you shouldn't override this method, but you can connect to it.
			evt.stopPropagation();
		}
	});


}

if(!dojo._hasResource["dijit.layout.StackContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout.StackContainer"] = true;
dojo.provide("dijit.layout.StackContainer");






dojo.declare(
	"dijit.layout.StackContainer",
	dijit.layout._LayoutWidget,
	{
	// summary: 
	//		A container that has multiple children, but shows only
	//		one child at a time
	//
	// description:
	//		A container for widgets (ContentPanes, for example) That displays
	//		only one Widget at a time.
	//	
	//		Publishes topics [widgetId]-addChild, [widgetId]-removeChild, and [widgetId]-selectChild
	//
	//		Can be base class for container, Wizard, Show, etc.

	// doLayout: Boolean
	//		If true, change the size of my currently displayed child to match my size
	doLayout: true,

	// persist: Boolean
	//		Remembers the selected child across sessions
	persist: false,	// Boolean
	
	baseClass: "dijitStackContainer",

	// _started: Boolean
	//		startup() has completed.
	//	TODO: comment this section out, it's just needed for documentation.
	//	Plus, move it to _Widget
	_started: false,

/*=====
	// selectedChildWidget: Widget
	//		References the currently selected child widget, if any
	//
	selectedChildWidget: null,
=====*/

	postCreate: function(){
		this.inherited(arguments);
		dojo.addClass(this.domNode, "dijitLayoutContainer");
		dijit.setWaiRole(this.containerNode, "tabpanel");
		this.connect(this.domNode, "onkeypress", this._onKeyPress);
	},

	startup: function(){
		if(this._started){ return; }

		var children = this.getChildren();

		// Setup each page panel to be initially hidden
		dojo.forEach(children, this._setupChild, this);

		// Figure out which child to initially display, defaulting to first one
		if(this.persist){
			this.selectedChildWidget = dijit.byId(dojo.cookie(this.id + "_selectedChild"));
		}else{
			dojo.some(children, function(child){
				if(child.selected){
					this.selectedChildWidget = child;
				}
				return child.selected;
			}, this);
		}
		var selected = this.selectedChildWidget;
		if(!selected && children[0]){
			selected = this.selectedChildWidget = children[0];
			selected.selected = true;
		}

		// Publish information about myself so any StackControllers can initialize.
		// This needs to happen before this.inherited(arguments) so that for
		// TabContainer, this._contentBox doesn't include the space for the tab labels.
		dojo.publish(this.id+"-startup", [{children: children, selected: selected}]);

		// Show the initially selected child (do this before this.inherited() call,
		// because child can't size correctly if it's hidden).
		// TODO: this will call onShow() on the child widget before startup() which is weird.
		if(selected){
			this._showChild(selected);
		}

		// Startup each child widget, and do initial layout like setting this._contentBox,
		// then calls this.resize() which does the initial sizing on the selected child.
		this.inherited(arguments);
	},

	_setupChild: function(/*Widget*/ child){
		// Overrides _LayoutWidget._setupChild()

		this.inherited(arguments);

		dojo.removeClass(child.domNode, "dijitVisible");
		dojo.addClass(child.domNode, "dijitHidden");

		// remove the title attribute so it doesn't show up when i hover
		// over a node
		child.domNode.title = "";

		return child; // dijit._Widget		(TODO: remove this, return code is unused)
	},

	addChild: function(/*Widget*/ child, /*Integer?*/ insertIndex){
		// Overrides _Container.addChild() to do layout and publish events
		 
		this.inherited(arguments);

		if(this._started){
			dojo.publish(this.id+"-addChild", [child, insertIndex]);

			// in case the tab titles have overflowed from one line to two lines
			// (or, if this if first child, from zero lines to one line)
			this.layout();

			// if this is the first child, then select it
			if(!this.selectedChildWidget){
				this.selectChild(child);
			}
		}
	},

	removeChild: function(/*Widget*/ page){
		// Overrides _Container.removeChild() to do layout and publish events

		this.inherited(arguments);

		// If we are being destroyed than don't run the code below (to select another page), because we are deleting
		// every page one by one
		if(this._beingDestroyed){ return; }

		if(this._started){
			// this will notify any tablists to remove a button; do this first because it may affect sizing
			dojo.publish(this.id+"-removeChild", [page]);

			// in case the tab titles now take up one line instead of two lines
			this.layout();
		}

		if(this.selectedChildWidget === page){
			this.selectedChildWidget = undefined;
			if(this._started){
				var children = this.getChildren();
				if(children.length){
					this.selectChild(children[0]);
				}
			}
		}
	},

	selectChild: function(/*Widget*/ page){
		// summary:
		//		Show the given widget (which must be one of my children)

		page = dijit.byId(page);

		if(this.selectedChildWidget != page){
			// Deselect old page and select new one
			this._transition(page, this.selectedChildWidget);
			this.selectedChildWidget = page;
			dojo.publish(this.id+"-selectChild", [page]);

			if(this.persist){
				dojo.cookie(this.id + "_selectedChild", this.selectedChildWidget.id);
			}
		}
	},

	_transition: function(/*Widget*/newWidget, /*Widget*/oldWidget){
		// summary:
		//		Hide the old widget and display the new widget.
		//		Subclasses should override this.
		// tags:
		//		protected extension
		if(oldWidget){
			this._hideChild(oldWidget);
		}
		this._showChild(newWidget);

		// Size the new widget, in case this is the first time it's being shown,
		// or I have been resized since the last time it was shown.
		// Note that page must be visible for resizing to work. 
		if(this.doLayout && newWidget.resize){
			newWidget.resize(this._containerContentBox || this._contentBox);
		}
	},

	_adjacent: function(/*Boolean*/ forward){
		// summary:
		//		Gets the next/previous child widget in this container from the current selection.
		var children = this.getChildren();
		var index = dojo.indexOf(children, this.selectedChildWidget);
		index += forward ? 1 : children.length - 1;
		return children[ index % children.length ]; // dijit._Widget
	},

	forward: function(){
		// summary:
		//		Advance to next page.
		this.selectChild(this._adjacent(true));
	},

	back: function(){
		// summary:
		//		Go back to previous page.
		this.selectChild(this._adjacent(false));
	},

	_onKeyPress: function(e){
		dojo.publish(this.id+"-containerKeyPress", [{ e: e, page: this}]);
	},

	layout: function(){
		// Implement _LayoutWidget.layout() virtual method.
		if(this.doLayout && this.selectedChildWidget && this.selectedChildWidget.resize){
			this.selectedChildWidget.resize(this._contentBox);
		}
	},

	_showChild: function(/*Widget*/ page){
		// summary:
		//		Show the specified child by changing it's CSS, and call _onShow()/onShow() so
		//		it can do any updates it needs regarding loading href's etc.
		var children = this.getChildren();
		page.isFirstChild = (page == children[0]);
		page.isLastChild = (page == children[children.length-1]);
		page.selected = true;

		dojo.removeClass(page.domNode, "dijitHidden");
		dojo.addClass(page.domNode, "dijitVisible");

		if(page._onShow){
			page._onShow(); // trigger load in ContentPane
		}else if(page.onShow){
			page.onShow();
		}
	},

	_hideChild: function(/*Widget*/ page){
		// summary:
		//		Hide the specified child by changing it's CSS, and call _onHide() so
		//		it's notified.
		page.selected=false;
		dojo.removeClass(page.domNode, "dijitVisible");
		dojo.addClass(page.domNode, "dijitHidden");

		if(page.onHide){
			page.onHide();
		}
	},

	closeChild: function(/*Widget*/ page){
		// summary:
		//		Callback when user clicks the [X] to remove a page.
		//		If onClose() returns true then remove and destroy the child.
		// tags:
		//		private
		var remove = page.onClose(this, page);
		if(remove){
			this.removeChild(page);
			// makes sure we can clean up executeScripts in ContentPane onUnLoad
			page.destroyRecursive();
		}
	},

	destroy: function(){
		this._beingDestroyed = true;
		this.inherited(arguments);
	}
});

// For back-compat, remove for 2.0



// These arguments can be specified for the children of a StackContainer.
// Since any widget can be specified as a StackContainer child, mix them
// into the base widget class.  (This is a hack, but it's effective.)
dojo.extend(dijit._Widget, {
	// title: String
	//		Title of this widget.  Used by TabContainer to the name the tab, etc.
	// TODO: remove this, it's in _Widget already.
	title: "",

	// selected: Boolean
	//		Is this child currently selected?
	selected: false,

	// closable: Boolean
	//		True if user can close (destroy) this child, such as (for example) clicking the X on the tab.
	closable: false,	// true if user can close this tab pane

	onClose: function(){
		// summary:
		//		Callback if someone tries to close the child, child will be closed if func returns true
		// tags:
		//		extension

		return true;		// Boolean
	}
});

}

if(!dojo._hasResource["dijit.layout.TabController"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout.TabController"] = true;
dojo.provide("dijit.layout.TabController");




//TODO: make private for 2.0?
dojo.declare("dijit.layout.TabController",
	dijit.layout.StackController,
	{
	// summary:
	// 		Set of tabs (the things with titles and a close button, that you click to show a tab panel).
	//		Used internally by `dijit.layout.TabContainer`.
	// description:
	//		Lets the user select the currently shown pane in a TabContainer or StackContainer.
	//		TabController also monitors the TabContainer, and whenever a pane is
	//		added or deleted updates itself accordingly.
	// tags:
	//		private

	templateString: "<div wairole='tablist' dojoAttachEvent='onkeypress:onkeypress'></div>",

	// tabPosition: String
	//		Defines where tabs go relative to the content.
	//		"top", "bottom", "left-h", "right-h"
	tabPosition: "top",

	// doLayout: Boolean
	//		TODO: unused, remove
	doLayout: true,

	// buttonWidget: String
	//		The name of the tab widget to create to correspond to each page
	buttonWidget: "dijit.layout._TabButton",

	_rectifyRtlTabList: function(){
		//summary: Rectify the width of all tabs in rtl, otherwise the tab widths are different in IE
		if(0 >= this.tabPosition.indexOf('-h')){ return; }
		if(!this.pane2button){ return; }

		var maxWidth = 0;
		for(var pane in this.pane2button){
			var ow = this.pane2button[pane].innerDiv.scrollWidth;
			maxWidth = Math.max(maxWidth, ow);
		}
		//unify the length of all the tabs
		for(pane in this.pane2button){
			this.pane2button[pane].innerDiv.style.width = maxWidth + 'px';
		}	
	}
});

dojo.declare("dijit.layout._TabButton",
	dijit.layout._StackButton,
	{
	// summary:
	//		A tab (the thing you click to select a pane).
	// description:
	//		Contains the title of the pane, and optionally a close-button to destroy the pane.
	//		This is an internal widget and should not be instantiated directly.
	// tags:
	//		private

	baseClass: "dijitTab",

	templateString:"<div waiRole=\"presentation\" dojoAttachEvent='onclick:onClick,onmouseenter:_onMouse,onmouseleave:_onMouse'>\n    <div waiRole=\"presentation\" class='dijitTabInnerDiv' dojoAttachPoint='innerDiv'>\n        <div waiRole=\"presentation\" class='dijitTabContent' dojoAttachPoint='tabContent'>\n\t        <span dojoAttachPoint='containerNode,focusNode' class='tabLabel'>${!label}</span><img class =\"dijitTabButtonSpacer\" src=\"${_blankGif}\" alt=\"\" />\n\t        <span class=\"closeButton\" dojoAttachPoint='closeNode'\n\t        \t\tdojoAttachEvent='onclick: onClickCloseButton, onmouseenter: _onCloseButtonEnter, onmouseleave: _onCloseButtonLeave'>\n\t        \t<img src=\"${_blankGif}\" alt=\"\" dojoAttachPoint='closeIcon' class='closeImage' waiRole=\"presentation\"/>\n\t            <span dojoAttachPoint='closeText' class='closeText'>x</span>\n\t        </span>\n        </div>\n    </div>\n</div>\n",

	// Override _FormWidget.scrollOnFocus.
	// Don't scroll the whole tab container into view when the button is focused.
	scrollOnFocus: false,

	postCreate: function(){
		if(this.closeButton){
			dojo.addClass(this.innerDiv, "dijitClosable");
			var _nlsResources = dojo.i18n.getLocalization("dijit", "common");
			if(this.closeNode){
				dojo.attr(this.closeNode,"title", _nlsResources.itemClose);
				// IE needs title set directly on image
				dojo.attr(this.closeIcon,"title", _nlsResources.itemClose);
			}
		}else{
			this.closeNode.style.display="none";		
		}
		this.inherited(arguments); 
		dojo.setSelectable(this.containerNode, false);
	},

	_onCloseButtonEnter: function(){
		// summary:
		//		Handler when mouse is moved over the close icon (the X)
		dojo.addClass(this.closeNode, "closeButton-hover");
	},

	_onCloseButtonLeave: function(){
		// summary:
		//		Handler when mouse is moved off the close icon (the X)
		dojo.removeClass(this.closeNode, "closeButton-hover");
	}
});

}

if(!dojo._hasResource["dijit.layout.TabContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout.TabContainer"] = true;
dojo.provide("dijit.layout.TabContainer");





dojo.declare("dijit.layout.TabContainer",
	[dijit.layout.StackContainer, dijit._Templated],
	{	
	// summary: 
	//		A Container with tabs to select each child (only one of which is displayed at a time).
	// description:
	//		A TabContainer is a container that has multiple panes, but shows only
	//		one pane at a time.  There are a set of tabs corresponding to each pane,
	//		where each tab has the title (aka title) of the pane, and optionally a close button.
	//
	//		Publishes topics [widgetId]-addChild, [widgetId]-removeChild, and [widgetId]-selectChild
	//		(where [widgetId] is the id of the TabContainer itself.

	// tabPosition: String
	//		Defines where tabs go relative to tab content.
	//		"top", "bottom", "left-h", "right-h"
	tabPosition: "top",

	baseClass: "dijitTabContainer",
	
	// tabStrip: Boolean
	//		Defines whether the tablist gets an extra class for layouting, putting a border/shading
	//		around the set of tabs.
	tabStrip: false,

	// nested: Boolean
	//		If true, use styling for a TabContainer nested inside another TabContainer.
	//		For tundra etc., makes tabs look like links, and hides the outer
	//		border since the outer TabContainer already has a border.
	nested: false,

	templateString: null,	// override setting in StackContainer
	templateString:"<div class=\"dijitTabContainer\">\n\t<div dojoAttachPoint=\"tablistNode\"></div>\n\t<div dojoAttachPoint=\"tablistSpacer\" class=\"dijitTabSpacer ${baseClass}-spacer\"></div>\n\t<div class=\"dijitTabPaneWrapper ${baseClass}-container\" dojoAttachPoint=\"containerNode\"></div>\n</div>\n",

	// _controllerWidget: String
	//		An optional parameter to overrider the default TabContainer controller used.
	_controllerWidget: "dijit.layout.TabController",

	postMixInProperties: function(){
		// set class name according to tab position, ex: dijiTabContainerTop
		this.baseClass += this.tabPosition.charAt(0).toUpperCase() + this.tabPosition.substr(1).replace(/-.*/, "");
		this.inherited(arguments);
	},

	postCreate: function(){
		this.inherited(arguments);

		// create the tab list that will have a tab (a.k.a. tab button) for each tab panel
		var TabController = dojo.getObject(this._controllerWidget);
		this.tablist = new TabController({
			id: this.id + "_tablist",
			tabPosition: this.tabPosition,
			doLayout: this.doLayout,
			containerId: this.id,
			"class": this.baseClass + "-tabs" + (this.doLayout ? "" : " dijitTabNoLayout")
		}, this.tablistNode);
		
		// add Class for tabstrip
		if (this.tabStrip){	dojo.addClass(this.tablist.domNode, this.baseClass+"Strip"); }		
		
		if(!this.doLayout){ dojo.addClass(this.domNode, "dijitTabContainerNoLayout"); }
		
		if(this.nested){
			/* workaround IE's lack of support for "a > b" selectors by
			 * tagging each node in the template.
			 */
			dojo.addClass(this.domNode, "dijitTabContainerNested");
			dojo.addClass(this.tablist.domNode, "dijitTabContainerTabListNested");
			dojo.addClass(this.tablistSpacer, "dijitTabContainerSpacerNested");
			dojo.addClass(this.containerNode, "dijitTabPaneWrapperNested");
		}
	},

	_setupChild: function(/* Widget */tab){
		// Overrides StackContainer._setupChild().
		dojo.addClass(tab.domNode, "dijitTabPane");
		this.inherited(arguments);
		return tab; // Widget		(TODO: remove this, return code is unused)
	},

	startup: function(){
		if(this._started){ return; }

		// wire up the tablist and its tabs
		this.tablist.startup();
		this.inherited(arguments);
	},

	layout: function(){
		// Overrides StackContainer.layout().
		// Configure the content pane to take up all the space except for where the tabs are
		if(!this.doLayout){ return; }

		// position and size the titles and the container node
		var titleAlign = this.tabPosition.replace(/-h/,"");
		var children = [
			{ domNode: this.tablist.domNode, layoutAlign: titleAlign },
			{ domNode: this.tablistSpacer, layoutAlign: titleAlign },
			{ domNode: this.containerNode, layoutAlign: "client" }
		];
		dijit.layout.layoutChildren(this.domNode, this._contentBox, children);

		// Compute size to make each of my children.
		// children[2] is the margin-box size of this.containerNode, set by layoutChildren() call above
		this._containerContentBox = dijit.layout.marginBox2contentBox(this.containerNode, children[2]);

		if(this.selectedChildWidget){
			this._showChild(this.selectedChildWidget);
			if(this.doLayout && this.selectedChildWidget.resize){
				this.selectedChildWidget.resize(this._containerContentBox);
			}
		}
	},

	destroy: function(){
		if(this.tablist){
			this.tablist.destroy();
		}
		this.inherited(arguments);
	}
});


}

if(!dojo._hasResource["dijit.layout.BorderContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout.BorderContainer"] = true;
dojo.provide("dijit.layout.BorderContainer");




dojo.declare(
	"dijit.layout.BorderContainer",
	dijit.layout._LayoutWidget,
{
	// summary:
	//		Provides layout in up to 5 regions, a mandatory center with optional borders along its 4 sides.
	//
	// description:
	//		A BorderContainer is a box with a specified size, such as style="width: 500px; height: 500px;",
	//		that contains a child widget marked region="center" and optionally children widgets marked
	//		region equal to "top", "bottom", "leading", "trailing", "left" or "right".
	//		Children along the edges will be laid out according to width or height dimensions and may
	//		include optional splitters (splitter="true") to make them resizable by the user.  The remaining
	//		space is designated for the center region.
	//
	//		NOTE: Splitters must not be more than 50 pixels in width.
	//
	//		The outer size must be specified on the BorderContainer node.  Width must be specified for the sides
	//		and height for the top and bottom, respectively.  No dimensions should be specified on the center;
	//		it will fill the remaining space.  Regions named "leading" and "trailing" may be used just like
	//		"left" and "right" except that they will be reversed in right-to-left environments.
	//
	// example:
	// |	<div dojoType="dijit.layout.BorderContainer" design="sidebar" gutters="false"
	// |            style="width: 400px; height: 300px;">
	// |		<div dojoType="ContentPane" region="top">header text</div>
	// |		<div dojoType="ContentPane" region="right" splitter="true" style="width: 200px;">table of contents</div>
	// |		<div dojoType="ContentPane" region="center">client area</div>
	// |	</div>

	// design: String
	//		Which design is used for the layout:
	//			- "headline" (default) where the top and bottom extend
	//				the full width of the container
	//			- "sidebar" where the left and right sides extend from top to bottom.
	design: "headline",

	// gutters: Boolean
	//		Give each pane a border and margin.
	//		Margin determined by domNode.paddingLeft.
	//		When false, only resizable panes have a gutter (i.e. draggable splitter) for resizing.
	gutters: true,

	// liveSplitters: Boolean
	//		Specifies whether splitters resize as you drag (true) or only upon mouseup (false)
	liveSplitters: true,

	// persist: Boolean
	//		Save splitter positions in a cookie.
	persist: false,

	baseClass: "dijitBorderContainer",

	// _splitterClass: String
	// 		Optional hook to override the default Splitter widget used by BorderContainer
	_splitterClass: "dijit.layout._Splitter",

	postMixInProperties: function(){
		// change class name to indicate that BorderContainer is being used purely for
		// layout (like LayoutContainer) rather than for pretty formatting.
		if(!this.gutters){
			this.baseClass += "NoGutter";
		}
		this.inherited(arguments);
	},

	postCreate: function(){
		this.inherited(arguments);

		this._splitters = {};
		this._splitterThickness = {};
	},

	startup: function(){
		if(this._started){ return; }
		dojo.forEach(this.getChildren(), this._setupChild, this);
		this.inherited(arguments);
	},

	_setupChild: function(/*Widget*/child){
		// Override _LayoutWidget._setupChild().

		var region = child.region;
		if(region){
			this.inherited(arguments);

			dojo.addClass(child.domNode, this.baseClass+"Pane");

			var ltr = this.isLeftToRight();
			if(region == "leading"){ region = ltr ? "left" : "right"; }
			if(region == "trailing"){ region = ltr ? "right" : "left"; }

			//FIXME: redundant?
			this["_"+region] = child.domNode;
			this["_"+region+"Widget"] = child;

			// Create draggable splitter for resizing pane,
			// or alternately if splitter=false but BorderContainer.gutters=true then
			// insert dummy div just for spacing
			if((child.splitter || this.gutters) && !this._splitters[region]){
				var _Splitter = dojo.getObject(child.splitter ? this._splitterClass : "dijit.layout._Gutter");
				var flip = {left:'right', right:'left', top:'bottom', bottom:'top', leading:'trailing', trailing:'leading'};
				var splitter = new _Splitter({
					container: this,
					child: child,
					region: region,
//					oppNode: dojo.query('[region=' + flip[child.region] + ']', this.domNode)[0],
					oppNode: this["_" + flip[child.region]],
					live: this.liveSplitters
				});
				splitter.isSplitter = true;
				this._splitters[region] = splitter.domNode;
				dojo.place(this._splitters[region], child.domNode, "after");

				// Splitters arent added as Contained children, so we need to call startup explicitly
				splitter.startup();
			}
			child.region = region;
		}
	},

	_computeSplitterThickness: function(region){
		this._splitterThickness[region] = this._splitterThickness[region] ||
			dojo.marginBox(this._splitters[region])[(/top|bottom/.test(region) ? 'h' : 'w')];
	},

	layout: function(){
		// Implement _LayoutWidget.layout() virtual method.
		for(var region in this._splitters){ this._computeSplitterThickness(region); }
		this._layoutChildren();
	},

	addChild: function(/*Widget*/ child, /*Integer?*/ insertIndex){
		// Override _LayoutWidget.addChild().
		this.inherited(arguments);
		if(this._started){
			this._layoutChildren(); //OPT
		}
	},

	removeChild: function(/*Widget*/ child){
		// Override _LayoutWidget.removeChild().
		var region = child.region;
		var splitter = this._splitters[region];
		if(splitter){
			dijit.byNode(splitter).destroy();
			delete this._splitters[region];
			delete this._splitterThickness[region];
		}
		this.inherited(arguments);
		delete this["_"+region];
		delete this["_" +region+"Widget"];
		if(this._started){
			this._layoutChildren(child.region);
		}
		dojo.removeClass(child.domNode, this.baseClass+"Pane");
	},

	getChildren: function(){
		// Override _LayoutWidget.getChildren() to only return real children, not the splitters.
		return dojo.filter(this.inherited(arguments), function(widget){
			return !widget.isSplitter;
		});
	},

	getSplitter: function(/*String*/region){
		// summary:
		//		Returns the widget responsible for rendering the splitter associated with region 
		var splitter = this._splitters[region];
		return splitter ? dijit.byNode(splitter) : null;
	},

	resize: function(newSize, currentSize){
		// Overrides _LayoutWidget.resize().

		// resetting potential padding to 0px to provide support for 100% width/height + padding
		// TODO: this hack doesn't respect the box model and is a temporary fix
		if (!this.cs || !this.pe){
			var node = this.domNode;
			this.cs = dojo.getComputedStyle(node);
			this.pe = dojo._getPadExtents(node, this.cs);
			this.pe.r = dojo._toPixelValue(node, this.cs.paddingRight);
			this.pe.b = dojo._toPixelValue(node, this.cs.paddingBottom);

			dojo.style(node, "padding", "0px");
		}

		this.inherited(arguments);
	},

	_layoutChildren: function(/*String?*/changedRegion){
		// summary:
		//		This is the main routine for setting size/position of each child

		if(!this._borderBox || !this._borderBox.h){
			// We are currently hidden, or we haven't been sized by our parent yet.
			// Abort.   Someone will resize us later.
			return;
		}

		var sidebarLayout = (this.design == "sidebar");
		var topHeight = 0, bottomHeight = 0, leftWidth = 0, rightWidth = 0;
		var topStyle = {}, leftStyle = {}, rightStyle = {}, bottomStyle = {},
			centerStyle = (this._center && this._center.style) || {};

		var changedSide = /left|right/.test(changedRegion);

		var layoutSides = !changedRegion || (!changedSide && !sidebarLayout);
		var layoutTopBottom = !changedRegion || (changedSide && sidebarLayout);

		// Ask browser for width/height of side panes.
		// Would be nice to cache this but height can change according to width
		// (because words wrap around).  I don't think width will ever change though
		// (except when the user drags a splitter). 
		if(this._top){
			topStyle = layoutTopBottom && this._top.style;
			topHeight = dojo.marginBox(this._top).h;
		}
		if(this._left){
			leftStyle = layoutSides && this._left.style;
			leftWidth = dojo.marginBox(this._left).w;
		}
		if(this._right){
			rightStyle = layoutSides && this._right.style;
			rightWidth = dojo.marginBox(this._right).w;
		}
		if(this._bottom){
			bottomStyle = layoutTopBottom && this._bottom.style;
			bottomHeight = dojo.marginBox(this._bottom).h;
		}

		var splitters = this._splitters;
		var topSplitter = splitters.top, bottomSplitter = splitters.bottom,
			leftSplitter = splitters.left, rightSplitter = splitters.right;
		var splitterThickness = this._splitterThickness;
		var topSplitterThickness = splitterThickness.top || 0,
			leftSplitterThickness = splitterThickness.left || 0,
			rightSplitterThickness = splitterThickness.right || 0,
			bottomSplitterThickness = splitterThickness.bottom || 0;

		// Check for race condition where CSS hasn't finished loading, so
		// the splitter width == the viewport width (#5824)
		if(leftSplitterThickness > 50 || rightSplitterThickness > 50){
			setTimeout(dojo.hitch(this, function(){
				// Results are invalid.  Clear them out.
				this._splitterThickness = {};

				for(var region in this._splitters){
					this._computeSplitterThickness(region);
				}
				this._layoutChildren();
			}), 50);
			return false;
		}

		var pe = this.pe;

		var splitterBounds = {
			left: (sidebarLayout ? leftWidth + leftSplitterThickness: 0) + pe.l + "px",
			right: (sidebarLayout ? rightWidth + rightSplitterThickness: 0) + pe.r + "px"
		};

		if(topSplitter){
			dojo.mixin(topSplitter.style, splitterBounds);
			topSplitter.style.top = topHeight + pe.t + "px";
		}

		if(bottomSplitter){
			dojo.mixin(bottomSplitter.style, splitterBounds);
			bottomSplitter.style.bottom = bottomHeight + pe.b + "px";
		}

		splitterBounds = {
			top: (sidebarLayout ? 0 : topHeight + topSplitterThickness) + pe.t + "px",
			bottom: (sidebarLayout ? 0 : bottomHeight + bottomSplitterThickness) + pe.b + "px"
		};

		if(leftSplitter){
			dojo.mixin(leftSplitter.style, splitterBounds);
			leftSplitter.style.left = leftWidth + pe.l + "px";
		}

		if(rightSplitter){
			dojo.mixin(rightSplitter.style, splitterBounds);
			rightSplitter.style.right = rightWidth + pe.r +  "px";
		}

		dojo.mixin(centerStyle, {
			top: pe.t + topHeight + topSplitterThickness + "px",
			left: pe.l + leftWidth + leftSplitterThickness + "px",
			right: pe.r + rightWidth + rightSplitterThickness + "px",
			bottom: pe.b + bottomHeight + bottomSplitterThickness + "px"
		});

		var bounds = {
			top: sidebarLayout ? pe.t + "px" : centerStyle.top,
			bottom: sidebarLayout ? pe.b + "px" : centerStyle.bottom
		};
		dojo.mixin(leftStyle, bounds);
		dojo.mixin(rightStyle, bounds);
		leftStyle.left = pe.l + "px"; rightStyle.right = pe.r + "px"; topStyle.top = pe.t + "px"; bottomStyle.bottom = pe.b + "px";
		if(sidebarLayout){
			topStyle.left = bottomStyle.left = leftWidth + leftSplitterThickness + pe.l + "px";
			topStyle.right = bottomStyle.right = rightWidth + rightSplitterThickness + pe.r + "px";
		}else{
			topStyle.left = bottomStyle.left = pe.l + "px";
			topStyle.right = bottomStyle.right = pe.r + "px";
		}

		// More calculations about sizes of panes
		var containerHeight = this._borderBox.h - pe.t - pe.b,
			middleHeight = containerHeight - ( topHeight + topSplitterThickness + bottomHeight + bottomSplitterThickness),
			sidebarHeight = sidebarLayout ? containerHeight : middleHeight;

		var containerWidth = this._borderBox.w - pe.l - pe.r,
			middleWidth = containerWidth - (leftWidth  + leftSplitterThickness + rightWidth + rightSplitterThickness),
			sidebarWidth = sidebarLayout ? middleWidth : containerWidth;

		// New margin-box size of each pane
		var dim = {
			top:	{ w: sidebarWidth, h: topHeight },
			bottom: { w: sidebarWidth, h: bottomHeight },
			left:	{ w: leftWidth, h: sidebarHeight },
			right:	{ w: rightWidth, h: sidebarHeight },
			center:	{ h: middleHeight, w: middleWidth }
		};

		// Nodes in IE<8 don't respond to t/l/b/r, and TEXTAREA doesn't respond in any browser
		var janky = dojo.isIE < 8 || (dojo.isIE && dojo.isQuirks) || dojo.some(this.getChildren(), function(child){
			return child.domNode.tagName == "TEXTAREA" || child.domNode.tagName == "INPUT";
		});
		if(janky){
			// Set the size of the children the old fashioned way, by setting
			// CSS width and height

			var resizeWidget = function(widget, changes, result){
				if(widget){
					(widget.resize ? widget.resize(changes, result) : dojo.marginBox(widget.domNode, changes));
				}
			};

			if(leftSplitter){ leftSplitter.style.height = sidebarHeight; }
			if(rightSplitter){ rightSplitter.style.height = sidebarHeight; }
			resizeWidget(this._leftWidget, {h: sidebarHeight}, dim.left);
			resizeWidget(this._rightWidget, {h: sidebarHeight}, dim.right);

			if(topSplitter){ topSplitter.style.width = sidebarWidth; }
			if(bottomSplitter){ bottomSplitter.style.width = sidebarWidth; }
			resizeWidget(this._topWidget, {w: sidebarWidth}, dim.top);
			resizeWidget(this._bottomWidget, {w: sidebarWidth}, dim.bottom);

			resizeWidget(this._centerWidget, dim.center);
		}else{
			// We've already sized the children by setting style.top/bottom/left/right...
			// Now just need to call resize() on those children telling them their new size,
			// so they can re-layout themselves

			// Calculate which panes need a notification
			var resizeList = {};
			if(changedRegion){
				resizeList[changedRegion] = resizeList.center = true;
				if(/top|bottom/.test(changedRegion) && this.design != "sidebar"){
					resizeList.left = resizeList.right = true;
				}else if(/left|right/.test(changedRegion) && this.design == "sidebar"){
					resizeList.top = resizeList.bottom = true;
				}
			}

			dojo.forEach(this.getChildren(), function(child){
				if(child.resize && (!changedRegion || child.region in resizeList)){
					child.resize(null, dim[child.region]);
				}
			}, this);
		}
	},

	destroy: function(){
		for(var region in this._splitters){
			var splitter = this._splitters[region];
			dijit.byNode(splitter).destroy();
			dojo.destroy(splitter);
		}
		delete this._splitters;
		delete this._splitterThickness;
		this.inherited(arguments);
	}
});

// This argument can be specified for the children of a BorderContainer.
// Since any widget can be specified as a LayoutContainer child, mix it
// into the base widget class.  (This is a hack, but it's effective.)
dojo.extend(dijit._Widget, {
	// region: String
	//		"top", "bottom", "leading", "trailing", "left", "right", "center".
	//		See the BorderContainer description for details on this parameter.
	region: '',

	// splitter: Boolean
	//		If true, puts a draggable splitter on this widget to resize when used
	//		inside a border container edge region.
	splitter: false,

	// minSize: Number
	//		Specifies a minimum size for this widget when resized by a splitter
	minSize: 0,

	// maxSize: Number
	//		Specifies a maximum size for this widget when resized by a splitter
	maxSize: Infinity
});



dojo.declare("dijit.layout._Splitter", [ dijit._Widget, dijit._Templated ],
{
	// summary:
	//		A draggable spacer between two items in a `dijit.layout.BorderContainer`.
	// description:
	//		This is instantiated by `dijit.layout.BorderContainer`.  Users should not
	//		create it directly.
	// tags:
	//		private

/*=====
 	// container: [const] dijit.layout.BorderContainer
 	//		Pointer to the parent BorderContainer
	container: null,

	// child: [const] dijit.layout._LayoutWidget
	//		Pointer to the pane associated with this splitter
	child: null,

	// region: String
	//		Region of pane associated with this splitter.
	//		"top", "bottom", "left", "right".
	region: null,
=====*/

	// live: [const] Boolean
	//		If true, the child's size changes and the child widget is redrawn as you drag the splitter;
	//		otherwise, the size doesn't change until you drop the splitter (by mouse-up)
	live: true,

	templateString: '<div class="dijitSplitter" dojoAttachEvent="onkeypress:_onKeyPress,onmousedown:_startDrag" tabIndex="0" waiRole="separator"><div class="dijitSplitterThumb"></div></div>',

	postCreate: function(){
		this.inherited(arguments);
		this.horizontal = /top|bottom/.test(this.region);
		dojo.addClass(this.domNode, "dijitSplitter" + (this.horizontal ? "H" : "V"));
//		dojo.addClass(this.child.domNode, "dijitSplitterPane");
//		dojo.setSelectable(this.domNode, false); //TODO is this necessary?

		this._factor = /top|left/.test(this.region) ? 1 : -1;
		this._minSize = this.child.minSize;

		// trigger constraints calculations
		this.child.domNode._recalc = true;
		this.connect(this.container, "resize", function(){ this.child.domNode._recalc = true; });

		this._cookieName = this.container.id + "_" + this.region;
		if(this.container.persist){
			// restore old size
			var persistSize = dojo.cookie(this._cookieName);
			if(persistSize){
				this.child.domNode.style[this.horizontal ? "height" : "width"] = persistSize;
			}
		}
	},

	_computeMaxSize: function(){
		var dim = this.horizontal ? 'h' : 'w',
			thickness = this.container._splitterThickness[this.region];
		var available = dojo.contentBox(this.container.domNode)[dim] -
			(this.oppNode ? dojo.marginBox(this.oppNode)[dim] : 0) -
			20 - thickness * 2;
		this._maxSize = Math.min(this.child.maxSize, available);
	},

	_startDrag: function(e){
		if(this.child.domNode._recalc){
			this._computeMaxSize();
			this.child.domNode._recalc = false;
		}

		if(!this.cover){
			this.cover = dojo.doc.createElement('div');
			dojo.addClass(this.cover, "dijitSplitterCover");
			dojo.place(this.cover, this.child.domNode, "after");
		}
		dojo.addClass(this.cover, "dijitSplitterCoverActive");

		// Safeguard in case the stop event was missed.  Shouldn't be necessary if we always get the mouse up.
		if(this.fake){ dojo.destroy(this.fake); }
		if(!(this._resize = this.live)){ //TODO: disable live for IE6?
			// create fake splitter to display at old position while we drag
			(this.fake = this.domNode.cloneNode(true)).removeAttribute("id");
			dojo.addClass(this.domNode, "dijitSplitterShadow");
			dojo.place(this.fake, this.domNode, "after");
		}
		dojo.addClass(this.domNode, "dijitSplitterActive");

		//Performance: load data info local vars for onmousevent function closure
		var factor = this._factor,
			max = this._maxSize,
			min = this._minSize || 20,
			isHorizontal = this.horizontal,
			axis = isHorizontal ? "pageY" : "pageX",
			pageStart = e[axis],
			splitterStyle = this.domNode.style,
			dim = isHorizontal ? 'h' : 'w',
			childStart = dojo.marginBox(this.child.domNode)[dim],
			region = this.region,
			splitterStart = parseInt(this.domNode.style[region], 10),
			resize = this._resize,
			mb = {},
			childNode = this.child.domNode,
			layoutFunc = dojo.hitch(this.container, this.container._layoutChildren),
			de = dojo.doc.body;

		this._handlers = (this._handlers || []).concat([
			dojo.connect(de, "onmousemove", this._drag = function(e, forceResize){
				var delta = e[axis] - pageStart,
					childSize = factor * delta + childStart,
					boundChildSize = Math.max(Math.min(childSize, max), min);

				if(resize || forceResize){
					mb[dim] = boundChildSize;
					// TODO: inefficient; we set the marginBox here and then immediately layoutFunc() needs to query it
					dojo.marginBox(childNode, mb);
					layoutFunc(region);
				}
				splitterStyle[region] = factor * delta + splitterStart + (boundChildSize - childSize) + "px";
			}),
			dojo.connect(dojo.doc, "ondragstart",   dojo.stopEvent),
			dojo.connect(dojo.body(), "onselectstart", dojo.stopEvent),
			dojo.connect(de, "onmouseup", this, "_stopDrag")
		]);
		dojo.stopEvent(e);
	},

	_stopDrag: function(e){
		try{
			if(this.cover){
				dojo.removeClass(this.cover, "dijitSplitterCoverActive");
			}
			if(this.fake){ dojo.destroy(this.fake); }
			dojo.removeClass(this.domNode, "dijitSplitterActive");
			dojo.removeClass(this.domNode, "dijitSplitterShadow");
			this._drag(e); //TODO: redundant with onmousemove?
			this._drag(e, true);
		}finally{
			this._cleanupHandlers();
			if(this.oppNode){ this.oppNode._recalc = true; }
			delete this._drag;
		}

		if(this.container.persist){
			dojo.cookie(this._cookieName, this.child.domNode.style[this.horizontal ? "height" : "width"], {expires:365});
		}
	},

	_cleanupHandlers: function(){
		dojo.forEach(this._handlers, dojo.disconnect);
		delete this._handlers;
	},

	_onKeyPress: function(/*Event*/ e){
		if(this.child.domNode._recalc){
			this._computeMaxSize();
			this.child.domNode._recalc = false;
		}

		// should we apply typematic to this?
		this._resize = true;
		var horizontal = this.horizontal;
		var tick = 1;
		var dk = dojo.keys;
		switch(e.charOrCode){
			case horizontal ? dk.UP_ARROW : dk.LEFT_ARROW:
				tick *= -1;
//				break;
			case horizontal ? dk.DOWN_ARROW : dk.RIGHT_ARROW:
				break;
			default:
//				this.inherited(arguments);
				return;
		}
		var childSize = dojo.marginBox(this.child.domNode)[ horizontal ? 'h' : 'w' ] + this._factor * tick;
		var mb = {};
		mb[ this.horizontal ? "h" : "w"] = Math.max(Math.min(childSize, this._maxSize), this._minSize);
		dojo.marginBox(this.child.domNode, mb);
		if(this.oppNode){ this.oppNode._recalc = true; }
		this.container._layoutChildren(this.region);
		dojo.stopEvent(e);
	},

	destroy: function(){
		this._cleanupHandlers();
		delete this.child;
		delete this.container;
		delete this.cover;
		delete this.fake;
		this.inherited(arguments);
	}
});

dojo.declare("dijit.layout._Gutter", [dijit._Widget, dijit._Templated ],
{
	// summary:
	// 		Just a spacer div to separate side pane from center pane.
	//		Basically a trick to lookup the gutter/splitter width from the theme.
	// description:
	//		Instantiated by `dijit.layout.BorderContainer`.  Users should not
	//		create directly.
	// tags:
	//		private

	templateString: '<div class="dijitGutter" waiRole="presentation"></div>',

	postCreate: function(){
		this.horizontal = /top|bottom/.test(this.region);
		dojo.addClass(this.domNode, "dijitGutter" + (this.horizontal ? "H" : "V"));
	}
});

}

if(!dojo._hasResource["dijit.layout.SplitContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout.SplitContainer"] = true;
dojo.provide("dijit.layout.SplitContainer");

//
// FIXME: make it prettier
// FIXME: active dragging upwards doesn't always shift other bars (direction calculation is wrong in this case)
//




dojo.declare("dijit.layout.SplitContainer",
	dijit.layout._LayoutWidget,
	{
	// summary: 
	//		Deprecated.  Use `dijit.layout.BorderContainer` instead.
	// description:
	//		A Container widget with sizing handles in-between each child.
	//		Contains multiple children widgets, all of which are displayed side by side
	//		(either horizontally or vertically); there's a bar between each of the children,
	//		and you can adjust the relative size of each child by dragging the bars.
	//
	//		You must specify a size (width and height) for the SplitContainer.
	// tags:
	//		deprecated

	constructor: function(){
		dojo.deprecated("dijit.layout.SplitContainer is deprecated", "use BorderContainer with splitter instead", 2.0);
	},

	// activeSizing: Boolean
	//		If true, the children's size changes as you drag the bar;
	//		otherwise, the sizes don't change until you drop the bar (by mouse-up)
	activeSizing: false,

	// sizerWidth: Integer
	//		Size in pixels of the bar between each child
	sizerWidth: 7, // FIXME: this should be a CSS attribute (at 7 because css wants it to be 7 until we fix to css)

	// orientation: String
	//		either 'horizontal' or vertical; indicates whether the children are
	//		arranged side-by-side or up/down.
	orientation: 'horizontal',

	// persist: Boolean
	//		Save splitter positions in a cookie
	persist: true,

	baseClass: "dijitSplitContainer",

	postMixInProperties: function(){
		this.inherited("postMixInProperties",arguments);
		this.isHorizontal = (this.orientation == 'horizontal');
	},

	postCreate: function(){
		this.inherited(arguments);
		this.sizers = [];

		// overflow has to be explicitly hidden for splitContainers using gekko (trac #1435)
		// to keep other combined css classes from inadvertantly making the overflow visible
		if(dojo.isMozilla){
			this.domNode.style.overflow = '-moz-scrollbars-none'; // hidden doesn't work
		}

		// create the fake dragger
		if(typeof this.sizerWidth == "object"){
			try{ //FIXME: do this without a try/catch
				this.sizerWidth = parseInt(this.sizerWidth.toString());
			}catch(e){ this.sizerWidth = 7; }
		}
		var sizer = dojo.doc.createElement('div');
		this.virtualSizer = sizer;
		sizer.style.position = 'relative';

		// #1681: work around the dreaded 'quirky percentages in IE' layout bug
		// If the splitcontainer's dimensions are specified in percentages, it
		// will be resized when the virtualsizer is displayed in _showSizingLine
		// (typically expanding its bounds unnecessarily). This happens because
		// we use position: relative for .dijitSplitContainer.
		// The workaround: instead of changing the display style attribute,
		// switch to changing the zIndex (bring to front/move to back)

		sizer.style.zIndex = 10;
		sizer.className = this.isHorizontal ? 'dijitSplitContainerVirtualSizerH' : 'dijitSplitContainerVirtualSizerV';
		this.domNode.appendChild(sizer);
		dojo.setSelectable(sizer, false);
	},

	destroy: function(){
		delete this.virtualSizer;
		dojo.forEach(this._ownconnects, dojo.disconnect);
		this.inherited(arguments);
	},
	startup: function(){
		if(this._started){ return; }

		dojo.forEach(this.getChildren(), function(child, i, children){
			// attach the children and create the draggers
			this._setupChild(child);

			if(i < children.length-1){
				this._addSizer();
			}
		}, this);

		if(this.persist){
			this._restoreState();
		}

		this.inherited(arguments); 
	},

	_setupChild: function(/*Widget*/ child){
		this.inherited(arguments);
		child.domNode.style.position = "absolute";
		dojo.addClass(child.domNode, "dijitSplitPane");
	},

	_onSizerMouseDown: function(e){
		if(e.target.id){
			for(var i=0;i<this.sizers.length;i++){
				if(this.sizers[i].id==e.target.id){
					break;
				}
			}
			if(i<this.sizers.length){
				this.beginSizing(e,i);
			}
		}
	},
	_addSizer: function(index){
		index = index===undefined?this.sizers.length:index;

		// TODO: use a template for this!!!
		var sizer = dojo.doc.createElement('div');
		sizer.id=dijit.getUniqueId('dijit_layout_SplitterContainer_Splitter');
		this.sizers.splice(index,0,sizer);
		this.domNode.appendChild(sizer);

		sizer.className = this.isHorizontal ? 'dijitSplitContainerSizerH' : 'dijitSplitContainerSizerV';

		// add the thumb div
		var thumb = dojo.doc.createElement('div');
		thumb.className = 'thumb';
		thumb.id = sizer.id;
		sizer.appendChild(thumb);

		// FIXME: are you serious? why aren't we using mover start/stop combo?
		this.connect(sizer, "onmousedown", '_onSizerMouseDown');
		
		dojo.setSelectable(sizer, false);
	},

	removeChild: function(widget){
		// summary: Remove sizer, but only if widget is really our child and
		// we have at least one sizer to throw away
		if(this.sizers.length){
			var i=dojo.indexOf(this.getChildren(), widget)
			if(i != -1){
				if(i==this.sizers.length){
					i--;
				}
				dojo.destroy(this.sizers[i]);
				this.sizers.splice(i,1);
			}
		}

		// Remove widget and repaint
		this.inherited(arguments); 
		if(this._started){
			this.layout();
		}
	},

	addChild: function(/*Widget*/ child, /*Integer?*/ insertIndex){
		// summary:
		//		Add a child widget to the container
		// child:
		//		a widget to add
		// insertIndex:
		//		postion in the "stack" to add the child widget
		
		this.inherited(arguments); 

		if(this._started){
			// Do the stuff that startup() does for each widget
			var children = this.getChildren();
			if(children.length > 1){
				this._addSizer(insertIndex);
			}

			// and then reposition (ie, shrink) every pane to make room for the new guy
			this.layout();
		}
	},

	layout: function(){
		// summary:
		//		Do layout of panels

		// base class defines this._contentBox on initial creation and also
		// on resize
		this.paneWidth = this._contentBox.w;
		this.paneHeight = this._contentBox.h;

		var children = this.getChildren();
		if(!children.length){ return; }

		//
		// calculate space
		//

		var space = this.isHorizontal ? this.paneWidth : this.paneHeight;
		if(children.length > 1){
			space -= this.sizerWidth * (children.length - 1);
		}

		//
		// calculate total of SizeShare values
		//
		var outOf = 0;
		dojo.forEach(children, function(child){
			outOf += child.sizeShare;
		});

		//
		// work out actual pixels per sizeshare unit
		//
		var pixPerUnit = space / outOf;

		//
		// set the SizeActual member of each pane
		//
		var totalSize = 0;
		dojo.forEach(children.slice(0, children.length - 1), function(child){
			var size = Math.round(pixPerUnit * child.sizeShare);
			child.sizeActual = size;
			totalSize += size;
		});

		children[children.length-1].sizeActual = space - totalSize;

		//
		// make sure the sizes are ok
		//
		this._checkSizes();

		//
		// now loop, positioning each pane and letting children resize themselves
		//

		var pos = 0;
		var size = children[0].sizeActual;
		this._movePanel(children[0], pos, size);
		children[0].position = pos;
		pos += size;

		// if we don't have any sizers, our layout method hasn't been called yet
		// so bail until we are called..TODO: REVISIT: need to change the startup
		// algorithm to guaranteed the ordering of calls to layout method
		if(!this.sizers){
			return;
		}

		dojo.some(children.slice(1), function(child, i){
			// error-checking
			if(!this.sizers[i]){
				return true;
			}
			// first we position the sizing handle before this pane
			this._moveSlider(this.sizers[i], pos, this.sizerWidth);
			this.sizers[i].position = pos;
			pos += this.sizerWidth;

			size = child.sizeActual;
			this._movePanel(child, pos, size);
			child.position = pos;
			pos += size;
		}, this);
	},

	_movePanel: function(panel, pos, size){
		if(this.isHorizontal){
			panel.domNode.style.left = pos + 'px';	// TODO: resize() takes l and t parameters too, don't need to set manually
			panel.domNode.style.top = 0;
			var box = {w: size, h: this.paneHeight};
			if(panel.resize){
				panel.resize(box);
			}else{
				dojo.marginBox(panel.domNode, box);
			}
		}else{
			panel.domNode.style.left = 0;	// TODO: resize() takes l and t parameters too, don't need to set manually
			panel.domNode.style.top = pos + 'px';
			var box = {w: this.paneWidth, h: size};
			if(panel.resize){
				panel.resize(box);
			}else{
				dojo.marginBox(panel.domNode, box);
			}
		}
	},

	_moveSlider: function(slider, pos, size){
		if(this.isHorizontal){
			slider.style.left = pos + 'px';
			slider.style.top = 0;
			dojo.marginBox(slider, { w: size, h: this.paneHeight });
		}else{
			slider.style.left = 0;
			slider.style.top = pos + 'px';
			dojo.marginBox(slider, { w: this.paneWidth, h: size });
		}
	},

	_growPane: function(growth, pane){
		if(growth > 0){
			if(pane.sizeActual > pane.sizeMin){
				if((pane.sizeActual - pane.sizeMin) > growth){

					// stick all the growth in this pane
					pane.sizeActual = pane.sizeActual - growth;
					growth = 0;
				}else{
					// put as much growth in here as we can
					growth -= pane.sizeActual - pane.sizeMin;
					pane.sizeActual = pane.sizeMin;
				}
			}
		}
		return growth;
	},

	_checkSizes: function(){

		var totalMinSize = 0;
		var totalSize = 0;
		var children = this.getChildren();

		dojo.forEach(children, function(child){
			totalSize += child.sizeActual;
			totalMinSize += child.sizeMin;
		});

		// only make adjustments if we have enough space for all the minimums

		if(totalMinSize <= totalSize){

			var growth = 0;

			dojo.forEach(children, function(child){
				if(child.sizeActual < child.sizeMin){
					growth += child.sizeMin - child.sizeActual;
					child.sizeActual = child.sizeMin;
				}
			});

			if(growth > 0){
				var list = this.isDraggingLeft ? children.reverse() : children;
				dojo.forEach(list, function(child){
					growth = this._growPane(growth, child);
				}, this);
			}
		}else{
			dojo.forEach(children, function(child){
				child.sizeActual = Math.round(totalSize * (child.sizeMin / totalMinSize));
			});
		}
	},

	beginSizing: function(e, i){
		var children = this.getChildren();
		this.paneBefore = children[i];
		this.paneAfter = children[i+1];

		this.isSizing = true;
		this.sizingSplitter = this.sizers[i];

		if(!this.cover){
			this.cover = dojo.create('div', {
					style: {
						position:'absolute',
						zIndex:5,
						top: 0,
						left: 0,
						width: "100%",
						height: "100%"
					}
				}, this.domNode);
		}else{
			this.cover.style.zIndex = 5;
		}
		this.sizingSplitter.style.zIndex = 6;

		// TODO: REVISIT - we want MARGIN_BOX and core hasn't exposed that yet (but can't we use it anyway if we pay attention? we do elsewhere.)
		this.originPos = dojo.coords(children[0].domNode, true);
		if(this.isHorizontal){
			var client = e.layerX || e.offsetX || 0;
			var screen = e.pageX;
			this.originPos = this.originPos.x;
		}else{
			var client = e.layerY || e.offsetY || 0;
			var screen = e.pageY;
			this.originPos = this.originPos.y;
		}
		this.startPoint = this.lastPoint = screen;
		this.screenToClientOffset = screen - client;
		this.dragOffset = this.lastPoint - this.paneBefore.sizeActual - this.originPos - this.paneBefore.position;

		if(!this.activeSizing){
			this._showSizingLine();
		}

		//					
		// attach mouse events
		//
		this._ownconnects = [];
		this._ownconnects.push(dojo.connect(dojo.doc.documentElement, "onmousemove", this, "changeSizing"));
		this._ownconnects.push(dojo.connect(dojo.doc.documentElement, "onmouseup", this, "endSizing"));

		dojo.stopEvent(e);
	},

	changeSizing: function(e){
		if(!this.isSizing){ return; }
		this.lastPoint = this.isHorizontal ? e.pageX : e.pageY;
		this.movePoint();
		if(this.activeSizing){
			this._updateSize();
		}else{
			this._moveSizingLine();
		}
		dojo.stopEvent(e);
	},

	endSizing: function(e){
		if(!this.isSizing){ return; }
		if(this.cover){
			this.cover.style.zIndex = -1;
		}
		if(!this.activeSizing){
			this._hideSizingLine();
		}

		this._updateSize();

		this.isSizing = false;

		if(this.persist){
			this._saveState(this);
		}

		dojo.forEach(this._ownconnects,dojo.disconnect); 
	},

	movePoint: function(){

		// make sure lastPoint is a legal point to drag to
		var p = this.lastPoint - this.screenToClientOffset;

		var a = p - this.dragOffset;
		a = this.legaliseSplitPoint(a);
		p = a + this.dragOffset;

		this.lastPoint = p + this.screenToClientOffset;
	},

	legaliseSplitPoint: function(a){

		a += this.sizingSplitter.position;

		this.isDraggingLeft = !!(a > 0);

		if(!this.activeSizing){
			var min = this.paneBefore.position + this.paneBefore.sizeMin;
			if(a < min){
				a = min;
			}

			var max = this.paneAfter.position + (this.paneAfter.sizeActual - (this.sizerWidth + this.paneAfter.sizeMin));
			if(a > max){
				a = max;
			}
		}

		a -= this.sizingSplitter.position;

		this._checkSizes();

		return a;
	},

	_updateSize: function(){
	//FIXME: sometimes this.lastPoint is NaN
		var pos = this.lastPoint - this.dragOffset - this.originPos;

		var start_region = this.paneBefore.position;
		var end_region   = this.paneAfter.position + this.paneAfter.sizeActual;

		this.paneBefore.sizeActual = pos - start_region;
		this.paneAfter.position	= pos + this.sizerWidth;
		this.paneAfter.sizeActual  = end_region - this.paneAfter.position;

		dojo.forEach(this.getChildren(), function(child){
			child.sizeShare = child.sizeActual;
		});

		if(this._started){
			this.layout();
		}
	},

	_showSizingLine: function(){

		this._moveSizingLine();

		dojo.marginBox(this.virtualSizer,
			this.isHorizontal ? { w: this.sizerWidth, h: this.paneHeight } : { w: this.paneWidth, h: this.sizerWidth });

		this.virtualSizer.style.display = 'block';
	},

	_hideSizingLine: function(){
		this.virtualSizer.style.display = 'none';
	},

	_moveSizingLine: function(){
		var pos = (this.lastPoint - this.startPoint) + this.sizingSplitter.position;
		dojo.style(this.virtualSizer,(this.isHorizontal ? "left" : "top"),pos+"px");
		// this.virtualSizer.style[ this.isHorizontal ? "left" : "top" ] = pos + 'px'; // FIXME: remove this line if the previous is better
	},

	_getCookieName: function(i){
		return this.id + "_" + i;
	},

	_restoreState: function(){
		dojo.forEach(this.getChildren(), function(child, i){
			var cookieName = this._getCookieName(i);
			var cookieValue = dojo.cookie(cookieName);
			if(cookieValue){
				var pos = parseInt(cookieValue);
				if(typeof pos == "number"){
					child.sizeShare = pos;
				}
			}
		}, this);
	},

	_saveState: function(){
		if(!this.persist){
			return;
		}
		dojo.forEach(this.getChildren(), function(child, i){
			dojo.cookie(this._getCookieName(i), child.sizeShare, {expires:365});
		}, this);
	}
});

// These arguments can be specified for the children of a SplitContainer.
// Since any widget can be specified as a SplitContainer child, mix them
// into the base widget class.  (This is a hack, but it's effective.)
dojo.extend(dijit._Widget, {
	// sizeMin: Integer
	//		Minimum size (width or height) of a child of a SplitContainer.
	//		The value is relative to other children's sizeShare properties.
	sizeMin: 10,

	// sizeShare: Integer
	//		Size (width or height) of a child of a SplitContainer.
	//		The value is relative to other children's sizeShare properties.
	//		For example, if there are two children and each has sizeShare=10, then
	//		each takes up 50% of the available space.
	sizeShare: 10
});

}

if(!dojo._hasResource["dijit.form.Form"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.Form"] = true;
dojo.provide("dijit.form.Form");





dojo.declare(
	"dijit.form.Form",
	[dijit._Widget, dijit._Templated, dijit.form._FormMixin],
	{
		// summary:
		//		Widget corresponding to HTML form tag, for validation and serialization
		//
		// example:
		//	|	<form dojoType="dijit.form.Form" id="myForm">
		//	|		Name: <input type="text" name="name" />
		//	|	</form>
		//	|	myObj = {name: "John Doe"};
		//	|	dijit.byId('myForm').attr('value', myObj);
		//	|
		//	|	myObj=dijit.byId('myForm').attr('value');

		// HTML <FORM> attributes

		// name: String?
		//		Name of form for scripting.
		name: "",

		// action: String?
		//		Server-side form handler.
		action: "",

		// method: String?
		//		HTTP method used to submit the form, either "GET" or "POST".
		method: "",

		// encType: String?
		//		Encoding type for the form, ex: application/x-www-form-urlencoded.
		encType: "",

		// accept-charset: String?
		//		List of supported charsets.
		"accept-charset": "",

		// accept: String?
		//		List of MIME types for file upload.
		accept: "",

		// target: String?
		//		Target frame for the document to be opened in.
		target: "",

		templateString: "<form dojoAttachPoint='containerNode' dojoAttachEvent='onreset:_onReset,onsubmit:_onSubmit' ${nameAttrSetting}></form>",

		attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
			action: "", 
			method: "", 
			encType: "", 
			"accept-charset": "", 
			accept: "", 
			target: ""
		}),

		postMixInProperties: function(){
			// Setup name=foo string to be referenced from the template (but only if a name has been specified)
			// Unfortunately we can't use attributeMap to set the name due to IE limitations, see #8660
			this.nameAttrSetting = this.name ? ("name='" + this.name + "'") : "";
			this.inherited(arguments);
		},

		execute: function(/*Object*/ formContents){
			// summary:
			//		Deprecated: use submit()
			// tags:
			//		deprecated
		},

		onExecute: function(){
			// summary:
			//		Deprecated: use onSubmit()
			// tags:
			//		deprecated
		},

		_setEncTypeAttr: function(/*String*/ value){
			this.encType = value;
			dojo.attr(this.domNode, "encType", value);
			if(dojo.isIE){ this.domNode.encoding = value; }
		},

		postCreate: function(){
			// IE tries to hide encType
			// TODO: this code should be in parser, not here.
			if(dojo.isIE && this.srcNodeRef && this.srcNodeRef.attributes){
				var item = this.srcNodeRef.attributes.getNamedItem('encType');
				if(item && !item.specified && (typeof item.value == "string")){
					this.attr('encType', item.value);
				}
			}
			this.inherited(arguments);
		},

		onReset: function(/*Event?*/ e){
			// summary:
			//		Callback when user resets the form. This method is intended
			//		to be over-ridden. When the `reset` method is called
			//		programmatically, the return value from `onReset` is used
			//		to compute whether or not resetting should proceed
			// tags:
			//		callback
			return true; // Boolean
		},

		_onReset: function(e){
			// create fake event so we can know if preventDefault() is called
			var faux = {
				returnValue: true, // the IE way
				preventDefault: function(){  // not IE
							this.returnValue = false;
						},
				stopPropagation: function(){}, currentTarget: e.currentTarget, target: e.target
			};
			// if return value is not exactly false, and haven't called preventDefault(), then reset
			if(!(this.onReset(faux) === false) && faux.returnValue){
				this.reset();
			}
			dojo.stopEvent(e);
			return false;
		},

		_onSubmit: function(e){
			var fp = dijit.form.Form.prototype;
			// TODO: remove this if statement beginning with 2.0
			if(this.execute != fp.execute || this.onExecute != fp.onExecute){
				dojo.deprecated("dijit.form.Form:execute()/onExecute() are deprecated. Use onSubmit() instead.", "", "2.0");
				this.onExecute();
				this.execute(this.getValues());
			}
			if(this.onSubmit(e) === false){ // only exactly false stops submit
				dojo.stopEvent(e);
			}
		},
		
		onSubmit: function(/*Event?*/e){ 
			// summary:
			//		Callback when user submits the form.
			// description:
			//		This method is intended to be over-ridden, but by default it checks and
			//		returns the validity of form elements. When the `submit`
			//		method is called programmatically, the return value from
			//		`onSubmit` is used to compute whether or not submission
			//		should proceed
			// tags:
			//		extension

			return this.isValid(); // Boolean
		},

		submit: function(){
			// summary:
			//		programmatically submit form if and only if the `onSubmit` returns true
			if(!(this.onSubmit() === false)){
				this.containerNode.submit();
			}
		}
	}
);

}

if(!dojo._hasResource["dojo.cldr.supplemental"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.cldr.supplemental"] = true;
dojo.provide("dojo.cldr.supplemental");



dojo.cldr.supplemental.getFirstDayOfWeek = function(/*String?*/locale){
// summary: Returns a zero-based index for first day of the week
// description:
//		Returns a zero-based index for first day of the week, as used by the local (Gregorian) calendar.
//		e.g. Sunday (returns 0), or Monday (returns 1)

	// from http://www.unicode.org/cldr/data/common/supplemental/supplementalData.xml:supplementalData/weekData/firstDay
	var firstDay = {/*default is 1=Monday*/
		mv:5,
		ae:6,af:6,bh:6,dj:6,dz:6,eg:6,er:6,et:6,iq:6,ir:6,jo:6,ke:6,kw:6,lb:6,ly:6,ma:6,om:6,qa:6,sa:6,
		sd:6,so:6,tn:6,ye:6,
		as:0,au:0,az:0,bw:0,ca:0,cn:0,fo:0,ge:0,gl:0,gu:0,hk:0,ie:0,il:0,is:0,jm:0,jp:0,kg:0,kr:0,la:0,
		mh:0,mo:0,mp:0,mt:0,nz:0,ph:0,pk:0,sg:0,th:0,tt:0,tw:0,um:0,us:0,uz:0,vi:0,za:0,zw:0,
		et:0,mw:0,ng:0,tj:0,
// variant. do not use?		gb:0,
		sy:4
	};

	var country = dojo.cldr.supplemental._region(locale);
	var dow = firstDay[country];
	return (dow === undefined) ? 1 : dow; /*Number*/
};

dojo.cldr.supplemental._region = function(/*String?*/locale){
	locale = dojo.i18n.normalizeLocale(locale);
	var tags = locale.split('-');
	var region = tags[1];
	if(!region){
		// IE often gives language only (#2269)
		// Arbitrary mappings of language-only locales to a country:
		region = {de:"de", en:"us", es:"es", fi:"fi", fr:"fr", he:"il", hu:"hu", it:"it",
			ja:"jp", ko:"kr", nl:"nl", pt:"br", sv:"se", zh:"cn"}[tags[0]];
	}else if(region.length == 4){
		// The ISO 3166 country code is usually in the second position, unless a
		// 4-letter script is given. See http://www.ietf.org/rfc/rfc4646.txt
		region = tags[2];
	}
	return region;
}

dojo.cldr.supplemental.getWeekend = function(/*String?*/locale){
// summary: Returns a hash containing the start and end days of the weekend
// description:
//		Returns a hash containing the start and end days of the weekend according to local custom using locale,
//		or by default in the user's locale.
//		e.g. {start:6, end:0}

	// from http://www.unicode.org/cldr/data/common/supplemental/supplementalData.xml:supplementalData/weekData/weekend{Start,End}
	var weekendStart = {/*default is 6=Saturday*/
		eg:5,il:5,sy:5,
		'in':0,
		ae:4,bh:4,dz:4,iq:4,jo:4,kw:4,lb:4,ly:4,ma:4,om:4,qa:4,sa:4,sd:4,tn:4,ye:4		
	};

	var weekendEnd = {/*default is 0=Sunday*/
		ae:5,bh:5,dz:5,iq:5,jo:5,kw:5,lb:5,ly:5,ma:5,om:5,qa:5,sa:5,sd:5,tn:5,ye:5,af:5,ir:5,
		eg:6,il:6,sy:6
	};

	var country = dojo.cldr.supplemental._region(locale);
	var start = weekendStart[country];
	var end = weekendEnd[country];
	if(start === undefined){start=6;}
	if(end === undefined){end=0;}
	return {start:start, end:end}; /*Object {start,end}*/
};

}

if(!dojo._hasResource["dojo.date"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.date"] = true;
dojo.provide("dojo.date");

/*=====
dojo.date = {
	// summary: Date manipulation utilities
}
=====*/

dojo.date.getDaysInMonth = function(/*Date*/dateObject){
	//	summary:
	//		Returns the number of days in the month used by dateObject
	var month = dateObject.getMonth();
	var days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
	if(month == 1 && dojo.date.isLeapYear(dateObject)){ return 29; } // Number
	return days[month]; // Number
}

dojo.date.isLeapYear = function(/*Date*/dateObject){
	//	summary:
	//		Determines if the year of the dateObject is a leap year
	//	description:
	//		Leap years are years with an additional day YYYY-02-29, where the
	//		year number is a multiple of four with the following exception: If
	//		a year is a multiple of 100, then it is only a leap year if it is
	//		also a multiple of 400. For example, 1900 was not a leap year, but
	//		2000 is one.

	var year = dateObject.getFullYear();
	return !(year%400) || (!(year%4) && !!(year%100)); // Boolean
}

// FIXME: This is not localized
dojo.date.getTimezoneName = function(/*Date*/dateObject){
	//	summary:
	//		Get the user's time zone as provided by the browser
	// dateObject:
	//		Needed because the timezone may vary with time (daylight savings)
	//	description:
	//		Try to get time zone info from toString or toLocaleString method of
	//		the Date object -- UTC offset is not a time zone.  See
	//		http://www.twinsun.com/tz/tz-link.htm Note: results may be
	//		inconsistent across browsers.

	var str = dateObject.toString(); // Start looking in toString
	var tz = ''; // The result -- return empty string if nothing found
	var match;

	// First look for something in parentheses -- fast lookup, no regex
	var pos = str.indexOf('(');
	if(pos > -1){
		tz = str.substring(++pos, str.indexOf(')'));
	}else{
		// If at first you don't succeed ...
		// If IE knows about the TZ, it appears before the year
		// Capital letters or slash before a 4-digit year 
		// at the end of string
		var pat = /([A-Z\/]+) \d{4}$/;
		if((match = str.match(pat))){
			tz = match[1];
		}else{
		// Some browsers (e.g. Safari) glue the TZ on the end
		// of toLocaleString instead of putting it in toString
			str = dateObject.toLocaleString();
			// Capital letters or slash -- end of string, 
			// after space
			pat = / ([A-Z\/]+)$/;
			if((match = str.match(pat))){
				tz = match[1];
			}
		}
	}

	// Make sure it doesn't somehow end up return AM or PM
	return (tz == 'AM' || tz == 'PM') ? '' : tz; // String
}

// Utility methods to do arithmetic calculations with Dates

dojo.date.compare = function(/*Date*/date1, /*Date?*/date2, /*String?*/portion){
	//	summary:
	//		Compare two date objects by date, time, or both.
	//	description:
	//  	Returns 0 if equal, positive if a > b, else negative.
	//	date1:
	//		Date object
	//	date2:
	//		Date object.  If not specified, the current Date is used.
	//	portion:
	//		A string indicating the "date" or "time" portion of a Date object.
	//		Compares both "date" and "time" by default.  One of the following:
	//		"date", "time", "datetime"

	// Extra step required in copy for IE - see #3112
	date1 = new Date(Number(date1));
	date2 = new Date(Number(date2 || new Date()));

	if(portion !== "undefined"){
		if(portion == "date"){
			// Ignore times and compare dates.
			date1.setHours(0, 0, 0, 0);
			date2.setHours(0, 0, 0, 0);
		}else if(portion == "time"){
			// Ignore dates and compare times.
			date1.setFullYear(0, 0, 0);
			date2.setFullYear(0, 0, 0);
		}
	}
	
	if(date1 > date2){ return 1; } // int
	if(date1 < date2){ return -1; } // int
	return 0; // int
};

dojo.date.add = function(/*Date*/date, /*String*/interval, /*int*/amount){
	//	summary:
	//		Add to a Date in intervals of different size, from milliseconds to years
	//	date: Date
	//		Date object to start with
	//	interval:
	//		A string representing the interval.  One of the following:
	//			"year", "month", "day", "hour", "minute", "second",
	//			"millisecond", "quarter", "week", "weekday"
	//	amount:
	//		How much to add to the date.

	var sum = new Date(Number(date)); // convert to Number before copying to accomodate IE (#3112)
	var fixOvershoot = false;
	var property = "Date";

	switch(interval){
		case "day":
			break;
		case "weekday":
			//i18n FIXME: assumes Saturday/Sunday weekend, but this is not always true.  see dojo.cldr.supplemental

			// Divide the increment time span into weekspans plus leftover days
			// e.g., 8 days is one 5-day weekspan / and two leftover days
			// Can't have zero leftover days, so numbers divisible by 5 get
			// a days value of 5, and the remaining days make up the number of weeks
			var days, weeks;
			var mod = amount % 5;
			if(!mod){
				days = (amount > 0) ? 5 : -5;
				weeks = (amount > 0) ? ((amount-5)/5) : ((amount+5)/5);
			}else{
				days = mod;
				weeks = parseInt(amount/5);
			}
			// Get weekday value for orig date param
			var strt = date.getDay();
			// Orig date is Sat / positive incrementer
			// Jump over Sun
			var adj = 0;
			if(strt == 6 && amount > 0){
				adj = 1;
			}else if(strt == 0 && amount < 0){
			// Orig date is Sun / negative incrementer
			// Jump back over Sat
				adj = -1;
			}
			// Get weekday val for the new date
			var trgt = strt + days;
			// New date is on Sat or Sun
			if(trgt == 0 || trgt == 6){
				adj = (amount > 0) ? 2 : -2;
			}
			// Increment by number of weeks plus leftover days plus
			// weekend adjustments
			amount = (7 * weeks) + days + adj;
			break;
		case "year":
			property = "FullYear";
			// Keep increment/decrement from 2/29 out of March
			fixOvershoot = true;
			break;
		case "week":
			amount *= 7;
			break;
		case "quarter":
			// Naive quarter is just three months
			amount *= 3;
			// fallthrough...
		case "month":
			// Reset to last day of month if you overshoot
			fixOvershoot = true;
			property = "Month";
			break;
		case "hour":
		case "minute":
		case "second":
		case "millisecond":
			property = "UTC"+interval.charAt(0).toUpperCase() + interval.substring(1) + "s";
	}

	if(property){
		sum["set"+property](sum["get"+property]()+amount);
	}

	if(fixOvershoot && (sum.getDate() < date.getDate())){
		sum.setDate(0);
	}

	return sum; // Date
};

dojo.date.difference = function(/*Date*/date1, /*Date?*/date2, /*String?*/interval){
	//	summary:
	//		Get the difference in a specific unit of time (e.g., number of
	//		months, weeks, days, etc.) between two dates, rounded to the
	//		nearest integer.
	//	date1:
	//		Date object
	//	date2:
	//		Date object.  If not specified, the current Date is used.
	//	interval:
	//		A string representing the interval.  One of the following:
	//			"year", "month", "day", "hour", "minute", "second",
	//			"millisecond", "quarter", "week", "weekday"
	//		Defaults to "day".

	date2 = date2 || new Date();
	interval = interval || "day";
	var yearDiff = date2.getFullYear() - date1.getFullYear();
	var delta = 1; // Integer return value

	switch(interval){
		case "quarter":
			var m1 = date1.getMonth();
			var m2 = date2.getMonth();
			// Figure out which quarter the months are in
			var q1 = Math.floor(m1/3) + 1;
			var q2 = Math.floor(m2/3) + 1;
			// Add quarters for any year difference between the dates
			q2 += (yearDiff * 4);
			delta = q2 - q1;
			break;
		case "weekday":
			var days = Math.round(dojo.date.difference(date1, date2, "day"));
			var weeks = parseInt(dojo.date.difference(date1, date2, "week"));
			var mod = days % 7;

			// Even number of weeks
			if(mod == 0){
				days = weeks*5;
			}else{
				// Weeks plus spare change (< 7 days)
				var adj = 0;
				var aDay = date1.getDay();
				var bDay = date2.getDay();

				weeks = parseInt(days/7);
				mod = days % 7;
				// Mark the date advanced by the number of
				// round weeks (may be zero)
				var dtMark = new Date(date1);
				dtMark.setDate(dtMark.getDate()+(weeks*7));
				var dayMark = dtMark.getDay();

				// Spare change days -- 6 or less
				if(days > 0){
					switch(true){
						// Range starts on Sat
						case aDay == 6:
							adj = -1;
							break;
						// Range starts on Sun
						case aDay == 0:
							adj = 0;
							break;
						// Range ends on Sat
						case bDay == 6:
							adj = -1;
							break;
						// Range ends on Sun
						case bDay == 0:
							adj = -2;
							break;
						// Range contains weekend
						case (dayMark + mod) > 5:
							adj = -2;
					}
				}else if(days < 0){
					switch(true){
						// Range starts on Sat
						case aDay == 6:
							adj = 0;
							break;
						// Range starts on Sun
						case aDay == 0:
							adj = 1;
							break;
						// Range ends on Sat
						case bDay == 6:
							adj = 2;
							break;
						// Range ends on Sun
						case bDay == 0:
							adj = 1;
							break;
						// Range contains weekend
						case (dayMark + mod) < 0:
							adj = 2;
					}
				}
				days += adj;
				days -= (weeks*2);
			}
			delta = days;
			break;
		case "year":
			delta = yearDiff;
			break;
		case "month":
			delta = (date2.getMonth() - date1.getMonth()) + (yearDiff * 12);
			break;
		case "week":
			// Truncate instead of rounding
			// Don't use Math.floor -- value may be negative
			delta = parseInt(dojo.date.difference(date1, date2, "day")/7);
			break;
		case "day":
			delta /= 24;
			// fallthrough
		case "hour":
			delta /= 60;
			// fallthrough
		case "minute":
			delta /= 60;
			// fallthrough
		case "second":
			delta /= 1000;
			// fallthrough
		case "millisecond":
			delta *= date2.getTime() - date1.getTime();
	}

	// Round for fractional values and DST leaps
	return Math.round(delta); // Number (integer)
};

}

if(!dojo._hasResource["dojo.date.locale"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.date.locale"] = true;
dojo.provide("dojo.date.locale");

// Localization methods for Date.   Honor local customs using locale-dependent dojo.cldr data.







// Load the bundles containing localization information for
// names and formats


//NOTE: Everything in this module assumes Gregorian calendars.
// Other calendars will be implemented in separate modules.

(function(){
	// Format a pattern without literals
	function formatPattern(dateObject, bundle, fullYear, pattern){
		return pattern.replace(/([a-z])\1*/ig, function(match){
			var s, pad;
			var c = match.charAt(0);
			var l = match.length;
			var widthList = ["abbr", "wide", "narrow"];
			switch(c){
				case 'G':
					s = bundle[(l < 4) ? "eraAbbr" : "eraNames"][dateObject.getFullYear() < 0 ? 0 : 1];
					break;
				case 'y':
					s = dateObject.getFullYear();
					switch(l){
						case 1:
							break;
						case 2:
							if(!fullYear){
								s = String(s); s = s.substr(s.length - 2);
								break;
							}
							// fallthrough
						default:
							pad = true;
					}
					break;
				case 'Q':
				case 'q':
					s = Math.ceil((dateObject.getMonth()+1)/3);
//					switch(l){
//						case 1: case 2:
							pad = true;
//							break;
//						case 3: case 4: // unimplemented
//					}
					break;
				case 'M':
					var m = dateObject.getMonth();
					if(l<3){
						s = m+1; pad = true;
					}else{
						var propM = ["months", "format", widthList[l-3]].join("-");
						s = bundle[propM][m];
					}
					break;
				case 'w':
					var firstDay = 0;
					s = dojo.date.locale._getWeekOfYear(dateObject, firstDay); pad = true;
					break;
				case 'd':
					s = dateObject.getDate(); pad = true;
					break;
				case 'D':
					s = dojo.date.locale._getDayOfYear(dateObject); pad = true;
					break;
				case 'E':
					var d = dateObject.getDay();
					if(l<3){
						s = d+1; pad = true;
					}else{
						var propD = ["days", "format", widthList[l-3]].join("-");
						s = bundle[propD][d];
					}
					break;
				case 'a':
					var timePeriod = (dateObject.getHours() < 12) ? 'am' : 'pm';
					s = bundle[timePeriod];
					break;
				case 'h':
				case 'H':
				case 'K':
				case 'k':
					var h = dateObject.getHours();
					// strange choices in the date format make it impossible to write this succinctly
					switch (c){
						case 'h': // 1-12
							s = (h % 12) || 12;
							break;
						case 'H': // 0-23
							s = h;
							break;
						case 'K': // 0-11
							s = (h % 12);
							break;
						case 'k': // 1-24
							s = h || 24;
							break;
					}
					pad = true;
					break;
				case 'm':
					s = dateObject.getMinutes(); pad = true;
					break;
				case 's':
					s = dateObject.getSeconds(); pad = true;
					break;
				case 'S':
					s = Math.round(dateObject.getMilliseconds() * Math.pow(10, l-3)); pad = true;
					break;
				case 'v': // FIXME: don't know what this is. seems to be same as z?
				case 'z':
					// We only have one timezone to offer; the one from the browser
					s = dojo.date.getTimezoneName(dateObject);
					if(s){break;}
					l=4;
					// fallthrough... use GMT if tz not available
				case 'Z':
					var offset = dateObject.getTimezoneOffset();
					var tz = [
						(offset<=0 ? "+" : "-"),
						dojo.string.pad(Math.floor(Math.abs(offset)/60), 2),
						dojo.string.pad(Math.abs(offset)% 60, 2)
					];
					if(l==4){
						tz.splice(0, 0, "GMT");
						tz.splice(3, 0, ":");
					}
					s = tz.join("");
					break;
//				case 'Y': case 'u': case 'W': case 'F': case 'g': case 'A': case 'e':
//					console.log(match+" modifier unimplemented");
				default:
					throw new Error("dojo.date.locale.format: invalid pattern char: "+pattern);
			}
			if(pad){ s = dojo.string.pad(s, l); }
			return s;
		});
	}

/*=====
	dojo.date.locale.__FormatOptions = function(){
	//	selector: String
	//		choice of 'time','date' (default: date and time)
	//	formatLength: String
	//		choice of long, short, medium or full (plus any custom additions).  Defaults to 'short'
	//	datePattern:String
	//		override pattern with this string
	//	timePattern:String
	//		override pattern with this string
	//	am: String
	//		override strings for am in times
	//	pm: String
	//		override strings for pm in times
	//	locale: String
	//		override the locale used to determine formatting rules
	//	fullYear: Boolean
	//		(format only) use 4 digit years whenever 2 digit years are called for
	//	strict: Boolean
	//		(parse only) strict parsing, off by default
		this.selector = selector;
		this.formatLength = formatLength;
		this.datePattern = datePattern;
		this.timePattern = timePattern;
		this.am = am;
		this.pm = pm;
		this.locale = locale;
		this.fullYear = fullYear;
		this.strict = strict;
	}
=====*/

dojo.date.locale.format = function(/*Date*/dateObject, /*dojo.date.locale.__FormatOptions?*/options){
	// summary:
	//		Format a Date object as a String, using locale-specific settings.
	//
	// description:
	//		Create a string from a Date object using a known localized pattern.
	//		By default, this method formats both date and time from dateObject.
	//		Formatting patterns are chosen appropriate to the locale.  Different
	//		formatting lengths may be chosen, with "full" used by default.
	//		Custom patterns may be used or registered with translations using
	//		the dojo.date.locale.addCustomFormats method.
	//		Formatting patterns are implemented using [the syntax described at
	//		unicode.org](http://www.unicode.org/reports/tr35/tr35-4.html#Date_Format_Patterns)
	//
	// dateObject:
	//		the date and/or time to be formatted.  If a time only is formatted,
	//		the values in the year, month, and day fields are irrelevant.  The
	//		opposite is true when formatting only dates.

	options = options || {};

	var locale = dojo.i18n.normalizeLocale(options.locale);
	var formatLength = options.formatLength || 'short';
	var bundle = dojo.date.locale._getGregorianBundle(locale);
	var str = [];
	var sauce = dojo.hitch(this, formatPattern, dateObject, bundle, options.fullYear);
	if(options.selector == "year"){
		// Special case as this is not yet driven by CLDR data
		var year = dateObject.getFullYear();
		if(locale.match(/^zh|^ja/)){
			year += "\u5E74";
		}
		return year;
	}
	if(options.selector != "time"){
		var datePattern = options.datePattern || bundle["dateFormat-"+formatLength];
		if(datePattern){str.push(_processPattern(datePattern, sauce));}
	}
	if(options.selector != "date"){
		var timePattern = options.timePattern || bundle["timeFormat-"+formatLength];
		if(timePattern){str.push(_processPattern(timePattern, sauce));}
	}
	var result = str.join(" "); //TODO: use locale-specific pattern to assemble date + time
	return result; // String
};

dojo.date.locale.regexp = function(/*dojo.date.locale.__FormatOptions?*/options){
	// summary:
	//		Builds the regular needed to parse a localized date

	return dojo.date.locale._parseInfo(options).regexp; // String
};

dojo.date.locale._parseInfo = function(/*dojo.date.locale.__FormatOptions?*/options){
	options = options || {};
	var locale = dojo.i18n.normalizeLocale(options.locale);
	var bundle = dojo.date.locale._getGregorianBundle(locale);
	var formatLength = options.formatLength || 'short';
	var datePattern = options.datePattern || bundle["dateFormat-" + formatLength];
	var timePattern = options.timePattern || bundle["timeFormat-" + formatLength];
	var pattern;
	if(options.selector == 'date'){
		pattern = datePattern;
	}else if(options.selector == 'time'){
		pattern = timePattern;
	}else{
		pattern = datePattern + ' ' + timePattern; //TODO: use locale-specific pattern to assemble date + time
	}

	var tokens = [];
	var re = _processPattern(pattern, dojo.hitch(this, _buildDateTimeRE, tokens, bundle, options));
	return {regexp: re, tokens: tokens, bundle: bundle};
};

dojo.date.locale.parse = function(/*String*/value, /*dojo.date.locale.__FormatOptions?*/options){
	// summary:
	//		Convert a properly formatted string to a primitive Date object,
	//		using locale-specific settings.
	//
	// description:
	//		Create a Date object from a string using a known localized pattern.
	//		By default, this method parses looking for both date and time in the string.
	//		Formatting patterns are chosen appropriate to the locale.  Different
	//		formatting lengths may be chosen, with "full" used by default.
	//		Custom patterns may be used or registered with translations using
	//		the dojo.date.locale.addCustomFormats method.
	//	
	//		Formatting patterns are implemented using [the syntax described at
	//		unicode.org](http://www.unicode.org/reports/tr35/tr35-4.html#Date_Format_Patterns)
	//		When two digit years are used, a century is chosen according to a sliding 
	//		window of 80 years before and 20 years after present year, for both `yy` and `yyyy` patterns.
	//		year < 100CE requires strict mode.
	//
	// value:
	//		A string representation of a date

	var info = dojo.date.locale._parseInfo(options);
	var tokens = info.tokens, bundle = info.bundle;
	var re = new RegExp("^" + info.regexp + "$", info.strict ? "" : "i");
	var match = re.exec(value);
	if(!match){ return null; } // null

	var widthList = ['abbr', 'wide', 'narrow'];
	var result = [1970,0,1,0,0,0,0]; // will get converted to a Date at the end
	var amPm = "";
	var valid = dojo.every(match, function(v, i){
		if(!i){return true;}
		var token=tokens[i-1];
		var l=token.length;
		switch(token.charAt(0)){
			case 'y':
				if(l != 2 && options.strict){
					//interpret year literally, so '5' would be 5 A.D.
					result[0] = v;
				}else{
					if(v<100){
						v = Number(v);
						//choose century to apply, according to a sliding window
						//of 80 years before and 20 years after present year
						var year = '' + new Date().getFullYear();
						var century = year.substring(0, 2) * 100;
						var cutoff = Math.min(Number(year.substring(2, 4)) + 20, 99);
						var num = (v < cutoff) ? century + v : century - 100 + v;
						result[0] = num;
					}else{
						//we expected 2 digits and got more...
						if(options.strict){
							return false;
						}
						//interpret literally, so '150' would be 150 A.D.
						//also tolerate '1950', if 'yyyy' input passed to 'yy' format
						result[0] = v;
					}
				}
				break;
			case 'M':
				if(l>2){
					var months = bundle['months-format-' + widthList[l-3]].concat();
					if(!options.strict){
						//Tolerate abbreviating period in month part
						//Case-insensitive comparison
						v = v.replace(".","").toLowerCase();
						months = dojo.map(months, function(s){ return s.replace(".","").toLowerCase(); } );
					}
					v = dojo.indexOf(months, v);
					if(v == -1){
//						console.log("dojo.date.locale.parse: Could not parse month name: '" + v + "'.");
						return false;
					}
				}else{
					v--;
				}
				result[1] = v;
				break;
			case 'E':
			case 'e':
				var days = bundle['days-format-' + widthList[l-3]].concat();
				if(!options.strict){
					//Case-insensitive comparison
					v = v.toLowerCase();
					days = dojo.map(days, function(d){return d.toLowerCase();});
				}
				v = dojo.indexOf(days, v);
				if(v == -1){
//					console.log("dojo.date.locale.parse: Could not parse weekday name: '" + v + "'.");
					return false;
				}

				//TODO: not sure what to actually do with this input,
				//in terms of setting something on the Date obj...?
				//without more context, can't affect the actual date
				//TODO: just validate?
				break;
			case 'D':
				result[1] = 0;
				// fallthrough...
			case 'd':
				result[2] = v;
				break;
			case 'a': //am/pm
				var am = options.am || bundle.am;
				var pm = options.pm || bundle.pm;
				if(!options.strict){
					var period = /\./g;
					v = v.replace(period,'').toLowerCase();
					am = am.replace(period,'').toLowerCase();
					pm = pm.replace(period,'').toLowerCase();
				}
				if(options.strict && v != am && v != pm){
//					console.log("dojo.date.locale.parse: Could not parse am/pm part.");
					return false;
				}

				// we might not have seen the hours field yet, so store the state and apply hour change later
				amPm = (v == pm) ? 'p' : (v == am) ? 'a' : '';
				break;
			case 'K': //hour (1-24)
				if(v == 24){ v = 0; }
				// fallthrough...
			case 'h': //hour (1-12)
			case 'H': //hour (0-23)
			case 'k': //hour (0-11)
				//TODO: strict bounds checking, padding
				if(v > 23){
//					console.log("dojo.date.locale.parse: Illegal hours value");
					return false;
				}

				//in the 12-hour case, adjusting for am/pm requires the 'a' part
				//which could come before or after the hour, so we will adjust later
				result[3] = v;
				break;
			case 'm': //minutes
				result[4] = v;
				break;
			case 's': //seconds
				result[5] = v;
				break;
			case 'S': //milliseconds
				result[6] = v;
//				break;
//			case 'w':
//TODO				var firstDay = 0;
//			default:
//TODO: throw?
//				console.log("dojo.date.locale.parse: unsupported pattern char=" + token.charAt(0));
		}
		return true;
	});

	var hours = +result[3];
	if(amPm === 'p' && hours < 12){
		result[3] = hours + 12; //e.g., 3pm -> 15
	}else if(amPm === 'a' && hours == 12){
		result[3] = 0; //12am -> 0
	}

	//TODO: implement a getWeekday() method in order to test 
	//validity of input strings containing 'EEE' or 'EEEE'...

	var dateObject = new Date(result[0], result[1], result[2], result[3], result[4], result[5], result[6]); // Date
	if(options.strict){
		dateObject.setFullYear(result[0]);
	}

	// Check for overflow.  The Date() constructor normalizes things like April 32nd...
	//TODO: why isn't this done for times as well?
	var allTokens = tokens.join(""),
		dateToken = allTokens.indexOf('d') != -1,
		monthToken = allTokens.indexOf('M') != -1;

	if(!valid ||
		(monthToken && dateObject.getMonth() > result[1]) ||
		(dateToken && dateObject.getDate() > result[2])){
		return null;
	}

	// Check for underflow, due to DST shifts.  See #9366
	// This assumes a 1 hour dst shift correction at midnight
	// We could compare the timezone offset after the shift and add the difference instead.
	if((monthToken && dateObject.getMonth() < result[1]) ||
		(dateToken && dateObject.getDate() < result[2])){
		dateObject = dojo.date.add(dateObject, "hour", 1);
	}

	return dateObject; // Date
};

function _processPattern(pattern, applyPattern, applyLiteral, applyAll){
	//summary: Process a pattern with literals in it

	// Break up on single quotes, treat every other one as a literal, except '' which becomes '
	var identity = function(x){return x;};
	applyPattern = applyPattern || identity;
	applyLiteral = applyLiteral || identity;
	applyAll = applyAll || identity;

	//split on single quotes (which escape literals in date format strings) 
	//but preserve escaped single quotes (e.g., o''clock)
	var chunks = pattern.match(/(''|[^'])+/g); 
	var literal = pattern.charAt(0) == "'";

	dojo.forEach(chunks, function(chunk, i){
		if(!chunk){
			chunks[i]='';
		}else{
			chunks[i]=(literal ? applyLiteral : applyPattern)(chunk);
			literal = !literal;
		}
	});
	return applyAll(chunks.join(''));
}

function _buildDateTimeRE(tokens, bundle, options, pattern){
	pattern = dojo.regexp.escapeString(pattern);
	if(!options.strict){ pattern = pattern.replace(" a", " ?a"); } // kludge to tolerate no space before am/pm
	return pattern.replace(/([a-z])\1*/ig, function(match){
		// Build a simple regexp.  Avoid captures, which would ruin the tokens list
		var s;
		var c = match.charAt(0);
		var l = match.length;
		var p2 = '', p3 = '';
		if(options.strict){
			if(l > 1){ p2 = '0' + '{'+(l-1)+'}'; }
			if(l > 2){ p3 = '0' + '{'+(l-2)+'}'; }
		}else{
			p2 = '0?'; p3 = '0{0,2}';
		}
		switch(c){
			case 'y':
				s = '\\d{2,4}';
				break;
			case 'M':
				s = (l>2) ? '\\S+?' : p2+'[1-9]|1[0-2]';
				break;
			case 'D':
				s = p2+'[1-9]|'+p3+'[1-9][0-9]|[12][0-9][0-9]|3[0-5][0-9]|36[0-6]';
				break;
			case 'd':
				s = '[12]\\d|'+p2+'[1-9]|3[01]';
				break;
			case 'w':
				s = p2+'[1-9]|[1-4][0-9]|5[0-3]';
				break;
		    case 'E':
				s = '\\S+';
				break;
			case 'h': //hour (1-12)
				s = p2+'[1-9]|1[0-2]';
				break;
			case 'k': //hour (0-11)
				s = p2+'\\d|1[01]';
				break;
			case 'H': //hour (0-23)
				s = p2+'\\d|1\\d|2[0-3]';
				break;
			case 'K': //hour (1-24)
				s = p2+'[1-9]|1\\d|2[0-4]';
				break;
			case 'm':
			case 's':
				s = '[0-5]\\d';
				break;
			case 'S':
				s = '\\d{'+l+'}';
				break;
			case 'a':
				var am = options.am || bundle.am || 'AM';
				var pm = options.pm || bundle.pm || 'PM';
				if(options.strict){
					s = am + '|' + pm;
				}else{
					s = am + '|' + pm;
					if(am != am.toLowerCase()){ s += '|' + am.toLowerCase(); }
					if(pm != pm.toLowerCase()){ s += '|' + pm.toLowerCase(); }
					if(s.indexOf('.') != -1){ s += '|' + s.replace(/\./g, ""); }
				}
				s = s.replace(/\./g, "\\.");
				break;
			default:
			// case 'v':
			// case 'z':
			// case 'Z':
				s = ".*";
//				console.log("parse of date format, pattern=" + pattern);
		}

		if(tokens){ tokens.push(match); }

		return "(" + s + ")"; // add capture
	}).replace(/[\xa0 ]/g, "[\\s\\xa0]"); // normalize whitespace.  Need explicit handling of \xa0 for IE.
}
})();

(function(){
var _customFormats = [];
dojo.date.locale.addCustomFormats = function(/*String*/packageName, /*String*/bundleName){
	// summary:
	//		Add a reference to a bundle containing localized custom formats to be
	//		used by date/time formatting and parsing routines.
	//
	// description:
	//		The user may add custom localized formats where the bundle has properties following the
	//		same naming convention used by dojo.cldr: `dateFormat-xxxx` / `timeFormat-xxxx`
	//		The pattern string should match the format used by the CLDR.
	//		See dojo.date.locale.format() for details.
	//		The resources must be loaded by dojo.requireLocalization() prior to use

	_customFormats.push({pkg:packageName,name:bundleName});
};

dojo.date.locale._getGregorianBundle = function(/*String*/locale){
	var gregorian = {};
	dojo.forEach(_customFormats, function(desc){
		var bundle = dojo.i18n.getLocalization(desc.pkg, desc.name, locale);
		gregorian = dojo.mixin(gregorian, bundle);
	}, this);
	return gregorian; /*Object*/
};
})();

dojo.date.locale.addCustomFormats("dojo.cldr","gregorian");

dojo.date.locale.getNames = function(/*String*/item, /*String*/type, /*String?*/context, /*String?*/locale){
	// summary:
	//		Used to get localized strings from dojo.cldr for day or month names.
	//
	// item:
	//	'months' || 'days'
	// type:
	//	'wide' || 'narrow' || 'abbr' (e.g. "Monday", "Mon", or "M" respectively, in English)
	// context:
	//	'standAlone' || 'format' (default)
	// locale:
	//	override locale used to find the names

	var label;
	var lookup = dojo.date.locale._getGregorianBundle(locale);
	var props = [item, context, type];
	if(context == 'standAlone'){
		var key = props.join('-');
		label = lookup[key];
		// Fall back to 'format' flavor of name
		if(label[0] == 1){ label = undefined; } // kludge, in the absense of real aliasing support in dojo.cldr
	}
	props[1] = 'format';

	// return by copy so changes won't be made accidentally to the in-memory model
	return (label || lookup[props.join('-')]).concat(); /*Array*/
};

dojo.date.locale.isWeekend = function(/*Date?*/dateObject, /*String?*/locale){
	// summary:
	//	Determines if the date falls on a weekend, according to local custom.

	var weekend = dojo.cldr.supplemental.getWeekend(locale);
	var day = (dateObject || new Date()).getDay();
	if(weekend.end < weekend.start){
		weekend.end += 7;
		if(day < weekend.start){ day += 7; }
	}
	return day >= weekend.start && day <= weekend.end; // Boolean
};

// These are used only by format and strftime.  Do they need to be public?  Which module should they go in?

dojo.date.locale._getDayOfYear = function(/*Date*/dateObject){
	// summary: gets the day of the year as represented by dateObject
	return dojo.date.difference(new Date(dateObject.getFullYear(), 0, 1, dateObject.getHours()), dateObject) + 1; // Number
};

dojo.date.locale._getWeekOfYear = function(/*Date*/dateObject, /*Number*/firstDayOfWeek){
	if(arguments.length == 1){ firstDayOfWeek = 0; } // Sunday

	var firstDayOfYear = new Date(dateObject.getFullYear(), 0, 1).getDay();
	var adj = (firstDayOfYear - firstDayOfWeek + 7) % 7;
	var week = Math.floor((dojo.date.locale._getDayOfYear(dateObject) + adj - 1) / 7);

	// if year starts on the specified day, start counting weeks at 1
	if(firstDayOfYear == firstDayOfWeek){ week++; }

	return week; // Number
};

}

if(!dojo._hasResource["dijit._Calendar"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._Calendar"] = true;
dojo.provide("dijit._Calendar");








dojo.declare(
	"dijit._Calendar",
	[dijit._Widget, dijit._Templated],
	{
	// summary:
	//		A simple GUI for choosing a date in the context of a monthly calendar.
	//
	// description:
	//		A simple GUI for choosing a date in the context of a monthly calendar.
	//		This widget is used internally by other widgets and is not accessible
	//		as a standalone widget.
	//		This widget can't be used in a form because it doesn't serialize the date to an
	//		`<input>` field.  For a form element, use dijit.form.DateTextBox instead.
	//
	//		Note that the parser takes all dates attributes passed in the
	//		[RFC 3339 format](http://www.faqs.org/rfcs/rfc3339.html), e.g. `2005-06-30T08:05:00-07:00`
	//		so that they are serializable and locale-independent.
	//
	// example:
	//	|	var calendar = new dijit._Calendar({}, dojo.byId("calendarNode"));
	//
	//	example:
	//	|	<div dojoType="dijit._Calendar"></div>

		templateString:"<table cellspacing=\"0\" cellpadding=\"0\" class=\"dijitCalendarContainer\">\n\t<thead>\n\t\t<tr class=\"dijitReset dijitCalendarMonthContainer\" valign=\"top\">\n\t\t\t<th class='dijitReset' dojoAttachPoint=\"decrementMonth\">\n\t\t\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitCalendarIncrementControl dijitCalendarDecrease\" waiRole=\"presentation\">\n\t\t\t\t<span dojoAttachPoint=\"decreaseArrowNode\" class=\"dijitA11ySideArrow\">-</span>\n\t\t\t</th>\n\t\t\t<th class='dijitReset' colspan=\"5\">\n\t\t\t\t<div dojoAttachPoint=\"monthLabelSpacer\" class=\"dijitCalendarMonthLabelSpacer\"></div>\n\t\t\t\t<div dojoAttachPoint=\"monthLabelNode\" class=\"dijitCalendarMonthLabel\"></div>\n\t\t\t</th>\n\t\t\t<th class='dijitReset' dojoAttachPoint=\"incrementMonth\">\n\t\t\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitCalendarIncrementControl dijitCalendarIncrease\" waiRole=\"presentation\">\n\t\t\t\t<span dojoAttachPoint=\"increaseArrowNode\" class=\"dijitA11ySideArrow\">+</span>\n\t\t\t</th>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<th class=\"dijitReset dijitCalendarDayLabelTemplate\"><span class=\"dijitCalendarDayLabel\"></span></th>\n\t\t</tr>\n\t</thead>\n\t<tbody dojoAttachEvent=\"onclick: _onDayClick, onmouseover: _onDayMouseOver, onmouseout: _onDayMouseOut\" class=\"dijitReset dijitCalendarBodyContainer\">\n\t\t<tr class=\"dijitReset dijitCalendarWeekTemplate\">\n\t\t\t<td class=\"dijitReset dijitCalendarDateTemplate\"><span class=\"dijitCalendarDateLabel\"></span></td>\n\t\t</tr>\n\t</tbody>\n\t<tfoot class=\"dijitReset dijitCalendarYearContainer\">\n\t\t<tr>\n\t\t\t<td class='dijitReset' valign=\"top\" colspan=\"7\">\n\t\t\t\t<h3 class=\"dijitCalendarYearLabel\">\n\t\t\t\t\t<span dojoAttachPoint=\"previousYearLabelNode\" class=\"dijitInline dijitCalendarPreviousYear\"></span>\n\t\t\t\t\t<span dojoAttachPoint=\"currentYearLabelNode\" class=\"dijitInline dijitCalendarSelectedYear\"></span>\n\t\t\t\t\t<span dojoAttachPoint=\"nextYearLabelNode\" class=\"dijitInline dijitCalendarNextYear\"></span>\n\t\t\t\t</h3>\n\t\t\t</td>\n\t\t</tr>\n\t</tfoot>\n</table>\t\n",

		// value: Date
		//		The currently selected Date
		value: new Date(),

		// dayWidth: String
		//		How to represent the days of the week in the calendar header. See dojo.date.locale
		dayWidth: "narrow",

		setValue: function(/*Date*/ value){
			// summary:
			//      Deprecated.   Used attr('value', ...) instead.
			// tags:
			//      deprecated
			dojo.deprecated("dijit.Calendar:setValue() is deprecated.  Use attr('value', ...) instead.", "", "2.0");
			this.attr('value', value);
		},

		_getValueAttr: function(/*String*/ value){
			// summary:
			//		Hook so attr('value') works.
			var value = new Date(this.value);
			value.setHours(0, 0, 0, 0); // return midnight, local time for back-compat

			// If daylight savings pushes midnight to the previous date, fix the Date
			// object to point at 1am so it will represent the correct day. See #9366
			if(value.getDate() < this.value.getDate()){
				value = dojo.date.add(value, "hour", 1);
			}
			return value;
		},

		_setValueAttr: function(/*Date*/ value){
			// summary:
			//		Hook to make attr("value", ...) work.
			// description:
			// 		Set the current date and update the UI.  If the date is disabled, the selection will
			//		not change, but the display will change to the corresponding month.
			// tags:
			//      protected
			if(!this.value || dojo.date.compare(value, this.value)){
				value = new Date(value);
				value.setHours(1); // to avoid issues when DST shift occurs at midnight, see #8521, #9366
				this.displayMonth = new Date(value);
				if(!this.isDisabledDate(value, this.lang)){
					this.value = value;
					this.onChange(this.attr('value'));
				}
				this._populateGrid();
			}
		},

		_setText: function(node, text){
			// summary:
			//		This just sets the content of node to the specified text.
			//		Can't do "node.innerHTML=text" because of an IE bug w/tables, see #3434.
			// tags:
			//      private
			while(node.firstChild){
				node.removeChild(node.firstChild);
			}
			node.appendChild(dojo.doc.createTextNode(text));
		},

		_populateGrid: function(){
			// summary:
			//      Fills in the calendar grid with each day (1-31)
			// tags:
			//      private
			var month = this.displayMonth;
			month.setDate(1);
			var firstDay = month.getDay();
			var daysInMonth = dojo.date.getDaysInMonth(month);
			var daysInPreviousMonth = dojo.date.getDaysInMonth(dojo.date.add(month, "month", -1));
			var today = new Date();
			var selected = this.value;

			var dayOffset = dojo.cldr.supplemental.getFirstDayOfWeek(this.lang);
			if(dayOffset > firstDay){ dayOffset -= 7; }

			// Iterate through dates in the calendar and fill in date numbers and style info
			dojo.query(".dijitCalendarDateTemplate", this.domNode).forEach(function(template, i){
				i += dayOffset;
				var date = new Date(month);
				var number, clazz = "dijitCalendar", adj = 0;

				if(i < firstDay){
					number = daysInPreviousMonth - firstDay + i + 1;
					adj = -1;
					clazz += "Previous";
				}else if(i >= (firstDay + daysInMonth)){
					number = i - firstDay - daysInMonth + 1;
					adj = 1;
					clazz += "Next";
				}else{
					number = i - firstDay + 1;
					clazz += "Current";
				}

				if(adj){
					date = dojo.date.add(date, "month", adj);
				}
				date.setDate(number);

				if(!dojo.date.compare(date, today, "date")){
					clazz = "dijitCalendarCurrentDate " + clazz;
				}

				if(!dojo.date.compare(date, selected, "date")){
					clazz = "dijitCalendarSelectedDate " + clazz;
				}

				if(this.isDisabledDate(date, this.lang)){
					clazz = "dijitCalendarDisabledDate " + clazz;
				}

				var clazz2 = this.getClassForDate(date, this.lang);
				if(clazz2){
					clazz = clazz2 + " " + clazz;
				}

				template.className =  clazz + "Month dijitCalendarDateTemplate";
				template.dijitDateValue = date.valueOf();
				var label = dojo.query(".dijitCalendarDateLabel", template)[0];
				this._setText(label, date.getDate());
			}, this);

			// Fill in localized month name
			var monthNames = dojo.date.locale.getNames('months', 'wide', 'standAlone', this.lang);
			this._setText(this.monthLabelNode, monthNames[month.getMonth()]);

			// Fill in localized prev/current/next years
			var y = month.getFullYear() - 1;
			var d = new Date();
			dojo.forEach(["previous", "current", "next"], function(name){
				d.setFullYear(y++);
				this._setText(this[name+"YearLabelNode"],
					dojo.date.locale.format(d, {selector:'year', locale:this.lang}));
			}, this);

			// Set up repeating mouse behavior
			var _this = this;
			var typematic = function(nodeProp, dateProp, adj){
				_this._connects.push(
					dijit.typematic.addMouseListener(_this[nodeProp], _this, function(count){
						if(count >= 0){ _this._adjustDisplay(dateProp, adj); }
					}, 0.8, 500)
				);
			};
			typematic("incrementMonth", "month", 1);
			typematic("decrementMonth", "month", -1);
			typematic("nextYearLabelNode", "year", 1);
			typematic("previousYearLabelNode", "year", -1);
		},

		goToToday: function(){
			// summary:
			//      Sets calendar's value to today's date
			this.attr('value', new Date());
		},

		postCreate: function(){
			this.inherited(arguments);
			dojo.setSelectable(this.domNode, false);

			var cloneClass = dojo.hitch(this, function(clazz, n){
				var template = dojo.query(clazz, this.domNode)[0];
	 			for(var i=0; i<n; i++){
					template.parentNode.appendChild(template.cloneNode(true));
				}
			});

			// clone the day label and calendar day templates 6 times to make 7 columns
			cloneClass(".dijitCalendarDayLabelTemplate", 6);
			cloneClass(".dijitCalendarDateTemplate", 6);

			// now make 6 week rows
			cloneClass(".dijitCalendarWeekTemplate", 5);

			// insert localized day names in the header
			var dayNames = dojo.date.locale.getNames('days', this.dayWidth, 'standAlone', this.lang);
			var dayOffset = dojo.cldr.supplemental.getFirstDayOfWeek(this.lang);
			dojo.query(".dijitCalendarDayLabel", this.domNode).forEach(function(label, i){
				this._setText(label, dayNames[(i + dayOffset) % 7]);
			}, this);

			// Fill in spacer element with all the month names (invisible) so that the maximum width will affect layout
			var monthNames = dojo.date.locale.getNames('months', 'wide', 'standAlone', this.lang);
			dojo.forEach(monthNames, function(name){
				var monthSpacer = dojo.create("div", null, this.monthLabelSpacer);
				this._setText(monthSpacer, name);
			}, this);

			this.value = null;
			this.attr('value', new Date());
		},

		_adjustDisplay: function(/*String*/ part, /*int*/ amount){
			// summary:
			//      Moves calendar forwards or backwards by months or years
			// part:
			//      "month" or "year"
			// amount:
			//      Number of months or years
			// tags:
			//      private
			this.displayMonth = dojo.date.add(this.displayMonth, part, amount);
			this._populateGrid();
		},

		_onDayClick: function(/*Event*/ evt){
			// summary:
			//      Handler for when user clicks a day
			// tags:
			//      protected
			dojo.stopEvent(evt);
			for(var node = evt.target; node && !node.dijitDateValue; node = node.parentNode);
			if(node && !dojo.hasClass(node, "dijitCalendarDisabledDate")){
				this.attr('value', node.dijitDateValue);
				this.onValueSelected(this.attr('value'));
			}
		},

		_onDayMouseOver: function(/*Event*/ evt){
			// summary:
			//      Handler for when user clicks a day
			// tags:
			//      protected
			var node = evt.target;
			if(node && (node.dijitDateValue || node == this.previousYearLabelNode || node == this.nextYearLabelNode) ){
				dojo.addClass(node, "dijitCalendarHoveredDate");
				this._currentNode = node;
			}
		},

		_onDayMouseOut: function(/*Event*/ evt){
			// summary:
			//      Handler for when user clicks a day
			// tags:
			//      protected
			if(!this._currentNode){ return; }
			for(var node = evt.relatedTarget; node;){
				if(node == this._currentNode){ return; }
				try{
					node = node.parentNode;
				}catch(x){
					node = null;
				}
			}
			dojo.removeClass(this._currentNode, "dijitCalendarHoveredDate");
			this._currentNode = null;
		},

		onValueSelected: function(/*Date*/ date){
			// summary:
			//		Notification that a date cell was selected.  It may be the same as the previous value.
			// description:
			//      Used by `dijit.form._DateTimeTextBox` (and thus `dijit.form.DateTextBox`)
			//      to get notification when the user has clicked a date.
			// tags:
			//      protected
		},

		onChange: function(/*Date*/ date){
			// summary:
			//		Called only when the selected date has changed
		},

		isDisabledDate: function(/*Date*/ dateObject, /*String?*/ locale){
			// summary:
			//		May be overridden to disable certain dates in the calendar e.g. `isDisabledDate=dojo.date.locale.isWeekend`
			// tags:
			//      extension
/*=====
			return false; // Boolean
=====*/
		},

		getClassForDate: function(/*Date*/ dateObject, /*String?*/ locale){
			// summary:
			//		May be overridden to return CSS classes to associate with the date entry for the given dateObject,
			//		for example to indicate a holiday in specified locale.
			// tags:
			//      extension

/*=====
			return ""; // String
=====*/
		}
	}
);

}

if(!dojo._hasResource["dijit.Tooltip"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.Tooltip"] = true;
dojo.provide("dijit.Tooltip");




dojo.declare(
	"dijit._MasterTooltip",
	[dijit._Widget, dijit._Templated],
	{
		// summary:
		//		Internal widget that holds the actual tooltip markup,
		//		which occurs once per page.
		//		Called by Tooltip widgets which are just containers to hold
		//		the markup
		// tags:
		//		protected

		// duration: Integer
		//		Milliseconds to fade in/fade out
		duration: dijit.defaultDuration,

		templateString:"<div class=\"dijitTooltip dijitTooltipLeft\" id=\"dojoTooltip\">\n\t<div class=\"dijitTooltipContainer dijitTooltipContents\" dojoAttachPoint=\"containerNode\" waiRole='alert'></div>\n\t<div class=\"dijitTooltipConnector\"></div>\n</div>\n",

		postCreate: function(){
			dojo.body().appendChild(this.domNode);

			this.bgIframe = new dijit.BackgroundIframe(this.domNode);

			// Setup fade-in and fade-out functions.
			this.fadeIn = dojo.fadeIn({ node: this.domNode, duration: this.duration, onEnd: dojo.hitch(this, "_onShow") });
			this.fadeOut = dojo.fadeOut({ node: this.domNode, duration: this.duration, onEnd: dojo.hitch(this, "_onHide") });

		},

		show: function(/*String*/ innerHTML, /*DomNode*/ aroundNode, /*String[]?*/ position){
			// summary:
			//		Display tooltip w/specified contents to right of specified node
			//		(To left if there's no space on the right, or if LTR==right)

			if(this.aroundNode && this.aroundNode === aroundNode){
				return;
			}

			if(this.fadeOut.status() == "playing"){
				// previous tooltip is being hidden; wait until the hide completes then show new one
				this._onDeck=arguments;
				return;
			}
			this.containerNode.innerHTML=innerHTML;

			// Firefox bug. when innerHTML changes to be shorter than previous
			// one, the node size will not be updated until it moves.
			this.domNode.style.top = (this.domNode.offsetTop + 1) + "px";

			// position the element and change CSS according to position[] (a list of positions to try)
			var align = {};
			var ltr = this.isLeftToRight();
			dojo.forEach( (position && position.length) ? position : dijit.Tooltip.defaultPosition, function(pos){
				switch(pos){
					case "after":				
						align[ltr ? "BR" : "BL"] = ltr ? "BL" : "BR";
						break;
					case "before":
						align[ltr ? "BL" : "BR"] = ltr ? "BR" : "BL";
						break;
					case "below":
						// first try to align left borders, next try to align right borders (or reverse for RTL mode)
						align[ltr ? "BL" : "BR"] = ltr ? "TL" : "TR";
						align[ltr ? "BR" : "BL"] = ltr ? "TR" : "TL";
						break;
					case "above":
					default:
						// first try to align left borders, next try to align right borders (or reverse for RTL mode)
						align[ltr ? "TL" : "TR"] = ltr ? "BL" : "BR";
						align[ltr ? "TR" : "TL"] = ltr ? "BR" : "BL";
						break;
				}
			});
			var pos = dijit.placeOnScreenAroundElement(this.domNode, aroundNode, align, dojo.hitch(this, "orient"));

			// show it
			dojo.style(this.domNode, "opacity", 0);
			this.fadeIn.play();
			this.isShowingNow = true;
			this.aroundNode = aroundNode;
		},

		orient: function(/* DomNode */ node, /* String */ aroundCorner, /* String */ tooltipCorner){
			// summary:
			//		Private function to set CSS for tooltip node based on which position it's in.
			//		This is called by the dijit popup code.
			// tags:
			//		protected

			node.className = "dijitTooltip " +
				{
					"BL-TL": "dijitTooltipBelow dijitTooltipABLeft",
					"TL-BL": "dijitTooltipAbove dijitTooltipABLeft",
					"BR-TR": "dijitTooltipBelow dijitTooltipABRight",
					"TR-BR": "dijitTooltipAbove dijitTooltipABRight",
					"BR-BL": "dijitTooltipRight",
					"BL-BR": "dijitTooltipLeft"
				}[aroundCorner + "-" + tooltipCorner];
		},

		_onShow: function(){
			// summary:
			//		Called at end of fade-in operation
			// tags:
			//		protected
			if(dojo.isIE){
				// the arrow won't show up on a node w/an opacity filter
				this.domNode.style.filter="";
			}
		},

		hide: function(aroundNode){
			// summary:
			//		Hide the tooltip
			if(this._onDeck && this._onDeck[1] == aroundNode){
				// this hide request is for a show() that hasn't even started yet;
				// just cancel the pending show()
				this._onDeck=null;
			}else if(this.aroundNode === aroundNode){
				// this hide request is for the currently displayed tooltip
				this.fadeIn.stop();
				this.isShowingNow = false;
				this.aroundNode = null;
				this.fadeOut.play();
			}else{
				// just ignore the call, it's for a tooltip that has already been erased
			}
		},

		_onHide: function(){
			// summary:
			//		Called at end of fade-out operation
			// tags:
			//		protected

			this.domNode.style.cssText="";	// to position offscreen again
			if(this._onDeck){
				// a show request has been queued up; do it now
				this.show.apply(this, this._onDeck);
				this._onDeck=null;
			}
		}

	}
);

dijit.showTooltip = function(/*String*/ innerHTML, /*DomNode*/ aroundNode, /*String[]?*/ position){
	// summary:
	//		Display tooltip w/specified contents in specified position.
	//		See description of dijit.Tooltip.defaultPosition for details on position parameter.
	//		If position is not specified then dijit.Tooltip.defaultPosition is used.
	if(!dijit._masterTT){ dijit._masterTT = new dijit._MasterTooltip(); }
	return dijit._masterTT.show(innerHTML, aroundNode, position);
};

dijit.hideTooltip = function(aroundNode){
	// summary:
	//		Hide the tooltip
	if(!dijit._masterTT){ dijit._masterTT = new dijit._MasterTooltip(); }
	return dijit._masterTT.hide(aroundNode);
};

dojo.declare(
	"dijit.Tooltip",
	dijit._Widget,
	{
		// summary
		//		Pops up a tooltip (a help message) when you hover over a node.

		// label: String
		//		Text to display in the tooltip.
		//		Specified as innerHTML when creating the widget from markup.
		label: "",

		// showDelay: Integer
		//		Number of milliseconds to wait after hovering over/focusing on the object, before
		//		the tooltip is displayed.
		showDelay: 400,

		// connectId: [const] String[]
		//		Id's of domNodes to attach the tooltip to.
		//		When user hovers over any of the specified dom nodes, the tooltip will appear.
		//
		//		Note: Currently connectId can only be specified on initialization, it cannot
		//		be changed via attr('connectId', ...)
		//
		//		Note: in 2.0 this will be renamed to connectIds for less confusion.
		connectId: [],

		// position: String[]
		//		See description of `dijit.Tooltip.defaultPosition` for details on position parameter.
		position: [],

		_setConnectIdAttr: function(ids){
			// TODO: erase old conections

			this._connectNodes = [];

			// TODO: rename connectId to connectIds for 2.0, and remove this code converting from string to array
			this.connectId = dojo.isArrayLike(ids) ? ids : [ids];
			
			dojo.forEach(this.connectId, function(id) {
				var node = dojo.byId(id);
				if (node) {
					this._connectNodes.push(node);
					dojo.forEach(["onMouseEnter", "onMouseLeave", "onFocus", "onBlur"], function(event){
						this.connect(node, event.toLowerCase(), "_"+event);
					}, this);
					if(dojo.isIE){
						// BiDi workaround
						node.style.zoom = 1;
					}
				}
			}, this);
		},

		postCreate: function(){	
			dojo.addClass(this.domNode,"dijitTooltipData");
		},

		_onMouseEnter: function(/*Event*/ e){
			// summary:
			//		Handler for mouseenter event on the target node
			// tags:
			//		private
			this._onHover(e);
		},

		_onMouseLeave: function(/*Event*/ e){
			// summary:
			//		Handler for mouseleave event on the target node
			// tags:
			//		private
			this._onUnHover(e);
		},

		_onFocus: function(/*Event*/ e){
			// summary:
			//		Handler for focus event on the target node
			// tags:
			//		private

			// TODO: this is dangerously named, as the dijit focus manager calls
			// _onFocus() on any widget that gets focus (whereas in this class we
			// are connecting onfocus on the *target* DOM node to this method

			this._focus = true;
			this._onHover(e);
			this.inherited(arguments);
		},
		
		_onBlur: function(/*Event*/ e){
			// summary:
			//		Handler for blur event on the target node
			// tags:
			//		private

			// TODO: rename; see above comment

			this._focus = false;
			this._onUnHover(e);
			this.inherited(arguments);
		},

		_onHover: function(/*Event*/ e){
			// summary:
			//		Despite the name of this method, it actually handles both hover and focus
			//		events on the target node, setting a timer to show the tooltip.
			// tags:
			//		private
			if(!this._showTimer){
				var target = e.target;
				this._showTimer = setTimeout(dojo.hitch(this, function(){this.open(target)}), this.showDelay);
			}
		},

		_onUnHover: function(/*Event*/ e){
			// summary:
			//		Despite the name of this method, it actually handles both mouseleave and blur
			//		events on the target node, hiding the tooltip.
			// tags:
			//		private

			// keep a tooltip open if the associated element still has focus (even though the
			// mouse moved away)
			if(this._focus){ return; }

			if(this._showTimer){
				clearTimeout(this._showTimer);
				delete this._showTimer;
			}
			this.close();
		},

		open: function(/*DomNode*/ target){
 			// summary:
			//		Display the tooltip; usually not called directly.
			// tags:
			//		private

			target = target || this._connectNodes[0];
			if(!target){ return; }

			if(this._showTimer){
				clearTimeout(this._showTimer);
				delete this._showTimer;
			}
			dijit.showTooltip(this.label || this.domNode.innerHTML, target, this.position);
			
			this._connectNode = target;
		},

		close: function(){
			// summary:
			//		Hide the tooltip or cancel timer for show of tooltip
			// tags:
			//		private

			if(this._connectNode){
				// if tooltip is currently shown
				dijit.hideTooltip(this._connectNode);
				delete this._connectNode;
			}
			if(this._showTimer){
				// if tooltip is scheduled to be shown (after a brief delay)
				clearTimeout(this._showTimer);
				delete this._showTimer;
			}
		},

		uninitialize: function(){
			this.close();
		}
	}
);

// dijit.Tooltip.defaultPosition: String[]
//		This variable controls the position of tooltips, if the position is not specified to
//		the Tooltip widget or *TextBox widget itself.  It's an array of strings with the following values:
//
//			* before: places tooltip to the left of the target node/widget, or to the right in
//			  the case of RTL scripts like Hebrew and Arabic
//			* after: places tooltip to the right of the target node/widget, or to the left in
//			  the case of RTL scripts like Hebrew and Arabic
//			* above: tooltip goes above target node
//			* below: tooltip goes below target node
//
//		The list is positions is tried, in order, until a position is found where the tooltip fits
//		within the viewport.
//
//		Be careful setting this parameter.  A value of "above" may work fine until the user scrolls
//		the screen so that there's no room above the target node.   Nodes with drop downs, like
//		DropDownButton or FilteringSelect, are especially problematic, in that you need to be sure
//		that the drop down and tooltip don't overlap, even when the viewport is scrolled so that there
//		is only room below (or above) the target node, but not both.
dijit.Tooltip.defaultPosition = ["after", "before"];

}

if(!dojo._hasResource["dijit.form.ValidationTextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.ValidationTextBox"] = true;
dojo.provide("dijit.form.ValidationTextBox");








/*=====
	dijit.form.ValidationTextBox.__Constraints = function(){
		// locale: String
		//		locale used for validation, picks up value from this widget's lang attribute
		// _flags_: anything
		//		various flags passed to regExpGen function
		this.locale = "";
		this._flags_ = "";
	}
=====*/

dojo.declare(
	"dijit.form.ValidationTextBox",
	dijit.form.TextBox,
	{
		// summary:
		//		Base class for textbox widgets with the ability to validate content of various types and provide user feedback.
		// tags:
		//		protected

		templateString:"<div class=\"dijit dijitReset dijitInlineTable dijitLeft\"\n\tid=\"widget_${id}\"\n\tdojoAttachEvent=\"onmouseenter:_onMouse,onmouseleave:_onMouse,onmousedown:_onMouse\" waiRole=\"presentation\"\n\t><div style=\"overflow:hidden;\"\n\t\t><div class=\"dijitReset dijitValidationIcon\"><br></div\n\t\t><div class=\"dijitReset dijitValidationIconText\">&Chi;</div\n\t\t><div class=\"dijitReset dijitInputField\"\n\t\t\t><input class=\"dijitReset\" dojoAttachPoint='textbox,focusNode' autocomplete=\"off\"\n\t\t\t${nameAttrSetting} type='${type}'\n\t\t/></div\n\t></div\n></div>\n",
		baseClass: "dijitTextBox",

		// required: Boolean
		//		User is required to enter data into this field.
		required: false,

		// promptMessage: String
		//		If defined, display this hint string immediately on focus to the textbox, if empty.
		//		Think of this like a tooltip that tells the user what to do, not an error message
		//		that tells the user what they've done wrong.
		//
		//		Message disappears when user starts typing.
		promptMessage: "",

		// invalidMessage: String
		// 		The message to display if value is invalid.
		invalidMessage: "$_unset_$", // read from the message file if not overridden

		// constraints: dijit.form.ValidationTextBox.__Constraints
		//		user-defined object needed to pass parameters to the validator functions
		constraints: {},

		// regExp: [extension protected] String
		//		regular expression string used to validate the input
		//		Do not specify both regExp and regExpGen
		regExp: ".*",

		regExpGen: function(/*dijit.form.ValidationTextBox.__Constraints*/constraints){
			// summary:
			//		Overridable function used to generate regExp when dependent on constraints.
			//		Do not specify both regExp and regExpGen.
			// tags:
			//		extension protected
			return this.regExp;     // String
		},

		// state: [readonly] String
		//		Shows current state (ie, validation result) of input (Normal, Warning, or Error)
		state: "",

		// tooltipPosition: String[]
		//		See description of `dijit.Tooltip.defaultPosition` for details on this parameter.
		tooltipPosition: [],

		_setValueAttr: function(){
			// summary:
			//		Hook so attr('value', ...) works.
			this.inherited(arguments);
			this.validate(this._focused);
		},

		validator: function(/*anything*/value, /*dijit.form.ValidationTextBox.__Constraints*/constraints){
			// summary:
			//		Overridable function used to validate the text input against the regular expression.
			// tags:
			//		protected
			return (new RegExp("^(?:" + this.regExpGen(constraints) + ")"+(this.required?"":"?")+"$")).test(value) &&
				(!this.required || !this._isEmpty(value)) &&
				(this._isEmpty(value) || this.parse(value, constraints) !== undefined); // Boolean
		},

		_isValidSubset: function(){
			// summary:
			//		Returns true if the value is either already valid or could be made valid by appending characters.
			//		This is used for validation while the user [may be] still typing.
			return this.textbox.value.search(this._partialre) == 0;
		},

		isValid: function(/*Boolean*/ isFocused){
			// summary:
			//		Tests if value is valid.
			//		Can override with your own routine in a subclass.
			// tags:
			//		protected
			return this.validator(this.textbox.value, this.constraints);
		},

		_isEmpty: function(value){
			// summary:
			//		Checks for whitespace
			return /^\s*$/.test(value); // Boolean
		},

		getErrorMessage: function(/*Boolean*/ isFocused){
			// summary:
			//		Return an error message to show if appropriate
			// tags:
			//		protected
			return this.invalidMessage; // String
		},

		getPromptMessage: function(/*Boolean*/ isFocused){
			// summary:
			//		Return a hint message to show when widget is first focused
			// tags:
			//		protected
			return this.promptMessage; // String
		},

		_maskValidSubsetError: true,
		validate: function(/*Boolean*/ isFocused){
			// summary:
			//		Called by oninit, onblur, and onkeypress.
			// description:
			//		Show missing or invalid messages if appropriate, and highlight textbox field.
			// tags:
			//		protected
			var message = "";
			var isValid = this.disabled || this.isValid(isFocused);
			if(isValid){ this._maskValidSubsetError = true; }
			var isValidSubset = !isValid && isFocused && this._isValidSubset();
			var isEmpty = this._isEmpty(this.textbox.value);
			this.state = (isValid || (!this._hasBeenBlurred && isEmpty) || isValidSubset) ? "" : "Error";
			if(this.state == "Error"){ this._maskValidSubsetError = false; }
			this._setStateClass();
			dijit.setWaiState(this.focusNode, "invalid", isValid ? "false" : "true");
			if(isFocused){
				if(isEmpty){
					message = this.getPromptMessage(true);
				}
				if(!message && (this.state == "Error" || (isValidSubset && !this._maskValidSubsetError))){
					message = this.getErrorMessage(true);
				}
			}
			this.displayMessage(message);
			return isValid;
		},

		// _message: String
		//		Currently displayed message
		_message: "",

		displayMessage: function(/*String*/ message){
			// summary:
			//		Overridable method to display validation errors/hints.
			//		By default uses a tooltip.
			// tags:
			//		extension
			if(this._message == message){ return; }
			this._message = message;
			dijit.hideTooltip(this.domNode);
			if(message){
				dijit.showTooltip(message, this.domNode, this.tooltipPosition);
			}
		},

		_refreshState: function(){
			// Overrides TextBox._refreshState()
			this.validate(this._focused);
			this.inherited(arguments);
		},

		//////////// INITIALIZATION METHODS ///////////////////////////////////////

		constructor: function(){
			this.constraints = {};
		},

		postMixInProperties: function(){
			this.inherited(arguments);
			this.constraints.locale = this.lang;
			this.messages = dojo.i18n.getLocalization("dijit.form", "validate", this.lang);
			if(this.invalidMessage == "$_unset_$"){ this.invalidMessage = this.messages.invalidMessage; }
			var p = this.regExpGen(this.constraints);
			this.regExp = p;
			var partialre = "";
			// parse the regexp and produce a new regexp that matches valid subsets
			// if the regexp is .* then there's no use in matching subsets since everything is valid
			if(p != ".*"){ this.regExp.replace(/\\.|\[\]|\[.*?[^\\]{1}\]|\{.*?\}|\(\?[=:!]|./g,
				function (re){
					switch(re.charAt(0)){
						case '{':
						case '+':
						case '?':
						case '*':
						case '^':
						case '$':
						case '|':
						case '(': partialre += re; break;
						case ")": partialre += "|$)"; break;
						 default: partialre += "(?:"+re+"|$)"; break;
					}
				}
			);}
			try{ // this is needed for now since the above regexp parsing needs more test verification
				"".search(partialre);
			}catch(e){ // should never be here unless the original RE is bad or the parsing is bad
				partialre = this.regExp;
				console.warn('RegExp error in ' + this.declaredClass + ': ' + this.regExp);
			} // should never be here unless the original RE is bad or the parsing is bad
			this._partialre = "^(?:" + partialre + ")$";
		},

		_setDisabledAttr: function(/*Boolean*/ value){
			this.inherited(arguments);	// call FormValueWidget._setDisabledAttr()
			if(this.valueNode){
				this.valueNode.disabled = value;
			}
			this._refreshState();
		},
		
		_setRequiredAttr: function(/*Boolean*/ value){
			this.required = value;
			dijit.setWaiState(this.focusNode,"required", value);
			this._refreshState();				
		},

		postCreate: function(){
			if(dojo.isIE){ // IE INPUT tag fontFamily has to be set directly using STYLE
				var s = dojo.getComputedStyle(this.focusNode);
				if(s){
					var ff = s.fontFamily;
					if(ff){
						this.focusNode.style.fontFamily = ff;
					}
				}
			}
			this.inherited(arguments);
		},

		reset:function(){
			// Overrides dijit.form.TextBox.reset() by also
			// hiding errors about partial matches
			this._maskValidSubsetError = true;
			this.inherited(arguments);
		}
	}
);

dojo.declare(
	"dijit.form.MappedTextBox",
	dijit.form.ValidationTextBox,
	{
		// summary:
		//		A dijit.form.ValidationTextBox subclass which provides a base class for widgets that have
		//		a visible formatted display value, and a serializable
		//		value in a hidden input field which is actually sent to the server.
		// description:
		//		The visible display may
		//		be locale-dependent and interactive.  The value sent to the server is stored in a hidden
		//		input field which uses the `name` attribute declared by the original widget.  That value sent
		//		to the server is defined by the dijit.form.MappedTextBox.serialize method and is typically
		//		locale-neutral.
		// tags:
		//		protected

		postMixInProperties: function(){
			this.inherited(arguments);
			
			// we want the name attribute to go to the hidden <input>, not the displayed <input>,
			// so override _FormWidget.postMixInProperties() setting of nameAttrSetting
			this.nameAttrSetting = "";
		},

		serialize: function(/*anything*/val, /*Object?*/options){
			// summary:
			//		Overridable function used to convert the attr('value') result to a canonical
			//		(non-localized) string.  For example, will print dates in ISO format, and
			//		numbers the same way as they are represented in javascript.
			// tags:
			//		protected extension
			return val.toString ? val.toString() : ""; // String
		},

		toString: function(){
			// summary:
			//		Returns widget as a printable string using the widget's value
			// tags:
			//		protected
			var val = this.filter(this.attr('value')); // call filter in case value is nonstring and filter has been customized
			return val != null ? (typeof val == "string" ? val : this.serialize(val, this.constraints)) : ""; // String
		},

		validate: function(){
			// Overrides `dijit.form.TextBox.validate`
			this.valueNode.value = this.toString();
			return this.inherited(arguments);
		},

		buildRendering: function(){
			// Overrides `dijit._Templated.buildRendering`

			this.inherited(arguments);

			// Create a hidden <input> node with the serialized value used for submit
			// (as opposed to the displayed value)
			this.valueNode = dojo.create("input", {
				style: { display: "none" },
				type: this.type,
				name: this.name
			}, this.textbox, "after");
		},

		_setDisabledAttr: function(/*Boolean*/ value){
			this.inherited(arguments);
			dojo.attr(this.valueNode, 'disabled', value);
		},

		reset:function(){
			// Overrides `dijit.form.ValidationTextBox.reset` to
			// reset the hidden textbox value to ''
			this.valueNode.value = '';
			this.inherited(arguments);
		}
	}
);

/*=====
	dijit.form.RangeBoundTextBox.__Constraints = function(){
		// min: Number
		//		Minimum signed value.  Default is -Infinity
		// max: Number
		//		Maximum signed value.  Default is +Infinity
		this.min = min;
		this.max = max;
	}
=====*/

dojo.declare(
	"dijit.form.RangeBoundTextBox",
	dijit.form.MappedTextBox,
	{
		// summary:
		//		Base class for textbox form widgets which defines a range of valid values.

		// rangeMessage: String
		//		The message to display if value is out-of-range
		rangeMessage: "",

		/*=====
		// constraints: dijit.form.RangeBoundTextBox.__Constraints
		constraints: {},
		======*/

		rangeCheck: function(/*Number*/ primitive, /*dijit.form.RangeBoundTextBox.__Constraints*/ constraints){
			// summary:
			//		Overridable function used to validate the range of the numeric input value.
			// tags:
			//		protected
			var isMin = "min" in constraints;
			var isMax = "max" in constraints;
			if(isMin || isMax){
				return (!isMin || this.compare(primitive,constraints.min) >= 0) &&
					(!isMax || this.compare(primitive,constraints.max) <= 0);
			}
			return true; // Boolean
		},

		isInRange: function(/*Boolean*/ isFocused){
			// summary:
			//		Tests if the value is in the min/max range specified in constraints
			// tags:
			//		protected
			return this.rangeCheck(this.attr('value'), this.constraints);
		},

		_isDefinitelyOutOfRange: function(){
			// summary:
			//		Returns true if the value is out of range and will remain
			//		out of range even if the user types more characters
			var val = this.attr('value');
			var isTooLittle = false;
			var isTooMuch = false;
			if("min" in this.constraints){
				var min = this.constraints.min;
				val = this.compare(val, ((typeof min == "number") && min >= 0 && val !=0)? 0 : min);
				isTooLittle = (typeof val == "number") && val < 0;
			}
			if("max" in this.constraints){
				var max = this.constraints.max;
				val = this.compare(val, ((typeof max != "number") || max > 0)? max : 0);
				isTooMuch = (typeof val == "number") && val > 0;
			}
			return isTooLittle || isTooMuch;
		},

		_isValidSubset: function(){
			// summary:
			//		Overrides `dijit.form.ValidationTextBox._isValidSubset`.
			//		Returns true if the input is syntactically valid, and either within
			//		range or could be made in range by more typing.
			return this.inherited(arguments) && !this._isDefinitelyOutOfRange();
		},

		isValid: function(/*Boolean*/ isFocused){
			// Overrides dijit.form.ValidationTextBox.isValid to check that the value is also in range.
			return this.inherited(arguments) &&
				((this._isEmpty(this.textbox.value) && !this.required) || this.isInRange(isFocused)); // Boolean
		},

		getErrorMessage: function(/*Boolean*/ isFocused){
			// Overrides dijit.form.ValidationTextBox.getErrorMessage to print "out of range" message if appropriate
			if(dijit.form.RangeBoundTextBox.superclass.isValid.call(this, false) && !this.isInRange(isFocused)){ return this.rangeMessage; } // String
			return this.inherited(arguments);
		},

		postMixInProperties: function(){
			this.inherited(arguments);
			if(!this.rangeMessage){
				this.messages = dojo.i18n.getLocalization("dijit.form", "validate", this.lang);
				this.rangeMessage = this.messages.rangeMessage;
			}
		},

		postCreate: function(){
			this.inherited(arguments);
			if(this.constraints.min !== undefined){
				dijit.setWaiState(this.focusNode, "valuemin", this.constraints.min);
			}
			if(this.constraints.max !== undefined){
				dijit.setWaiState(this.focusNode, "valuemax", this.constraints.max);
			}
		},
		
		_setValueAttr: function(/*Number*/ value, /*Boolean?*/ priorityChange){
			// summary:
			//		Hook so attr('value', ...) works.

			dijit.setWaiState(this.focusNode, "valuenow", value);
			this.inherited(arguments);
		}
	}
);

}

if(!dojo._hasResource["dijit.form._DateTimeTextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form._DateTimeTextBox"] = true;
dojo.provide("dijit.form._DateTimeTextBox");






/*=====
dojo.declare(
	"dijit.form._DateTimeTextBox.__Constraints",
	[dijit.form.RangeBoundTextBox.__Constraints, dojo.date.locale.__FormatOptions]
);
=====*/

dojo.declare(
	"dijit.form._DateTimeTextBox",
	dijit.form.RangeBoundTextBox,
	{
		// summary:
		//		Base class for validating, serializable, range-bound date or time text box.

		/*=====
		// constraints: dijit.form._DateTimeTextBox.__Constraints
		//		Starting / ending dates or times allowed
		constraints: {},
		======*/

		// Override ValidationTextBox.regExpGen().... we use a reg-ex generating function rather
		// than a straight regexp to deal with locale  (plus formatting options too?)
		regExpGen: dojo.date.locale.regexp,

		// Override _FormWidget.compare() to work for dates/times
		compare: dojo.date.compare,

		format: function(/*Date*/ value, /*dojo.date.locale.__FormatOptions*/ constraints){
			// summary:
			//		Formats the value as a Date, according to specified locale (second argument)
			// tags:
			//		protected
			if(!value){ return ''; }
			return dojo.date.locale.format(value, constraints);
		},

		parse: function(/*String*/ value, /*dojo.date.locale.__FormatOptions*/ constraints){
			// summary:
			//		Parses as string as a Date, according to constraints
			// tags:
			//		protected

			return dojo.date.locale.parse(value, constraints) || (this._isEmpty(value)? null : undefined);	 // Date
		},

		// Overrides ValidationTextBox.serialize() to serialize a date in canonical ISO format.
		serialize: dojo.date.stamp.toISOString,

		//	value: Date
		//		The value of this widget as a JavaScript Date object.  Use attr("value") / attr("value", val) to manipulate.
		//		When passed to the parser in markup, must be specified according to `dojo.date.stamp.fromISOString`
		value: new Date(""),	// value.toString()="NaN"
		_blankValue: null,    // used by filter() when the textbox is blank

		//	popupClass: [protected extension] String
		//		Name of the popup widget class used to select a date/time.
		//		Subclasses should specify this.
		popupClass: "", // default is no popup = text only


		// _selector: [protected extension] String
		//		Specifies constraints.selector passed to dojo.date functions, should be either
		//		"date" or "time".
		//		Subclass must specify this.
		_selector: "",

		postMixInProperties: function(){
			//dijit.form.RangeBoundTextBox.prototype.postMixInProperties.apply(this, arguments);
			this.inherited(arguments);
			if(!this.value || this.value.toString() == dijit.form._DateTimeTextBox.prototype.value.toString()){
				this.value = null;
			}
			var constraints = this.constraints;
			constraints.selector = this._selector;
			constraints.fullYear = true; // see #5465 - always format with 4-digit years
			var fromISO = dojo.date.stamp.fromISOString;
			if(typeof constraints.min == "string"){ constraints.min = fromISO(constraints.min); }
 			if(typeof constraints.max == "string"){ constraints.max = fromISO(constraints.max); }
		},
		
		_onFocus: function(/*Event*/ evt){
			// summary:
			//		open the TimePicker popup
			this._open();
		},

		_setValueAttr: function(/*Date*/ value, /*Boolean?*/ priorityChange, /*String?*/ formattedValue){
			// summary:
			//		Sets the date on this textbox.  Note that `value` must be a Javascript Date object.
			this.inherited(arguments);
			if(this._picker){
				// #3948: fix blank date on popup only
				if(!value){value=new Date();}
				this._picker.attr('value', value);
			}
		},

		_open: function(){
			// summary:
			//		opens the TimePicker, and sets the onValueSelected value

			if(this.disabled || this.readOnly || !this.popupClass){return;}

			var textBox = this;

			if(!this._picker){
				var PopupProto=dojo.getObject(this.popupClass, false);
				this._picker = new PopupProto({
					onValueSelected: function(value){
						if(textBox._tabbingAway){
							delete textBox._tabbingAway;
						}else{
							textBox.focus(); // focus the textbox before the popup closes to avoid reopening the popup
						}
						setTimeout(dojo.hitch(textBox, "_close"), 1); // allow focus time to take

						// this will cause InlineEditBox and other handlers to do stuff so make sure it's last
						dijit.form._DateTimeTextBox.superclass._setValueAttr.call(textBox, value, true);
					},
					lang: textBox.lang,
					constraints: textBox.constraints,
					isDisabledDate: function(/*Date*/ date){
						// summary:
						// 	disables dates outside of the min/max of the _DateTimeTextBox
						var compare = dojo.date.compare;
						var constraints = textBox.constraints;
						return constraints && (constraints.min && (compare(constraints.min, date, "date") > 0) || 
							(constraints.max && compare(constraints.max, date, "date") < 0));
					}
				});
				this._picker.attr('value', this.attr('value') || new Date());
			}
			if(!this._opened){
				dijit.popup.open({
					parent: this,
					popup: this._picker,
					around: this.domNode,
					onCancel: dojo.hitch(this, this._close),
					onClose: function(){ textBox._opened=false; }
				});
				this._opened=true;
			}
			
			dojo.marginBox(this._picker.domNode,{ w:this.domNode.offsetWidth });
		},

		_close: function(){
			if(this._opened){
				dijit.popup.close(this._picker);
				this._opened=false;
			}			
		},

		_onBlur: function(){
			// summary:
			//		Called magically when focus has shifted away from this widget and it's dropdown
			this._close();
			if(this._picker){
				// teardown so that constraints will be rebuilt next time (redundant reference: #6002)
				this._picker.destroy();
				delete this._picker;
			}
			this.inherited(arguments);
			// don't focus on <input>.  the user has explicitly focused on something else.
		},

		_getDisplayedValueAttr: function(){
			return this.textbox.value;
		},

		_setDisplayedValueAttr: function(/*String*/ value, /*Boolean?*/ priorityChange){
			this._setValueAttr(this.parse(value, this.constraints), priorityChange, value);
		},

		destroy: function(){
			if(this._picker){
				this._picker.destroy();
				delete this._picker;
			}
			this.inherited(arguments);
		},

		postCreate: function(){
			this.inherited(arguments);
			this.connect(this.focusNode, 'onkeypress', this._onKeyPress);
		},

		_onKeyPress: function(/*Event*/ e){
			// summary:
			//		Handler for keypress events

			var p = this._picker, dk = dojo.keys;
			// Handle the key in the picker, if it has a handler.  If the handler
			// returns false, then don't handle any other keys.
			if(p && this._opened && p.handleKey){
				if(p.handleKey(e) === false){ return; }
			}
			if(this._opened && e.charOrCode == dk.ESCAPE && !e.shiftKey && !e.ctrlKey && !e.altKey){
				this._close();
				dojo.stopEvent(e);
			}else if(!this._opened && e.charOrCode == dk.DOWN_ARROW){
				this._open();
				dojo.stopEvent(e);
			}else if(e.charOrCode === dk.TAB){
				this._tabbingAway = true;
			}else if(this._opened && (e.keyChar || e.charOrCode === dk.BACKSPACE || e.charOrCode == dk.DELETE)){
				// Replace the element - but do it after a delay to allow for 
				// filtering to occur
				setTimeout(dojo.hitch(this, function(){
					dijit.placeOnScreenAroundElement(p.domNode.parentNode, this.domNode, {'BL':'TL', 'TL':'BL'}, p.orient ? dojo.hitch(p, "orient") : null);
				}), 1);
			}
		}
	}
);

}

if(!dojo._hasResource["dijit.form.DateTextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.DateTextBox"] = true;
dojo.provide("dijit.form.DateTextBox");




dojo.declare(
	"dijit.form.DateTextBox",
	dijit.form._DateTimeTextBox,
	{
		// summary:
		//		A validating, serializable, range-bound date text box with a drop down calendar

		baseClass: "dijitTextBox dijitDateTextBox",
		popupClass: "dijit._Calendar",
		_selector: "date",

		//	value: Date
		//		The value of this widget as a JavaScript Date object, with only year/month/day specified.
		//
		//		Example:
		// |	new dijit.form.DateTextBox({value: new Date(2009,1,20)})
		//
		//		When passed to the parser in markup, must be specified according to locale-independent
		//		`dojo.date.stamp.fromISOString` format.
		//
		//		Example:
		// |	<input dojotype='dijit.form.DateTextBox' value='2009-01-20'>
		value: new Date("")	// value.toString()="NaN"

	}
);

}

if(!dojo._hasResource["dijit.form.SimpleTextarea"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.SimpleTextarea"] = true;
dojo.provide("dijit.form.SimpleTextarea");



dojo.declare("dijit.form.SimpleTextarea",
	dijit.form.TextBox,
	{
	// summary:
	//		A simple textarea that degrades, and responds to
	// 		minimal LayoutContainer usage, and works with dijit.form.Form.
	//		Doesn't automatically size according to input, like Textarea.
	//
	// example:
	//	|	<textarea dojoType="dijit.form.SimpleTextarea" name="foo" value="bar" rows=30 cols=40></textarea>
	//
	// example:
	//	|	new dijit.form.SimpleTextarea({ rows:20, cols:30 }, "foo");

	baseClass: "dijitTextArea",

	attributeMap: dojo.delegate(dijit.form._FormValueWidget.prototype.attributeMap, {
		rows:"textbox", cols: "textbox"
	}),

	// rows: Number
	//		The number of rows of text.
	rows: "3",

	// rows: Number
	//		The number of characters per line.
	cols: "20",

	templatePath: null,
	templateString: "<textarea ${nameAttrSetting} dojoAttachPoint='focusNode,containerNode,textbox' autocomplete='off'></textarea>",

	postMixInProperties: function(){
		// Copy value from srcNodeRef, unless user specified a value explicitly (or there is no srcNodeRef)
		if(!this.value && this.srcNodeRef){
			this.value = this.srcNodeRef.value;
		}
		this.inherited(arguments);
	},

	filter: function(/*String*/ value){
		// Override TextBox.filter to deal with newlines... specifically (IIRC) this is for IE which writes newlines
		// as \r\n instead of just \n
		if(value){
			value = value.replace(/\r/g,"");
		}
		return this.inherited(arguments);
	},

	postCreate: function(){
		this.inherited(arguments);
		if(dojo.isIE && this.cols){ // attribute selectors is not supported in IE6
			dojo.addClass(this.domNode, "dijitTextAreaCols");
		}
	},

	_previousValue: "",
	_onInput: function(e){
		// Override TextBox._onInput() to enforce maxLength restriction
		if(this.maxLength){
			var maxLength = parseInt(this.maxLength);
			var value = this.textbox.value.replace(/\r/g,'');
			var overflow = value.length - maxLength;
			if(overflow > 0){
				dojo.stopEvent(e);
				var textarea = this.textbox;
				if(textarea.selectionStart){
					var pos = textarea.selectionStart;
					var cr = 0;
					if(dojo.isOpera){
						cr = (this.textbox.value.substring(0,pos).match(/\r/g)||[]).length;
					}
					this.textbox.value = value.substring(0,pos-overflow-cr)+value.substring(pos-cr);
					textarea.setSelectionRange(pos-overflow, pos-overflow);
				}else if(dojo.doc.selection){ //IE
					textarea.focus();
					var range = dojo.doc.selection.createRange();
					// delete overflow characters
					range.moveStart("character", -overflow);
					range.text = '';
					// show cursor
					range.select();
				}
			}
			this._previousValue = this.textbox.value;
		}
		this.inherited(arguments);
	}
});

}

if(!dojo._hasResource["dijit.form.Textarea"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.Textarea"] = true;
dojo.provide("dijit.form.Textarea");



dojo.declare(
	"dijit.form.Textarea",
	dijit.form.SimpleTextarea,
	{
	// summary:
	//		A textarea widget that adjusts it's height according to the amount of data.
	//
	// description:
	//		A textarea that dynamically expands/contracts (changing it's height) as
	//		the user types, to display all the text without requiring a scroll bar.
	//
	//		Takes nearly all the parameters (name, value, etc.) that a vanilla textarea takes.
	//		Rows is not supported since this widget adjusts the height.
	//
	// example:
	// |	<textarea dojoType="dijit.form.TextArea">...</textarea>


	// Override SimpleTextArea.cols to default to width:100%, for backward compatibility
	cols: "",

	_previousNewlines: 0,
	_strictMode: (dojo.doc.compatMode != 'BackCompat'), // not the same as !dojo.isQuirks

	_getHeight: function(textarea){
		var newH = textarea.scrollHeight;
		if(dojo.isIE){
			newH += textarea.offsetHeight - textarea.clientHeight - ((dojo.isIE < 8 && this._strictMode)? dojo._getPadBorderExtents(textarea).h : 0);
		}else if(dojo.isMoz){
			newH += textarea.offsetHeight - textarea.clientHeight; // creates room for horizontal scrollbar
		}else if(dojo.isWebKit && !(dojo.isSafari < 4)){ // Safari 4.0 && Chrome
			newH += dojo._getBorderExtents(textarea).h;
		}else{ // Safari 3.x and Opera 9.6
			newH += dojo._getPadBorderExtents(textarea).h;
		}
		return newH;
	},

	_estimateHeight: function(textarea){
		// summary:
		// 		Approximate the height when the textarea is invisible with the number of lines in the text.
		// 		Fails when someone calls setValue with a long wrapping line, but the layout fixes itself when the user clicks inside so . . .
		// 		In IE, the resize event is supposed to fire when the textarea becomes visible again and that will correct the size automatically.
		//
		textarea.style.maxHeight = "";
		textarea.style.height = "auto";
		// #rows = #newlines+1
		// Note: on Moz, the following #rows appears to be 1 too many.
		// Actually, Moz is reserving room for the scrollbar.
		// If you increase the font size, this behavior becomes readily apparent as the last line gets cut off without the +1.
		textarea.rows = (textarea.value.match(/\n/g) || []).length + 1;
	},

	_needsHelpShrinking: dojo.isMoz || dojo.isWebKit,

	_onInput: function(){
		// Override SimpleTextArea._onInput() to deal with height adjustment
		this.inherited(arguments);
		if(this._busyResizing){ return; }
		this._busyResizing = true;
		var textarea = this.textbox;
		if(textarea.scrollHeight){
			var newH = this._getHeight(textarea) + "px";
			if(textarea.style.height != newH){
				textarea.style.maxHeight = textarea.style.height = newH;
			}
			if(this._needsHelpShrinking){
				if(this._setTimeoutHandle){
					clearTimeout(this._setTimeoutHandle);
				}
				this._setTimeoutHandle = setTimeout(dojo.hitch(this, "_shrink"), 0); // try to collapse multiple shrinks into 1
			}
		}else{
			// hidden content of unknown size
			this._estimateHeight(textarea);
		}
		this._busyResizing = false;
	},

	_busyResizing: false,
	_shrink: function(){
		// grow paddingBottom to see if scrollHeight shrinks (when it is unneccesarily big)
		this._setTimeoutHandle = null;
		if(this._needsHelpShrinking && !this._busyResizing){
			this._busyResizing = true;
			var textarea = this.textbox;
			var empty = false;
			if(textarea.value == ''){
				textarea.value = ' '; // prevent collapse all the way back to 0
				empty = true;
			}
			var scrollHeight = textarea.scrollHeight;
			if(!scrollHeight){
				this._estimateHeight(textarea);
			}else{
				var oldPadding = textarea.style.paddingBottom;
				var newPadding = dojo._getPadExtents(textarea);
				newPadding = newPadding.h - newPadding.t;
				textarea.style.paddingBottom = newPadding + 1 + "px"; // tweak padding to see if height can be reduced
				var newH = this._getHeight(textarea) - 1 + "px"; // see if the height changed by the 1px added
				if(textarea.style.maxHeight != newH){ // if can be reduced, so now try a big chunk
					textarea.style.paddingBottom = newPadding + scrollHeight + "px";
					textarea.scrollTop = 0;
					textarea.style.maxHeight = this._getHeight(textarea) - scrollHeight + "px"; // scrollHeight is the added padding
				}
				textarea.style.paddingBottom = oldPadding;
			}
			if(empty){
				textarea.value = '';
			}
			this._busyResizing = false;
		}
	},

	resize: function(){
		// summary:
		//		Resizes the textarea vertically (should be called after a style/value change)
		this._onInput();
	},

	_setValueAttr: function(){
		this.inherited(arguments);
		this.resize();
	},

	postCreate: function(){
		this.inherited(arguments);
		// tweak textarea style to reduce browser differences
		dojo.style(this.textbox, { overflowY: 'hidden', overflowX: 'auto', boxSizing: 'border-box', MsBoxSizing: 'border-box', WebkitBoxSizing: 'border-box', MozBoxSizing: 'border-box' });
		this.connect(this.textbox, "onscroll", this._onInput);
		this.connect(this.textbox, "onresize", this._onInput);
		this.connect(this.textbox, "onfocus", this._onInput); // useful when a previous estimate was off a bit
		setTimeout(dojo.hitch(this, "resize"), 0);
	}
});

}

if(!dojo._hasResource["dojo.fx.easing"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.fx.easing"] = true;
dojo.provide("dojo.fx.easing");

dojo.fx.easing = {
	// summary: Collection of easing functions to use beyond the default dojo._defaultEasing
	// 
	// description:
	//	Easing functions are used to manipulate the iteration through
	//	an _Animation's _Line. _Line being the properties of an Animation,
	//	and the easing function progresses through that Line determing
	//	how quickly (or slowly) it should go. Or more accurately: modify
	//	the value of the _Line based on the percentage of animation completed.
	//	
	//	All functions follow a simple naming convention of "ease type" + "when".
	//	If the name of the function ends in Out, the easing described appears
	//	towards the end of the animation. "In" means during the beginning,
	//	and InOut means both ranges of the Animation will applied, both beginning
	//	and end. 
	//
	//	example:
	//	|	
	//	|	var anim = dojo.fadeOut({
	//	|		node: 'node',	
	//	|		duration: 2000,
	//	|		easing: dojo.fx.easing.quadIn
	//	|	}).play();
	//
	
	linear: function(/* Decimal? */n){
		// summary: A linear easing function
		return n;
	},

	quadIn: function(/* Decimal? */n){
		return Math.pow(n, 2);
	},

	quadOut: function(/* Decimal? */n){
		return n * (n - 2) * -1;
	},

	quadInOut: function(/* Decimal? */n){
		n = n * 2;
		if(n < 1){ return Math.pow(n, 2) / 2; }
		return -1 * ((--n) * (n - 2) - 1) / 2;
	},

	cubicIn: function(/* Decimal? */n){
		return Math.pow(n, 3);
	},

	cubicOut: function(/* Decimal? */n){
		return Math.pow(n - 1, 3) + 1;
	},

	cubicInOut: function(/* Decimal? */n){
		n = n * 2;
		if(n < 1){ return Math.pow(n, 3) / 2; }
		n -= 2;
		return (Math.pow(n, 3) + 2) / 2;
	},

	quartIn: function(/* Decimal? */n){
		return Math.pow(n, 4);
	},

	quartOut: function(/* Decimal? */n){
		return -1 * (Math.pow(n - 1, 4) - 1);
	},

	quartInOut: function(/* Decimal? */n){
		n = n * 2;
		if(n < 1){ return Math.pow(n, 4) / 2; }
		n -= 2;
		return -1 / 2 * (Math.pow(n, 4) - 2);
	},

	quintIn: function(/* Decimal? */n){
		return Math.pow(n, 5);
	},

	quintOut: function(/* Decimal? */n){
		return Math.pow(n - 1, 5) + 1;
	},

	quintInOut: function(/* Decimal? */n){
		n = n * 2;
		if(n < 1){ return Math.pow(n, 5) / 2; };
		n -= 2;
		return (Math.pow(n, 5) + 2) / 2;
	},

	sineIn: function(/* Decimal? */n){
		return -1 * Math.cos(n * (Math.PI / 2)) + 1;
	},

	sineOut: function(/* Decimal? */n){
		return Math.sin(n * (Math.PI / 2));
	},

	sineInOut: function(/* Decimal? */n){
		return -1 * (Math.cos(Math.PI * n) - 1) / 2;
	},

	expoIn: function(/* Decimal? */n){
		return (n == 0) ? 0 : Math.pow(2, 10 * (n - 1));
	},

	expoOut: function(/* Decimal? */n){
		return (n == 1) ? 1 : (-1 * Math.pow(2, -10 * n) + 1);
	},

	expoInOut: function(/* Decimal? */n){
		if(n == 0){ return 0; }
		if(n == 1){ return 1; }
		n = n * 2;
		if(n < 1){ return Math.pow(2, 10 * (n - 1)) / 2; }
		--n;
		return (-1 * Math.pow(2, -10 * n) + 2) / 2;
	},

	circIn: function(/* Decimal? */n){
		return -1 * (Math.sqrt(1 - Math.pow(n, 2)) - 1);
	},

	circOut: function(/* Decimal? */n){
		n = n - 1;
		return Math.sqrt(1 - Math.pow(n, 2));
	},

	circInOut: function(/* Decimal? */n){
		n = n * 2;
		if(n < 1){ return -1 / 2 * (Math.sqrt(1 - Math.pow(n, 2)) - 1); }
		n -= 2;
		return 1 / 2 * (Math.sqrt(1 - Math.pow(n, 2)) + 1);
	},

	backIn: function(/* Decimal? */n){
		// summary: An easing function that starts away from the target, and 
		//		quickly accelerates towards the end value
		var s = 1.70158;
		return Math.pow(n, 2) * ((s + 1) * n - s);
	},

	backOut: function(/* Decimal? */n){
		// summary: An easing function that pops past the range briefly, and 
		// 	slowly comes back. 
		n = n - 1;
		var s = 1.70158;
		return Math.pow(n, 2) * ((s + 1) * n + s) + 1;
	},

	backInOut: function(/* Decimal? */n){
		// summary: An easing function combining the effects of backIn and backOut
		var s = 1.70158 * 1.525;
		n = n * 2;
		if(n < 1){ return (Math.pow(n, 2) * ((s + 1) * n - s)) / 2; }
		n-=2;
		return (Math.pow(n, 2) * ((s + 1) * n + s) + 2) / 2;
	},

	elasticIn: function(/* Decimal? */n){
		// summary: An easing function the elastically snaps from the start value
		if(n == 0 || n == 1){ return n; }
		var p = .3;
		var s = p / 4;
		n = n - 1;
		return -1 * Math.pow(2, 10 * n) * Math.sin((n - s) * (2 * Math.PI) / p);
	},

	elasticOut: function(/* Decimal? */n){
		// summary: An easing function that elasticly snaps around the target value, near the end of the Animation
		if(n==0 || n == 1){ return n; }
		var p = .3;
		var s = p / 4;
		return Math.pow(2, -10 * n) * Math.sin((n - s) * (2 * Math.PI) / p) + 1;
	},

	elasticInOut: function(/* Decimal? */n){
		// summary: An easing function that elasticly snaps around the value, near the beginning and end of the Animation		
		if(n == 0) return 0;
		n = n * 2;
		if(n == 2) return 1;
		var p = .3 * 1.5;
		var s = p / 4;
		if(n < 1){
			n -= 1;
			return -.5 * (Math.pow(2, 10 * n) * Math.sin((n - s) * (2 * Math.PI) / p));
		}
		n -= 1;
		return .5 * (Math.pow(2, -10 * n) * Math.sin((n - s) * (2 * Math.PI) / p)) + 1;
	},

	bounceIn: function(/* Decimal? */n){
		// summary: An easing function that "bounces" near the beginning of an Animation
		return (1 - dojo.fx.easing.bounceOut(1 - n)); // Decimal
	},

	bounceOut: function(/* Decimal? */n){
		// summary: An easing function that "bounces" near the end of an Animation
		var s = 7.5625;
		var p = 2.75;
		var l; 
		if(n < (1 / p)){
			l = s * Math.pow(n, 2);
		}else if(n < (2 / p)){
			n -= (1.5 / p);
			l = s * Math.pow(n, 2) + .75;
		}else if(n < (2.5 / p)){
			n -= (2.25 / p);
			l = s * Math.pow(n, 2) + .9375;
		}else{
			n -= (2.625 / p);
			l = s * Math.pow(n, 2) + .984375;
		}
		return l;
	},

	bounceInOut: function(/* Decimal? */n){
		// summary: An easing function that "bounces" at the beginning and end of the Animation
		if(n < 0.5){ return dojo.fx.easing.bounceIn(n * 2) / 2; }
		return (dojo.fx.easing.bounceOut(n * 2 - 1) / 2) + 0.5; // Decimal
	}
};

}

if(!dojo._hasResource["dojox.widget.FisheyeLite"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.widget.FisheyeLite"] = true;
dojo.provide("dojox.widget.FisheyeLite");
dojo.experimental("dojox.widget.FisheyeLite");




dojo.declare("dojox.widget.FisheyeLite",
	dijit._Widget,
	{
	// summary:  A Light-weight Fisheye Component, or an exhanced version
	//		of dojo.fx.Toggler ... 
	//
	// description:
	//		A Simple FisheyeList-like widget which (in the interest of
	//		performance) relies on well-styled content for positioning,
	// 		and natural page layout for rendering.
	//
	//		use position:absolute/relative nodes to prevent layout
	//		changes, and use caution when seleting properties to
	//		scale. Negative scaling works, but some properties
	//		react poorly to being set to negative values, IE being
	//		particularly annoying in that regard.
	//
	//		quirk: uses the domNode as the target of the animation
	//		unless it finds a node class="fisheyeTarget" in the container
	//		being turned into a FisheyeLite instance
	//
	// example:
	//	|	// make all the LI's in a node Fisheye's:
	//	|   dojo.query("#node li").forEach(function(n){
	// 	|		new dojox.widget.FisheyeLite({},n);
	//	|	});
	//
	//
	// example:
	//	|	new dojox.widget.FisheyeLite({ 
	//	|		properties:{
	//	|			// height is literal, width is multiplied
	//	|			height:{ end: 200 }, width:2.3
	//	|		}
	//	|	}, "someNode");
	//
	// duationIn: Integer
	//		The time (in ms) the run the show animation
	durationIn: 350,
	
	// easeIn: Function
	//		An easing function to use for the show animation
	easeIn: dojo.fx.easing.backOut,
	
	// durationOut: Integer
	//		The Time (in ms) to run the hide animation
	durationOut: 1420,
	
	// easeOut: Function	
	// 		An easing function to use for the hide animation
	easeOut: dojo.fx.easing.elasticOut,

	//	properties: Object
	//			An object of "property":scale pairs, or "property":{} pairs.
	//			defaults to font-size with a scale of 2.75
	//			If a named property is an integer or float, the "scale multiplier"
	//			is used. If the named property is an object, that object is mixed
	//			into the animation directly. eg: height:{ end:20, unit:"em" }
	properties: null,
	
	// unit: String
	//		Sometimes, you need to specify a unit. Should be part of
	//		properties attrib, but was trying to shorthand the logic there
	unit:"px",
	
	constructor: function(props, node){
		this.properties = props.properties || {
			fontSize: 2.75
		}
	},
	
	postCreate: function(){
		
		this.inherited(arguments);
		this._target = dojo.query(".fisheyeTarget", this.domNode)[0] || this.domNode;
		this._makeAnims();
		
		this.connect(this.domNode, "onmouseover", "show");
		this.connect(this.domNode, "onmouseout", "hide");
		this.connect(this._target, "onclick", "onClick");

	},
	
	show: function(){
		// summary:
		//		Show this Fisheye item. 
		this._runningOut.stop();
		this._runningIn.play();
	},
	
	hide: function(){
		// summary:
		//		Hide this fisheye item on mouse leave
		this._runningIn.stop();
		this._runningOut.play();
	},
	
	_makeAnims: function(){
		// summary:
		//		Pre-generate the animations

		// create two properties: objects, one for each "state"
		var _in = {}, _out = {}, cs = dojo.getComputedStyle(this._target);
		for(var p in this.properties){
			var prop = this.properties[p],
				deep = dojo.isObject(prop),
				v = parseInt(cs[p])
			;
			// note: do not set negative scale for [a list of properties] for IE support
			// note: filter:'s are your own issue, too ;)
			// FIXME: this.unit here is bad, likely. d._toPixelValue ?
			_out[p] = { end: v, unit:this.unit };
			_in[p] = deep ? prop : { end: prop * v, unit:this.unit };
		}
		
		this._runningIn = dojo.animateProperty({
			node: this._target,
			easing: this.easeIn,
			duration: this.durationIn,
			properties: _in
		});
		
		this._runningOut = dojo.animateProperty({
			node: this._target,
			duration: this.durationOut,
			easing: this.easeOut,
			properties: _out
		});
		
		this.connect(this._runningIn, "onEnd", dojo.hitch(this, "onSelected", this));
	},
	
	onClick: function(/* Event */e){
		// summary: stub function fired when target is clicked
		//		connect or override to use.
	},
	
	onSelected: function(/* Object */e){
		// summary: stub function fired when Fisheye Item is fully visible and
		// 		hovered. connect or override use.
	}
	
});

}

if(!dojo._hasResource["dojox.form._FormSelectWidget"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.form._FormSelectWidget"] = true;
dojo.provide("dojox.form._FormSelectWidget");



/*=====
dojox.form.__SelectOption = function(){
	//	value: String
	//		The value of the option.  Setting to empty (or missing) will
	//		place a separator at that location
	//	label: String
	//		The label for our option.  It can contain html tags.
	//  selected: Boolean
	//		Whether or not we are a selected option
	//	disabled: Boolean
	//		Whether or not this specific option is disabled
	this.value = value;
	this.label = label;
	this.selected = selected;
	this.disabled = disabled;
}
=====*/

dojo.declare("dojox.form._FormSelectWidget", dijit.form._FormValueWidget, {
	// multiple: Boolean
	//		Matches the select's "multiple=" value
	multiple: "",
	
	// _multiValue: Boolean
	//		Whether or not we are multi-valued (for form)
	_multiValue: false,

	// options: dojox.form.__SelectOption[]
	//		The set of options for our select item.  Roughly corresponds to
	//      the html <option> tag.
	options: null,
	
	getOptions: function(/* anything */ valueOrIdx){
		// summary:
		//		Returns a given option (or options).
		// valueOrIdx:
		//		If passed in as a string, that string is used to look up the option
		//		in the array of options - based on the value property. 
		//		(See dojox.form.__SelectOption).
		//
		//		If passed in a number, then the option with the given index (0-based)
		//		within this select will be returned.
		//		
		//		If passed in a dojox.form.__SelectOption, the same option will be
		//		returned if and only if it exists within this select.
		//		
		//		If passed an array, then an array will be returned with each element
		//		in the array being looked up.
		//
		//		If not passed a value, then all options will be returned
		//
		// returns:
		//		The option corresponding with the given value or index.  null
		//		is returned if any of the following are true:
		//			- A string value is passed in which doesn't exist
		//			- An index is passed in which is outside the bounds of the array of options
		//			- A dojox.form.__SelectOption is passed in which is not a part of the select
		
		// NOTE: the compare for passing in a dojox.form.__SelectOption checks
		//		if the value property matches - NOT if the exact option exists
		// NOTE: if passing in an array, null elements will be placed in the returned
		//		array when a value is not found.
		var lookupValue = valueOrIdx, opts = this.options || [], l = opts.length;

		if(lookupValue === undefined){
			return opts; // dojox.form.__SelectOption[]
		}
		if(dojo.isArray(lookupValue)){
			return dojo.map(lookupValue, "return this.getOptions(item);", this); // dojox.form.__SelectOption[]
		}
		if(dojo.isObject(valueOrIdx)){
			// We were passed an option - so see if it's in our array (directly),
			// and if it's not, try and find it by value.
			if (!dojo.some(this.options, function(o, idx){
				if (o === lookupValue ||
					(o.value && o.value === lookupValue.value)){
					lookupValue = idx;
					return true;
				}
				return false;
			})){
				lookupValue = -1;
			}
		}
		if(typeof lookupValue == "string"){
			for(var i=0; i<l; i++){
				if(opts[i].value === lookupValue){
					lookupValue = i;
					break;
				}
			}
		}
		if(typeof lookupValue == "number" && lookupValue >= 0 && lookupValue < l){
			return this.options[lookupValue] // dojox.form.__SelectOption
		}
		return null; // null
	},
	
	addOption: function(/* dojox.form.__SelectOption, dojox.form.__SelectOption[] */ option){
		//	summary:
		//		Adds an option or options to the end of the select.  If value
		//		of the option is empty or missing, a separator is created instead.
		//		Passing in an array of options will yeild slightly better performance
		//		since the children are only loaded once.
		if(!dojo.isArray(option)){ option = [option]; }
		dojo.forEach(option, function(i){
			if(i && dojo.isObject(i)){
				this.options.push(i);
			}
		}, this);
		this._loadChildren();
	},
	
	removeOption: function(/* string, dojox.form.__SelectOption, number, or array */ valueOrIdx){
		// summary:
		//		Removes the given option or options.  You can remove by string 
		//		(in which case the value is removed), number (in which case the
		//		index in the options array is removed), or select option (in 
		//		which case, the select option with a matching value is removed).
		//		You can also pass in an array of those values for a slightly
		//		better performance since the children are only loaded once.
		if(!dojo.isArray(valueOrIdx)){ valueOrIdx = [valueOrIdx]; }
		var oldOpts = this.getOptions(valueOrIdx);
		dojo.forEach(oldOpts, function(i){
			this.options = dojo.filter(this.options, function(node, idx){
				return (node.value !== i.value);
			});
			this._removeOptionItem(i);
		}, this);
		this._loadChildren();
	},
	
	updateOption: function(/* dojox.form.__SelectOption, dojox.form.__SelectOption[] */ newOption){
		// summary:
		//		Updates the values of the given option.  The option to update
		//		is matched based on the value of the entered option.  Passing
		//		in an array of new options will yeild better performance since
		//		the children will only be loaded once.
		if(!dojo.isArray(newOption)){ newOption = [newOption]; }
		dojo.forEach(newOption, function(i){
			var oldOpt = this.getOptions(i), k;
			if(oldOpt){
				for(k in i){ oldOpt[k] = i[k]; }
			}
		}, this);
		this._loadChildren();
	},

	_setValueAttr: function(/*anything*/ newValue, /*Boolean, optional*/ priorityChange){
		// summary: set the value of the widget.
		// If a string is passed, then we set our value from looking it up.
		var opts = this.getOptions() || [];
		if(!dojo.isArray(newValue)){
			newValue = [newValue];
		}
		dojo.forEach(newValue, function(i, idx){
			if(!dojo.isObject(i)){
				i = i + "";
			}
			if(typeof i === "string"){
				newValue[idx] = dojo.filter(opts, function(node){
					return node.value === i;
				})[0] || {value: "", label: ""};
			}
		}, this);
		
		// Make sure some sane default is set
		newValue = dojo.filter(newValue, function(i){ return i && i.value; });
		if(!this._multiValue && (!newValue[0] || !newValue[0].value) && opts.length){
			newValue[0] = opts[0];
		}
		dojo.forEach(opts, function(i){
			i.selected = dojo.some(newValue, function(v){ return v.value === i.value; });
		});
		var val = dojo.map(newValue, function(i){ return i.value; }),
			disp = dojo.map(newValue, function(i){ return i.label; });
		
		this.value = this._multiValue ? val : val[0];
		this._setDisplay(this._multiValue ? disp : disp[0]);
		this._updateSelection();
		this._handleOnChange(this.value, priorityChange);
	},
	
	_getDisplayedValueAttr: function(){
		// summary: returns the displayed value of the widget
		var val = this.attr("value");
		if(!dojo.isArray(val)){
			val = [val];
		}
		var ret = dojo.map(this.getOptions(val), function(v){
			if(v && "label" in v){
				return v.label;
			}else if(v){
				return v.value;
			}
			return null;
		}, this);
		return this._multiValue ? ret : ret[0];
	},
	
	_getValueDeprecated: false, // remove when _FormWidget:getValue is removed
	getValue: function(){
		// summary: get the value of the widget.
		return this._lastValue;
	},

	undo: function(){
		// summary: restore the value to the last value passed to onChange
		this._setValueAttr(this._lastValueReported, false);
	},

	_loadChildren: function(){
		// summary: 
		//		Loads the children represented by this widget's optiosn.
		// reset the menu to make it "populatable on the next click
		dojo.forEach(this._getChildren(), function(child){
			child.destroyRecursive();
		});	
		// Add each menu item
		dojo.forEach(this.options, this._addOptionItem, this);
		
		// Update states
		this._updateSelection();
	},

	_updateSelection: function(){
		// summary:
		//		Sets the "selected" class on the item for styling purposes
		this.value = this._getValueFromOpts();
		var val = this.value;
		if(!dojo.isArray(val)){
			val = [val];
		}
		if(val && val[0]){
			dojo.forEach(this._getChildren(), function(child){
				var isSelected = dojo.some(val, function(v){
					return child.option && (v === child.option.value);
				});
				dojo.toggleClass(child.domNode, this.baseClass + "SelectedOption", isSelected);
				dijit.setWaiState(child.domNode, "selected", isSelected);
			}, this);
		}
		this._handleOnChange(this.value);
	},
	
	_getValueFromOpts: function(){
		// summary:
		//		Returns the value of the widget by reading the options for
		//		the selected flag
		var opts = this.getOptions() || [];
		if(!this._multiValue && opts.length){
			// Mirror what a select does - choose the first one
			var opt = dojo.filter(opts, function(i){
				return i.selected;
			})[0];
			if(opt && opt.value){
				return opt.value
			}else{
				opts[0].selected = true;
				return opts[0].value;
			}
		}else if(this._multiValue){
			// Set value to be the sum of all selected
			return dojo.map(dojo.filter(opts, function(i){
				return i.selected;
			}), function(i){
				return i.value;
			}) || [];
		}
		return "";
	},
	
	postMixInProperties: function(){
		this._multiValue = (this.multiple.toLowerCase() === "true");
		this.inherited(arguments);
	},
	
	_fillContent: function(){
		// summary:  
		//		Loads our options and sets up our dropdown correctly.  We 
		//		don't want any content, so we don't call any inherit chain
		//		function.
		var opts = this.options;
		if(!opts){
			opts = this.options = this.srcNodeRef ? dojo.query(">", 
						this.srcNodeRef).map(function(node){
							if(node.getAttribute("type") === "separator"){
								return { value: "", label: "", selected: false, disabled: false };
							}
							return { value: node.getAttribute("value"),
										label: String(node.innerHTML),
										selected: node.getAttribute("selected") || false,
										disabled: node.getAttribute("disabled") || false };
						}, this) : [];
		}
		if(!this.value){
			this.value = this._getValueFromOpts();
		}else if(this._multiValue && typeof this.value == "string"){
			this.value = this.value.split(",");
		}
	},

	postCreate: function(){
		// summary: sets up our event handling that we need for functioning
		//			as a select
		dojo.setSelectable(this.focusNode, false);
		this.inherited(arguments);

		// Make our event connections for updating state
		this.connect(this, "onChange", "_updateSelection");
		this.connect(this, "startup", "_loadChildren");
		
		this._setValueAttr(this.value, null);
	},
	
	_addOptionItem: function(/* dojox.form.__SelectOption */ option){
		// summary:
		//		User-overridable function which, for the given option, adds an 
		//		item to the select.  If the option doesn't have a value, then a 
		//		separator is added in that place.  Make sure to store the option
		//		in the created option widget.
	},
	
	_removeOptionItem: function(/* dojox.form.__SelectOption */ option){
		// summary:
		//		User-overridable function which, for the given option, removes
		//		its item from the select.
	},
	
	_setDisplay: function(/*String or String[]*/ newDisplay){
		// summary: Overridable function which will set the display for the 
		//			widget.  newDisplay is either a string (in the case of 
		//			single selects) or array of strings (in the case of multi-
		//			selects)
	},
	
	_getChildren: function(){
		// summary: Overridable function to return the children that this widget
		//			contains.
		return [];
	},
	
	_getSelectedOptionsAttr: function(){
		// summary: hooks into this.attr to provide a mechanism for getting the
		//			option items for the current value of the widget.
		return this.getOptions(this.attr("value"));
	}

});

}

if(!dojo._hasResource["dojox.form._HasDropDown"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.form._HasDropDown"] = true;
dojo.provide("dojox.form._HasDropDown");



dojo.declare("dojox.form._HasDropDown",
	null,
	{
		//	summary:
		//		Mixin for widgets that need drop down ability.
		//
		//	dropDownNode: DomNode
		//		responds to click events.  "dropDownNode" can be set via
		//		a dojoAttachPoint assignment.  If missing, then either focusNode
		//		or domNode (if focusNode is also missing) will be used.
		dropDownNode: null,
		
		//	popupStateNode: DomNode
		//		the node to set the popupActive class on.  If missing, then 
		//		focusNode or dropDownNode (if focusNode is missing) will be used.
		popupStateNode: null,
		
		//	aroundNode: DomNode
		//		the node to display the popup around.  If missing, then 
		//		domNode will be used.
		aroundNode: null,
		
		//	dropDown: Widget
		//		the widget to display in the popup.  This widget *must* be 
		//		defined before the startup function is called.
		dropDown: null,
		
		//	autoWidth: Boolean
		//		Set to true to make the drop down at least as wide as this 
		//		widget.  Set to false if the drop down should just be its
		//		default width
		autoWidth: true,
		
		//	_stopClickEvents: Boolean
		//		When set to false, the click events will not be stopped, in
		//		case you want to use them in your subwidget
		_stopClickEvents: true,
		
		_onMenuMouseup: function(/*Event*/ e){
			// summary: called with the mouseup event if the mouseup occurred
			//			over the menu.  You can try and use this event in
			//			order to automatically execute your dropdown (as
			//			if it were clicked).  You mightwant to close your menu 
			//			as a part of this function.
		},
		
		_onDropDownMouse: function(/*Event*/ e){
			// summary: callback when the user mouse clicks on menu popup node
			//
			// We handle mouse events using onmousedown in order to allow for
			// selecting via a drag.  So, our click is already handled, unless
			// we are executed via keypress - in which case, this._seenKeydown
			// will be set to true.			
			if(e.type == "click" && !this._seenKeydown){ return; }
			this._seenKeydown = false;
			
			// If we are a mouse event, set up the mouseup handler
			if(e.type == "mousedown"){
				this._docHandler = this.connect(dojo.doc, "onmouseup", "_onDropDownMouseup");
			}
			if(this.disabled || this.readOnly){ return; }
			if(this._stopClickEvents){
				dojo.stopEvent(e);
			}
			this.toggleDropDown();

			// If we are a click, then we'll pretend we did a mouse up
			if(e.type == "click" || e.type == "keypress"){
				this._onDropDownMouseup();
			}
		},

		_onDropDownMouseup: function(/*Event?*/ e){
			// summary: callback when the user lifts their mouse - if we are
			//			over the menu, we execute it, otherwise, we focus our 
			//			dropDown node.  If the event is missing, then we are not
			//			a mouseup event.
			if(e && this._docHandler){
				this.disconnect(this._docHandler);
			}
			var dropDown = this.dropDown, overMenu = false;
			
			if(e && this._opened){
				// Find out if our target is somewhere in our dropdown widget
				var t = e.target;
				while(t && !overMenu){
					if(dojo.hasClass(t, "dijitPopup")){
						overMenu = true;
					}else{
						t = t.parentNode;
					}
				}
				if(overMenu){
					this._onMenuMouseup(e);
					return;
				}
			}
			if(this._opened && dropDown.focus){
				// delay so that we don't steal our own focus.
				window.setTimeout(dojo.hitch(dropDown, "focus"), 1);
			}else{
				dijit.focus(this.focusNode);
			}
		},
		
		_setupDropdown: function(){
			//	summary:
			//		set up nodes and connect our mouse and keypress events
			this.dropDownNode = this.dropDownNode || this.focusNode || this.domNode;
			this.popupStateNode = this.popupStateNode || this.focusNode || this.dropDownNode;
			this.aroundNode = this.aroundNode || this.domNode;
			this.connect(this.dropDownNode, "onmousedown", "_onDropDownMouse");
			this.connect(this.dropDownNode, "onclick", "_onDropDownMouse");
			this.connect(this.dropDownNode, "onkeydown", "_onDropDownKeydown");
			this.connect(this.dropDownNode, "onblur", "_onDropDownBlur");
			this.connect(this.dropDownNode, "onkeypress", "_onKey");	
			
			// If we have a _setStateClass function (which happens when
			// we are a form widget), then we need to connect our open/close
			// functions to it
			if(this._setStateClass){
				this.connect(this, "openDropDown", "_setStateClass");
				this.connect(this, "closeDropDown", "_setStateClass");
			}
		},
		
		postCreate: function(){
			this._setupDropdown();
			this.inherited("postCreate", arguments);
		},
		
		startup: function(){
			dijit.popup.prepare(this.dropDown.domNode);
			this.inherited("startup", arguments);
		},
		
		destroyDescendants: function(){
			if(this.dropDown){
				this.dropDown.destroyRecursive();
				delete this.dropDown;
			}
			this.inherited("destroyDescendants", arguments);
		},

		_onDropDownKeydown: function(/*Event*/ e){
			this._seenKeydown = true;
		},
		
		_onKeyPress: function(/*Event*/ e){
			if(this._opened && e.charOrCode == dojo.keys.ESCAPE && !e.shiftKey && !e.ctrlKey && !e.altKey){
				this.toggleDropDown();
				dojo.stopEvent(e);
				return;
			}
			this.inherited(arguments);
		},

		_onDropDownBlur: function(/*Event*/ e){
			this._seenKeydown = false;
		},

		_onKey: function(/*Event*/ e){
			// summary: callback when the user presses a key on menu popup node
			if(this.disabled || this.readOnly){ return; }
			var d = this.dropDown;
			if(d && this._opened && d.handleKey){
				if(d.handleKey(e) === false){ return; }
			}
			if(d && this._opened && e.keyCode == dojo.keys.ESCAPE){
				this.toggleDropDown();
				return;
			}
			if(e.keyCode == dojo.keys.DOWN_ARROW){
				this._onDropDownMouse(e);
			}
		},

		_onBlur: function(){
			// summary: called magically when focus has shifted away from this widget and it's dropdown
			this.closeDropDown();
			// don't focus on button.  the user has explicitly focused on something else.
			this.inherited("_onBlur", arguments);
		},
		
		isLoaded: function(){
			// summary: returns whether or not the dropdown is loaded.  This can
			//		be overridden in order to force a call to loadDropDown().
			return true;
		},
		
		loadDropDown: function(/* Function */ loadCallback){
			// summary: loads the data for the dropdown, and at some point, calls
			//		the given callback
			loadCallback();
		},

		toggleDropDown: function(){
			// summary: toggle the drop-down widget; if it is up, close it, if not, open it
			if(this.disabled || this.readOnly){ return; }
			this.focus();
			var dropDown = this.dropDown;
			if(!dropDown){ return; }
			if(!this._opened){
				// If we aren't loaded, load it first so there isn't a flicker
				if(!this.isLoaded()){
					this.loadDropDown(dojo.hitch(this, "openDropDown"));
					return;
				}else{
					this.openDropDown();
				}
			}else{
				this.closeDropDown();
			}
		},
		
		openDropDown: function(){
			// summary: opens the dropdown for this widget - it returns the 
			//			return value of dijit.popup.open
			var dropDown = this.dropDown;
			var oldWidth=dropDown.domNode.style.width;
			var self = this;

			var retVal = dijit.popup.open({
				parent: this,
				popup: dropDown,
				around: this.aroundNode,
				orient:
					// TODO: add user-defined positioning option, like in Tooltip.js
					this.isLeftToRight() ? {'BL':'TL', 'BR':'TR', 'TL':'BL', 'TR':'BR'}
					: {'BR':'TR', 'BL':'TL', 'TR':'BR', 'TL':'BL'},
				onExecute: function(){
					self.closeDropDown(true);
				},
				onCancel: function(){
					self.closeDropDown(true);
				},
				onClose: function(){
					dropDown.domNode.style.width = oldWidth;
					dojo.attr(self.popupStateNode, "popupActive", false);
					dojo.removeClass(self.popupStateNode, "dojoxHasDropDownOpen");
					self._opened = false;
					self.state = "";
				}
			});
			if(this.autoWidth && this.domNode.offsetWidth > dropDown.domNode.offsetWidth){
				var adjustNode = null;
				if(!this.isLeftToRight()){
					adjustNode = dropDown.domNode.parentNode;
					var oldRight = adjustNode.offsetLeft + adjustNode.offsetWidth;
				}
				// make menu at least as wide as the node
				if(dropDown.resize){
					dropDown.resize({w: this.domNode.offsetWidth});
				}else{
					dojo.marginBox(dropDown.domNode, {w: this.domNode.offsetWidth});
				}
				if(adjustNode){
					adjustNode.style.left = oldRight - this.domNode.offsetWidth + "px";
				}
			}
			dojo.attr(this.popupStateNode, "popupActive", "true");
			dojo.addClass(self.popupStateNode, "dojoxHasDropDownOpen");
			this._opened=true;
			this.state="Opened";
			// TODO: set this.checked and call setStateClass(), to affect button look while drop down is shown
			return retVal;
		},
	
		closeDropDown: function(/*Boolean*/ focus){
			// summary: Closes the drop down on this widget
			if(this._opened){
				dijit.popup.close(this.dropDown);
				if(focus){ this.focus(); }
				this._opened = false;
				this.state = "";
			}
		}
		
	}
);

}

if(!dojo._hasResource["dojox.form.DropDownSelect"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.form.DropDownSelect"] = true;
dojo.provide("dojox.form.DropDownSelect");







dojo.declare("dojox.form.DropDownSelect", [dojox.form._FormSelectWidget, dojox.form._HasDropDown], {
	attributeMap: dojo.mixin(dojo.clone(dojox.form._FormSelectWidget.prototype.attributeMap),{value:"valueNode",name:"valueNode"}),
	// summary:
	//		This is a "Styleable" select box - it is basically a DropDownButton which
	//		can take as its input a <select>.

	baseClass: "dojoxDropDownSelect",
	
	templateString:"<table class='dijit dijitReset dijitInline dijitLeft'\n\tdojoAttachPoint=\"dropDownNode,tableNode\" cellspacing='0' cellpadding='0' waiRole=\"presentation\"\n\tdojoAttachEvent=\"onmouseenter:_onMouse,onmouseleave:_onMouse,onmousedown:_onMouse\"\n\t><tbody waiRole=\"presentation\"><tr waiRole=\"presentation\"\n\t\t><td class=\"dijitReset dijitStretch dijitButtonContents dijitButtonNode\" \n\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"  dojoAttachPoint=\"containerNode,popupStateNode\" id=\"${id}_label\"></span\n\t\t\t><input type=\"hidden\" ${nameAttrSetting} dojoAttachPoint=\"valueNode\" value=\"${value}\" />\n\t\t</td><td class=\"dijitReset dijitRight dijitButtonNode dijitArrowButton dijitDownArrowButton\" \n\t\t\t\tdojoAttachPoint=\"focusNode,titleNode\" waiRole=\"button\" waiState=\"haspopup-true,labelledby-${id}_label\"\n\t\t\t><div class=\"dijitReset dijitArrowButtonInner\">&thinsp;</div\n\t\t\t><div class=\"dijitReset dijitArrowButtonChar\" waiRole=\"presentation\">&#9660;</div\n\t\t></td\n\t></tr></tbody\n></table>\n",
	
	// attributeMap: Object
	//		Add in our style to be applied to the focus node
	attributeMap: dojo.mixin(dojo.clone(dojox.form._FormSelectWidget.prototype.attributeMap),{style:"tableNode"}),
	
	// required: Boolean
	//		Can be true or false, default is false.
	required: false,

	// state: String
	//		Shows current state (ie, validation result) of input (Normal, Warning, or Error)
	state: "",

	//	tooltipPosition: String[]
	//		See description of dijit.Tooltip.defaultPosition for details on this parameter.
	tooltipPosition: [],

	// emptyLabel: string
	//		What to display in an "empty" dropdown
	emptyLabel: "",
	
	// _isLoaded: boolean
	//		Whether or not we have been loaded
	_isLoaded: false,
	
	// _childrenLoaded: boolean
	//		Whether or not our children have been loaded
	_childrenLoaded: false,
	
	_fillContent: function(){
		// summary:  
		//		Set the value to be the first, or the selected index
		this.inherited(arguments);
		if(this.options.length && !this.value){
			var si = this.srcNodeRef.selectedIndex;
			this.value = this.options[si != -1 ? si : 0].value;
		}
		
		// Create the dropDown widget
		this.dropDown = new dijit.Menu();
		dojo.addClass(this.dropDown.domNode, this.baseClass + "Menu");
	},

	_getMenuItemForOption: function(/* dojox.form.__SelectOption */ option){
		// summary:
		//		For the given option, return the menu item that should be
		//		used to display it.  This can be overridden as needed
		if(!option.value){
			// We are a separator (no label set for it)
			return new dijit.MenuSeparator();
		}else{
			// Just a regular menu option
			var click = dojo.hitch(this, "_setValueAttr", option);
			return new dijit.MenuItem({
				option: option,
				label: option.label,
				onClick: click,
				disabled: option.disabled || false
			});
		}
	},

	_addOptionItem: function(/* dojox.form.__SelectOption */ option){
		// summary:
		//		For the given option, add a option to our dropdown
		//		If the option doesn't have a value, then a separator is added 
		//		in that place.
		this.dropDown.addChild(this._getMenuItemForOption(option));
	},

	_getChildren: function(){ return this.dropDown.getChildren(); },
	
	_loadChildren: function(){
		// summary: 
		//		Resets the menu and the length attribute of the button - and
		//		ensures that the label is appropriately set.
		this.inherited(arguments);
		var len = this.options.length;
		this._isLoaded = false;
		this._childrenLoaded = true;
		
		// Set our length attribute and our value
		if(!this._iReadOnly){
			this.attr("readOnly", (len === 1));
			delete this._iReadOnly;
		}
		if(!this._iDisabled){
			this.attr("disabled", (len === 0));
			delete this._iDisabled;
		}
		this._setValueAttr(this.value);
	},
	
	_setValueAttr: function(value){
		this.inherited(arguments);
		dojo.attr(this.valueNode, "value", this.attr("value"));
	},
	
	_setDisplay: function(/*String*/ newDisplay){
		// summary: sets the display for the given value (or values)
		this.containerNode.innerHTML = '<span class=" ' + this.baseClass + 'Label">' +
					(newDisplay || this.emptyLabel || "&nbsp;") +
					'</span>';
		this._layoutHack();
	},

	validate: function(/*Boolean*/ isFocused){
		// summary:
		//		Called by oninit, onblur, and onkeypress.
		// description:
		//		Show missing or invalid messages if appropriate, and highlight textbox field.
		var isValid = this.isValid(isFocused);
		this.state = isValid ? "" : "Error";
		this._setStateClass();
		dijit.setWaiState(this.focusNode, "invalid", isValid ? "false" : "true");
		var message = isValid ? "" : this._missingMsg;
		if(this._message !== message){
			this._message = message;
			dijit.hideTooltip(this.domNode);
			if(message){
				dijit.showTooltip(message, this.domNode, this.tooltipPosition);
			}
		}
		return isValid;		
	},

	isValid: function(/*Boolean*/ isFocused){
		// summary: Whether or not this is a valid value
		return (!this.required || !(/^\s*$/.test(this.value)));
	},
	
	reset: function(){
		// summary: Overridden so that the state will be cleared.
		this.inherited(arguments);
		dijit.hideTooltip(this.domNode);
		this.state = "";
		this._setStateClass();
		delete this._message;
	},

	postMixInProperties: function(){
		// summary: set the missing message
		this.inherited(arguments);
		this._missingMsg = dojo.i18n.getLocalization("dijit.form", "validate", 
									this.lang).missingMessage;
	},
	
	postCreate: function(){
		this.inherited(arguments);
		if(dojo.attr(this.srcNodeRef, "disabled")){
			this.attr("disabled", true);
		}
		if(this.tableNode.style.width){
			dojo.addClass(this.domNode, this.baseClass + "FixedWidth");
		}
	},

	startup: function(){
		if(this._started){ return; }

		// the child widget from srcNodeRef is the dropdown widget.  Insert it in the page DOM,
		// make it invisible, and store a reference to pass to the popup code.
		if(!this.dropDown){
			var dropDownNode = dojo.query("[widgetId]", this.dropDownContainer)[0];
			this.dropDown = dijit.byNode(dropDownNode);
			delete this.dropDownContainer;
		}
		this.inherited(arguments);
	},
	
	_onMenuMouseup: function(e){
		// override this to actually "pretend" to do a click on our menu - it will
		// call onExecute - so it will close our popup for us.  For non-menu
		// popups, it will not execute.
		var dropDown = this.dropDown, t = e.target;
		
		if(dropDown.onItemClick){
			var menuItem;
			while(t && !(menuItem = dijit.byNode(t))){
				t = t.parentNode;
			}
			if(menuItem && menuItem.onClick && menuItem.getParent){
				menuItem.getParent().onItemClick(menuItem, e);
			}
		}
		// TODO: how to handle non-menu popups?
	},

	isLoaded: function(){
		return this._isLoaded;
	},
	
	loadDropDown: function(/* Function */ loadCallback){
		// summary: populates the menu
		this._loadChildren();
		this._isLoaded = true;
		loadCallback();
	},
	
	_setReadOnlyAttr: function(value){
		this._iReadOnly = value;
		if(!value && this._childrenLoaded && this.options.length === 1){
			return;
		}
		this.readOnly = value;
	},
	
	_setDisabledAttr: function(value){
		this._iDisabled = value;
		if(!value && this._childrenLoaded && this.options.length === 0){
			return;
		}
		this.inherited(arguments);
	},

	uninitialize: function(preserveDom){
		if(this.dropDown){
			this.dropDown.destroyRecursive(preserveDom);
			delete this.dropDown;
		}
		this.inherited(arguments);
	}
});

}

if(!dojo._hasResource["widgets.Button"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.Button"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.Button");



dojo.declare(
	"widgets.Button",
	[dijit.form.Button],
	{
		templateString:"<div class=\"dijit dijitLeft dijitInline dijitButton\"\n\tdojoAttachEvent=\"onclick:_onButtonClick,onmouseenter:_onMouse,onmouseleave:_onMouse,onmousedown:_onMouse\">\n\t<div class='dijitRight'>\n\t\t<div dojoAttachPoint=\"btnCtr\" class=\"ButtonContainer\">\n\t\t\t<div dojoAttachPoint=\"btnCtrTop\" class=\"ButtonContainerTop\">\t\n\t\t\t\t<div class=\"ButtonContainerTopLeft\"></div>\n\t\t\t\t<div class=\"ButtonContainerTopMiddle\">\n\t\t\t\t\t<div class=\"ButtonContent\" dojoAttachPoint=\"ButtonContentNode\">\n\t\t\t\t\t\t<button class=\"dijitStretch dijitButtonNode dijitButtonContents\" dojoAttachPoint=\"focusNode,titleNode\"\n\t\t\t\t\t\t\ttype=\"${type}\" title=\"${title}\" tabindex=\"${tabindex}\" waiRole=\"button\" waiState=\"labelledby-${id}_label\"\n\t\t\t\t\t\t\t><span class=\"dijitInline ${iconClass}\" dojoAttachPoint=\"iconNode\" \n\t\t\t\t \t\t\t\t><span class=\"dijitToggleButtonIconChar\">&#10003</span \n\t\t\t\t\t\t\t></span\n\t\t\t\t\t\t\t><span class=\"dijitButtonText\" id=\"${id}_label\" dojoAttachPoint=\"containerNode\">${label}</span\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t</button\n\t\t\t\t\t>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div dojoAttachPoint=\"btnCtrBottom\" class=\"ButtonContainerBottom\">\t\n\t\t\t\t<div dojoAttachPoint=\"btnCtrBottomLeft\" class=\"ButtonContainerBottomLeft\"></div>\n\t\t\t\t<div class=\"ButtonContainerBottomMiddle\"></div>\n\t\t\t</div>\n\t\t</div>\n\t</div\n></div>\n",

		tabindex: "0",
		title: "",
		type: "button",
		
		postCreate: function(){
			this.inherited(arguments);
			if (!this.isLeftToRight()) {
/*				dojo.removeClass(this.btnCtrBottom, "ButtonContainerBottom");
				dojo.addClass(this.btnCtrBottom, "ButtonContainerBottom_rtl");
				dojo.removeClass(this.btnCtrBottomLeft, "ButtonContainerBottomLeft");
				dojo.addClass(this.btnCtrBottomLeft, "ButtonContainerBottomLeft_rtl"); */
			}
//			this.adjustButtonWidth();
		},
		
		startup: function() {
			this.inherited(arguments);
			this.adjustButtonWidth();
		},
		
		// adjustButtonWidth - set the button's bottom width to the buttonContainer's clientWidth
		adjustButtonWidth: function() {
			var buttonContainer = this.btnCtr;
			var buttonContainerBottom = this.btnCtrBottom;
			
			if (buttonContainer && buttonContainerBottom && (buttonContainer.clientWidth != 0)) {
				buttonContainerBottom.style.width = buttonContainer.clientWidth; 
				//for IE7, adjusting OK button's layout
				if(dojo.isIE<=7){
					var buttonContainerTop =  this.btnCtrTop;
					buttonContainerTop.style.width = buttonContainer.clientWidth;
					dojo.attr(this.ButtonContentNode,"align","center");
				}
			}
		},
		
		setButtonWidth: function(width) {
			dojo.byId(this.id).style.width = width + "px";
			var buttonContainerBottom = this.btnCtrBottom;
			buttonContainerBottom.style.width = width + 10 + "px";
		}
	}
);

}

if(!dojo._hasResource["widgets.Moveable"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.Moveable"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.Moveable");



dojo.declare("widgets.Moveable",
dojo.dnd.Moveable,
{
	onMove: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop){
		this.onMoving(mover, leftTop);
		var s = mover.node.style;
		var ltt = leftTop.t;
		var ltl = leftTop.l;
		var bodyWidth = dojo.body().clientWidth;
		var bodyHeight = dojo.body().clientHeight;
		
		if(0 < ltt && ltt < bodyHeight - 20) {
			s.top  = ltt + "px";
		} else if (ltt < 0) {
			s.top = "0px";
		} else {
			s.top = bodyHeight - 20 + "px"; 
		}
		if(0 < ltl && ltl < bodyWidth - 20) {
			s.left = ltl + "px";
		} else if(ltl < 0) {
			s.left = "0px";
		} else {
			s.left = bodyWidth - 20 + "px";
		}
		this.onMoved(mover, leftTop);
	}	
}
);

}

if(!dojo._hasResource["widgets.customDialog"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.customDialog"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.customDialog");





/*
 * This class was created so that we could have a common look-and-feel
 * for all dialogs in the product.  This should be used instead of 
 * dijit.Dialog.  It also adds a property to the standard dijit.Dialog
 * class called isClosable.  Setting this property to false when the 
 * dialog is declared in HTML will prevent the close button from appearing
 * in the title bar.
 */
dojo.declare(
	"widgets.customDialog",
	dijit.Dialog,
	{		
		templateString: null,		
		templateString:"<div class=\"dijitDialog customDialog_portlet\">\n\t\t\n\t<div class=\"customDialog_header\" dojoAttachPoint=\"titleBar\" waiRole=\"dialog\">\n\n\t\t<div class=\"customDialog_top\">\n\t\t\t<div class=\"customDialog_left\"></div>\n\t\t\t<div class=\"customDialog_middle\" dojoAttachPoint=\"titleNode\">\n\t\t\t\t<div class=\"customDialog_title\" dojoAttachPoint=\"titleTextNode\">${title}</div>\t\t\t\t\n\t\t\t\t<div dojoAttachPoint=\"closeButtonNode\" class=\"closeIcon\">\n\t\t\t\t\t<a class=\"customDialog_link\" href=\"javascript:;\">\n\t\t\t\t\t\t<img dojoAttachPoint=\"closeButtonImgNode\" src=\"${imgBasePath}title_close16.png\" alt=\"${messages_close}\"/>\n\t\t\t\t\t</a>\n\t\t\t\t\t<span dojoAttachPoint=\"closeText\" class=\"closeText\">x</span>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\n\t\t<div class=\"customDialog_bottom\">\n\t\t\t<div class=\"customDialog_left\"></div>\n\t\t \t<div class=\"customDialog_middle\"></div>\n\t\t</div>\n\t\n\t</div>\n\t\n\t<div class=\"contentOuter\" dojoAttachPoint=\"containerOuter\">\n\t\t<div dojoAttachPoint=\"containerNode\" style=\"position:relative;overflow:hidden;\"></div>\n\t</div>\n\t\t\t\n\t<div class=\"customDialog_buttonBar\" dojoAttachPoint=\"buttonBarNode\">\t\n\t\t<div class=\"customDialog_left\"></div>\n\t\t<div class=\"customDialog_middle\">\n\t\t\t<div class=\"customDialog_buttons\" dojoAttachPoint=\"buttonNode\">\t\n\t\t\t\t<span dojoAttachPoint=\"customButton2NodeParent\"><div tabindex=\"0\" dojoType=\"widgets.Button\" showAsGray=\"false\" dojoAttachPoint=\"customButton2Node\"></div></span>\t\n\t\t\t\t<span dojoAttachPoint=\"customButtonNodeParent\"><div tabindex=\"0\" dojoType=\"widgets.Button\" showAsGray=\"false\" dojoAttachPoint=\"customButtonNode\"></div></span>\t\n\t\t\t\t<span dojoAttachPoint=\"okButtonNodeParent\"><div tabindex=\"0\" dojoType=\"widgets.Button\" showAsGray=\"false\" dojoAttachPoint=\"okButtonNode\"></div></span>\t\n\t\t\t\t<span dojoAttachPoint=\"cancelButtonNodeParent\"><div tabindex=\"0\" dojoType=\"widgets.Button\" showAsGray=\"false\" dojoAttachPoint=\"cancelButtonNode\"></div></span>\n\t\t\t</div>\t\n\t\t</div>\n\t</div>\n\t\n\t<div class=\"customDialog_footer\" dojoAttachPoint=\"altFooterNode\" style=\"display:none\">\t\n\t\t<div class=\"customDialog_left\"></div>\n\t\t<div class=\"customDialog_middle\"></div>\n\t</div>\n\t\n</div>\n",		
		widgetsInTemplate: true,
		imgBasePath: EDR.config.imageBaseDir,
		
		closable: true,		
		
		// ID of the element that should receive focus on open
		showCancel: true,		
		showOk: true,
		showCustom: false,
		showCustom2: false,
		showButtonBar: true,
		
//		firstFocusId: "",				

		cancelButtonLabel: "",
//		cancelButtonId: "",
		cancelButtonWidget: null,
		customButtonLabel: "",
		customButtonTitle: "",
//		customButtonId: "",
		customButtonFunction: function(){},

		customButton2Label: "",
//		customButton2Id: "",
		customButton2Title: "",
		customButton2Function: function(){},
		cancelFunction: function() {
			this._onCancel();
			this.close();
		},
				
		okButtonLabel: "",		
//		okButtonId: "",		
		okFunction: function() {
			this._onOk();
			this.close();
//			this.onExecute();
		},		
		okButtonHandle: null,//Array
		okButtonWidget: null,
		
		duration: 500,
		
		postCreate: function() {
			// Call the parent function
			this.inherited("postCreate", arguments);
			
			this.okButtonHandle = [];			
			this.okButtonWidget = this._supportingWidgets[2];
			this.cancelButtonWidget = this._supportingWidgets[3];
			
			if (!this.closable) {
				this.closeButtonNode.style.display = "none";
				// this.cancelButtonNodeParent.style.display = "none"; // IMPORTANT!  Using display=none causes FF to dismiss line-height
			}		
			
			if (this.draggable) {
				this.titleNode.style.cursor = "move";
			}
			
			// Set button IDs
			// if (this.cancelButtonId != "") this.cancelButtonNode.titleNode.id = this.cancelButtonId; 
			// if (this.okButtonId != "") this.okButtonNode.titleNode.id = this.okButtonId;
			// if (this.customButtonId != "") this.customButtonNode.titleNode.id = this.customButtonId;
			
			// Set button labels
			this.cancelButtonNode.setLabel((this.cancelButtonLabel == "" ? EDR.messages.K0001I_COMMON_CANCEL : this.cancelButtonLabel));		
			this.okButtonNode.setLabel((this.okButtonLabel == "" ? EDR.messages.K0001I_COMMON_OK : this.okButtonLabel));
			this.customButtonNode.setLabel((this.customButtonLabel == "" ? EDR.messages.K0001I_COMMON_OK : this.customButtonLabel));
			this.customButton2Node.setLabel((this.customButton2Label == "" ? EDR.messages.K0001I_COMMON_OK : this.customButton2Label));
	
			// Set tooltip text
			this.closeButtonNode.title = EDR.messages.K0001I_COMMON_CLOSE;
			this.cancelButtonNode.titleNode.title = this.cancelButtonLabel == "" ? EDR.messages.K0001I_COMMON_CANCEL : this.cancelButtonLabel;		
			this.okButtonNode.titleNode.title = this.okButtonLabel == "" ? EDR.messages.K0001I_COMMON_OK : this.okButtonLabel;
			this.customButtonNode.titleNode.title = this.customButtonTitle == "" ? (this.customButtonLabel == "" ? EDR.messages.K0001I_COMMON_OK : this.customButtonLabel) : this.customButtonTitle;
			this.customButton2Node.titleNode.title = this.customButton2Title == "" ? (this.customButton2Label == "" ? EDR.messages.K0001I_COMMON_OK : this.customButton2Label) : this.customButton2Title;
			
			if (this.showButtonBar) {
				
				// Wire up cancel click event
				/* CJH - this is not needed and caused the hide() function to be called twice */
				if (this.showCancel) {
					dojo.connect(this.cancelButtonNode, "onClick", this, this.cancelFunction);		
				}
				
				// Disable the ok button if necessary
				if (this.showOk) {
					this.okButtonHandle = dojo.connect(this.okButtonNode, "onClick", this, this.okFunction);
				} else {
					this.okButtonNode.domNode.style.display = "none"; // IMPORTANT!  Using display=none causes FF to dismiss line-height	
				}
				
				// Disable the custom button if necessary 
				if (this.showCustom) {
					dojo.connect(this.customButtonNode, "onClick", this, this.customButtonFunction);
				} else {
					this.customButtonNode.domNode.style.display = "none"; // IMPORTANT!  Using display=none causes FF to dismiss line-height						
				}	
				
				// Disable the second custom button if necessary 
				if (this.showCustom2) {
					dojo.connect(this.customButton2Node, "onClick", this, this.customButton2Function);
				} else {
					this.customButton2Node.domNode.style.display = "none"; // IMPORTANT!  Using display=none causes FF to dismiss line-height						
				}	
				
			} else {
				this.buttonBarNode.style.display = "none";
				this.altFooterNode.style.display = "block";
			}
		},
		
		_onSubmit: function() {
		},
		
		startup: function() {
			this.inherited(arguments);
			
			// fit to content divs			
			var maxWidth = 0;
			dojo.forEach(dojo.query("> DIV", this.containerNode), function(div) {
				var size = dojo.marginBox(div);
				maxWidth = Math.max(maxWidth, size.w);
			});
			dojo.marginBox(this.containerOuter, {w:maxWidth+2});
			dojo.marginBox(this.buttonBarNode, {w:maxWidth+2});
			dojo.marginBox(this.titleBar, {w:maxWidth+2});
		},
		
		show: function() {
			this.inherited(arguments);
			this.containerNode.style.width = "100%";
			this.containerNode.style.height = "100%";
			
			var childWidgets = this.getChildren();
			if(childWidgets && childWidgets.length == 1) {
				var child = childWidgets[0];
				if(child && child._onDialogShow) {
					child._onDialogShow();
				}
			}
		},
		
		hide: function() {
			EDR.dialog.util.hide(this);
		},
		
		_onCancel: function() {
			var childWidgets = this.getChildren();
			if(childWidgets && childWidgets.length == 1) {
				var child = childWidgets[0];
				if(child && child._onDialogHide) {
					child._onDialogHide();
				}
			}	
		},
		
		_onOk: function() {
			var childWidgets = this.getChildren();
			if(childWidgets && childWidgets.length == 1) {
				var child = childWidgets[0];
				if(child && child._onDialogOk) {
					child._onDialogOk();
				}
			}	
		},		
		
		enableKeyhandler: function() {
			this._modalconnects.push(dojo.connect(dojo.doc.documentElement, "onkeypress", this, "_onKey"));		
		},
		
		disableKeyHandler: function() {
			dojo.disconnect(this._modalconnects[this._modalconnects.length-1]);
		},
		
		close: function() {
			this.hide();
		},
		
		// override
		_setup: function() {
			this.inherited(arguments);
			if(this.draggable) {
				this._moveable.destroy();
				this._moveable = new widgets.Moveable(this.domNode, { handle: this.titleBar, timeout: 0 });				
			}
		},
		
		setWidth: function(width) {
			dojo.marginBox(this.containerOuter, {w:width+2});
			dojo.marginBox(this.buttonBarNode, {w:width+2});
			dojo.marginBox(this.titleBar, {w:width+2});
		},
		
		messages_close: EDR.messages.K0001I_COMMON_CLOSE
	}
);

}

if(!dojo._hasResource["widgets.Banner"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.Banner"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.Banner");




dojo.declare(
	"widgets.Banner",
	[dijit.layout._LayoutWidget, dijit._Templated],
	{
		config_banner_file: EDR.config.banner_file,
		
		"class": "Banner",
				
		templateString: null,
		
		loginId: "",
		loginIdLabel: "",
		productName: "",
		isFacetedSearch: false,
		isLoggedIn: true,
		collections: "",
		collectionIds: "",
		fontStyle: "font-size:13px;",
		limitWidthForCollections: 80,
		limitWidthForUserName: 80,
		
		messages_banner_collection : EDR.messages.banner_collection,
		messages_banner_collection_change : EDR.messages.banner_collection_change,
		messages_banner_collection_change_tooltip: EDR.messages.banner_collection_change_tooltip,
		
		templateString:"<div class=\"Banner\">\n\t<div class=\"BannerGroup\">\n\t\t<div class=\"BannerLeft\"></div>\n\t\t<div class=\"BannerCenter\">\n\t\t\t<div class=\"BannerContent\">\t\t\t\t\n\t\t\t\t<div class=\"BannerLogo\"><img src=\"${config_banner_file}\" alt=\"\"/></div>\t\n\t\t\t\t<div class=\"BannerProductName\" dojoAttachPoint=\"productNameNode\">${productName}</div>\n\t\t\t\t<div class=\"BannerNav\" dojoAttachPoint=\"containerNode\"></div>\n\t\t\t\t<div class=\"BannerLoginId\" dojoAttachPoint=\"loginIdNode\" style=\"display:none;\">\n\t\t\t\t\t<span>${loginIdLabel}</span>&nbsp;<span dojoAttachPoint=\"userNameNode\">${loginId}</span>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"BannerCollections\" dojoAttachPoint=\"collectionNode\"  style=\"display:none;\">\n\t\t\t\t\t<span>${messages_banner_collection}:&nbsp;</span><span dojoAttachPoint=\"bannerCollectionsDisplay\">${collections}</span>\n\t\t\t\t\t(<a dojoAttachPoint=\"changeLinkNode\" href=\"javascript:;\"\n\t\t\t\t\t\ttitle=\"${messages_banner_collection_change_tooltip}\">${messages_banner_collection_change}</a>)\n\t\t\t\t</div>\n\t\t\t\t<span dojoAttachPoint=\"hiddenSpan\" style=\"${fontStyle}visibility:hidden;position:absolute;\"></span>\n \t\t\t</div>\t\t\t\n\t\t</div>\n\t</div>\n</div>\n",
		
		postCreate: function() {
			if (this.loginId != "" && this.loginIdLabel != "") {
				if(!EDR.isPortlet) {
					this.loginIdNode.style.display = "block";
				} else {
					this.limitWidthForCollections = 320;
				}
				this.collectionNode.style.display = "block";
			}
			this.userNameNode.title = this.loginId;
			this.userNameNode.innerHTML = this._getTruncatedLabel(this.loginId,this.limitWidthForUserName);
			this.bannerCollectionsDisplay.title = this.collections;
			this.bannerCollectionsDisplay.innerHTML = this._getTruncatedLabel(this.collections,this.limitWidthForCollections);
			this.changeLinkNode.onclick = function(){
				var dlg = dijit.byId(EDR.prefix+"preference");
				if(!dlg) {
					dojo.parser.parse(EDR.prefix+"preference-Container");
					dlg = dijit.byId(EDR.prefix+"preference");
				}
				dlg.showTab(EDR.prefix+"searchOptionsTab");
				EDR.dialog.util.show(dlg);
			};
		},
		
		_getTruncatedLabel: function(item, width) {
			var label = item + ""/*hack: object2string*/; 
			if (this._getStringExtent(label) < width) {
				return label;
			} else {
				var ellipse = "...";
				var labelWidth = width - this._getStringExtent(ellipse);
				if (labelWidth > 0) { 	
					for (var i=0; i<label.length; i++) {
						var s = label.slice(0, i);
						if (labelWidth < this._getStringExtent(s) && i > 0) {
							return label.slice(0, i-1) + ellipse;
						}
			}
		}
				return ellipse;
			}
		},
		
		_getStringExtent: function(str) {
			this.hiddenSpan.innerHTML = str;
			var size = this.hiddenSpan.offsetWidth;
			this.hiddenSpan.innerHTML = "";
			return size;
		},
		
		setCollections: function(json, isFacetedSearch){
			var collectionsStr = json.collectionLabels;
			var collectionIds = json.collectionIds;
			var isChanged = false;
			if (this.isFacetedSearch == null || this.isFacetedSearch != isFacetedSearch) isChanged = true;
			if (this.collectionIds != null && this.collectionIds != collectionIds) isChanged = true;
			this.collections = collectionsStr;
			this.collectionIds = collectionIds;
			this.isFacetedSearch = isFacetedSearch;
			this.bannerCollectionsDisplay.title = collectionsStr;
			this.bannerCollectionsDisplay.innerHTML = this._getTruncatedLabel(collectionsStr,this.limitWidthForCollections);
			return isChanged;
		},
		
		resize: function(){
			var width = this.domNode.clientWidth;
			var w = ((width-1000)> 0) ? (width-1000) : 0;
			var collectionMargin = w*0.25 + 20;
			dojo.style(this.collectionNode,"marginRight",collectionMargin+"px");
			if(!EDR.isPortlet) {
				this.limitWidthForCollections = w*0.25 +30;	
			} else {
			}
			
			this.bannerCollectionsDisplay.innerHTML = this._getTruncatedLabel(this.collections,this.limitWidthForCollections);
			this.userNameNode.innerHTML = this._getTruncatedLabel(this.loginId,this.limitWidthForCollections);
		}
	}
);

}

if(!dojo._hasResource["widgets.Toolbar"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.Toolbar"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.Toolbar");



dojo.declare(
	"widgets.Toolbar",
	[dijit.Toolbar],
	{
		templateString: null,		
		templateString:"<div class=\"dijit dijitToolbar ToolbarContainer\" waiRole=\"toolbar\">\n\t<div class=\"ToolbarContainerTop\">\t\n\t\t<div class=\"ToolbarContainerTopLeft\"></div>\n\t\t<div class=\"ToolbarContainerTopMiddle\"></div>\n\t</div>\n\t<div class=\"ToolbarContainerMiddle\">\n\t\t<div class=\"ToolbarContainerMiddleLeft\"></div>\n\t\t<div class=\"ToolbarContainerMiddleMiddle\">\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t<div class=\"ToolbarContent\">\n\t\t\t\t<div dojoAttachPoint=\"containerNode\"></div>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\t<div class=\"ToolbarContainerBottom\">\t\n\t\t<div class=\"ToolbarContainerBottomLeft\"></div>\n\t\t<div class=\"ToolbarContainerBottomMiddle\"></div>\n\t</div>\n</div>\n",
		
		postCreate: function() {
		},

		startup: function(){
			if(this._started){ return; }
			dijit.Toolbar.superclass.postCreate.apply(this,arguments);
		}
		
		/*
		focusNext: function() {
			// summary: Focus the next widget or focal node (for widgets
			//		with multiple focal nodes) within this container.
			if(this.focusedChild && this.focusedChild.hasNextFocalNode
					&& this.focusedChild.hasNextFocalNode()){
				this.focusedChild.focusNext();
				return;
			}
			var child = this._getNextFocusableChild(this.focusedChild, 1);
			if (child) {
				if(child.getFocalNodes){
					this.focusChild(child, child.getFocalNodes()[0]);
				} else {
					this.focusChild(child);
				}	
			} 
		},
		
		focusPrev: function(){
			// summary: Focus the previous widget or focal node (for widgets
			//		with multiple focal nodes) within this container.
			if(this.focusedChild && this.focusedChild.hasPrevFocalNode
					&& this.focusedChild.hasPrevFocalNode()){
				this.focusedChild.focusPrev();
				return;
			}
			var child = this._getNextFocusableChild(this.focusedChild, -1);
			if (child) {
				if(child.getFocalNodes){
					var nodes = child.getFocalNodes();
					this.focusChild(child, nodes[nodes.length-1]);
				} else {
					this.focusChild(child);
				}	
			}
		} */
	}
);

}

if(!dojo._hasResource["widgets.InlineEditBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.InlineEditBox"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.InlineEditBox");



dojo.declare(
	"widgets.InlineEditBox",
	dijit.InlineEditBox,
	{
		
		onCancel: function(value){
			// summary: User should set this handler to be notified of changes to value
		},
		
		postCreate: function() {
		
			// Call the parent function
			this.inherited("postCreate", arguments);			
			
			// Force edit to occur 
			this._edit();
						
		},
			
		_onMouseOver: function(){
			dojo.addClass(this.displayNode, this.disabled ? "disabledInlineEditorHover" : "enabledInlineEditorHover");
		},
	
		_onMouseOut: function(){
			dojo.removeClass(this.displayNode, this.disabled ? "disabledInlineEditorHover" : "enabledInlineEditorHover");
		},
		
		_edit: function(){
			// summary: display the editor widget in place of the original (read only) markup
	
			this.editing = true;
	
			var editValue = 
					(this.renderAsHtml ?
					this.value :
					this.value.replace(/\s*\r?\n\s*/g,"").replace(/<br\/?>/gi, "\n").replace(/&gt;/g,">").replace(/&lt;/g,"<").replace(/&amp;/g,"&"));
	
			// Placeholder for edit widget
			// Put place holder (and eventually editWidget) before the display node so that it's positioned correctly
			// when Calendar dropdown appears, which happens automatically on focus.
			var placeholder = document.createElement("span");
			dojo.place(placeholder, this.domNode, "before");
	
			var ew = this.editWidget = new widgets._InlineEditor({
				value: dojo.trim(editValue),
				autoSave: this.autoSave,
				buttonSave: this.buttonSave,
				buttonCancel: this.buttonCancel,
				renderAsHtml: this.renderAsHtml,
				editor: this.editor,
				editorParams: this.editorParams,
				style: dojo.getComputedStyle(this.displayNode),
				save: dojo.hitch(this, "save"),
				cancel: dojo.hitch(this, "cancel"),
				width: this.width
			}, placeholder);
	
			// to avoid screen jitter, we first create the editor with position:absolute, visibility:hidden,
			// and then when it's finished rendering, we switch from display mode to editor
			var ews = ew.domNode.style;
			this.displayNode.style.display="none";
			ews.position = "static";
			ews.visibility = "visible";
	
			// Replace the display widget with edit widget, leaving them both displayed for a brief time so that
			// focus can be shifted without incident.  (browser may needs some time to render the editor.)
			this.domNode = ew.domNode;
			
			/* LGG - NO TIMEOUT NECESSARY SINCE THERE IS NO READONLY MODE
			setTimeout(function(){
				ew.focus();
			}, 100);*/
		},		

		cancel: function(/*Boolean*/ focus){
			/* LGG - DISABLE DEFAULT CANCEL OPERATIONS TO SUPPORT CUSTOM JAVASCRIPT
			// summary:
			//		Revert to display mode, discarding any changes made in the editor
			this.editing = false;
			this._showText(focus);*/
			this.onCancel(this.value);
		}
});

dojo.declare(
	"widgets._InlineEditor",
	dijit._InlineEditor,
	{			
		templateString: null,
		
		templateString:"<fieldset dojoAttachPoint=\"editNode\" waiRole=\"presentation\" style=\"width: 100%; position: absolute; visibility:hidden\" class=\"dijitReset dijitInline\"\n\tdojoAttachEvent=\"onkeypress: _onKeyPress\">\n\t<div class=\"inlineEditBox\"><textarea dojoAttachPoint=\"editorPlaceholder\"></textarea></div>\n\t<div class=\"inlineEditButtons\" dojoAttachPoint=\"buttonContainer\">\n\t\t<div class=\"inlineEditButton\"><button class='saveButton' dojoAttachPoint=\"saveButton\" dojoType=\"dijit.form.Button\" dojoAttachEvent=\"onClick:save\">${buttonSave}</button></div>\n\t\t<div class=\"inlineEditButton\"><button class='cancelButton' dojoAttachPoint=\"cancelButton\" dojoType=\"dijit.form.Button\" dojoAttachEvent=\"onClick:cancel\">${buttonCancel}</button></div>\n\t</div>\n</fieldset>\n"

});

}

if(!dojo._hasResource["widgets.DateTextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.DateTextBox"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.DateTextBox");



dojo.declare(
	"widgets.DateTextBox",
	dijit.form.DateTextBox,
	{
		showPicker: function() {
			this._open();
			this.focus();
		},
		
		hidePicker: function() {
			this._close();		
		},		
		
		_onFocus: function(/*Event*/ evt) {
		}
	}
);

}

if(!dojo._hasResource["widgets.TabContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.TabContainer"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.TabContainer");



dojo.declare(
	"widgets.TabContainer",
	[dijit.layout.TabContainer],	
	{
		_controllerWidget: "widgets.TabController",
		transitioning: true,
		activeTabId: "",
		showIcon: false,
		
		postCreate: function() {
			this.inherited(arguments);
			this.modifyTemplate();
			if(this.isLeftToRight()) {
				dojo.addClass(this.domNode, "widgetsLtr");
			}
		},
		
		isLeftToRight: function() {
			var dir = this.attr("dir");
			if(dir) {
				return dir == "ltr";
			} else {
				return dojo._isBodyLtr();	
			}
		},
		
		_transition: function(newWidget, oldWidget) {
			this.transitioning = true;
			this.inherited(arguments);
			this.transitioning = false;
		},
		
		_showChild: function(page) {
			if (!this.transitioning) return;			
			this.activeTabId = page.id;
			this.inherited(arguments);
			if (page.onTabShow) page.onTabShow();
			var button = this.tablist.pane2button[page];
			if (button != null && dojo.hasClass(button.innerDiv, "tabInactiveMiddle"))
				this.toggleTabStyle(button);
		},
		
		_hideChild: function(page) {			
			this.inherited(arguments);
			
			if (!this.transitioning) return;
			if (page.onTabHide) page.onTabHide();
			var button = this.tablist.pane2button[page];
			if (button != null && dojo.hasClass(button.innerDiv, "tabActiveMiddle"))
				this.toggleTabStyle(button);
		},
		
		toggleTabStyle: function(button) {
			if (button == null) return;
			dojo.toggleClass(button.leftEdgeOfInnerDiv, "tabInactiveLeft");
			dojo.toggleClass(button.rightEdgeOfInnerDiv, "tabInactiveRight");
			dojo.toggleClass(button.innerDiv, "tabInactiveMiddle");			
			dojo.toggleClass(button.leftEdgeOfInnerDiv, "tabActiveLeft");
			dojo.toggleClass(button.rightEdgeOfInnerDiv, "tabActiveRight");
			dojo.toggleClass(button.innerDiv, "tabActiveMiddle");			
			button.toggleIcon();
		},
				
		modifyTemplate: function() {
			dojo.style(this.containerNode, "borderLeft", "1px solid #CCCCCC");
			dojo.style(this.containerNode, "borderRight", "1px solid #CCCCCC");
		}
	}
);

dojo.declare(
	"widgets.TabController",
	[dijit.layout.TabController],
	{
		buttonWidget: "widgets._TabButton",
		
		postCreate: function() {
			this.inherited(arguments);
			this.modifyTemplate();
		},
		
		onAddChild: function(page, insertIndex){
			this.inherited(arguments);		
			this.pane2button[page].setIcons(
				page.activeIconPath,
				page.inactiveIconPath
			);
		},
		
		modifyTemplate: function() {
			this.domNode.style.paddingLeft = "5px";
		}
	}
);

dojo.declare(
	"widgets._TabButton",
	[dijit.layout._TabButton],
	{
		leftEdgeOfInnerDiv: null,
		rightEdgeOfInnerDiv: null,
		tabIcon: null,
		activeIconPath: null,	// assume 16x16 size
		inactiveIconPath: null, // assume 16x16 size
		
		postCreate: function() {
			this.inherited(arguments);
			this.showIcon = EDR.isTextAnalyticsEnabled;
			this.modifyTemplate();
		},
		
		setIcons: function(activeIconPath, inactiveIconPath) {
			if (!this.showIcon) return;
			//for IE to avoid blank IMG tag
			if(activeIconPath==undefined&&inactiveIconPath==undefined){
				dojo.style(this.tabIcon,"visibility","hidden");
				dojo.style(this.tabIcon,"width","0px");
				dojo.style(this.tabIcon,"height","0px");
			}else{
				this.activeIconPath = activeIconPath;
				this.inactiveIconPath = inactiveIconPath;
				this.tabIcon.src = this.activeIconPath;
			}
		},
		
		toggleIcon: function() {
			if (!this.showIcon) return;
			
			if (this.tabIcon.src == this.activeIconPath) {
				if (this.inactiveIconPath != null && this.inactiveIconPath != "")
					this.tabIcon.src = this.inactiveIconPath;
			}
			else if (this.tabIcon.src == this.inactiveIconPath) {
				if (this.activeIconPath != null && this.activeIconPath != "")
					this.tabIcon.src = this.activeIconPath;
			}
		},
		
		modifyTemplate: function() {
			dojo.addClass(this.domNode, "tabInactive");
			this.leftEdgeOfInnerDiv = dojo.doc.createElement("DIV");
			dojo.addClass(this.leftEdgeOfInnerDiv, "tabInactiveLeft");
			this.rightEdgeOfInnerDiv = dojo.doc.createElement("DIV");
			dojo.addClass(this.rightEdgeOfInnerDiv, "tabInactiveRight");
			dojo.addClass(this.innerDiv, "tabInactiveMiddle");
			
			this.domNode.insertBefore(this.leftEdgeOfInnerDiv, this.innerDiv);
			this.domNode.appendChild(this.rightEdgeOfInnerDiv);
			if (this.showIcon) {			
				this.tabIcon = dojo.doc.createElement("IMG");
				this.tabIcon.setAttribute("alt", "");
				dojo.addClass(this.tabIcon, "tabIcon");
				this.tabContent.insertBefore(this.tabIcon, this.tabContent.firstChild);
			}			
		}
	}
);


}

if(!dojo._hasResource["widgets.TabWindow"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.TabWindow"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.TabWindow");


dojo.declare(
	"widgets.TabWindow",
	[widgets.TabContainer],	
	{
		_controllerWidget: "widgets.TabWindowController",
		
		leftBottomEdgeWindowDiv: null,
		rightBottomEdgeWindowDiv: null,
		middleBottomEdgeWindowDiv: null,
		
		postCreate: function(){
			this.inherited(arguments);
			if (!this.isLeftToRight()) {
				dojo.removeClass(this.leftBottomEdgeWindowDiv, "tabWindowBottomLeft");
				dojo.addClass(this.leftBottomEdgeWindowDiv, "tabWindowBottomLeft_rtl");
				dojo.removeClass(this.rightBottomEdgeWindowDiv, "tabWindowBottomRight");
				dojo.addClass(this.rightBottomEdgeWindowDiv, "tabWindowBottomRight_rtl");
			}
		},
		
		startup: function() {
			this.inherited(arguments);
			this.isSingleTab = this.getChildren().length == 1;
			if (this.isSingleTab) {
				dojo.style(this.tablist.domNode, "display", "none");
				dojo.style(this.tablist.leftEdgeWindowDiv, "display", "none");
				dojo.style(this.tablist.rightEdgeWindowDiv, "display", "none");
				dojo.style(this.leftBottomEdgeWindowDiv, "display", "none");
				dojo.style(this.rightBottomEdgeWindowDiv, "display", "none");
				dojo.style(this.middleBottomEdgeWindowDiv, "display", "none");				

			}
		},
		
		modifyTemplate: function() {
			this.inherited(arguments);
			
			this.leftBottomEdgeWindowDiv = dojo.doc.createElement("DIV");
			dojo.addClass(this.leftBottomEdgeWindowDiv, "tabWindowBottomLeft");
			this.rightBottomEdgeWindowDiv = dojo.doc.createElement("DIV");
			dojo.addClass(this.rightBottomEdgeWindowDiv, "tabWindowBottomRight");
			this.middleBottomEdgeWindowDiv = dojo.doc.createElement("DIV");
			dojo.addClass(this.middleBottomEdgeWindowDiv, "tabWindowBottomMiddle");			
			
			this.domNode.appendChild(this.leftBottomEdgeWindowDiv);
			this.domNode.appendChild(this.middleBottomEdgeWindowDiv);
			this.domNode.appendChild(this.rightBottomEdgeWindowDiv);
		},
		
		layout: function() {
			this._contentBox.h -= 4;
			this.inherited(arguments);

			var controller = this.tablist;			
			var header = controller.domNode;
			var container = this.containerNode;
			
			var width = parseInt(header.style.width);
			header.style.left = "3px";
			header.style.width = (width - 6) + "px";
			controller.rightEdgeWindowDiv.style.left = (width - 3) + "px";

//			var height = parseInt(container.style.height) - 4;			
//			container.style.height =  height + "px";
			this.middleBottomEdgeWindowDiv.style.width = (width - 6) + "px";
		}		
	}
);

dojo.declare(
	"widgets.TabWindowController",
	[widgets.TabController],
	{
		leftEdgeWindowDiv: null,
		rightEdgeWindowDiv: null,
		
		modifyTemplate: function() {
			this.inherited(arguments);
			this.domNode.style.paddingLeft = "0px";
			
			this.leftEdgeWindowDiv = dojo.doc.createElement("DIV");
			dojo.addClass(this.leftEdgeWindowDiv, "tabWindowLeft");
			this.rightEdgeWindowDiv = dojo.doc.createElement("DIV");
			dojo.addClass(this.rightEdgeWindowDiv, "tabWindowRight");
			dojo.addClass(this.domNode, "tabWindowMiddle");
			
			this.buildToolbar(this.domNode);

			var parent = this.domNode.parentNode;
			parent.appendChild(this.rightEdgeWindowDiv);
			parent.insertBefore(this.leftEdgeWindowDiv, this.domNode);
		},
		
		buildToolbar: function(parent) {
		}
	}
);


}

if(!dojo._hasResource["widgets.QueryTabWindow"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.QueryTabWindow"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.QueryTabWindow");




dojo.declare(
	"widgets.QueryTabWindow",
	[widgets.TabWindow],	
	{
		_controllerWidget: "widgets.QueryTabWindowController",
		
		minHeight: 32,
		defaultHeight: 95,
		
		postCreate: function(){
			this.inherited(arguments);
		},
		
		layout: function() {
			this.inherited(arguments);
			this.tablist.layout();
		},
		
		setViewModeSimple: function() {
			dojo.style(this.containerNode, "display", "none");
			this.tablist.setViewMode("simple");
		},
		
		setViewModeNormal: function() {
			dojo.style(this.containerNode, "display", "block");
			this.tablist.setViewMode("normal");
		}
	}
);

dojo.declare(
	"widgets.QueryTabWindowController",
	[widgets.TabWindowController],
	{
		viewMode: "normal", // "simple" or "normal"
		simpleSearchInput: null,
		simpleSearchButton: null,
		
		refreshImgPath: "images/refresh23.png",
		loadSearchImgPath: "images/loadsearch23.png",
		saveSearchImgPath: "images/save23.png",
		animations: [],
		handlers: [],

		onSerchBtnClicked: function(evt) {
			if (evt.type == "click" || evt.keyCode == dojo.keys.ENTER){
				var keywords = this.simpleSearchInput.textbox.value;
				if (keywords != null && keywords != "") {
					var params = {
						keywords: this.simpleSearchInput.textbox.value,
						basicKeywords: this.simpleSearchInput.textbox.value
					};
					dijit.byId(EDR.prefix+"searchManager").submitSearch(dijit.byId(EDR.prefix+"basicSearchPane"), "search", params);
				}
			}
		},
		
		setViewMode: function(mode) {
			if (this.viewMode == mode) return;
			if (mode == "simple") {
				for(var pane in this.pane2button) {
					dojo.style(this.pane2button[pane].domNode, "display", "none");
				}
				dojo.style(this.simpleSearchInput.domNode, "display", "block");
				dojo.style(this.simpleSearchButton.domNode, "display", "block");
				this.simpleSearchInput.textbox.value = "";
			} else {
				for(var pane in this.pane2button) {
					dojo.style(this.pane2button[pane].domNode, "display", "block");
				}
				dojo.style(this.simpleSearchInput.domNode, "display", "none");
				dojo.style(this.simpleSearchButton.domNode, "display", "none");
			}
			this.viewMode = mode;
		},		
		
		buildToolbar: function(parent) {
			// simple query text
			var input = dojo.doc.createElement("INPUT");
			this.simpleSearchInput = new dijit.form.TextBox( {
				id: EDR.prefix+"itt",
				trim: true
			}, input);
			dojo.style(this.simpleSearchInput.domNode, "height", 19);
			dojo.style(this.simpleSearchInput.domNode, "display", "none");
			dojo.style(this.simpleSearchInput.domNode, "float", this.isLeftToRight() ? "left" : "right");
			
			// simple search button
			var button = dojo.doc.createElement("INPUT");
			this.simpleSearchButton = new widgets.Button( {
				label: EDR.messages.button_search
			}, input);
			dojo.style(this.simpleSearchButton.domNode, "display", "none");
			dojo.style(this.simpleSearchButton.domNode, "position", "relative");
			dojo.style(this.simpleSearchButton.domNode, "top", "-3px");
			dojo.style(this.simpleSearchButton.domNode, "float", this.isLeftToRight() ? "left" : "right");
			this.handlers.push(dojo.connect(this.simpleSearchButton, "onClick", this, "onSerchBtnClicked"));			
			this.handlers.push(dojo.connect(this.simpleSearchInput.textbox, "onkeypress", this, "onSerchBtnClicked"));			
			
			dojo.style(parent, "overflow", "visible"); // to enalbe FishEye
			var refreshImg = this.buildImg(this.refreshImgPath, "refresh");
			var loadSearchImg = this.buildImg(this.loadSearchImgPath, "loadSearch");
			var saveSearchImg = this.buildImg(this.saveSearchImgPath, "saveSearch");
			
			if (this.isLeftToRight()) {
				parent.appendChild(this.simpleSearchInput.domNode);
				parent.appendChild(this.simpleSearchButton.domNode);
				parent.appendChild(saveSearchImg);
				parent.appendChild(loadSearchImg);
				parent.appendChild(refreshImg);
				saveSearchImg.style.marginRight = "15px";
			} else {
				parent.appendChild(refreshImg);
				parent.appendChild(loadSearchImg);
				parent.appendChild(saveSearchImg);
				parent.appendChild(this.simpleSearchButton.domNode);
				parent.appendChild(this.simpleSearchInput.domNode);
				saveSearchImg.style.marginLeft = "15px";
			}
		},
		
		layout: function() {
			var contentBox = dojo.contentBox(this.domNode);
			dojo.style(this.simpleSearchInput.domNode, "width", contentBox.w - 250);
		},
		
		refresh: function(evt) {
			alert("refresh");
		},
		
		loadSearch: function(evt) {
			alert("loadSearch");
		},
		
		saveSearch: function(evt) {
			alert("saveSearch");
		},
				
		buildImg: function(imgPath, eventHandlerName) {
			var img = dojo.doc.createElement("IMG");
			img.width = "23";
			img.height = "23";
			img.src = imgPath;
			dojo.style(img, "z-index", 20);
			dojo.style(img, "float", this.isLeftToRight() ? "right" : "left");
			var margin = this.isLeftToRight() ? "0px 0px 2px 10px" : "0px 10px 2px 0px";
			dojo.style(img, "margin", margin);
			this.handlers.push(dojo.connect(img, "onclick", this, eventHandlerName));
			var anim = new dojox.widget.FisheyeLite({
				properties: {
					height:1.4,
					width:1.4
				}
			},img);
			return img;			
		},
		
		destroy: function() {
			dojo.forEach(this.handlers, dojo.disconnect);
			this.inherited("destroy", arguments);
		}		
	}
);


}

if(!dojo._hasResource["widgets.SearchTabWindow"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.SearchTabWindow"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.SearchTabWindow");




dojo.declare(
	"widgets.SearchTabWindow",
	[widgets.TabWindow],	
	{
		_controllerWidget: "widgets.SearchTabWindowController",
		isSingleTab: false,
		
		postCreate: function(){
			this.inherited(arguments);
		}
	}
);

dojo.declare(
	"widgets.SearchTabWindowController",
	[widgets.TabWindowController],
	{
		maximizeImgPath: "images/size_max.png",		
		normalImgPath: "images/size_normal.png",
		showSearchPaneImgPath: "images/show_search.png",		
		hideSearchPaneImgPath: "images/hide_search.png",	
		showHiedePaneTrigerImg: null,
		sizeChangeTrigerImg: null,
		handlers: [],

		buildToolbar: function(parent) {
/*			dojo.style(parent, "overflow", "visible"); // to enalbe FishEye
			this.showHiedePaneTrigerImg = this.buildImg(this.hideSearchPaneImgPath, "showHideSearchPane");
			this.sizeChangeTrigerImg = this.buildImg(this.normalImgPath, "showHideSearchQueryPane");
			
			if (this.isLeftToRight()) {
				parent.appendChild(this.sizeChangeTrigerImg);
				parent.appendChild(this.showHiedePaneTrigerImg);
				this.sizeChangeTrigerImg.style.marginRight = "15px";
			} else {
				parent.appendChild(this.showHiedePaneTrigerImg);
				parent.appendChild(this.sizeChangeTrigerImg);
				this.showHiedePaneTrigerImg.style.marginLeft = "15px";
			} */
		},
		
		layout: function() {
			var contentBox = dojo.contentBox(this.domNode);
			dojo.style(this.simpleSearchInput.domNode, "width", contentBox.w - 250);
		},
		
		showHideSearchPane: function(evt) {
			var layoutManager = dijit.byId(EDR.prefix+"tabSearchContent");
			if (this.showHiedePaneTrigerImg.src == this.showSearchPaneImgPath) {
				layoutManager.showSearchPane();
				this.showHiedePaneTrigerImg.src = this.hideSearchPaneImgPath;
			} else {
				layoutManager.hideSearchPane();
				this.showHiedePaneTrigerImg.src = this.showSearchPaneImgPath;
			}
			this.reconnect();
		},
		
		showHideSearchQueryPane: function(evt) {
			var layoutManager = dijit.byId(EDR.prefix+"tabSearchContent");
			if (this.sizeChangeTrigerImg.src == this.maximizeImgPath) {
				layoutManager.maximizeSearchResultPane();
				this.sizeChangeTrigerImg.src = this.normalImgPath;
			} else {
				layoutManager.maximizeSearchQueryPane();
				this.sizeChangeTrigerImg.src = this.maximizeImgPath;
			}
			this.reconnect();
		},
		
		reconnect: function() {
			dojo.forEach(this.handlers, dojo.disconnect);
			this.handlers.push(dojo.connect(this.showHiedePaneTrigerImg, "onclick", this, "showHideSearchPane"));						
			this.handlers.push(dojo.connect(this.sizeChangeTrigerImg, "onclick", this, "showHideSearchQueryPane"));						
		},
		
		buildImg: function(imgPath, eventHandlerName) {
			var img = dojo.doc.createElement("IMG");
			img.width = "16";
			img.height = "16";
			img.src = imgPath;
			dojo.style(img, "float", this.isLeftToRight() ? "right" : "left");
			var margin = this.isLeftToRight() ? "0px 0px 2px 10px" : "0px 10px 2px 0px";
			dojo.style(img, "margin", margin);
			this.handlers.push(dojo.connect(img, "onclick", this, eventHandlerName));
/*			var anim = new dojox.widget.FisheyeLite({
				properties: {
					height:1.6,
					width:1.6
				}
			},img);*/
			return img;			
		},
		
		destroy: function() {
			dojo.forEach(this.handlers, dojo.disconnect);
			this.inherited("destroy", arguments);
		}		
	}
);


}

if(!dojo._hasResource["dojox.collections._base"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.collections._base"] = true;
dojo.provide("dojox.collections._base");

dojox.collections.DictionaryEntry=function(/* string */k, /* object */v){
	//	summary
	//	return an object of type dojox.collections.DictionaryEntry
	this.key=k;
	this.value=v;
	this.valueOf=function(){ 
		return this.value; 	//	object
	};
	this.toString=function(){ 
		return String(this.value);	//	string 
	};
}

/*	Iterators
 *	The collections.Iterators (Iterator and DictionaryIterator) are built to
 *	work with the Collections included in this module.  However, they *can*
 *	be used with arrays and objects, respectively, should one choose to do so.
 */
dojox.collections.Iterator=function(/* array */arr){
	//	summary
	//	return an object of type dojox.collections.Iterator
	var a=arr;
	var position=0;
	this.element=a[position]||null;
	this.atEnd=function(){
		//	summary
		//	Test to see if the internal cursor has reached the end of the internal collection.
		return (position>=a.length);	//	bool
	};
	this.get=function(){
		//	summary
		//	Get the next member in the collection.
		if(this.atEnd()){
			return null;		//	object
		}
		this.element=a[position++];
		return this.element;	//	object
	};
	this.map=function(/* function */fn, /* object? */scope){
		//	summary
		//	Functional iteration with optional scope.
		return dojo.map(a, fn, scope);
	};
	this.reset=function(){
		//	summary
		//	reset the internal cursor.
		position=0;
		this.element=a[position];
	};
}

/*	Notes:
 *	The DictionaryIterator no longer supports a key and value property;
 *	the reality is that you can use this to iterate over a JS object
 *	being used as a hashtable.
 */
dojox.collections.DictionaryIterator=function(/* object */obj){
	//	summary
	//	return an object of type dojox.collections.DictionaryIterator
	var a=[];	//	Create an indexing array
	var testObject={};
	for(var p in obj){
		if(!testObject[p]){
			a.push(obj[p]);	//	fill it up
		}
	}
	var position=0;
	this.element=a[position]||null;
	this.atEnd=function(){
		//	summary
		//	Test to see if the internal cursor has reached the end of the internal collection.
		return (position>=a.length);	//	bool
	};
	this.get=function(){
		//	summary
		//	Get the next member in the collection.
		if(this.atEnd()){
			return null;		//	object
		}
		this.element=a[position++];
		return this.element;	//	object
	};
	this.map=function(/* function */fn, /* object? */scope){
		//	summary
		//	Functional iteration with optional scope.
		return dojo.map(a, fn, scope);
	};
	this.reset=function() { 
		//	summary
		//	reset the internal cursor.
		position=0; 
		this.element=a[position];
	};
};

}

if(!dojo._hasResource["dojox.collections.ArrayList"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.collections.ArrayList"] = true;
dojo.provide("dojox.collections.ArrayList");


dojox.collections.ArrayList=function(/* array? */arr){
	//	summary
	//	Returns a new object of type dojox.collections.ArrayList
	var items=[];
	if(arr) items=items.concat(arr);
	this.count=items.length;
	this.add=function(/* object */obj){
		//	summary
		//	Add an element to the collection.
		items.push(obj);
		this.count=items.length;
	};
	this.addRange=function(/* array */a){
		//	summary
		//	Add a range of objects to the ArrayList
		if(a.getIterator){
			var e=a.getIterator();
			while(!e.atEnd()){
				this.add(e.get());
			}
			this.count=items.length;
		}else{
			for(var i=0; i<a.length; i++){
				items.push(a[i]);
			}
			this.count=items.length;
		}
	};
	this.clear=function(){
		//	summary
		//	Clear all elements out of the collection, and reset the count.
		items.splice(0, items.length);
		this.count=0;
	};
	this.clone=function(){
		//	summary
		//	Clone the array list
		return new dojox.collections.ArrayList(items);	//	dojox.collections.ArrayList
	};
	this.contains=function(/* object */obj){
		//	summary
		//	Check to see if the passed object is a member in the ArrayList
		for(var i=0; i < items.length; i++){
			if(items[i] == obj) {
				return true;	//	bool
			}
		}
		return false;	//	bool
	};
	this.forEach=function(/* function */ fn, /* object? */ scope){
		//	summary
		//	functional iterator, following the mozilla spec.
		dojo.forEach(items, fn, scope);
	};
	this.getIterator=function(){
		//	summary
		//	Get an Iterator for this object
		return new dojox.collections.Iterator(items);	//	dojox.collections.Iterator
	};
	this.indexOf=function(/* object */obj){
		//	summary
		//	Return the numeric index of the passed object; will return -1 if not found.
		for(var i=0; i < items.length; i++){
			if(items[i] == obj) {
				return i;	//	int
			}
		}
		return -1;	// int
	};
	this.insert=function(/* int */ i, /* object */ obj){
		//	summary
		//	Insert the passed object at index i
		items.splice(i,0,obj);
		this.count=items.length;
	};
	this.item=function(/* int */ i){
		//	summary
		//	return the element at index i
		return items[i];	//	object
	};
	this.remove=function(/* object */obj){
		//	summary
		//	Look for the passed object, and if found, remove it from the internal array.
		var i=this.indexOf(obj);
		if(i >=0) {
			items.splice(i,1);
		}
		this.count=items.length;
	};
	this.removeAt=function(/* int */ i){
		//	summary
		//	return an array with function applied to all elements
		items.splice(i,1);
		this.count=items.length;
	};
	this.reverse=function(){
		//	summary
		//	Reverse the internal array
		items.reverse();
	};
	this.sort=function(/* function? */ fn){
		//	summary
		//	sort the internal array
		if(fn){
			items.sort(fn);
		}else{
			items.sort();
		}
	};
	this.setByIndex=function(/* int */ i, /* object */ obj){
		//	summary
		//	Set an element in the array by the passed index.
		items[i]=obj;
		this.count=items.length;
	};
	this.toArray=function(){
		//	summary
		//	Return a new array with all of the items of the internal array concatenated.
		return [].concat(items);
	}
	this.toString=function(/* string */ delim){
		//	summary
		//	implementation of toString, follows [].toString();
		return items.join((delim||","));
	};
};

}

if(!dojo._hasResource["widgets.FacetBase"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.FacetBase"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.FacetBase");




dojo.declare(
	"widgets.FacetBase", [dijit._Widget],
	{				
		treeItemWidth: 180,
		imgBasePath: EDR.config.imageBaseDir,
		itemIdPrefix: "",
		andfacets: null,
		notfacets: null,
		handlers: [],
				
		postCreate: function() {
			this.handlers = [];
			this.inherited("postCreate", arguments);
			this.andfacets = new dojox.collections.ArrayList([]);
			this.notfacets = new dojox.collections.ArrayList([]);
		},
		
		isEmpty: function() {
			return (this.andfacets.count == 0 && this.notfacets.count == 0) ? true : false;
		},
		
		getFormValues: function() {
			var values = {};
			if (this.andfacets.count > 0) values.andfacet = this.andfacets.toArray();
			if (this.notfacets.count > 0) values.notfacet = this.notfacets.toArray();
			return values;
		},
		
		facetSelectedEventHandler: function(evt) {
			if (evt.type != "click" && evt.keyCode != dojo.keys.ENTER) return;
			
			var facetLink = evt.currentTarget;
			var facetInput = facetLink.parentNode.firstChild;
			this.andfacets.clear();
			this.notfacets.clear();
			this.andfacets.add(facetInput.value);
		},
		
		toggleCheckBoxEventHandler: function(chkbox) {
			var facetInput = chkbox.domNode.parentNode.firstChild;
			if (chkbox.checked) {
				facetInput.name = "andfacet";
				this.andfacets.add(facetInput.value);
			} else {
				facetInput.name = "facet";
				this.andfacets.remove(facetInput.value);
			}
		},
		
		toggleFacetEventHandler: function(evt) {
		},
		
		buildFacetGroupElem: function(facet) {
			var refGroup = dojo.doc.createElement("DIV");
			dojo.addClass(refGroup, "refinement-group");
			//refGroup.style.width = this.treeItemWidth + "px";
			refGroup.style.width = "95%";

			var refTitle = dojo.doc.createElement("DIV");
			refTitle.tabIndex = 0;
			refTitle.title = dojo.string.substitute(EDR.messages.tooltip_facet_expandcollapse, [facet.facetLabel]);
			dojo.addClass(refTitle, "refinement-title");
			refTitle.facet = facet;
			dojo.attr(refTitle, "role", "treeitem");

			if (facet.items != null) {
				this.handlers.push(dojo.connect(refTitle, "onkeypress", this, this.toggleFacetEventHandler));
				if(facet.items.length != 0){
					this.handlers.push(dojo.connect(refTitle, "onclick", this, this.toggleFacetEventHandler));
				}
			}
			
			var contentTop = dojo.doc.createElement("DIV");
			dojo.addClass(contentTop, "refinement-title-top");
			contentTop.innerHTML = "<div></div>";

			var contentBody = this.buildFacetGroupContentElem(facet);

			var contentBottom = dojo.doc.createElement("DIV");
			dojo.addClass(contentBottom, "refinement-title-bottom");
			contentBottom.innerHTML = "<div></div>";
			
			var refGroupList = dojo.doc.createElement("DIV");
			dojo.addClass(refGroupList, "refinement-group-list");
			refGroupList.style.display = 'none';
			
			var refList = dojo.doc.createElement("DIV");
			dojo.addClass(refList, "refinement-list");
			refList.style.display = 'none';
			refList.style.paddingTop = "3px";
			
			refTitle.appendChild(contentTop);
			refTitle.appendChild(contentBody);
			refTitle.appendChild(contentBottom);
			
			refGroup.appendChild(refTitle);
			refGroup.appendChild(refGroupList);
			refGroup.appendChild(refList);
			
			return refGroup;
		},
		
		buildFacetGroupContentElem: function(facet) {
			var content = dojo.doc.createElement("DIV");
			dojo.addClass(content, "refinement-title-body");
			
			var arrowImg = dojo.doc.createElement("IMG");
			dojo.addClass(arrowImg, "arrow-img");
			arrowImg.src = this.imgBasePath + (this.isLeftToRight() ? "arrow_right8.png" : "arrow_left8.png");
			arrowImg.alt = dojo.string.substitute(EDR.messages.tooltip_facet_expandcollapse, [facet.facetLabel]);
			
			if (facet.items == null || facet.items.length == 0) dojo.style(arrowImg, "visibility", "hidden");
			
			var label = dojo.doc.createElement("DIV");
			dojo.addClass(label, "label");
			label.innerHTML = facet.facetLabel;
			
			content.appendChild(arrowImg);
			content.appendChild(label);
			
			return content;
		},
		
		buildFacetItemElem: function(item) {
			var container = dojo.doc.createElement("DIV");
			var isAndFacet = this.andfacets.contains(item.postParamValue + "");
			var isNotFacet = this.notfacets.contains(item.postParamValue + "");
			
			var facetInput = dojo.create("INPUT", {
				type: "hidden",
				value: item.postParamValue + "",
				name: isAndFacet ? "andfacet" : "facet"
			}, container);

			var chkbox = new dijit.form.CheckBox({id:EDR.prefix+this.itemIdPrefix + item.itemId+"_chkbox", name:""});
			if (isAndFacet) chkbox.attr("checked", true);
			container.appendChild(chkbox.domNode);
			facetInput.chkbox = chkbox;
			this.handlers.push(dojo.connect(chkbox, "onClick", this, function(evt) {
				this.toggleCheckBoxEventHandler(chkbox);
			}));
			
			var facetLabel = item.itemLabel + "";
			var labelTitle = dojo.string.substitute(EDR.messages.tooltip_facet_quick, ['"' + facetLabel + '"']);
			var labelLink = dojo.create("A", {
				href: "javascript:;",
				itemId: item.itemId + "",
				title: labelTitle,
				"for": item.itemId+"_chkbox"
			}, container);
			var label = dojo.create("LABEL", {"for":EDR.prefix+this.itemIdPrefix + item.itemId+"_chkbox"}, labelLink);
			label.appendChild(dojo.doc.createTextNode(facetLabel));
			
			this.handlers.push(dojo.connect(labelLink, "onclick", this, this.facetSelectedEventHandler));
			
			dojo.create("span", {innerHTML: "<bdo dir='ltr'>(" + item.count + ")</bdo>"}, container);
			
			return container;
		},
		
		submitSearch: function(searchType) {
			var params = this.getFormValues();
			dijit.byId(EDR.prefix+"searchManager").submitSearch(null, searchType, params);
		},
		
		removeFacet: function(removefacet) {
			this.andfacets.clear();
			this.notfacets.clear();
			this.notfacets.add(removefacet);
			var params = this.getFormValues();
			dijit.byId(EDR.prefix+"searchManager").submitSearch(null, "refineSearch", params);
		},
		
		buildItemLabel: function(item) {
			return item.itemLabel;
		},
		
		reset: function() {
			this.andfacets.clear();
			this.notfacets.clear();			
		},
		
		clear: function() {
			this.andfacets.clear();
			this.notfacets.clear();
			if (this.facetForm) {
				dojo.forEach(dijit.findWidgets(this.facetForm), function(widget) {
					widget.destroy();
				});
				this.facetForm.innerHTML = "";
			}
		},
		
		destroy: function() {
			this.clear();
			dojo.forEach(this.handlers, dojo.disconnect);
			this.inherited("destroy", arguments);
		}	
	}
);

}

if(!dojo._hasResource["dijit.form.CheckBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.CheckBox"] = true;
dojo.provide("dijit.form.CheckBox");



dojo.declare(
	"dijit.form.CheckBox",
	dijit.form.ToggleButton,
	{
		// summary:
		// 		Same as an HTML checkbox, but with fancy styling.
		//
		// description:
		// User interacts with real html inputs.
		// On onclick (which occurs by mouse click, space-bar, or
		// using the arrow keys to switch the selected radio button),
		// we update the state of the checkbox/radio.
		//
		// There are two modes:
		//   1. High contrast mode
		//   2. Normal mode
		// In case 1, the regular html inputs are shown and used by the user.
		// In case 2, the regular html inputs are invisible but still used by
		// the user. They are turned quasi-invisible and overlay the background-image.

		templateString:"<div class=\"dijitReset dijitInline\" waiRole=\"presentation\"\n\t><input\n\t \t${nameAttrSetting} type=\"${type}\" ${checkedAttrSetting}\n\t\tclass=\"dijitReset dijitCheckBoxInput\"\n\t\tdojoAttachPoint=\"focusNode\"\n\t \tdojoAttachEvent=\"onmouseover:_onMouse,onmouseout:_onMouse,onclick:_onClick\"\n/></div>\n",

		baseClass: "dijitCheckBox",

		// type: [private] String
		//		type attribute on <input> node.
		//		Overrides `dijit.form.Button.type`.   Users should not change this value.
		type: "checkbox",

		// value: String
		//		As an initialization parameter, equivalent to value field on normal checkbox
		//		(if checked, the value is passed as the value when form is submitted).
		//
		//		However, attr('value') will return either the string or false depending on
		//		whether or not the checkbox is checked.
		//
		//		attr('value', string) will check the checkbox and change the value to the
		//		specified string
		//
		//		attr('value', boolean) will change the checked state.
		value: "on",

		_setValueAttr: function(/*String or Boolean*/ newValue){
			// summary:
			//		Handler for value= attribute to constructor, and also calls to
			//		attr('value', val).
			// description:
			//		During initialization, just saves as attribute to the <input type=checkbox>.
			//		
			//		After initialization,
			//		when passed a boolean, controls whether or not the CheckBox is checked.
			//		If passed a string, changes the value attribute of the CheckBox (the one
			//		specified as "value" when the CheckBox was constructed (ex: <input
			//		dojoType="dijit.CheckBox" value="chicken">)
			if(typeof newValue == "string"){
				this.value = newValue;
				dojo.attr(this.focusNode, 'value', newValue);
				newValue = true;
			}
			if(this._created){
				this.attr('checked', newValue);
			}
		},
		_getValueAttr: function(){
			// summary:
			//		Hook so attr('value') works.
			// description:
			//		If the CheckBox is checked, returns the value attribute.
			//		Otherwise returns false.
			return (this.checked ? this.value : false);
		},

		postMixInProperties: function(){
			if(this.value == ""){
				this.value = "on";
			}

			// Need to set initial checked state as part of template, so that form submit works.
			// dojo.attr(node, "checked", bool) doesn't work on IEuntil node has been attached
			// to <body>, see #8666
			this.checkedAttrSetting = this.checked ? "checked" : "";

			this.inherited(arguments);
		},
		
		 _fillContent: function(/*DomNode*/ source){
			// Override Button::_fillContent() since it doesn't make sense for CheckBox,
			// since CheckBox doesn't even have a container
		},

		reset: function(){
			// Override ToggleButton.reset()

			this._hasBeenBlurred = false;

			this.attr('checked', this.params.checked || false);

			// Handle unlikely event that the <input type=checkbox> value attribute has changed
			this.value = this.params.value || "on";
			dojo.attr(this.focusNode, 'value', this.value);
		},
		
		_onFocus: function(){
			if(this.id){
				dojo.query("label[for='"+this.id+"']").addClass("dijitFocusedLabel");
			}
		},

		_onBlur: function(){
			if(this.id){
				dojo.query("label[for='"+this.id+"']").removeClass("dijitFocusedLabel");
			}
		}
	}
);

dojo.declare(
	"dijit.form.RadioButton",
	dijit.form.CheckBox,
	{
		// summary:
		// 		Same as an HTML radio, but with fancy styling.

		type: "radio",
		baseClass: "dijitRadio",

		_setCheckedAttr: function(/*Boolean*/ value){
			// If I am being checked then have to deselect currently checked radio button
			this.inherited(arguments);
			if(!this._created){ return; }
			if(value){
				var _this = this;
				// search for radio buttons with the same name that need to be unchecked
				dojo.query("INPUT[type=radio]", this.focusNode.form||dojo.doc).forEach( // can't use name= since dojo.query doesn't support [] in the name
					function(inputNode){
						if(inputNode.name == _this.name && inputNode != _this.focusNode && inputNode.form == _this.focusNode.form){
							var widget = dijit.getEnclosingWidget(inputNode);
							if(widget && widget.checked){
								widget.attr('checked', false);
							}
						}
					}
				);
			}
		},

		_clicked: function(/*Event*/ e){
			if(!this.checked){
				this.attr('checked', true);
			}
		}
	}
);

}

if(!dojo._hasResource["dijit.form.RadioButton"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.RadioButton"] = true;
dojo.provide("dijit.form.RadioButton");


// TODO: for 2.0, move the RadioButton code into this file

}

if(!dojo._hasResource["widgets.FacetTree"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.FacetTree"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.FacetTree");







dojo.declare(
	"widgets.FacetTree", [widgets.FacetBase, dijit._Templated],
	{		
		prefix: EDR.prefix,
		widgetsInTemplate: true,
		templateString:"<div class=\"refinement\">\n\t<a name=\"facettree\"></a>\n\t<div dojoAttachPoint=\"facetTreeContainer\" role=\"tree\">\n\t\t<form dojoAttachPoint=\"facetForm\" onSubmit=\"return false;\">\n\t\t</form>\n\t</div>\n\t<div dojoAttachPoint=\"buttonContainer\" style=\"padding-top:7px;padding-left:5px;\">\n\t\t<div style=\"padding-left:2px;padding-bottom:2px;\" role=\"radiogroup\">\n\t\t\t<form>\n\t\t\t\t<div style=\"overflow:left;\">\n\t\t\t\t\t<input id=\"${prefix}facetNewSearch\" dojoAttachPoint=\"newSearchChk\" dojoType=\"dijit.form.RadioButton\" checked=\"true\" name=\"searchType\"/>\n\t\t\t\t\t<label for=\"${prefix}facetNewSearch\" title=\"${messages_tooltip_searchpane_newsearch_link}\">${label_newsearch}</label>\n\t\t\t\t</div>\n\t\t\t\t<div style=\"overflow:left;\">\n\t\t\t\t\t<input id=\"${prefix}facetRefineSearch\" dojoAttachPoint=\"refineSearchChk\" dojoType=\"dijit.form.RadioButton\" name=\"searchType\"/>\n\t\t\t\t\t<label for=\"${prefix}facetRefineSearch\" title=\"${messages_tooltip_searchpane_addsearch_link}\">${label_refinesearch}</label>\n\t\t\t\t</div>\n\t\t\t</form>\n\t\t</div>\n\t\t<div dojoAttachPoint=\"facetSearchBtn\" dojoType=\"widgets.Button\" style=\"height:20px;\" label=\"${label_search}\"\n\t\t\t\tdojoAttachEvent=\"onClick: onSearchButtonClicked\"></div>\n\t\t<div dojoAttachPoint=\"facetClearBtn\" dojoType=\"widgets.Button\" style=\"height:20px;\" label=\"${label_clear}\" disabled=\"true\"\n\t\t\t\tdojoAttachEvent=\"onClick: onClearButtonClicked\"></div>\n\t</div>\t\n</div>\n",
		url: "",
		urlLoadChildren: "",
		urlTypeAhead: "",
		timeout: 10000,
		
		facetDialog: null,
		facetDialogContent: null,
		facetTypeAheadWidget: null,
		
		newSearchChk: null,
		refineSearchChk: null,
		facetSearchBtn: null,
		facetClearBtn: null,
		
		facetTypeAheadInputIndex: 0,
		defaultSize: 0,
		maxSize: 0,
		
		openedItems: null,
		previousOpenedItems: null,
		loadRefCounter: 0,

		postCreate: function() {
			this.inherited("postCreate", arguments);
			this.previousOpenedItems = new dojox.collections.ArrayList([]);
			this.openedItems = new dojox.collections.ArrayList([]);
			dojo.subscribe("refresh", this, "refresh");
			dojo.subscribe("reset", this, "reset");
			dojo.subscribe("collectionChanged", this, "collectionChanged");
		},
		
		startup: function() {
			this.inherited(arguments);			
			if (dojo.isIE <= 7) {
				this.facetSearchBtn.adjustButtonWidth();
				this.facetClearBtn.adjustButtonWidth();
			}
			this.initDialog();
		},
		
		initDialog: function() {
			this.facetTypeAheadWidget = dijit.byId(EDR.prefix+"facetTypeAheadWidget");
			this.facetDialogContent = dijit.byId(EDR.prefix+"facetDialogContent");
			this.facetDialog = dijit.byId(EDR.prefix+"facetDialog");
			this.handlers.push(dojo.connect(this.facetDialog.okButtonNode, "onClick", this, "onFacetDialogApplied"));
			this.handlers.push(dojo.connect(this.facetDialog.cancelButtonNode, "onClick", this, "onFacetDialogCanceled"));
			this.handlers.push(dojo.connect(this.facetDialogContent, "facetSelectedEventHandler", this, "facetSelectedEventHandler"));
		},
		
		resize: function() {			
		},
		
		load: function() {
			if (!this.isVisible()) return;
			
			var params = {
				defaultSize: this.defaultSize,
				maxSize: this.maxSize
			};
			var args = 	{ 
				url: this.url,
				showProgress: false,
				successCallback: dojo.hitch(this, function(response, ioArgs) {
					var json = null;
					try {
						json = dojo.fromJson(response);
					} catch (e) {
			        	this.loadErrorHandler(response, ioArgs);
			        	return;
					}
					this.clear();
					this.loadRefCounter = 1;
					this.loadJson(json);	
					this.loadRefCounter--;
					if (this.loadRefCounter <= 0) this.postLoad();		
				}),
				afterErrorHandlerCallback: dojo.hitch(this, function(response, ioArgs) {
					this.loadErrorHandler(response, ioArgs);
				}),
				content: params,
				timeout: this.timeout
			};			
			this.preLoad();					
			EDR.ajax.Request.post(args);
		},
		
		loadChildren: function(params, afterChildrenLoaded) {
			if (!this.isVisible()) return;
			
			var args = 	{ 
				url: this.urlLoadChildren,
				content: params,
				showProgress: false,
				successCallback: dojo.hitch(this, function(response, ioArgs) {
					var json = null;
					try {
						json = dojo.fromJson(response);
					} catch (e) {
			        	this.loadErrorHandler(response, ioArgs);
			        	return;
					}
					afterChildrenLoaded(json);					
				}),
				afterErrorHandlerCallback: dojo.hitch(this, function(response, ioArgs) {
					this.loadErrorHandler(response, ioArgs);
				}),
				timeout: this.timeout
			};			
			EDR.ajax.Request.post(args);
		},
		
		loadJson: function(json, parent) {			
			if (json == null || json.length == 0) {
				dojo.style(this.buttonContainer, "display", "none");
				this.facetForm.innerHTML = "<div style='padding:5px'>" + this.label_nofacet + "</div>";
			} else {
				this.previousOpenedItems = this.openedItems;
				this.openedItems =  new dojox.collections.ArrayList([]);
				dojo.style(this.buttonContainer, "display", "block");
				this.buildSelectedFacets(json.selectedFacets, this.facetForm);
				this.buildFacetGroups(json.facets, this.facetForm);	
			}
		},
		
		isVisible: function() {
			if (dijit.byId(EDR.prefix+"horizontalSearchPanes").leftContentPane.domNode.style.visibility != "visible") return;
			
			var node = this.domNode;
			while (node != null) {
				if (node.style != null && (node.style.display == "none" || node.style.visibility == "hidden"))
					return false;
				node = node.parentNode;
			}
			return true;
		},
		
		refresh: function() {
			if (this.isVisible()) this.load();
		},
		
		collectionChanged: function() {
			this.openedItems.clear();
			this.previousOpenedItems.clear();
		},
		
		clear: function() {
			this.inherited(arguments);
			dijit.byId(EDR.prefix+"facetTypeAheadWidget").detach();
			this.facetTypeAheadInputIndex = 0;
			this.refineSearchChk.attr("checked", true);
			this.facetSearchBtn.setDisabled(true);
			this.facetClearBtn.setDisabled(true);
		},		
		
		reset: function() {			
			this.inherited(arguments);
			
			var self = this;
			dojo.forEach(this.domNode.getElementsByTagName("INPUT"), function(input) {
				if (input.name == "andfacet") {
/*					self.toggleAndImgEventHandler({
						type: "click",
						currentTarget: input.nextSibling
					})*/
					input.name = "facet";
					input.chkbox.attr("checked", false);
				}
/*					
				} else if (input.name == "notfacet") {
					self.toggleNotImgEventHandler({
						type: "click",
						currentTarget: input.nextSibling.nextSibling
					})
				}
*/
			});
			this.facetTypeAheadWidget.detach();
			this.refineSearchChk.attr("checked", true);
			this.facetSearchBtn.setDisabled(true);
			this.facetClearBtn.setDisabled(true);
		},
		
		preLoad: function() {},		
		postLoad: function() {},		
		loadErrorHandler: function(response) {},	
			
		onFacetDialogCanceled: function(evt) {
			this.facetDialogContent.clear();
		},
		
		onFacetDialogApplied: function(evt) {
			this.andfacets = this.facetDialogContent.andfacets;
			this.notfacets = this.facetDialogContent.notfacets;
			
			if (this.andfacets.count == 0) return;
			
			var searchType = this.newSearchChk.checked ? "search" : "refineSearch";
			this.submitSearch(searchType);
			this.facetDialog.cancelFunction();
		},

		facetSelectedEventHandler: function(evt) {
			this.inherited("facetSelectedEventHandler", arguments);
			if (this.facetDialog.open) this.facetDialog.cancelFunction();
			this.submitSearch("refineSearch");
		},

		onSearchButtonClicked: function(evt) {
			var searchType = this.newSearchChk.checked ? "search" : "refineSearch";
			this.submitSearch(searchType);
		},
		
		onClearButtonClicked: function(evt) {
			this.reset();
		},
				
		toggleCheckBoxEventHandler: function(chkbox) {
			this.inherited("toggleCheckBoxEventHandler", arguments);
			if ( (this.andfacets == null || this.andfacets.count == 0) )
			{
//				this.newSearchChk.attr("checked", true);
				this.facetSearchBtn.setDisabled(true);
				this.facetClearBtn.setDisabled(true);
			} else {				
//				this.refineSearchChk.attr("checked", true);	
				this.facetSearchBtn.setDisabled(false);
				this.facetClearBtn.setDisabled(false);
			}
		},
		
		onMoreLinkClicked: function(evt) {
			this.setupFacetDialog(evt.currentTarget.facetName, evt.currentTarget.facetPath, evt.currentTarget.facetId, this.facetDialogContent);
			EDR.dialog.util.show(this.facetDialog);
		},
				
		setupFacetDialog: function(facetName, facetPath, facetId, facetDialogContent) {
			facetDialogContent.facetName = facetName;
			facetDialogContent.facetPath = facetPath;
			facetDialogContent.facetId = facetId;
			facetDialogContent.maxSize = this.maxSize;
			facetDialogContent.andfacets = this.andfacets.clone();
			facetDialogContent.notfacets = this.notfacets.clone();
			facetDialogContent.load();
		},
		
		toggleFacetEventHandler: function(evt) {
			if(evt.keyCode == dojo.keys.UP_ARROW || evt.keyCode == dojo.keys.DOWN_ARROW){
				this.focusNextFacetNode(evt.currentTarget, (evt.keyCode == dojo.keys.UP_ARROW) ? true : false);
			}
			if (evt.type != "click" && evt.keyCode != dojo.keys.ENTER && evt.charCode != dojo.keys.SPACE
				&& evt.keyCode != dojo.keys.RIGHT_ARROW && evt.keyCode != dojo.keys.LEFT_ARROW ) return;
			
			var refTitle = evt.currentTarget;			
			var arrowImg = refTitle.childNodes[1].firstChild;
			var refGroupList = refTitle.nextSibling;
			var refList = refGroupList.nextSibling;
			
			if((evt.keyCode == dojo.keys.RIGHT_ARROW && refGroupList.style.display != 'none')||
				(evt.keyCode == dojo.keys.LEFT_ARROW && refGroupList.style.display == 'none')) return;
			
			if (refGroupList.style.display == 'none') {			
				if (refGroupList.firstChild == null) this.buildFacetGroups(refTitle.facet.facets, refGroupList);
				if (refList.firstChild == null) {
					this.buildFacetItems(refTitle.facet.items, refList);
					if (refTitle.facet.more) {
						refList.appendChild(this.buildFacetTypeAheadInput(refTitle.facet.facetLabel, "", refTitle.facet.facetId));
//						refList.appendChild(this.buildMoreLink(refTitle.facet.facetLabel, "", refTitle.facet.facetId));
						refList.appendChild(this.buildMoreLink(refTitle.facet.facetName, "", refTitle.facet.facetId));
					}
				}				
				arrowImg.src = this.imgBasePath + "arrow_down8.png";
				refGroupList.style.display = 'block';
				refList.style.display = 'block';
				
				this.onElemOpened(refTitle.facet.postParamValue);
			} else {
				arrowImg.src = this.imgBasePath + (this.isLeftToRight() ? "arrow_right8.png" : "arrow_left8.png");
				refGroupList.style.display = 'none';
				refList.style.display = 'none';

				this.onElemClosed(refTitle.facet.postParamValue);
			}		
		},
		
		toggleNestedItemEventHandler: function(evt) {
			if(evt.keyCode == dojo.keys.UP_ARROW || evt.keyCode == dojo.keys.DOWN_ARROW){
				this.focusNextFacetNode(evt.currentTarget, (evt.keyCode == dojo.keys.UP_ARROW) ? true : false);
			}
			if (evt.type != "click" && evt.keyCode != dojo.keys.ENTER && evt.charCode != dojo.keys.SPACE
				&& evt.keyCode != dojo.keys.RIGHT_ARROW && evt.keyCode != dojo.keys.LEFT_ARROW) return;
			
			var container = evt.currentTarget.parentNode.parentNode;
			var arrowImg = evt.currentTarget.firstChild;
			var children = container.childNodes[1];
			
			if((evt.keyCode == dojo.keys.RIGHT_ARROW && children.style.display != 'none')||
				(evt.keyCode == dojo.keys.LEFT_ARROW && children.style.display == 'none')) return;
			
			if (children.style.display == 'none') {			
				if (children.firstChild == null) {
					var item = container.item;
					var items = container.item.items;
					if (items == null || items.length == 0) {
						var params = {
							facetName: item.facetName,
							facetPath: item.postParamValue,
							maxSize: this.defaultSize
						};
						this.loadChildren(params, dojo.hitch(this, function(json) {
							items = container.item.items = json.items;
							// avoid ajax problem (remove duplicate items)
							if (children.firstChild != null) {
								dojo.forEach(dijit.findWidgets(children), function(widget) {
									widget.destroy();
								});
								dojo.empty(children);
							}
							this.buildFacetItems(items, children);
							if (container.item.more) {
								children.appendChild(this.buildFacetTypeAheadInput(items[0].facetName, items[0].facetPath, ""));
								children.appendChild(this.buildMoreLink(items[0].facetName, items[0].facetPath, ""));
							}
							arrowImg.src = this.imgBasePath + "arrow_down8.png";
							//setTimeout(function() {dojo.fx.wipeIn({node: children, duration: 300}).play();}, 0);
							children.style.display = 'block';
							
							this.onElemOpened(item.postParamValue);
						}));
					} else {
//						this.buildFacetItems(items, children);
//						if (container.item.more) {
//							children.appendChild(this.buildFacetTypeAheadInput(items[0].facetName, items[0].facetPath));
//							children.appendChild(this.buildMoreLink(items[0].facetName, items[0].facetPath));
//						}
//						arrowImg.src = this.imgBasePath + "arrow_down8.png";
//						children.style.display = 'block';
					}
				} else {
					arrowImg.src = this.imgBasePath + "arrow_down8.png";
					//setTimeout(function() {dojo.fx.wipeIn({node: children, duration: 300}).play();}, 0);
					children.style.display = 'block';

					this.onElemOpened(container.item.postParamValue);
				}
			} else {
				arrowImg.src = this.imgBasePath + (this.isLeftToRight() ? "arrow_right8.png" : "arrow_left8.png");
				children.style.display = 'none';
				
				this.onElemClosed(container.item.postParamValue);
			}		
		},
		
		onElemOpened: function(postParamValue) {
			if (this.loadRefCounter >= 1) {
				this.loadRefCounter--;
				if (this.loadRefCounter <= 0) {
					this.postLoad();
				}
			}
			
			if (!this.openedItems.contains(postParamValue)) {
				this.openedItems.add(postParamValue);
			}
		},
		
		onElemClosed: function(postParamValue) {
			var removeValues = [];
			for (var i=0; i<this.openedItems.count; i++) {
				// close descendats
				var value = this.openedItems.item(i);
				if (value.indexOf(postParamValue) == 0) {
					removeValues.push(value);
				}
			}
			for (var i=0; i<removeValues.length; i++) {
				this.openedItems.remove(removeValues[i]);
			}
//			console.debug(this.openedItems);
			this.postLoad();
		},
		
		buildSelectedFacets: function(facets, parent) {
			var self = this;
			if (parent == null) parent = this.facetForm;
			if (facets == null || facets.length == 0) return;
			var container = dojo.create("DIV", {
				innerHTML:"<span>" + this.label_narrowedby + ":</span>",
				className:"selected-facet-container"
	//			style:"padding-left:5px;font-weight:bold;margin-bottom:5px;"
			}, parent);
			dojo.forEach(facets, function(facet, index) {
				self.buildSelectedFacet(facet, container);
			});
		},
		
		buildSelectedFacet: function(facet, parent) {
			var container = dojo.create("DIV", {className:"selected-facet"}, parent);
			var tooltip = dojo.string.substitute(this.label_removefacet, [facet.label]);
			var imgAnchor = dojo.create("A", {
				title: tooltip,
				href:"javascript:;"
			}, container);
			var img = dojo.create("IMG", {
				src:this.imgBasePath + "delete23.png",
				className:"selected-facet-img",
				alt:tooltip,
				title:tooltip
//				style:"width:15px;height:15px;vertical-align:bottom;"
			}, imgAnchor);
			var anchor = dojo.create("A", {
				innerHTML:facet.label,
				className:"selected-facet-label",
//				style:"padding-left:5px;",
				title:tooltip
			}, container);
						
			this.handlers.push(dojo.connect(imgAnchor, "onclick", this, function() {this.removeFacet(facet.value);}));
			this.handlers.push(dojo.connect(anchor, "onclick", this, function() {this.removeFacet(facet.value);}));
			return container;
		},
		
		buildFacetGroups: function(facets, parent) {
			var self = this;
			if (parent == null) parent = this.facetForm;
			if (facets == null) return;
			dojo.forEach(facets, function(facet, index) {
				var elem = self.buildFacetGroupElem(facet);
				parent.appendChild(elem);				
				
				if (self.previousOpenedItems.contains(facet.postParamValue)) {
					self.loadRefCounter++;
					var evt = { type: "click", currentTarget: elem.firstChild/*ref title*/ };
					self.toggleFacetEventHandler(evt, false);					
				}
			});
		},
				
		buildFacetItems: function(items, parent) {
			var self = this;
			dojo.forEach(items, function(item, index) {
				var elem = self.buildFacetItemElem(item);
				parent.appendChild(elem);
				
				if (self.previousOpenedItems.contains(item.postParamValue)) {
					self.loadRefCounter++;
					var evt = { type: "click", currentTarget: elem.firstChild.firstChild.nextSibling/*arrow container*/ };
					self.toggleNestedItemEventHandler(evt, false);					
				}
			});
		},
		
		buildFacetItemElem: function(item) {
			var container = dojo.create("DIV", {}, null);
			container.item = item;
			var itemContent = this._buildFacetItemElem(item);
			container.appendChild(itemContent);
			if (item.hasChildren) {
				var children = dojo.create("DIV", {className:"refinement-list", style:"display:none"}, container);
				children.style.display = "none";
			}
			return container;
		},
		
		_buildFacetItemElem: function(item) {
			var container = dojo.doc.createElement("DIV");
			var isAndFacet = this.andfacets.contains(item.postParamValue);
			var isNotFacet = this.notfacets.contains(item.postParamValue);
			
			var facetInput = dojo.create("INPUT", {
				type: "hidden",
				value: item.postParamValue,
				name: isAndFacet ? "andfacet" : "facet"
			}, container);

			var arrowContainer = dojo.create("DIV", {className: "arrow-container"}, container);
			var arrowImg = dojo.create("IMG", {className: "arrow-img-hierarchical",
				alt: dojo.string.substitute(EDR.messages.tooltip_facet_expandcollapse, [item.itemLabel]),
				src: this.imgBasePath + (this.isLeftToRight() ? "arrow_right8.png" : "arrow_left8.png"),
				tabindex: 0
			}, arrowContainer);
			
			if (item.hasChildren) {
				dojo.style(arrowContainer, "visibility", "visible");
				this.handlers.push(dojo.connect(arrowContainer, "onclick", this, this.toggleNestedItemEventHandler));
				this.handlers.push(dojo.connect(arrowContainer, "onkeypress", this, this.toggleNestedItemEventHandler));				
			} else {
				dojo.style(arrowContainer, "visibility", "hidden");
			}

			var chkbox = new dijit.form.CheckBox({id:EDR.prefix+this.itemIdPrefix + item.itemId+"_chkbox", name:""});
			if (isAndFacet) chkbox.attr("checked", true);
			container.appendChild(chkbox.domNode);
			facetInput.chkbox = chkbox;
			
			this.handlers.push(dojo.connect(chkbox, "onClick", this, function(evt) {
				this.toggleCheckBoxEventHandler(chkbox);
			}));
			
			var facetLabel = this.buildItemLabel(item);
			var labelTitle = dojo.string.substitute(EDR.messages.tooltip_facet_quick, ['"' + facetLabel + '"']);
			var labelLink = dojo.create("A", {
				href: "javascript:;", itemId: item.itemId, "for": item.itemId+"_chkbox",
				title: labelTitle}, null);
			var labelName = dojo.create("LABEL", {"for":EDR.prefix+this.itemIdPrefix + item.itemId+"_chkbox", role:"treeitem"}, labelLink);
			labelName.appendChild(dojo.doc.createTextNode(facetLabel));
			
			this.handlers.push(dojo.connect(labelLink, "onkeypress", this, this.onFacetLabelKeyPress));
			this.handlers.push(dojo.connect(labelLink, "onclick", this, this.facetSelectedEventHandler));			
			var countText = dojo.create("span", {innerHTML: "<bdo dir='ltr'>(" + item.count + ")</bdo>"}, null);
			
			if (this.isLeftToRight()) {
				container.appendChild(labelLink);
				container.appendChild(countText);
			} else {
				container.appendChild(countText);
				container.appendChild(labelLink);
			}
			
			return container;
		},
				
		buildMoreLink: function(facetName, facetPath, facetId) {
			var link = dojo.create("A", {
				href:"javascript:;", className:"morelink", 
				title:this.label_showmore,
				innerHTML:EDR.messages.searchpane_morelink
			}, null);
			link.facetName = facetName;
			link.facetPath = facetPath;
			link.facetId = facetId;
			this.handlers.push(dojo.connect(link, "onclick", this, "onMoreLinkClicked"));
			return link;
		},
		
		buildFacetTypeAheadInput: function(facetName, facetPath, facetId) {
			this.facetTypeAheadInputIndex += 1;
			var container = dojo.create("DIV", {
				style: "padding-left:15px;"
			}, null);
			var input = dojo.create("INPUT", {				
				id: EDR.prefix+"facetTypeAheadInput_" + this.facetTypeAheadInputIndex,
				style: "width:95%;",
				type: "text",
				title: this.label_typeahead
			}, container);
			input.facetName = facetName;
			input.facetPath = facetPath;
			input.facetId = facetId;
			var typeAhead = this.facetTypeAheadWidget;
			
			var self = this;
			this.handlers.push(dojo.connect(input, "onfocus", typeAhead, function(e) {
				typeAhead.attach(input.id, self.urlTypeAhead, false);
				typeAhead.onExecute = function(e, value) {
					var td = null;
					if (e.type == "click") {
						td = e.currentTarget.firstChild;
					} else {
						var selectedItem = self.facetTypeAheadWidget.selectedItem;
						if (selectedItem != null) {
							td = selectedItem.firstChild;
						}
					}
					if (td != null) {
						self.andfacets.add(td.getAttribute("param"));
						dijit.byId(EDR.prefix+"searchManager").submitSearch(null, "refineSearch", self.getFormValues());
					}
				}
			}));
			return container;
		},
		
		onFacetLabelKeyPress: function(evt){
			if(evt.keyCode == dojo.keys.UP_ARROW || evt.keyCode == dojo.keys.DOWN_ARROW){
				var target = evt.currentTarget.previousSibling.previousSibling;
				this.focusNextFacetNode(target, (evt.keyCode == dojo.keys.UP_ARROW) ? true : false);
			}
		},
		
		focusNextFacetNode: function(target, isUp){
			var nodeList = [];
			var topFacets = dojo.query("div.refinement-title", this.facetTreeContainer);
			for(var i=0; i<topFacets.length; i++){
				nodeList.push(topFacets[i]);
				dojo.query("div.arrow-container",topFacets[i].parentNode).forEach(function(node){
					nodeList.push(node);
				});
			}
			var index = null;
			var nextNode = null;
			var i = isUp ? nodeList.length-1 : 0;
			while(isUp?(i>=0):(i<nodeList.length)){
				if(index!=null && nodeList[i].parentNode.parentNode.parentNode.style.display!="none"){
					nextNode = nodeList[i];
					break;
				}
				if(target == nodeList[i]){
					index = i;
				} 
				isUp ? i-- : i++;
			}
			if(nextNode != null){
				if(dojo.hasClass(nextNode,"refinement-title")){
					nextNode.focus();
				}else if(nextNode.style.visibility=="hidden"){
					nextNode.nextSibling.nextSibling.focus();
				}else{
					nextNode.getElementsByTagName("img")[0].focus();
				}
			}
		},
		
		// messages
		label_showmore: EDR.messages.tooltip_showmorefacet,
		label_narrowedby: EDR.messages.facets_narrowedby,
		label_removefacet: EDR.messages.tooltip_facet_selected_remove,
		label_typeahead: EDR.messages.tooltip_facet_typeahead,
		label_newsearch: EDR.messages.searchpane_newsearch,
		label_refinesearch: EDR.messages.searchpane_addsearch,
		label_nofacet: EDR.messages.facets_noResult,
		label_search: EDR.messages.searchpane_search,
		label_clear: EDR.messages.searchpane_clear,
		messages_tooltip_searchpane_newsearch_link: EDR.messages.tooltip_searchpane_newsearch_link,
		messages_tooltip_searchpane_addsearch_link: EDR.messages.tooltip_searchpane_addsearch_link
	}
);

}

if(!dojo._hasResource["widgets.ESFacetTree"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.ESFacetTree"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.ESFacetTree");



dojo.declare(
	"widgets.ESFacetTree", [widgets.FacetTree],
	{		
		requestId: "",
		searchPane: null,		
		
		startup: function() {
			this.inherited(arguments);
		},
		
		preLoad: function() {
			EDR.ajax.Loading.setIsLoading(this.domNode);
		},
		
		postLoad: function() {
			EDR.ajax.Loading.clearIsLoading(this.domNode);
		},
		
		loadErrorHandler: function(response) {
			EDR.ajax.Loading.clearIsLoading(this.domNode);
		}		
	}
);

}

if(!dojo._hasResource["dojo.NodeList-fx"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.NodeList-fx"] = true;
dojo.provide("dojo.NodeList-fx");


/*=====
dojo["NodeList-fx"] = {
	// summary: Adds dojo.fx animation support to dojo.query()
};
=====*/

dojo.extend(dojo.NodeList, {
	_anim: function(obj, method, args){
		args = args||{};
		return dojo.fx.combine(
			this.map(function(item){
				var tmpArgs = { node: item };
				dojo.mixin(tmpArgs, args);
				return obj[method](tmpArgs);
			})
		); // dojo._Animation
	},

	wipeIn: function(args){
		//	summary:
		//		wipe in all elements of this NodeList. Returns an instance of dojo._Animation
		//	example:
		//		Fade in all tables with class "blah":
		//		|	dojo.query("table.blah").wipeIn().play();
		return this._anim(dojo.fx, "wipeIn", args); // dojo._Animation
	},

	wipeOut: function(args){
		//	summary:
		//		wipe out all elements of this NodeList. Returns an instance of dojo._Animation
		//	example:
		//		Wipe out all tables with class "blah":
		//		|	dojo.query("table.blah").wipeOut().play();
		return this._anim(dojo.fx, "wipeOut", args); // dojo._Animation
	},

	slideTo: function(args){
		//	summary:
		//		slide all elements of the node list to the specified place.
		//		Returns an instance of dojo._Animation
		//	example:
		//		|	Move all tables with class "blah" to 300/300:
		//		|	dojo.query("table.blah").slideTo({
		//		|		left: 40,
		//		|		top: 50
		//		|	}).play();
		return this._anim(dojo.fx, "slideTo", args); // dojo._Animation
	},


	fadeIn: function(args){
		//	summary:
		//		fade in all elements of this NodeList. Returns an instance of dojo._Animation
		//	example:
		//		Fade in all tables with class "blah":
		//		|	dojo.query("table.blah").fadeIn().play();
		return this._anim(dojo, "fadeIn", args); // dojo._Animation
	},

	fadeOut: function(args){
		//	summary:
		//		fade out all elements of this NodeList. Returns an instance of dojo._Animation
		//	example:
		//		Fade out all elements with class "zork":
		//		|	dojo.query(".zork").fadeOut().play();
		//	example:
		//		Fade them on a delay and do something at the end:
		//		|	var fo = dojo.query(".zork").fadeOut();
		//		|	dojo.connect(fo, "onEnd", function(){ /*...*/ });
		//		|	fo.play();
		return this._anim(dojo, "fadeOut", args); // dojo._Animation
	},

	animateProperty: function(args){
		//	summary:
		//		see dojo.animateProperty(). Animate all elements of this
		//		NodeList across the properties specified.
		//	example:
		//	|	dojo.query(".zork").animateProperty({
		//	|		duration: 500,
		//	|		properties: { 
		//	|			color:		{ start: "black", end: "white" },
		//	|			left:		{ end: 300 } 
		//	|		} 
		//	|	}).play();
		return this._anim(dojo, "animateProperty", args); // dojo._Animation
	},

	anim: function(	/*Object*/ 			properties, 
					/*Integer?*/		duration, 
					/*Function?*/		easing, 
					/*Function?*/		onEnd,
					/*Integer?*/		delay){
		//	summary:
		//		Animate one or more CSS properties for all nodes in this list.
		//		The returned animation object will already be playing when it
		//		is returned. See the docs for `dojo.anim` for full details.
		//	properties: Object
		//		the properties to animate
		//	duration: Integer?
		//		Optional. The time to run the animations for
		//	easing: Function?
		//		Optional. The easing function to use.
		//	onEnd: Function?
		//		A function to be called when the animation ends
		//	delay:
		//		how long to delay playing the returned animation
		//	example:
		//		Another way to fade out:
		//	|	dojo.query(".thinger").anim({ opacity: 0 });
		//	example:
		//		animate all elements with the "thigner" class to a width of 500
		//		pixels over half a second
		//	|	dojo.query(".thinger").anim({ width: 500 }, 700);
		var canim = dojo.fx.combine(
			this.map(function(item){
				return dojo.animateProperty({
					node: item,
					properties: properties,
					duration: duration||350,
					easing: easing
				});
			})
		); 
		if(onEnd){
			dojo.connect(canim, "onEnd", onEnd);
		}
		return canim.play(delay||0); // dojo._Animation
	}
});

}

if(!dojo._hasResource["dojox.fx.Shadow"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.fx.Shadow"] = true;
dojo.provide("dojox.fx.Shadow");
dojo.experimental("dojox.fx.Shadow"); 

 
 

dojo.declare("dojox.fx.Shadow",
	dijit._Widget,{
	// summary: Adds a drop-shadow to a node.
	// 
	// example:
	// |	// add drop shadows to all nodes with class="hasShadow"
	// |	dojo.query(".hasShadow").forEach(function(n){
	// |		var foo = new dojox.fx.Shadow({ node: n });
	// |		foo.startup();
	// |	});
	//
	// shadowPng: String
	// 	Base location for drop-shadow images
	shadowPng: dojo.moduleUrl("dojox.fx", "resources/shadow"),

	// shadowThickness: Integer
	// 	How wide (in px) to make the shadow
	shadowThickness: 7,

	// shadowOffset: Integer
	//	How deep to make the shadow appear to be
	shadowOffset: 3,

	// opacity: Float
	//	Overall opacity of the shadow
	opacity: 0.75,

	// animate: Boolean	
	// 	A toggle to disable animated transitions
	animate: false,

	// node: DomNode
	// 	The node we will be applying this shadow to
	node: null,

	startup: function(){
		// summary: Initializes the shadow.

		this.inherited(arguments);
		this.node.style.position = "relative";
		// make all the pieces of the shadow, and position/size them as much
		// as possible (but a lot of the coordinates are set in sizeShadow
		this.pieces={};
		var x1 = -1 * this.shadowThickness;
		var y0 = this.shadowOffset;
		var y1 = this.shadowOffset + this.shadowThickness;
		this._makePiece("tl", "top", y0, "left", x1);
		this._makePiece("l", "top", y1, "left", x1, "scale");
		this._makePiece("tr", "top", y0, "left", 0);
		this._makePiece("r", "top", y1, "left", 0, "scale");
		this._makePiece("bl", "top", 0, "left", x1);
		this._makePiece("b", "top", 0, "left", 0, "crop");
		this._makePiece("br", "top", 0, "left", 0);

		this.nodeList = dojo.query(".shadowPiece",this.node);

		this.setOpacity(this.opacity);
		this.resize();
	},

	_makePiece: function(name, vertAttach, vertCoord, horzAttach, horzCoord, sizing){
		// summary: append a shadow pieces to the node, and position it
		var img;
		var url = this.shadowPng + name.toUpperCase() + ".png";
		if(dojo.isIE < 7){
			img = dojo.create("div");
			img.style.filter="progid:DXImageTransform.Microsoft.AlphaImageLoader(src='"+url+"'"+
				(sizing?", sizingMethod='"+sizing+"'":"") + ")";
		}else{
			img = dojo.create("img", { src:url });
		}

		img.style.position="absolute"; 
		img.style[vertAttach]=vertCoord+"px";
		img.style[horzAttach]=horzCoord+"px";
		img.style.width=this.shadowThickness+"px";
		img.style.height=this.shadowThickness+"px";
		dojo.addClass(img,"shadowPiece"); 
		this.pieces[name]=img;
		this.node.appendChild(img);

	},

	setOpacity: function(/* Float */n,/* Object? */animArgs){
		// summary: set the opacity of the underlay
		// note: does not work in IE? FIXME.
		if(dojo.isIE){ return; } 
		if(!animArgs){ animArgs = {}; } 
		if(this.animate){
			var _anims = [];
			this.nodeList.forEach(function(node){
				_anims.push(dojo._fade(dojo.mixin(animArgs,{ node: node, end: n })));
			});
			dojo.fx.combine(_anims).play();
		}else{
			this.nodeList.style("opacity",n);
		}	

	},

	setDisabled: function(/* Boolean */disabled){
		// summary: enable / disable the shadow
		if(disabled){
			if(this.disabled){ return; }
			if(this.animate){ this.nodeList.fadeOut().play(); 
			}else{ this.nodeList.style("visibility","hidden"); }
			this.disabled = true;
		}else{
			if(!this.disabled){ return; }
			if(this.animate){ this.nodeList.fadeIn().play(); 
			}else{ this.nodeList.style("visibility","visible"); }
			this.disabled = false;
		}
	},

	resize: function(/* dojox.fx._arg.ShadowResizeArgs */args){
		// summary: Resizes the shadow based on width and height.
		var x; var y;
		if(args){ x = args.x; y = args.y;
		}else{
			var co = dojo._getBorderBox(this.node); 
			x = co.w; y = co.h; 
		}
		var sideHeight = y - (this.shadowOffset+this.shadowThickness);
		if (sideHeight < 0) { sideHeight = 0; }
		if (y < 1) { y = 1; }
		if (x < 1) { x = 1; }
		with(this.pieces){
			l.style.height = sideHeight+"px";
			r.style.height = sideHeight+"px";
			b.style.width = x+"px";
			bl.style.top = y+"px";
			b.style.top = y+"px";
			br.style.top = y+"px";
			tr.style.left = x+"px";
			r.style.left = x+"px";
			br.style.left = x+"px";
		}
	}
});

}

if(!dojo._hasResource["widgets.HorizontalBarChart"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.HorizontalBarChart"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.HorizontalBarChart");





dojo.declare("widgets.HorizontalBarChart",
	[dijit._Widget, dijit._Templated],
	{
		templateString:"<div tabindex=\"0\" style=\"overflow-y:auto;overflow-x:hidden;position:relative;\">\n\t<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" dojoAttachPoint=\"chartContainer\"\n\t\tstyle=\"white-space:nowrap; table-layout:fixed; position:absolute; left:0px; top0px; width:100%;\">\n\t\t<thead dojoAttachPoint=\"chartHeaderContainer\">\n\t\t</thead>\n\t\t<tbody dojoAttachPoint=\"chartBodyContainer\">\n\t\t</tbody>\n\t\t<tfoot dojoAttachPoint=\"chartFooterContainer\">\n\t\t</tfoot>\n\t</table>\n\t<div dojoAttachPoint=\"dummyDiv\" style=\"width:100%;height:0px;\"/>\n\t<span dojoAttachPoint=\"hiddenSpan\" style=\"visibility:hidden;position:absolute;\"></span>\n</div>\n",
		imgBasePath: EDR.config.imageBaseDir,
		imgFileName: "gradient_chartbar.png",
		barImgPath: "",
		
		json: null,
		url: '',
		_autoLoad: false,
		handlers:[],
		animations: [],
		shadows: [],
		resizing: false,
		
		rowHeight: 20,
		labelWidth: 100,
		barWidth: -1,
		barHeight: 10,
		barAnimDuration: 700,
		barImgWidth: -1,
		
		maxScrollTop: 0,
		maxScrollDelta: 0,
		numOfRows: 0,
		beginOffset: 0,
		endOffset: 4,
		
		prevFocusedNode: null,				
		
		postCreate: function() {
			this.animations = [];
			this.handlers = []
			this.barImgPath = this.imgBasePath + "gradient_chartbar.png",
			this.inherited("postCreate", arguments);
			if(this._autoLoad) this.load(this.url);
			this.handlers.push(dojo.connect(this.domNode, "onscroll", this, "onScroll"));
		},
		
		clear: function() {
			var rows = this.chartBodyContainer.rows;
			while (rows.length != 0) {
				this.chartBodyContainer.deleteRow(0);
			}
			this.animations = [];
			this.shadows = [];
		},
		
		reload: function(field) {
			this.clear();
			this.load(this.url, field);
		},
		
		load: function(url, field) {
			this.preLoad();
			var self = this;
			if (url == null) url = this.url;
			function load(response, ioArgs) {
				var json = null;
				try {
					json = dojo.fromJson(response);
				} catch (e) {
			        self.loadErrorHandler(response);
				}
				self.loadJson(json);
				self.postLoad();					
			}
			var param = {
				url: url,
				load: load,
				error: self.loadErrorHandler,
				timeout: 10000
			};
			dojo.xhrGet(param);
		},
		
		loadJson: function(json) {
			this.json = json;
			this.clear();
			this.render(json);
		},
		
		preLoad: function() {
		},
		
		postLoad: function() {
		},		
				
		render: function(json) {
			var items = json.items;
			if(items == null || items.length == 0) return;

			var size = dojo.contentBox(this.domNode);
			this.labelWidth = size.w / 2;
			this.barWidth = size.w - this.labelWidth;
			this.barImgWidth = this.barWidth - 20/*scroll width*/;
			
			this.numOfRows = Math.floor(size.h / this.rowHeight) + 1;
			this.beginOffset = 0;
			this.endOffset = Math.min(this.numOfRows, items.length);
			
			var dummyHeight = Math.max(items.length * this.rowHeight, 0);
			dojo.style(this.dummyDiv, "height", dummyHeight + "px");
			this.maxScrollTop = dummyHeight - size.h;
			this.maxScrollDelta = Math.max((items.length - this.numOfRows) * this.rowHeight, 0);
			
			var beginOffset = this.beginOffset;
			var endOffset = Math.min(this.endOffset, items.length);
			
			this.animations = [];
			this.shadows = [];
			for(var i=beginOffset; i<endOffset; i++) {
				var tr = dojo.doc.createElement("TR");
				dojo.style(tr, "height", this.rowHeight + "px");

				var labelCell = this.buildLabelCell(items[i]);
				tr.appendChild(labelCell);
				this.handlers.push(dojo.connect(labelCell, "onkeypress", this, "onCellKeyPressed"));
				this.handlers.push(dojo.connect(labelCell.firstChild, "onfocus", this, "onCellFocused"));

				var barCell = this.buildBarCell(items[i], json.maxCount);
				tr.appendChild(barCell);
				this.handlers.push(dojo.connect(barCell, "onkeypress", this, "onCellKeyPressed"));
				this.handlers.push(dojo.connect(barCell.firstChild, "onfocus", this, "onCellFocused"));
				
				this.chartBodyContainer.appendChild(tr);
			}
			var rows = this.chartBodyContainer.rows;
			var lastBarDiv = rows[rows.length-1].firstChild.nextSibling;

			if (this.animations.length != 0) dojo.fx.combine(this.animations).play();
			if (this.shadows.length != 0) {
				var self = this;
				setTimeout(function() {
					for (var i=0; i<self.shadows.length; i++) {
						self.shadows[i].resize();
					}
				}, 0);
			}
		},
		
		updateRange: function() {
			var items = this.json.items;
			if(items == null || items.length == 0) return;
			
			var beginOffset = Math.max(0, this.beginOffset);
			var endOffset = Math.min(this.endOffset, items.length);
			
			for(var i=beginOffset, trIndex=0; i<endOffset; i++) {
				var tr = this.chartBodyContainer.rows[trIndex];
				this.updateLabel(tr.cells[0], items[i]);
				this.updateBar(tr.cells[1], items[i], this.json.maxCount);
				trIndex++;
			}
		},
		
		buildLabelCell: function(item) {
			var cell = dojo.doc.createElement("TH");
			dojo.style(cell, "width", this.labelWidth + "px");
			cell.style.margin = "0px";
			dojo.style(cell, "overflow", "hidden");
			dojo.style(cell, "whiteSpace", "nowrap");
			this.renderLabel(cell, item);			
			return cell;
		},
		
		renderLabel: function(cell, item) {
			var label = this._getTruncatedLabel(item, this.labelWidth);
			var tooltip = item.itemLabel + " : (" + item.count + ")";
			if (item.isSearchable) {
				cell.innerHTML = "<a href='javascript:;' tabindex='0' style='font-style:italic;font-size:8pt;'></a>";				
				cell.firstChild.title = tooltip;
				cell.firstChild.appendChild(dojo.doc.createTextNode(label));
				this.handlers.push(dojo.connect(cell.firstChild, "onclick", this, "onLabelClicked"));
			} else {
				cell.innerHTML = "<span tabindex='0' style='font-style:italic;font-size:8pt;'></span>";
				cell.firstChild.appendChild(dojo.doc.createTextNode(label));
				cell.firstChild.title = tooltip;
			}
		},
		
		updateLabel: function(cell, item) {
			if (item == null) {
				cell.firstChild.innerHTML = "";
			} else {
				var label = this._getTruncatedLabel(item, this.labelWidth);
				var tooltip = item.itemLabel + " : (" + item.count + ")";
				cell.firstChild.innerHTML = label;
				cell.firstChild.title = tooltip;
			}
		},
		
		buildBarCell: function(item, maxCount) {
			var cell = dojo.doc.createElement("TD");
			dojo.style(cell, "width", this.barWidth);
			this.renderBar(cell, item, maxCount);	        
			return cell;
		},
		
		renderBar: function(cell, item, maxCount) {
			var barSize = { w:this.barImgWidth * (item.count/maxCount), h:this.barHeight};
			var tooltip = item.itemLabel + " : (" + item.count + ")";
			cell.innerHTML = 
				"<div tabindex='0' style='margin-bottom:5px;width:" + barSize.w + "px;height:" + barSize.h + "px;'>" +
					"<img src='" + this.barImgPath + "' alt='" + tooltip + "' title='" + tooltip + "'" +
						" width='100%' height='" + (barSize.h) + "px'/>" +
				"</div>";
			var barDiv = cell.firstChild;
			barDiv.item = item;
			barDiv.barImg = cell.firstChild.firstChild; // Bar div has pointer to Bar img
			if (item.isSearchable) {
				this.handlers.push(dojo.connect(barDiv, "onclick", this, "onBarChartClicked"));
				this.handlers.push(dojo.connect(barDiv, "onkeypress", this, "onBarChartClicked"));
				this.handlers.push(dojo.connect(barDiv, "onmouseover", this, "onChartBarMouseOver"));
				this.handlers.push(dojo.connect(barDiv, "onmouseout", this, "onChartBarMouseOut"));
			}
			if (this.needAnimation()) {
		        this.animations.push(this.buildBarAnimation(barDiv, 0, barSize.w));
			} else {
				dojo.style(barDiv, "width", barSize.w + "px");
				if (barDiv.shadow == null) {
					var shadow = new dojox.fx.Shadow({ node: barDiv});
					barDiv.shadow = shadow;
					shadow.startup();
				}
				this.shadows.push(shadow);
			}
		},
		
		barSelected: function(item) {
			// override
		},
		
		onScroll: function(evt) {
			var scrollTop = Math.abs(parseInt(this.domNode.scrollTop));			
			var scrollDelta = scrollTop % this.rowHeight;
			var rows = Math.floor(scrollTop / this.rowHeight); 
			
			if (scrollTop == this.maxScrollTop) {
				this.endOffset = this.json.items.length;		
				this.beginOffset = this.endOffset - this.numOfRows;
				dojo.style(this.chartContainer, "top", this.maxScrollDelta + "px");				
			} else if (scrollTop == 0) {
				this.beginOffset = 0;
				this.endOffset = this.beginOffset + this.numOfRows;		
				dojo.style(this.chartContainer, "top", 0 + "px");							
			} else {
				this.beginOffset = rows;
				this.endOffset = this.beginOffset + this.numOfRows;		
				dojo.style(this.chartContainer, "top", scrollTop - scrollDelta + "px");
			}			
			this.updateRange();
		},
		
		onCellFocused: function(evt) {
			var targetCell = evt.currentTarget.parentNode;
			
			var rows = this.chartBodyContainer.rows;
			var firstLabelCell = rows[0].firstChild;
			var firstBarCell = firstLabelCell.nextSibling;
			var lastLabelCell = rows[rows.length-1].firstChild;
			var lastBarCell = lastLabelCell.nextSibling;
			
			if (targetCell == firstLabelCell && this.prevFocusedNode != firstBarCell && this.beginOffset != 0) {
				this.domNode.scrollTop = 0;
				this.onScroll();
			} else if (targetCell == lastBarCell && this.prevFocusedNode != lastLabelCell && this.endOffset < this.json.items.length) {
				this.domNode.scrollTop = this.maxScrollTop;
				this.onScroll();
			}
			this.prevFocusedNode = targetCell;
		},
		
		onCellKeyPressed: function(evt) {
			if(!(evt.charOrCode && evt.charOrCode === dojo.keys.TAB)) return;
			
			var rows = this.chartBodyContainer.rows;
			var target = evt.currentTarget;
			var firstLabelCell = rows[0].firstChild;
			var firstBarCell = firstLabelCell.nextSibling;
			var lastLabelCell = rows[rows.length-1].firstChild;
			var lastBarCell = lastLabelCell.nextSibling;
			
			if (target != firstLabelCell && target != lastBarCell) return;
			
			if (target == lastBarCell) {
				if (!evt.shiftKey && this.endOffset < this.json.items.length) {
					// go to next cell					
					var scrollTop = Math.abs(parseInt(this.domNode.scrollTop)) + this.rowHeight;
					scrollTop = Math.min(scrollTop, this.maxScrollTop);					
					this.domNode.scrollTop = scrollTop;
					lastLabelCell.firstChild.focus();
					this.onScroll();
					dojo.stopEvent(evt);
				}
			} else {
				if (evt.shiftKey && this.numOfRows < this.endOffset) {
					// go to previous cell
					var scrollTop = Math.abs(parseInt(this.domNode.scrollTop)) - this.rowHeight;
					scrollTop = Math.max(scrollTop, 0);					
					this.domNode.scrollTop = scrollTop;
					firstBarCell.firstChild.focus();
					this.onScroll();
					dojo.stopEvent(evt);					
				}
			}
		},
		
		onLabelClicked: function(evt) {
			if (evt.type != "click" && evt.keyCode != dojo.keys.ENTER) return;
			this.barSelected(evt.currentTarget.parentNode.nextSibling.firstChild.item);
		},
		
		onBarChartClicked: function(evt) {
			if (evt.type != "click" && evt.keyCode != dojo.keys.ENTER) return;
			this.barSelected(evt.currentTarget.item);
		},
		
		onChartBarMouseOver: function(evt) {
			var img = evt.currentTarget.barImg;
			img.style.border = "1px solid navy";
		},
		
		onChartBarMouseOut: function(evt) {
			var img = evt.currentTarget.barImg;
			img.style.border = "none";
		},
		
		needAnimation: function() {
			if (this.resizing) return false;
			var node = this.domNode;
			while (node != null) {
				if (node.style != null && (node.style.display == "none" || node.style.visibility == "hidden"))
					return false;
				node = node.parentNode;
			}
			return true;
		},
		
		updateBar: function(cell, item, maxCount) {
			var barDiv = cell.firstChild;
			var barImg = barDiv.barImg;
			if (item == null) {
				dojo.style(barDiv, "width", 0);
				barDiv.shadow.setDisabled(true);
				barImg.alt = img.title = "";
			} else {
				var width = this.barImgWidth * (item.count/maxCount);
				dojo.style(barDiv, "width", width + "px");
				barDiv.shadow.setDisabled(false);
				barDiv.shadow.resize();
				
				var tooltip = item.itemLabel + " : (" + item.count + ")";				
				barImg.alt = barImg.title = tooltip;
			}
		},
		
		buildBarAnimation: function(target, start, end) {
			var shadow = new dojox.fx.Shadow({ node: target});
			target.shadow = shadow;
			shadow.startup();				
			var animation = dojo.animateProperty(
		    	{
		    	    node: target,
		    	    duration: this.barAnimDuration,
		    	    easing: function(n) {
		    	    	if (dojo.isIE) {
		    	    	} else {
			    	    	shadow.resize();
			    	   }
						return dojo._defaultEasing(n);
		    	    },
		    	    properties: {
		    	    	width: {start: start, end: end}
		            },
		            onEnd: function(n) {
			    	    	shadow.resize();
		            }
		        });
		    return animation;
		},
		
		_getTruncatedLabel: function(item, width) {
			var label = item.itemLabel + ""/*hack: object2string*/; 
			var count = " (" + item.count + ")";
			if (this._getStringExtent(label + count) < width) {
				return label + count;
			} else {
				var ellipse = "... (" + item.count + ")";
				var labelWidth = width - this._getStringExtent(ellipse);
				if (labelWidth > 0) { 	
					for (var i=0; i<label.length; i++) {
						var s = label.slice(0, i);
						if (labelWidth < this._getStringExtent(s) && i > 0) {
							return label.slice(0, i-1) + ellipse;
						}
					}				
				}
				return ellipse;
			}
		},
		
		_getStringExtent: function(str) {
			this.hiddenSpan.innerHTML = str;
			var size = this.hiddenSpan.offsetWidth;
			this.hiddenSpan.innerHTML = "";
			return size;
		},
		
		loadErrorHandler: function() {
		}
	}
);

}

if(!dojo._hasResource["dijit.form.ComboBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.ComboBox"] = true;
dojo.provide("dijit.form.ComboBox");








dojo.declare(
	"dijit.form.ComboBoxMixin",
	null,
	{
		// summary:
		//		Implements the base functionality for `dijit.form.ComboBox`/`dijit.form.FilteringSelect`
		// description:
		//		All widgets that mix in dijit.form.ComboBoxMixin must extend `dijit.form._FormValueWidget`.
		// tags:
		//		protected

		// item: Object
		//		This is the item returned by the dojo.data.store implementation that
		//		provides the data for this cobobox, it's the currently selected item.
		item: null,

		// pageSize: Integer
		//		Argument to data provider.
		//		Specifies number of search results per page (before hitting "next" button)
		pageSize: Infinity,

		// store: Object
		//		Reference to data provider object used by this ComboBox
		store: null,

		// fetchProperties: Object
		//		Mixin to the dojo.data store's fetch.
		//		For example, to set the sort order of the ComboBox menu, pass:
		//	|	{ sort: {attribute:"name",descending: true} }
		//		To override the default queryOptions so that deep=false, do:
		//	|	{ queryOptions: {ignoreCase: true, deep: false} }
		fetchProperties:{},

		// query: Object
		//		A query that can be passed to 'store' to initially filter the items,
		//		before doing further filtering based on `searchAttr` and the key.
		//		Any reference to the `searchAttr` is ignored.
		query: {},

		// autoComplete: Boolean
		//		If user types in a partial string, and then tab out of the `<input>` box,
		//		automatically copy the first entry displayed in the drop down list to
		//		the `<input>` field
		autoComplete: true,

		// highlightMatch: String
		// 		One of: "first", "all" or "none".
		//
		//		If the ComboBox/FilteringSelect opens with the search results and the searched
		//		string can be found, it will be highlighted.  If set to "all"
		//		then will probably want to change `queryExpr` parameter to '*${0}*'
		//
		//		Highlighting is only performed when `labelType` is "text", so as to not
		//		interfere with any HTML markup an HTML label might contain.
		highlightMatch: "first",
		
		// searchDelay: Integer
		//		Delay in milliseconds between when user types something and we start
		//		searching based on that value
		searchDelay: 100,

		// searchAttr: String
		//		Search for items in the data store where this attribute (in the item)
		//		matches what the user typed
		searchAttr: "name",

		// labelAttr: String?
		//		The entries in the drop down list come from this attribute in the
		//		dojo.data items.
		//		If not specified, the searchAttr attribute is used instead.
		labelAttr: "",

		// labelType: String
		//		Specifies how to interpret the labelAttr in the data store items.
		//		Can be "html" or "text".
		labelType: "text",

		// queryExpr: String
		//		This specifies what query ComboBox/FilteringSelect sends to the data store,
		//		based on what the user has typed.  Changing this expression will modify
		//		whether the drop down shows only exact matches, a "starting with" match,
		//		etc.   Use it in conjunction with highlightMatch.
		//		dojo.data query expression pattern.
		//		`${0}` will be substituted for the user text.
		//		`*` is used for wildcards.
		//		`${0}*` means "starts with", `*${0}*` means "contains", `${0}` means "is"
		queryExpr: "${0}*",

		// ignoreCase: Boolean
		//		Set true if the ComboBox/FilteringSelect should ignore case when matching possible items
		ignoreCase: true,

		// hasDownArrow: Boolean
		//		Set this textbox to have a down arrow button, to display the drop down list.
		//		Defaults to true.
		hasDownArrow: true,

		templateString:"<div class=\"dijit dijitReset dijitInlineTable dijitLeft\"\n\tid=\"widget_${id}\"\n\tdojoAttachEvent=\"onmouseenter:_onMouse,onmouseleave:_onMouse,onmousedown:_onMouse\" dojoAttachPoint=\"comboNode\" waiRole=\"combobox\" tabIndex=\"-1\"\n\t><div style=\"overflow:hidden;\"\n\t\t><div class='dijitReset dijitRight dijitButtonNode dijitArrowButton dijitDownArrowButton'\n\t\t\tdojoAttachPoint=\"downArrowNode\" waiRole=\"presentation\"\n\t\t\tdojoAttachEvent=\"onmousedown:_onArrowMouseDown,onmouseup:_onMouse,onmouseenter:_onMouse,onmouseleave:_onMouse\"\n\t\t\t><div class=\"dijitArrowButtonInner\">&thinsp;</div\n\t\t\t><div class=\"dijitArrowButtonChar\">&#9660;</div\n\t\t></div\n\t\t><div class=\"dijitReset dijitValidationIcon\"><br></div\n\t\t><div class=\"dijitReset dijitValidationIconText\">&Chi;</div\n\t\t><div class=\"dijitReset dijitInputField\"\n\t\t\t><input ${nameAttrSetting} type=\"text\" autocomplete=\"off\" class='dijitReset'\n\t\t\tdojoAttachEvent=\"onkeypress:_onKeyPress,compositionend\"\n\t\t\tdojoAttachPoint=\"textbox,focusNode\" waiRole=\"textbox\" waiState=\"haspopup-true,autocomplete-list\"\n\t\t/></div\n\t></div\n></div>\n",

		baseClass:"dijitComboBox",

		_getCaretPos: function(/*DomNode*/ element){
			// khtml 3.5.2 has selection* methods as does webkit nightlies from 2005-06-22
			var pos = 0;
			if(typeof(element.selectionStart)=="number"){
				// FIXME: this is totally borked on Moz < 1.3. Any recourse?
				pos = element.selectionStart;
			}else if(dojo.isIE){
				// in the case of a mouse click in a popup being handled,
				// then the dojo.doc.selection is not the textarea, but the popup
				// var r = dojo.doc.selection.createRange();
				// hack to get IE 6 to play nice. What a POS browser.
				var tr = dojo.doc.selection.createRange().duplicate();
				var ntr = element.createTextRange();
				tr.move("character",0);
				ntr.move("character",0);
				try{
					// If control doesnt have focus, you get an exception.
					// Seems to happen on reverse-tab, but can also happen on tab (seems to be a race condition - only happens sometimes).
					// There appears to be no workaround for this - googled for quite a while.
					ntr.setEndPoint("EndToEnd", tr);
					pos = String(ntr.text).replace(/\r/g,"").length;
				}catch(e){
					// If focus has shifted, 0 is fine for caret pos.
				}
			}
			return pos;
		},

		_setCaretPos: function(/*DomNode*/ element, /*Number*/ location){
			location = parseInt(location);
			dijit.selectInputText(element, location, location);
		},

		_setDisabledAttr: function(/*Boolean*/ value){
			// Additional code to set disabled state of combobox node.
			// Overrides _FormValueWidget._setDisabledAttr() or ValidationTextBox._setDisabledAttr().
			this.inherited(arguments);
			dijit.setWaiState(this.comboNode, "disabled", value);
		},	
		
		_abortQuery: function(){
			// stop in-progress query
			if(this.searchTimer){ 
				 clearTimeout(this.searchTimer); 
				this.searchTimer = null; 
			} 
			if(this._fetchHandle){
				if(this._fetchHandle.abort){ this._fetchHandle.abort(); }
				this._fetchHandle = null;
			}
		},

		_onKeyPress: function(/*Event*/ evt){
			// summary:
			//		Handles keyboard events
			var key = evt.charOrCode;
			//except for cutting/pasting case - ctrl + x/v
			if(evt.altKey || ((evt.ctrlKey||evt.metaKey) && (key != 'x' && key != 'v')) || key == dojo.keys.SHIFT){
				return; // throw out weird key combinations and spurious events
			}
			var doSearch = false;
			var searchFunction = "_startSearchFromInput";
			var pw = this._popupWidget;
			var dk = dojo.keys;
			var highlighted = null;
			this._prev_key_backspace = false;
			this._abortQuery();
			if(this._isShowingNow){
				pw.handleKey(key);
				highlighted = pw.getHighlightedOption();
			}
			switch(key){
				case dk.PAGE_DOWN:
				case dk.DOWN_ARROW:
				case dk.PAGE_UP:
				case dk.UP_ARROW:
					if(!this._isShowingNow){
						this._arrowPressed();
						doSearch = true;
						searchFunction = "_startSearchAll";
					}else{
						this._announceOption(highlighted);
					}
					dojo.stopEvent(evt);
					break;

				case dk.ENTER:
					// prevent submitting form if user presses enter. Also
					// prevent accepting the value if either Next or Previous
					// are selected
					if(highlighted){
						// only stop event on prev/next
						if(highlighted == pw.nextButton){
							this._nextSearch(1);
							dojo.stopEvent(evt);
							break;
						}else if(highlighted == pw.previousButton){
							this._nextSearch(-1);
							dojo.stopEvent(evt);
							break;
						}
					}else{
						// Update 'value' (ex: KY) according to currently displayed text
						this._setDisplayedValueAttr(this.attr('displayedValue'), true);
					}
					// default case:
					// prevent submit, but allow event to bubble
					evt.preventDefault();
					// fall through

				case dk.TAB:
					var newvalue = this.attr('displayedValue');
					// #4617: 
					//		if the user had More Choices selected fall into the
					//		_onBlur handler
					if(pw && (
						newvalue == pw._messages["previousMessage"] ||
						newvalue == pw._messages["nextMessage"])
					){
						break;
					}
					if(this._isShowingNow){
						if(highlighted){
							pw.attr('value', { target: highlighted });
						}
						this._lastQuery = null; // in case results come back later
						this._hideResultList();
					}
					break;

				case ' ':
					if(highlighted){
						dojo.stopEvent(evt);
						this._selectOption();
						this._hideResultList();
					}else{
						doSearch = true;
					}
					break;

				case dk.ESCAPE:
					if(this._isShowingNow){
						dojo.stopEvent(evt);
						this._hideResultList();
					}
					break;

				case dk.DELETE:
				case dk.BACKSPACE:
					this._prev_key_backspace = true;
					doSearch = true;
					break;

				default:
					// Non char keys (F1-F12 etc..)  shouldn't open list.
					// Ascii characters and IME input (Chinese, Japanese etc.) should.
					// On IE and safari, IME input produces keycode == 229, and we simulate
					// it on firefox by attaching to compositionend event (see compositionend method)
					doSearch = typeof key == 'string' || key == 229;
			}
			if(doSearch){
				// need to wait a tad before start search so that the event
				// bubbles through DOM and we have value visible
				this.searchTimer = setTimeout(dojo.hitch(this, searchFunction),1);
			}
		},

		_autoCompleteText: function(/*String*/ text){
			// summary:
			// 		Fill in the textbox with the first item from the drop down
			// 		list, and highlight the characters that were
			// 		auto-completed. For example, if user typed "CA" and the
			// 		drop down list appeared, the textbox would be changed to
			// 		"California" and "ifornia" would be highlighted.

			var fn = this.focusNode;

			// IE7: clear selection so next highlight works all the time
			dijit.selectInputText(fn, fn.value.length);
			// does text autoComplete the value in the textbox?
			var caseFilter = this.ignoreCase? 'toLowerCase' : 'substr';
			if(text[caseFilter](0).indexOf(this.focusNode.value[caseFilter](0)) == 0){
				var cpos = this._getCaretPos(fn);
				// only try to extend if we added the last character at the end of the input
				if((cpos+1) > fn.value.length){
					// only add to input node as we would overwrite Capitalisation of chars
					// actually, that is ok
					fn.value = text;//.substr(cpos);
					// visually highlight the autocompleted characters
					dijit.selectInputText(fn, cpos);
				}
			}else{
				// text does not autoComplete; replace the whole value and highlight
				fn.value = text;
				dijit.selectInputText(fn);
			}
		},

		_openResultList: function(/*Object*/ results, /*Object*/ dataObject){
			this._fetchHandle = null;
			if(	this.disabled || 
				this.readOnly || 
				(dataObject.query[this.searchAttr] != this._lastQuery)
			){
				return;
			}
			this._popupWidget.clearResultList();
			if(!results.length){
				this._hideResultList();
				return;
			}

			// Fill in the textbox with the first item from the drop down list,
			// and highlight the characters that were auto-completed. For
			// example, if user typed "CA" and the drop down list appeared, the
			// textbox would be changed to "California" and "ifornia" would be
			// highlighted.

			this.item = null;
			var zerothvalue = new String(this.store.getValue(results[0], this.searchAttr));
			if(zerothvalue && this.autoComplete && !this._prev_key_backspace &&
				!/^[*]+$/.test(dataObject.query[this.searchAttr])){
				// when the user clicks the arrow button to show the full list,
				// startSearch looks for "*".
				// it does not make sense to autocomplete
				// if they are just previewing the options available.
				this.item = results[0];
				this._autoCompleteText(zerothvalue);
			}
			dataObject._maxOptions = this._maxOptions;
			this._popupWidget.createOptions(
				results, 
				dataObject, 
				dojo.hitch(this, "_getMenuLabelFromItem")
			);

			// show our list (only if we have content, else nothing)
			this._showResultList();

			// #4091:
			//		tell the screen reader that the paging callback finished by
			//		shouting the next choice
			if(dataObject.direction){
				if(1 == dataObject.direction){
					this._popupWidget.highlightFirstOption();
				}else if(-1 == dataObject.direction){
					this._popupWidget.highlightLastOption();
				}
				this._announceOption(this._popupWidget.getHighlightedOption());
			}
		},

		_showResultList: function(){
			this._hideResultList();
			this._arrowPressed();
			// hide the tooltip
			this.displayMessage("");
			
			// Position the list and if it's too big to fit on the screen then
			// size it to the maximum possible height
			// Our dear friend IE doesnt take max-height so we need to
			// calculate that on our own every time

			// TODO: want to redo this, see 
			//		http://trac.dojotoolkit.org/ticket/3272
			//	and
			//		http://trac.dojotoolkit.org/ticket/4108


			// natural size of the list has changed, so erase old
			// width/height settings, which were hardcoded in a previous
			// call to this function (via dojo.marginBox() call)
			dojo.style(this._popupWidget.domNode, {width: "", height: ""});

			var best = this.open();
			// #3212:
			//		only set auto scroll bars if necessary prevents issues with
			//		scroll bars appearing when they shouldn't when node is made
			//		wider (fractional pixels cause this)
			var popupbox = dojo.marginBox(this._popupWidget.domNode);
			this._popupWidget.domNode.style.overflow = 
				((best.h==popupbox.h)&&(best.w==popupbox.w)) ? "hidden" : "auto";
			// #4134:
			//		borrow TextArea scrollbar test so content isn't covered by
			//		scrollbar and horizontal scrollbar doesn't appear
			var newwidth = best.w;
			if(best.h < this._popupWidget.domNode.scrollHeight){
				newwidth += 16;
			}
			dojo.marginBox(this._popupWidget.domNode, {
				h: best.h,
				w: Math.max(newwidth, this.domNode.offsetWidth)
			});
			dijit.setWaiState(this.comboNode, "expanded", "true");
		},

		_hideResultList: function(){
			this._abortQuery();
			if(this._isShowingNow){
				dijit.popup.close(this._popupWidget);
				this._arrowIdle();
				this._isShowingNow=false;
				dijit.setWaiState(this.comboNode, "expanded", "false");
				dijit.removeWaiState(this.focusNode,"activedescendant");
			}
		},

		_setBlurValue: function(){
			// if the user clicks away from the textbox OR tabs away, set the
			// value to the textbox value
			// #4617: 
			//		if value is now more choices or previous choices, revert
			//		the value
			var newvalue=this.attr('displayedValue');
			var pw = this._popupWidget;
			if(pw && (
				newvalue == pw._messages["previousMessage"] ||
				newvalue == pw._messages["nextMessage"]
				)
			){
				this._setValueAttr(this._lastValueReported, true);
			}else{
				// Update 'value' (ex: KY) according to currently displayed text
				this.attr('displayedValue', newvalue);
			}
		},

		_onBlur: function(){
			// summary:
			//		Called magically when focus has shifted away from this widget and it's drop down
			this._hideResultList();
			this._arrowIdle();
			this.inherited(arguments);
		},
		
		_getAnnounceString: function(/*Node*/ node){
			return this.store.getValue(node.item, this.searchAttr);
		},

		_announceOption: function(/*Node*/ node){
			// summary:
			//		a11y code that puts the highlighted option in the textbox.
			//		This way screen readers will know what is happening in the
			//		menu.

			if(!node){
				return;
			}
			// pull the text value from the item attached to the DOM node
			var newValue;
			if( node == this._popupWidget.nextButton ||
				node == this._popupWidget.previousButton){
				newValue = node.innerHTML;
			}else{
				newValue = this._getAnnounceString(node);
			}
			// get the text that the user manually entered (cut off autocompleted text)
			this.focusNode.value = this.focusNode.value.substring(0, this._getCaretPos(this.focusNode));
			//set up ARIA activedescendant
			dijit.setWaiState(this.focusNode, "activedescendant", dojo.attr(node, "id")); 
			// autocomplete the rest of the option to announce change
			this._autoCompleteText(newValue);
		},

		_selectOption: function(/*Event*/ evt){
			var tgt = null;
			if(!evt){
				evt ={ target: this._popupWidget.getHighlightedOption()};
			}
				// what if nothing is highlighted yet?
			if(!evt.target){
				// handle autocompletion where the the user has hit ENTER or TAB
				this.attr('displayedValue', this.attr('displayedValue'));
				return;
			// otherwise the user has accepted the autocompleted value
			}else{
				tgt = evt.target;
			}
			if(!evt.noHide){
				this._hideResultList();
				this._setCaretPos(this.focusNode, this.store.getValue(tgt.item, this.searchAttr).length);
			}
			this._doSelect(tgt);
		},

		_doSelect: function(tgt){
			// summary:
			//		Menu callback function, called when an item in the menu is selected.
			this.item = tgt.item;
			this.attr('value', this.store.getValue(tgt.item, this.searchAttr));
		},

		_onArrowMouseDown: function(evt){
			// summary:
			//		Callback when arrow is clicked
			if(this.disabled || this.readOnly){
				return;
			}
			dojo.stopEvent(evt);
			this.focus();
			if(this._isShowingNow){
				this._hideResultList();
			}else{
				// forces full population of results, if they click
				// on the arrow it means they want to see more options
				this._startSearch("");
			}
		},

		_startSearchAll: function(){
			this._startSearch('');
		},

		_startSearchFromInput: function(){
			this._startSearch(this.focusNode.value.replace(/([\\\*\?])/g, "\\$1"));
		},

		_getQueryString: function(/*String*/ text){
			return dojo.string.substitute(this.queryExpr, [text]);
		},

		_startSearch: function(/*String*/ key){
			if(!this._popupWidget){
				var popupId = this.id + "_popup";
				this._popupWidget = new dijit.form._ComboBoxMenu({
					onChange: dojo.hitch(this, this._selectOption),
					id: popupId
				});
				dijit.removeWaiState(this.focusNode,"activedescendant");
				dijit.setWaiState(this.textbox,"owns",popupId); // associate popup with textbox
			}
			// create a new query to prevent accidentally querying for a hidden
			// value from FilteringSelect's keyField
			this.item = null; // #4872
			var query = dojo.clone(this.query); // #5970
			this._lastInput = key; // Store exactly what was entered by the user.
			this._lastQuery = query[this.searchAttr] = this._getQueryString(key);
			// #5970: set _lastQuery, *then* start the timeout
			// otherwise, if the user types and the last query returns before the timeout,
			// _lastQuery won't be set and their input gets rewritten
			this.searchTimer=setTimeout(dojo.hitch(this, function(query, _this){
				this.searchTimer = null;
				var fetch = {
					queryOptions: {
						ignoreCase: this.ignoreCase, 
						deep: true
					},
					query: query,
					onBegin: dojo.hitch(this, "_setMaxOptions"),
					onComplete: dojo.hitch(this, "_openResultList"), 
					onError: function(errText){
						_this._fetchHandle = null;
						console.error('dijit.form.ComboBox: ' + errText);
						dojo.hitch(_this, "_hideResultList")();
					},
					start: 0,
					count: this.pageSize
				};
				dojo.mixin(fetch, _this.fetchProperties);
				this._fetchHandle = _this.store.fetch(fetch);

				var nextSearch = function(dataObject, direction){
					dataObject.start += dataObject.count*direction;
					// #4091:
					//		tell callback the direction of the paging so the screen
					//		reader knows which menu option to shout
					dataObject.direction = direction;
					this._fetchHandle = this.store.fetch(dataObject);
				};
				this._nextSearch = this._popupWidget.onPage = dojo.hitch(this, nextSearch, this._fetchHandle);
			}, query, this), this.searchDelay);
		},

		_setMaxOptions: function(size, request){
			 this._maxOptions = size;
		},

		_getValueField: function(){
			// summmary:
			//		Helper for postMixInProperties() to set this.value based on data inlined into the markup.
			//		Returns the attribute name in the item (in dijit.form._ComboBoxDataStore) to use as the value.
			return this.searchAttr;
		},

		/////////////// Event handlers /////////////////////

		_arrowPressed: function(){
			if(!this.disabled && !this.readOnly && this.hasDownArrow){
				dojo.addClass(this.downArrowNode, "dijitArrowButtonActive");
			}
		},

		_arrowIdle: function(){
			if(!this.disabled && !this.readOnly && this.hasDownArrow){
				dojo.removeClass(this.downArrowNode, "dojoArrowButtonPushed");
			}
		},

		// FIXME: For 2.0, rename to "_compositionEnd"
		compositionend: function(/*Event*/ evt){
			// summary:
			//		When inputting characters using an input method, such as
			//		Asian languages, it will generate this event instead of
			//		onKeyDown event.
			//		Note: this event is only triggered in FF (not in IE/safari)
			// tags:
			//		private
			
			// 229 is the code produced by IE and safari while pressing keys during
			// IME input mode
			this._onKeyPress({charOrCode: 229});
		},

		//////////// INITIALIZATION METHODS ///////////////////////////////////////

		constructor: function(){
			this.query={};
			this.fetchProperties={};
		},

		postMixInProperties: function(){
			if(!this.hasDownArrow){
				this.baseClass = "dijitTextBox";
			}
			if(!this.store){
				var srcNodeRef = this.srcNodeRef;

				// if user didn't specify store, then assume there are option tags
				this.store = new dijit.form._ComboBoxDataStore(srcNodeRef);

				// if there is no value set and there is an option list, set
				// the value to the first value to be consistent with native
				// Select

				// Firefox and Safari set value
				// IE6 and Opera set selectedIndex, which is automatically set
				// by the selected attribute of an option tag
				// IE6 does not set value, Opera sets value = selectedIndex
				if(	!this.value || (
						(typeof srcNodeRef.selectedIndex == "number") && 
						srcNodeRef.selectedIndex.toString() === this.value)
				){
					var item = this.store.fetchSelectedItem();
					if(item){
						this.value = this.store.getValue(item, this._getValueField());
					}
				}
			}
			this.inherited(arguments);
		},
		
		postCreate: function(){
			// summary:
			//		Subclasses must call this method from their postCreate() methods
			// tags: protected

			//find any associated label element and add to combobox node.
			var label=dojo.query('label[for="'+this.id+'"]');
			if(label.length){
				label[0].id = (this.id+"_label");
				var cn=this.comboNode;
				dijit.setWaiState(cn, "labelledby", label[0].id);
				
			}
			this.inherited(arguments);
		},

		uninitialize: function(){
			if(this._popupWidget){
				this._hideResultList();
				this._popupWidget.destroy();
			}
			this.inherited(arguments);
		},

		_getMenuLabelFromItem: function(/*Item*/ item){
			var label = this.store.getValue(item, this.labelAttr || this.searchAttr);
			var labelType = this.labelType;
			// If labelType is not "text" we don't want to screw any markup ot whatever.
			if (this.highlightMatch!="none" && this.labelType=="text" && this._lastInput){
				label = this.doHighlight(label, this._escapeHtml(this._lastInput));
				labelType = "html";
			}
			return {html: labelType=="html", label: label};
		},
		
		doHighlight: function(/*String*/label, /*String*/find){
			// summary:
			//		Highlights the string entered by the user in the menu.  By default this
			//		highlights the first occurence found. Override this method
			//		to implement your custom highlighing.
			// tags:
			//		protected

			// Add greedy when this.highlightMatch=="all"
			var modifiers = "i"+(this.highlightMatch=="all"?"g":"");
			var escapedLabel = this._escapeHtml(label);
			find = dojo.regexp.escapeString(find); // escape regexp special chars
			var ret = escapedLabel.replace(new RegExp("(^|\\s)("+ find +")", modifiers),
					'$1<span class="dijitComboBoxHighlightMatch">$2</span>');
			return ret;// returns String, (almost) valid HTML (entities encoded)
		},
		
		_escapeHtml: function(/*string*/str){
			// TODO Should become dojo.html.entities(), when exists use instead
			// summary:
			//		Adds escape sequences for special characters in XML: &<>"'
			str = String(str).replace(/&/gm, "&amp;").replace(/</gm, "&lt;")
				.replace(/>/gm, "&gt;").replace(/"/gm, "&quot;");
			return str; // string
		},

		open: function(){
			// summary:
			//		Opens the drop down menu.  TODO: rename to _open.
			// tags:
			//		private
			this._isShowingNow=true;
			return dijit.popup.open({
				popup: this._popupWidget,
				around: this.domNode,
				parent: this
			});
		},
		
		reset: function(){
			// Overrides the _FormWidget.reset().
			// Additionally reset the .item (to clean up).
			this.item = null;
			this.inherited(arguments);
		}
		
	}
);

dojo.declare(
	"dijit.form._ComboBoxMenu",
	[dijit._Widget, dijit._Templated],
	{
		// summary:
		//		Focus-less menu for internal use in `dijit.form.ComboBox`
		// tags:
		//		private

		templateString: "<ul class='dijitReset dijitMenu' dojoAttachEvent='onmousedown:_onMouseDown,onmouseup:_onMouseUp,onmouseover:_onMouseOver,onmouseout:_onMouseOut' tabIndex='-1' style='overflow: \"auto\"; overflow-x: \"hidden\";'>"
				+"<li class='dijitMenuItem dijitMenuPreviousButton' dojoAttachPoint='previousButton' waiRole='option'></li>"
				+"<li class='dijitMenuItem dijitMenuNextButton' dojoAttachPoint='nextButton' waiRole='option'></li>"
			+"</ul>",

		// _messages: Object
		//		Holds "next" and "previous" text for paging buttons on drop down
		_messages: null,

		postMixInProperties: function(){
			this._messages = dojo.i18n.getLocalization("dijit.form", "ComboBox", this.lang);
			this.inherited(arguments);
		},

		_setValueAttr: function(/*Object*/ value){
			this.value = value;
			this.onChange(value);
		},

		// stubs
		onChange: function(/*Object*/ value){
			// summary:
			//		Notifies ComboBox/FilteringSelect that user clicked an option in the drop down menu.
			//		Probably should be called onSelect.
			// tags:
			//		callback
		},
		onPage: function(/*Number*/ direction){
			// summary:
			//		Notifies ComboBox/FilteringSelect that user clicked to advance to next/previous page.
			// tags:
			//		callback
		},

		postCreate: function(){
			// fill in template with i18n messages
			this.previousButton.innerHTML = this._messages["previousMessage"];
			this.nextButton.innerHTML = this._messages["nextMessage"];
			this.inherited(arguments);
		},

		onClose: function(){
			// summary:
			//		Callback from dijit.popup code to this widget, notifying it that it closed
			// tags:
			//		private
			this._blurOptionNode();
		},

		_createOption: function(/*Object*/ item, labelFunc){
			// summary: 
			//		Creates an option to appear on the popup menu subclassed by
			//		`dijit.form.FilteringSelect`.

			var labelObject = labelFunc(item);
			var menuitem = dojo.doc.createElement("li");
			dijit.setWaiRole(menuitem, "option");
			if(labelObject.html){
				menuitem.innerHTML = labelObject.label;
			}else{
				menuitem.appendChild(
					dojo.doc.createTextNode(labelObject.label)
				);
			}
			// #3250: in blank options, assign a normal height
			if(menuitem.innerHTML == ""){
				menuitem.innerHTML = "&nbsp;";
			}
			menuitem.item=item;
			return menuitem;
		},

		createOptions: function(results, dataObject, labelFunc){
			// summary:
			//		Fills in the items in the drop down list
			// results:
			//		Array of dojo.data items
			// dataObject:
			//		dojo.data store
			// labelFunc:
			//		Function to produce a label in the drop down list from a dojo.data item

			//this._dataObject=dataObject;
			//this._dataObject.onComplete=dojo.hitch(comboBox, comboBox._openResultList);
			// display "Previous . . ." button
			this.previousButton.style.display = (dataObject.start == 0) ? "none" : "";
			dojo.attr(this.previousButton, "id", this.id + "_prev");
			// create options using _createOption function defined by parent
			// ComboBox (or FilteringSelect) class
			// #2309:
			//		iterate over cache nondestructively
			dojo.forEach(results, function(item, i){
				var menuitem = this._createOption(item, labelFunc);
				menuitem.className = "dijitReset dijitMenuItem";
				dojo.attr(menuitem, "id", this.id + i);
				this.domNode.insertBefore(menuitem, this.nextButton);
			}, this);
			// display "Next . . ." button
			var displayMore = false;
			//Try to determine if we should show 'more'...
			if(dataObject._maxOptions && dataObject._maxOptions != -1){
				if((dataObject.start + dataObject.count) < dataObject._maxOptions){
					displayMore = true;
				}else if((dataObject.start + dataObject.count) > (dataObject._maxOptions - 1)){
					//Weird return from a datastore, where a start + count > maxOptions
					//implies maxOptions isn't really valid and we have to go into faking it.
					//And more or less assume more if count == results.length
					if(dataObject.count == results.length){
						displayMore = true;
					}
				}
			}else if(dataObject.count == results.length){
				//Don't know the size, so we do the best we can based off count alone.
				//So, if we have an exact match to count, assume more.
				displayMore = true;
			}

			this.nextButton.style.display = displayMore ? "" : "none";
			dojo.attr(this.nextButton,"id", this.id + "_next");
		},

		clearResultList: function(){
			// summary:
			//		Clears the entries in the drop down list, but of course keeps the previous and next buttons.
			while(this.domNode.childNodes.length>2){
				this.domNode.removeChild(this.domNode.childNodes[this.domNode.childNodes.length-2]);
			}
		},

		_onMouseDown: function(/*Event*/ evt){
			dojo.stopEvent(evt);
		},

		_onMouseUp: function(/*Event*/ evt){
			if(evt.target === this.domNode){
				return;
			}else if(evt.target==this.previousButton){
				this.onPage(-1);
			}else if(evt.target==this.nextButton){
				this.onPage(1);
			}else{
				var tgt = evt.target;
				// while the clicked node is inside the div
				while(!tgt.item){
					// recurse to the top
					tgt = tgt.parentNode;
				}
				this._setValueAttr({ target: tgt }, true);
			}
		},

		_onMouseOver: function(/*Event*/ evt){
			if(evt.target === this.domNode){ return; }
			var tgt = evt.target;
			if(!(tgt == this.previousButton || tgt == this.nextButton)){
				// while the clicked node is inside the div
				while(!tgt.item){
					// recurse to the top
					tgt = tgt.parentNode;
				}
			}
			this._focusOptionNode(tgt);
		},

		_onMouseOut: function(/*Event*/ evt){
			if(evt.target === this.domNode){ return; }
			this._blurOptionNode();
		},

		_focusOptionNode: function(/*DomNode*/ node){
			// summary:
			//		Does the actual highlight.
			if(this._highlighted_option != node){
				this._blurOptionNode();
				this._highlighted_option = node;
				dojo.addClass(this._highlighted_option, "dijitMenuItemSelected");
			}
		},

		_blurOptionNode: function(){
			// summary:
			//		Removes highlight on highlighted option.
			if(this._highlighted_option){
				dojo.removeClass(this._highlighted_option, "dijitMenuItemSelected");
				this._highlighted_option = null;
			}
		},

		_highlightNextOption: function(){
			//	summary:
			// 		Highlight the item just below the current selection.
			// 		If nothing selected, highlight first option.

			// because each press of a button clears the menu,
			// the highlighted option sometimes becomes detached from the menu!
			// test to see if the option has a parent to see if this is the case.
			var fc = this.domNode.firstChild;
			if(!this.getHighlightedOption()){
				this._focusOptionNode(fc.style.display=="none" ? fc.nextSibling : fc);
			}else{
				var ns = this._highlighted_option.nextSibling;
				if(ns && ns.style.display!="none"){
					this._focusOptionNode(ns);
				}
			}
			// scrollIntoView is called outside of _focusOptionNode because in IE putting it inside causes the menu to scroll up on mouseover
			dijit.scrollIntoView(this._highlighted_option);
		},

		highlightFirstOption: function(){
			//	summary:
			// 		Highlight the first real item in the list (not Previous Choices).
			this._focusOptionNode(this.domNode.firstChild.nextSibling);
			dijit.scrollIntoView(this._highlighted_option);
		},

		highlightLastOption: function(){
			//	summary:
			// 		Highlight the last real item in the list (not More Choices).
			this._focusOptionNode(this.domNode.lastChild.previousSibling);
			dijit.scrollIntoView(this._highlighted_option);
		},

		_highlightPrevOption: function(){
			//	summary:
			// 		Highlight the item just above the current selection.
			// 		If nothing selected, highlight last option (if
			// 		you select Previous and try to keep scrolling up the list).
			var lc = this.domNode.lastChild;
			if(!this.getHighlightedOption()){
				this._focusOptionNode(lc.style.display == "none" ? lc.previousSibling : lc);
			}else{
				var ps = this._highlighted_option.previousSibling;
				if(ps && ps.style.display != "none"){
					this._focusOptionNode(ps);
				}
			}
			dijit.scrollIntoView(this._highlighted_option);
		},

		_page: function(/*Boolean*/ up){
			// summary:
			//		Handles page-up and page-down keypresses

			var scrollamount = 0;
			var oldscroll = this.domNode.scrollTop;
			var height = dojo.style(this.domNode, "height");
			// if no item is highlighted, highlight the first option
			if(!this.getHighlightedOption()){
				this._highlightNextOption();
			}
			while(scrollamount<height){
				if(up){
					// stop at option 1
					if(!this.getHighlightedOption().previousSibling ||
						this._highlighted_option.previousSibling.style.display == "none"){
						break;
					}
					this._highlightPrevOption();
				}else{
					// stop at last option
					if(!this.getHighlightedOption().nextSibling ||
						this._highlighted_option.nextSibling.style.display == "none"){
						break;
					}
					this._highlightNextOption();
				}
				// going backwards
				var newscroll=this.domNode.scrollTop;
				scrollamount+=(newscroll-oldscroll)*(up ? -1:1);
				oldscroll=newscroll;
			}
		},

		pageUp: function(){
			// summary:
			//		Handles pageup keypress.
			//		TODO: just call _page directly from handleKey().
			// tags:
			//		private
			this._page(true);
		},

		pageDown: function(){
			// summary:
			//		Handles pagedown keypress.
			//		TODO: just call _page directly from handleKey().
			// tags:
			//		private
			this._page(false);
		},

		getHighlightedOption: function(){
			//	summary:
			//		Returns the highlighted option.
			var ho = this._highlighted_option;
			return (ho && ho.parentNode) ? ho : null;
		},

		handleKey: function(key){
			switch(key){
				case dojo.keys.DOWN_ARROW:
					this._highlightNextOption();
					break;
				case dojo.keys.PAGE_DOWN:
					this.pageDown();
					break;	
				case dojo.keys.UP_ARROW:
					this._highlightPrevOption();
					break;
				case dojo.keys.PAGE_UP:
					this.pageUp();
					break;	
			}
		}
	}
);

dojo.declare(
	"dijit.form.ComboBox",
	[dijit.form.ValidationTextBox, dijit.form.ComboBoxMixin],
	{
		//	summary:
		//		Auto-completing text box, and base class for dijit.form.FilteringSelect.
		// 
		//	description:
		//		The drop down box's values are populated from an class called
		//		a data provider, which returns a list of values based on the characters
		//		that the user has typed into the input box.
		//		If OPTION tags are used as the data provider via markup,
		//		then the OPTION tag's child text node is used as the widget value 
		//		when selected.  The OPTION tag's value attribute is ignored.
		//		To set the default value when using OPTION tags, specify the selected 
		//		attribute on 1 of the child OPTION tags.
		// 
		//		Some of the options to the ComboBox are actually arguments to the data
		//		provider.

		_setValueAttr: function(/*String*/ value, /*Boolean?*/ priorityChange){
			// summary:
			//		Hook so attr('value', value) works.
			// description:
			//		Sets the value of the select.
			if(!value){ value = ''; } // null translates to blank
			dijit.form.ValidationTextBox.prototype._setValueAttr.call(this, value, priorityChange);
		}
	}
);

dojo.declare("dijit.form._ComboBoxDataStore", null, {
	//	summary:
	//		Inefficient but small data store specialized for inlined `dijit.form.ComboBox` data
	//
	//	description:
	//		Provides a store for inlined data like:
	//
	//	|	<select>
	//	|		<option value="AL">Alabama</option>
	//	|		...
	//
	//		Actually. just implements the subset of dojo.data.Read/Notification
	//		needed for ComboBox and FilteringSelect to work.
	//
	//		Note that an item is just a pointer to the <option> DomNode.

	constructor: function( /*DomNode*/ root){
		this.root = root;

		dojo.query("> option", root).forEach(function(node){
			//	TODO: this was added in #3858 but unclear why/if it's needed;  doesn't seem to be.
			//	If it is needed then can we just hide the select itself instead?
			//node.style.display="none";
			node.innerHTML = dojo.trim(node.innerHTML);
		});

	},

	getValue: function(	/* item */ item, 
						/* attribute-name-string */ attribute, 
						/* value? */ defaultValue){
		return (attribute == "value") ? item.value : (item.innerText || item.textContent || '');
	},

	isItemLoaded: function(/* anything */ something) {
		return true;
	},

	getFeatures: function(){
		return {"dojo.data.api.Read": true, "dojo.data.api.Identity": true};
	},
	
	_fetchItems: function(	/* Object */ args,
							/* Function */ findCallback, 
							/* Function */ errorCallback){
		//	summary: 
		//		See dojo.data.util.simpleFetch.fetch()
		if(!args.query){ args.query = {}; }
		if(!args.query.name){ args.query.name = ""; }
		if(!args.queryOptions){ args.queryOptions = {}; }
		var matcher = dojo.data.util.filter.patternToRegExp(args.query.name, args.queryOptions.ignoreCase),
			items = dojo.query("> option", this.root).filter(function(option){
				return (option.innerText || option.textContent || '').match(matcher);
			} );
		if(args.sort){
			items.sort(dojo.data.util.sorter.createSortFunction(args.sort, this));
		}
		findCallback(items, args);
	},

	close: function(/*dojo.data.api.Request || args || null */ request){
		return;
	},

	getLabel: function(/* item */ item){
		return item.innerHTML;
	},

	getIdentity: function(/* item */ item){
		return dojo.attr(item, "value");
	},

	fetchItemByIdentity: function(/* Object */ args){
		//	summary:
		//		Given the identity of an item, this method returns the item that has
		//		that identity through the onItem callback.
		//		Refer to dojo.data.api.Identity.fetchItemByIdentity() for more details.
		//
		//	description:
		//		Given arguments like:
		//
		//	|		{identity: "CA", onItem: function(item){...}
		//
		//		Call `onItem()` with the DOM node `<option value="CA">California</option>`
		var item = dojo.query("option[value='" + args.identity + "']", this.root)[0];
		args.onItem(item);
	},
	
	fetchSelectedItem: function(){
		//	summary:
		//		Get the option marked as selected, like `<option selected>`.
		//		Not part of dojo.data API.
		var root = this.root,
			si = root.selectedIndex;
		return dojo.query("> option:nth-child(" +
			(si != -1 ? si+1 : 1) + ")",
			root)[0];	// dojo.data.Item
	}
});
//Mix in the simple fetch implementation to this class. 
dojo.extend(dijit.form._ComboBoxDataStore,dojo.data.util.simpleFetch);

}

if(!dojo._hasResource["widgets.DynamicHorizontalBarChart"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.DynamicHorizontalBarChart"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.DynamicHorizontalBarChart");







dojo.declare(
	"widgets.DynamicHorizontalBarChart", [dijit._Widget, dijit._Templated],
	{		
		templateString:"<div>\n\t<div dojoAttachPoint=\"selectionContainer\" style=\"padding:5px 5px 10px 5px;\">\n\t\t<select dojoType=\"dijit.form.ComboBox\" dojoAttachPoint=\"selection\"\n\t\t\ttitle=\"${selectionTitle}\" labelAttr=\"${labelAttr}\" searchAttr=\"${searchAttr}\">\n\t\t</select>\n\t</div>\n\t<div dojoType=\"widgets.HorizontalBarChart\" style=\"width:100%;\"\n\t\t_autoLoad=\"${_autoLoad}\" imgBasePath=\"${imgBasePath}\"/>\n</div>\n",
		widgetsInTemplate: true,
		
		selection: null,
		chart: null,
		json: null,
		handlers: [],		
		
		_autoLoad: false,
		timeout: 60000,
		imgBasePath: EDR.config.imageBaseDir,
		url: "",
		resizing: false,
		
		labelAttr: "",
		searchAttr: "",
		groupPrefix: "",
		
		isDynamic: true,
		
		postCreate: function() {
			this.inherited("postCreate", arguments);
			this.selection = this._supportingWidgets[0];
			this.chart = this._supportingWidgets[1];
			
			if (!this.isDynamic) dojo.style(this.selectionContainer, "display", "none");
			
			this.handlers.push(dojo.connect(this.chart, "barSelected", this, "onItemSelected"));
			this.handlers.push(dojo.connect(this.selection, "onChange", this, "onGroupSelected"));
			
			dojo.subscribe("refresh", this, "refresh");
			
			if (this._autoLoad && this.url != null && this.url.length != 0) {
				this.load(this.url);
			} else {
				this.json = this._getNullGroups();
			}
			if (this._autoLoad) this.loadJson(this.json);
		},
		
		load: function(url) {
			if (!this.isVisible()) return;
			
			if (url == null) url = this.url;
			var params = this.getRequestParams();
			
			var args = 	{ 
				url: url,
				showProgress: false,
				successCallback: dojo.hitch(this, function(response, ioArgs) {
					var json = null;
					try {
						json = dojo.fromJson(response);
					} catch (e) {
			        	this.loadErrorHandler(response, ioArgs);
			        	return;
					}
					this.loadJson(json);	
					this.postLoad();		
				}),
				afterErrorHandlerCallback: dojo.hitch(this, function(response, ioArgs) {
					this.loadErrorHandler(response, ioArgs);
				}),
				content: params,
				timeout: this.timeout
			};			
			this.preLoad();					
			EDR.ajax.Request.post(args);
		},
		
		resize: function() {
			if (!this.isVisible()) return;
			
			this.resizing = true;
			this.layout();
			this.resizing = false;
		},
		
		layout: function() {
			var clientSize = dojo.contentBox(this.domNode);
			var selectionSize = dojo.marginBox(this.selectionContainer);
			dojo.marginBox(this.chart.domNode, {
				// w: clientSize.w,
				h: (clientSize.h - selectionSize.h)
			});
			this.onGroupSelected();
		},
		
		isVisible: function() {
			if (dijit.byId(EDR.prefix+"horizontalSearchPanes").leftContentPane.domNode.style.visibility != "visible") return;
			
			var node = this.domNode;
			while (node != null) {
				if (node.style != null && (node.style.display == "none" || node.style.visibility == "hidden"))
					return false;
				node = node.parentNode;
			}
			return true;
		},
		
		refresh: function() {
			if (this.isVisible()) this.load();
		},
		
		loadJson: function(json) {
			if (json == null) return;
			
			this.json = json;
			this.buildGroupSelection(json);
		},
		
		onGroupSelected: function(value) {
			var selected = this.selection.item;
			if (selected == null) {
				this.renderBarChart(this._getNullGroupItems());
			} else {
				var selectedName = selected[this.groupPrefix + "Id"];
				if (this[this.groupPrefix + "Name"] == selectedName) {
					this.renderBarChart(selected);
				} else {
					this[this.groupPrefix + "Name"] = selectedName;
					this.load();
				}
			}
		},
		
		onItemSelected: function(item) {
			var param = this.getFormValues(item);
			dijit.byId(EDR.prefix+"searchManager").submitQuickRefineSearch(param);
		},
		
		getFormValues: function(item) {
			return {};
		},
		
		getRequestParams: function() {
			return {};
		},
		
		buildGroupSelection: function(groups) {
			this.selection.store = new dojo.data.ItemFileReadStore(
				{ data: { items:groups } }
			);
			
			if (groups.length > 0) {
				var selected = null;
				for (var i=0; i<groups.length; i++) {
					if (groups[i].isSelected) {
						selected = groups[i];
						break;
					}
				}
//				if (selected == null && this.isDynamic) selected = groups[0];
				if (selected != null)
					this.selectGroup(selected);
				else
					this.chart.clear();
			} else {
				this.selection.attr("value", "");
				this.selection.attr("item", null);
				this.chart.clear();
			}
		},
		
		selectGroup: function(group) {
			if (group == null) return;
			
			this.selection.attr("value", group[this.groupPrefix + "Label"]);
			this.selection.attr("item", group);
			this.onGroupSelected(group[this.groupPrefix + "Name"]);		
		},
		
		renderBarChart: function(json) {
			if (json == null) return;

			// set maxCount param
			if (json.maxCount == null) {
				var maxCount = 0;
				for (var i=0; i<json.items.length; i++) {
					var count = parseInt(json.items[i].count);
					if (maxCount < count) maxCount = count;
				}
				json.maxCount = maxCount;
			}
			
			this.chart.resizing = this.resizing;
			this.chart.loadJson(json);
		},
		
		preLoad: function() {
		},
		
		postLoad: function() {
		},
		
		_getNullGroups: function() {
			return [];
		},
		
		_getNullGroupItems: function() {
			return {
				items: []
			};
		},
		
		loadErrorHandler: function(response) {
		},
		
		clear: function() {
			dojo.forEach(this.handlers, dojo.disconnect);
		},
		
		destroy: function() {
			this.clear();
			this.inherited("destroy", arguments);
		}		
	}
);

}

if(!dojo._hasResource["widgets.DynamicFieldChart"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.DynamicFieldChart"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.DynamicFieldChart");



dojo.declare(
	"widgets.DynamicFieldChart", [widgets.DynamicHorizontalBarChart],
	{		
		labelAttr: "fieldLabel",
		searchAttr: "fieldLabel",
		groupPrefix: "field",
		
		maxSize: "",
		fieldName: "",
		separator: "",
		sortType: "",
		sortOrder: "",
		
		getFormValues: function(item) {
			return { andfield: item.postParamValue };
		},
		
		getRequestParams: function() {
			return params = {
				fieldName: this.fieldName,
				maxSize: this.maxSize,
				separator: this.separator,
				sortType: this.sortType,
				sortOrder: this.sortOrder
			};
		},
		
		preLoad: function() {
			EDR.ajax.Loading.setIsLoading(this.domNode);
		},
		
		postLoad: function() {
			EDR.ajax.Loading.clearIsLoading(this.domNode);
		},
		
		loadErrorHandler: function(response) {
			EDR.ajax.Loading.clearIsLoading(this.domNode);
		},
		
		selectionTitle: EDR.messages.hiddenLabel_dyc_fieldselection
	}
);

}

if(!dojo._hasResource["widgets.DynamicFacetChart"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.DynamicFacetChart"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.DynamicFacetChart");



dojo.declare(
	"widgets.DynamicFacetChart", [widgets.DynamicHorizontalBarChart],
	{		
		labelAttr: "facetLabel",
		searchAttr: "facetLabel",
		groupPrefix: "facet",
		
		facetName: "model",
		maxSize: 0,
		
		getFormValues: function(item) {
			return { andfacet: item.postParamValue };
		},
		
		getRequestParams: function() {
			return params = {
				facetName: this.facetName,
				maxSize: this.maxSize
			};
		},
		
		preLoad: function() {
			EDR.ajax.Loading.setIsLoading(this.domNode);
		},
		
		postLoad: function() {
			EDR.ajax.Loading.clearIsLoading(this.domNode);
		},
		
		loadErrorHandler: function(response) {
			EDR.ajax.Loading.clearIsLoading(this.domNode);
		},
		
		selectionTitle: EDR.messages.hiddenLabel_dyc_facetselection
	}
);

}

if(!dojo._hasResource["widgets.FileSizeChart"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.FileSizeChart"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.FileSizeChart");



dojo.declare(
	"widgets.FileSizeChart", [widgets.HorizontalBarChart],
	{		
		requestId: "",
		
		preLoad: function() {
			EDR.ajax.Loading.setIsLoading('fileSizeChartContainer');
		},
		
		postLoad: function() {
			EDR.ajax.Loading.clearIsLoading('fileSizeChartContainer');
		},
		
		loadErrorHandler: function(response) {
			this.inherited("loadErrorHandler", arguments);
			EDR.dialog.ErrorDialog.show(response, null);		
		}
	}
);

}

if(!dojo._hasResource["widgets.TypeAhead"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.TypeAhead"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.TypeAhead");




dojo.declare(
	"widgets.TypeAhead", [dijit._Widget, dijit._Templated],
	{				
		templateString:"<div class='typeAheadDiv'></div>",
		
		connectedInputElementId: "",
		connectedInputElement : null,
		
		selectedItem: null,
		selectedItemIndex: null,
		defaultValue: "",
		isVisible: false,
		
		//for IE
		typeTimer: null,
		typeDuration: 200,
		
		//for firefox
		loopTimer: null,
		loopTimerDuration: 300,
		
		blurTimer: null,
		stopTimer: false,
		numberOfResults: 10,
		mode: "",
		
		//apply the value when attaching with needSendingOption == false
		needSendingOption: true,
		defaultNumberOfResults: 10,
	
		//prevent showing after enter key
		isExecuteEnter: false,
		
		//prevent showing after the input value become blank
		isEmpty: true,
		
		url:"",
		timeout: 1000,
	
		handlers: [],
		trHandlers: [],
		blurHandler: null,
		
		constructor: function(){
			this.handlers = [];
			this.trHandlers = [];
		},

		//new widgets.TypeAhead()
		postCreate: function() {
			this.inherited("postCreate", arguments);
			if ((this.connectedInputElementId != null)&&(this.connectedInputElementId != "")) {
				this.attach(this.connectedInputElementId);
			}
		},
		
		//create by HTML
		startup: function() {
			this.inherited("startup", arguments);
			//for click the scroll bar
			if(dojo.isIE){
				this.blurHandler = dojo.connect(this.domNode, "onfocus", this, function() {
					if (this.blurTimer != null) {
						clearTimeout(this.blurTimer);
					}
				});
			}
			if ((this.connectedInputElementId != null)&&(this.connectedInputElementId != "")) {
				this.attach(this.connectedInputElementId);
			}
		},
		
		//call after focus on the connected input element 
		attach: function(connectedInputElementId, url, needSendingOption) {
			if(needSendingOption && (this.mode=="off" || this.mode=="allOff")){
				this.detach();
				return;
			}
			if ((connectedInputElementId == null)||(connectedInputElementId == "")||(connectedInputElementId==this.connectedInputElementId)){
				 return;
			}
			if(this.connectedInputElementId!=connectedInputElementId){
				this.detach();
			}
			
			this.connectedInputElementId = connectedInputElementId;
			this.connectedInputElement = dojo.byId(this.connectedInputElementId);
			var targetInput = this.connectedInputElement;
			if(url!=null){
				this.url = url;
			}
			
			this.needSendingOption = needSendingOption;
			
			if(targetInput!=null){
				this.handlers.push(dojo.connect(targetInput,"onkeyup",this,"_onInputKeyup"));
				this.handlers.push(dojo.connect(targetInput,"onblur",this,"_onBlur"));
				this.handlers.push(dojo.connect(targetInput,"onkeydown",this,"_onInputKeyDown"));
				this.handlers.push(dojo.connect(window,"onresize",this,"hideTable"));
			}
		},
		
		detach: function() {
			if(!this.isVisible){
				this.hideTable();
			}
			this.clearTable();
			this.defaultValue = "";
			this.connectedInputElementId = "";
			dojo.forEach(this.handlers, dojo.disconnect);
			if(dojo.isFF){
				this.clearLoopTimer();
			}
		},
		
		showTable: function(){
			var best = dijit.popup.open({
				popup: this,
				around: this.connectedInputElement
			});
			this.isVisible = true;
			this.domNode.style.visibility = "visible";
			dojo.marginBox(this.domNode, {
				w:(dojo.marginBox(this.connectedInputElement)).w
			});
			this.adjustScrollBar();
		},
		
		hideTable: function(){
			dijit.popup.close(this);
			this.isVisible = false;
			this.domNode.style.visibility = "hidden";
		},
		
		_onStartTimer: function(e,self){
			if(self.loopTimer==null){
				return;
			}
			var isFirstStart = (self.loopTimer=="");
			self.loopTimer = setTimeout(function(){
				var value = self.connectedInputElement.value;
				if(self.defaultValue != value){
					self.preLoadTypeAheadSuggestion(e, value);
				}
				self._onStartTimer(e,self);
			}, (isFirstStart ? 0 : self.loopTimerDuration));
		},
		
		//for holding press
		_onInputKeyDown: function(e){
			if(e.keyCode == dojo.keys.ENTER){
				this.onExecute(e, e.target.value);
				this.defaultValue = e.target.value;
				this.isExecuteEnter = true;
			}else{
				this.isExecuteEnter = false;
			}
			if(e.keyCode == dojo.keys.UP_ARROW || e.keyCode == dojo.keys.DOWN_ARROW){
				if(dojo.isFF){
					this.clearLoopTimer();
				}
				this._onKeyUpDownArrow(e.keyCode);
			}else if(dojo.isFF){
				if(e.keyCode == dojo.keys.LEFT_ARROW || e.keyCode == dojo.keys.RIGHT_ARROW){
					this.clearLoopTimer();
				}else if(this.loopTimer==null){
					//set loop start				
					this.loopTimer = "";
					this._onStartTimer(e,this);
				}
			}
			if(e.keyCode == dojo.keys.ESCAPE){
				this.setDisplayValue(this.defaultValue);
				this.hideTable();
			}
		},
		
		_onInputKeyup: function(e){
			var value = e.target.value;
			if(!(dojo.isFF||(e.keyCode == dojo.keys.UP_ARROW)||(e.keyCode == dojo.keys.DOWN_ARROW)||(e.keyCode == dojo.keys.LEFT_ARROW)||(e.keyCode == dojo.keys.RIGHT_ARROW))){
				this._onTypeKeyword(e,value);
			}
		},
		
		loadTypeAheadSuggestionHTML: function(e,keyword) {
			var content = this.getLoadParams(e, keyword);
			var args = 	{ 
				url: this.url,
				showProgress: false,
				successCallback: dojo.hitch(this, function(response, ioArgs) {
					this.hideTable();
					this.disconnectTrHandlers();
					this.selectedItem = null;
					this.selectedItemIndex = null;
					this.buildTableFromHTML(response);
					this.postLoad();		
				}),
				afterErrorHandlerCallback: dojo.hitch(this, function(response, ioArgs) {
					this.loadErrorHandler(response, ioArgs);
				}),
				content: content,
				timeout: this.timeout
			};			
			this.preLoad();					
			EDR.ajax.Request.post(args);
		},
		
		getLoadParams: function(e, keyword) {
			var content = null; 
			if(this.needSendingOption){
				content = {
					"keyword": keyword,
					"numberOfResults": this.numberOfResults,
					"mode": this.mode
				};
			}else{
				content = {
					"keyword": keyword,
					"numberOfResults": this.defaultNumberOfResults
				};			
			}
			return content;
		},
		
		buildTableFromHTML: function(table){
			var self = this;
			if(!self.isExecuteEnter && !self.isEmpty ){
				self.domNode.innerHTML = table;
				//connect handlers after rendering
				var tableNode = self.domNode.firstChild;
				if(tableNode && tableNode.tagName=="TABLE"){
					var trs = dojo.query("tr",tableNode);
					var trLength = trs.length;
					if(trLength>0){
						self.showTable();
						for(var i=0; i<trLength; i++){
							self._trConnectHandlers(trs[i]);
						}
						//for overlay on flash panes
						self.domNode.parentNode.style.zIndex = 900;
					}else{
						self.clearTable();
					}
				}
			}else{
				self.clearTable();
			}
		},
		
		_onTypeKeyword: function(e,value){
			if (this.typeTimer != null) {
				this.clearTypeTimer();
			}
			//to prevent keys which is no input or pre
			if(this.defaultValue == value){
				return;
			}
		 	this.typeTimer = setTimeout(dojo.hitch(this, function(){
		 		this.preLoadTypeAheadSuggestion(e, value);
		 	}), this.isFirstType(value) ? 0 : this.typeDuration);
		},
		
		preLoadTypeAheadSuggestion: function(e, value){
			this.defaultValue = value;
			if(value.length>0){
				this.isEmpty = false;
				this.loadTypeAheadSuggestionHTML(e,value);
			}else{
				this.clearTable();
				//prevent showing after ajax callback
				this.defaultValue = "";
				this.isEmpty = true;
			}			
			if(!dojo.isFF){
				this.clearTypeTimer();
			}
		},
		
		_onKeyUpDownArrow: function(keyCode){
			if(this.domNode.firstChild){
				if(!this.isVisible){
					this.showTable();
				}else{
					if(keyCode == dojo.keys.DOWN_ARROW){
						this.selectedItem = this.getNextTr(this.selectedItemIndex);
					}else if(keyCode == dojo.keys.UP_ARROW){
						this.selectedItem = this.getPreviousTr(this.selectedItemIndex);						
					}
					if(this.selectedItem != null){
						var firstTd = this.selectedItem.firstChild;
						if(firstTd){						
							dojo.addClass(this.selectedItem,"selected");
							var value = dojo.attr(firstTd,"value");
							if(value!=null){
								this.setDisplayValue(value);
							}
							this.adjustScrollBar();
						}
					}else{
						this.setDisplayValue(this.defaultValue);
					}
				}					
			}
		},
		
		_onKeyEnter: function(e){
			if(this.isVisible && this.selectedItem != null){
				this.hideTable();
			}
		},
		
		_trConnectHandlers: function(elm){
			var self = this;
			self.trHandlers.push(dojo.connect(elm,"onmouseover",self,function(e) {
				self._onTrMouseOverHandler(elm,e);
			}));
			self.trHandlers.push(dojo.connect(elm, "onclick", self,function(e) {
				self._onTrClickHandler(elm,e);
			}));
		},
		
		_onTrMouseOverHandler: function(elm, e){
			if(this.selectedItem!=null){
				dojo.removeClass(this.selectedItem,"selected");
			}
			dojo.addClass(elm,"selected");
			this.selectedItem = elm;
			this.changeSelectedIndex();
		},
		
		changeSelectedIndex: function(){
			var tableNode = this.domNode.firstChild;
			if(tableNode!=null){
				var trNodes = dojo.query("tr",tableNode);
				var length = trNodes.length;
				for(var i=0; i<length; i++){
					if(trNodes[i]==this.selectedItem){
						this.selectedItemIndex = i;
						break;
					}
				}
			}			
		},
		
		_onTrClickHandler: function(elm,e){
			var firstTd = elm.firstChild;
			if(firstTd && firstTd.tagName=="TD"){
				var value = dojo.attr(firstTd,"value");
				this.setDisplayValue(value);
				this.hideTable();
				this.connectedInputElement.focus();
				this.onExecute(e, firstTd.innerHTML);
				this.defaultValue = value;
			}
		},
		
		//for override
		onExecute: function(e, value){

		},
		
		_onBlur: function(){
			if(this.isVisible){
				//activate onclick handler on the table 
				this.blurTimer = setTimeout(dojo.hitch(this, function() {
					 this.blurTimer = null;
					 this.hideTable();
				}), 300);
			}
			if(dojo.isFF){
				this.clearLoopTimer();
			}
		},
		
		clearLoopTimer: function(){
			if(this.loopTimer != null){
				clearTimeout(this.loopTimer);
				this.loopTimer = null;
			}
		},
		
		clearTypeTimer: function(){
			clearTimeout(this.typeTimer);
			this.typeTimer = null;
		},
		
		isFirstType: function(value){
			if(this.defaultValue.length==0 && value.length==1){
				return true;
			}else{
				return false;
			}
		},

		adjustScrollBar: function(){
			var tableNode = this.domNode.firstChild;
			if(tableNode){
				if(dojo.contentBox(this.domNode).h < dojo.contentBox(tableNode).h){
					if(this.selectedItem != null){
						dijit.scrollIntoView(this.selectedItem);
					}
				}
			}
		},
		
		clearTable: function(){
			this.hideTable();
			var tableNode = this.domNode.firstChild;
			if(tableNode){
				//disconnect event on table cell
				this.disconnectTrHandlers();
				this.domNode.removeChild(tableNode);
			}
			this.selectedItem = null;
			this.selectedItemIndex = null;
		},
		
		disconnectTrHandlers: function(){
			var length = this.trHandlers.length;
			for(var i=0;i<length;i++){
				dojo.disconnect(this.trHandlers[i]);
			}
		},
		
		getNextTr: function(index){
			var tableNode = this.domNode.firstChild;
			if(tableNode!=null){
			var trNodes = dojo.query("tr",tableNode);
				if(trNodes.length>0){
					if(index != null){
						dojo.removeClass(this.selectedItem,"selected");
						if(index==(trNodes.length-1)){
							this.selectedItemIndex = null;
							return null;
						}else{
							this.selectedItemIndex = this.selectedItemIndex + 1;
							return trNodes[this.selectedItemIndex];
						}						
					}else{
						this.selectedItemIndex = 0;
						return trNodes[0];
					}
				}
			}
			this.selectedItemIndex = null;
			return null;
		},
		
		getPreviousTr: function(index){
			var tableNode = this.domNode.firstChild;
			if(tableNode!=null){
			var trNodes = dojo.query("tr",tableNode);
				if(trNodes.length>0){
					if(index != null){
						dojo.removeClass(this.selectedItem,"selected");
						if(index==0){
							this.selectedItemIndex = null;
							return null;
						}else{
							this.selectedItemIndex = this.selectedItemIndex - 1;
							return trNodes[this.selectedItemIndex];
						}
					}else{
						this.selectedItemIndex = trNodes.length - 1;
						return trNodes[trNodes.length - 1];
					}
				}
			}
			this.selectedItemIndex = null;
			return null;
		},
		
		setDisplayValue: function(value){
			this.connectedInputElement.value = value;
		},
		
		setWidth: function(value){
			this.domNode.style.width = value + "px";
		},
		
		setURL: function(url){
			this.url = url;
		},
		
		setNumberOfResults: function(numberOfResults){
			this.numberOfResults = numberOfResults;
		},
		
		setMode: function(mode){
			this.mode = mode;
		},
		
		preLoad: function() {},		
		
		postLoad: function() {},	
		
		loadErrorHandler: function(response, ioArgs) {

		},
		
		destroy: function() {
			dojo.forEach(this.handlers, dojo.disconnect);
			if(dojo.isIE){
				dojo.disconnect(this.blurHandler);
			}
			this.inherited("destroy", arguments);
		}
	}
);

}

if(!dojo._hasResource["widgets.QueryTextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.QueryTextBox"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.QueryTextBox");





dojo.declare(
	"widgets.QueryTextBox", [dijit._Widget, dijit._Templated],
	{		
		prefix: EDR.prefix,
		templateString:"<div style=\"position:relative;\">\n\t<div dojoAttachPoint=\"queryArea\" style=\"position:absolute;right:0px;width:100%;height:100%;\">\n\t\t<div style=\"width:300px;position:absolute;left:0px;top:8px;\">\n\t\t\t<a dojoAttachPoint=\"hideQueryLink\"  dojoAttachEvent=\"onclick: hideQueryArea\"\n\t\t\t\thref=\"javascript:;\" style=\"color:#003063;\">${hidearea_label}</a>\n\t\t</div>\n\t\t<div dojoAttachPoint=\"queryHelp\" style=\"width:200px;position:absolute;right:0px;bottom:25px;\">\n\t\t\t<a href=\"javascript:;\" style=\"float:right;color:#003063;\" onclick=\"EDR.viewHelp('iiysuqysyntx.htm?noframes=true')\">${message_queryHelp}</a>\n\t\t</div>\n\t\t<div dojoAttachPoint=\"textInputContainer\"\n\t\t\tstyle=\"position:absolute;right:0px;bottom:0px;width:100%;height:22px;\">\n\t\t\t<label for=\"${prefix}mainTextInput\" class=\"hiddenAccessible\">${searchQueryInput}</label>\n\t\t\t<input id=\"${prefix}mainTextInput\" dojoAttachPoint=\"textInput\" type=\"text\" style=\"width:100%;height:20px;border:1px solid #7b9ebd\" autocomplete=\"off\" role=\"textbox\" wairole=\"textbox\" aria-haspopup=\"true\" aria-autocomplete=\"list\"></input>\n\t\t</div>\n\t\t<div dojoAttachPoint=\"textAreaContainer\"\n\t\tstyle=\"position:absolute;right:0px;bottom:0px;width:100%;height:38px;\">\n\t\t\t<label for=\"${prefix}mainTextArea\" class=\"hiddenAccessible\">${searchQueryInput}</label>\n\t\t\t<textarea id=\"${prefix}mainTextArea\" dojoAttachPoint=\"textArea\" style=\"width:100%;height:36px;overflow:auto;border:1px solid #7b9ebd\" role=\"textbox\" wairole=\"textbox\" aria-haspopup=\"true\" aria-autocomplete=\"list\"></textarea>\n\t\t</div>\n\t</div>\n\t<!-- div dojoAttachPoint=\"showHideQueryArea\" style=\"position:absolute;right:0px;width:100%;height:100%;\">\n\t\t<div style=\"width:200px;position:absolute;left:0px;top:8px;\">\n\t\t\t<a dojoAttachPoint=\"showQueryLink\" href=\"javascript:;\" style=\"color:#003063;\">${message_queryHelp}</a>\n\t\t</div>\n\t</div -->\n</div>\n",
		widgetsInTemplate: true,
		handlers: [],
		
		textbox: null,
		imgBasePath: EDR.config.imageBaseDir,
		
		message_queryHelp: EDR.messages.queryHelp,
				
		postCreate: function() {
			this.inherited("postCreate", arguments);
//			this.queryTextBox = this._supportingWidgets[0];
			if (EDR.isTextAnalyticsEnabled) {
				dojo.style(this.queryHelp, "bottom", "43px");
				dojo.style(this.textInputContainer, "display", "none");
				dojo.style(this.textAreaContainer, "display", "block");
				this.textbox = this.textArea;
			} else {
				dojo.style(this.hideQueryLink, "display", "none");
				dojo.style(this.textInputContainer, "display", "block");
				dojo.style(this.textAreaContainer, "display", "none");
				this.textbox = this.textInput;
			}
			this.handlers.push(dojo.connect(this.textbox, "onkeypress", this, "onKeyPress"));
			this.setFullQuery("");
		},
		
		startup: function() {
			this.inherited(arguments);
			dojo.style(this.textbox, "right", 0);
		},
		
/*		showQueryArea: function() {
			dojo.style(this.queryArea, "display", "block");
			dojo.style(this.showHideQueryArea, "display", "none");
			dijit.byId(EDR.prefix+"searchPane").showQueryArea();
		}, */
		
		hideQueryArea: function() {
			dijit.byId(EDR.prefix+"searchPane").hideQueryArea();
		},
		
		getFullQuery: function() {
			return this.textbox.value;
		},
		
		setFullQuery: function(fullQuery) {
			this.textbox.value = fullQuery;
		},
		
		loadErrorHandler: function(response) {
			//console.debug(response);
		},
		
		onKeyPress: function(evt) {
			if (evt.keyCode == dojo.keys.ENTER) {
				this.textbox.blur();
				dijit.byId(EDR.prefix+"searchPane").submitSearch();
			}
		},
		
		reset: function() {
			this.setFullQuery("");
		},
		
		clear: function() {
		},
		
		destroy: function() {
			dojo.forEach(this.handlers, dojo.disconnect);
			this.inherited("destroy", arguments);
		},
		
		hidearea_label: EDR.messages.searchpane_hidequeryarea,
		searchQueryInput: EDR.messages.hiddenLabel_searchQuery
	}
);

}

if(!dojo._hasResource["dojox.fx._base"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.fx._base"] = true;
dojo.provide("dojox.fx._base");
// summary: Experimental and extended Animations beyond Dojo Core / Base functionality. 
//	Provides advanced Lines, Animations, and convenience aliases.
 

dojo.mixin(dojox.fx, {

	// anim: Function
	//	Alias of dojo.anim - the shorthand dojo.animateProperty with auto-play
	anim: dojo.anim,

	// animateProperty: Function
	//	Alias of dojo.animateProperty - animate any CSS property
	animateProperty: dojo.animateProperty,

	// fadeTo: Function 
	//		Fade an element from an opacity to an opacity.
	//		Omit start: property to detect. End: property required
	fadeTo: dojo._fade,

	// fadeIn: Function
	//	Alias of dojo.fadeIn - Fade a node in.
	fadeIn: dojo.fadeIn,
	
	// fadeOut: Function
	//	Alias of dojo.fadeOut - Fades a node out.
	fadeOut: dojo.fadeOut,

	// combine: Function
	//	Alias of dojo.fx.combine - Run animations in parallel
	combine: dojo.fx.combine,

	// chain: Function
	//	Alias of dojo.fx.chain - Run animations in sequence
	chain: dojo.fx.chain,

	// slideTo: Function
	//	Alias of dojo.fx.slideTo - Slide a node to a defined top/left coordinate
	slideTo: dojo.fx.slideTo,

	// wipeIn: Function
	//	Alias of dojo.fx.wipeIn - Wipe a node to visible
	wipeIn: dojo.fx.wipeIn,

	// wipeOut: Function
	//	Alias of dojo.fx.wipeOut - Wipe a node to non-visible
	wipeOut: dojo.fx.wipeOut

});

dojox.fx.sizeTo = function(/* Object */args){
	// summary: Creates an animation that will size a node 
	// description:
	//		Returns an animation that will size the target node
	//		defined in args Object about it's center to
	//		a width and height defined by (args.width, args.height), 
	//		supporting an optional method: chain||combine mixin
	//		(defaults to chain).	
	//
	//	- works best on absolutely or relatively positioned elements
	//	
	// example:
	// |	// size #myNode to 400px x 200px over 1 second
	// |	dojo.fx.sizeTo({
	// |		node:'myNode',
	// |		duration: 1000,
	// |		width: 400,
	// |		height: 200,
	// |		method: "combine"
	// |	}).play();
	//

	var node = args.node = dojo.byId(args.node);

	var method = args.method || "chain"; 
	if(!args.duration){ args.duration = 500; } // default duration needed
	if(method == "chain"){ args.duration = Math.floor(args.duration / 2); } 
	
	var top, newTop, left, newLeft, width, height = null;

	var init = (function(n){
		return function(){
			var cs = dojo.getComputedStyle(n);
			var pos = cs.position;
			top = (pos == 'absolute' ? n.offsetTop : parseInt(cs.top) || 0);
			left = (pos == 'absolute' ? n.offsetLeft : parseInt(cs.left) || 0);
			width = parseInt(cs.width);
			height = parseInt(cs.height);

			newLeft = left - Math.floor((args.width - width) / 2); 
			newTop = top - Math.floor((args.height - height) / 2); 

			if(pos != 'absolute' && pos != 'relative'){
				var ret = dojo.coords(n, true);
				top = ret.y;
				left = ret.x;
				n.style.position = "absolute";
				n.style.top = top + "px";
				n.style.left = left + "px";
			}
		}
	})(node);
	init(); 

	var anim1 = dojo.animateProperty(dojo.mixin({
		properties: {
			height: { start: height, end: args.height || 0, unit:"px" },
			top: { start: top, end: newTop }
		}
	}, args));
	var anim2 = dojo.animateProperty(dojo.mixin({
		properties: {
			width: { start: width, end: args.width || 0, unit:"px" },
			left: { start: left, end: newLeft }
		}
	}, args));

	var anim = dojo.fx[(args.method == "combine" ? "combine" : "chain")]([anim1, anim2]);
	dojo.connect(anim, "beforeBegin", anim, init);
	return anim; // dojo._Animation

};

dojox.fx.slideBy = function(/* Object */args){
	// summary: Returns an animation to slide a node by a defined offset.
	//
	// description:
	//	Returns an animation that will slide a node (args.node) from it's
	//	current position to it's current posision plus the numbers defined
	//	in args.top and args.left. standard dojo.fx mixin's apply. 
	//	
	// example:
	// |	// slide domNode 50px down, and 22px left
	// |	dojox.fx.slideBy({ 
	// |		node: domNode, duration:400, 
	// |		top: 50, left: -22 
	// |	}).play();

	var node = args.node = dojo.byId(args.node);	
	var top = null; var left = null;

	var init = (function(n){
		return function(){
			var cs = dojo.getComputedStyle(n);
			var pos = cs.position;
			top = (pos == 'absolute' ? n.offsetTop : parseInt(cs.top) || 0);
			left = (pos == 'absolute' ? n.offsetLeft : parseInt(cs.left) || 0);
			if(pos != 'absolute' && pos != 'relative'){
				var ret = dojo.coords(n, true);
				top = ret.y;
				left = ret.x;
				n.style.position = "absolute";
				n.style.top = top + "px";
				n.style.left = left + "px";
			}
		}
	})(node);
	init();
	var _anim = dojo.animateProperty(dojo.mixin({
		properties: {
			// FIXME: is there a way to update the _Line after creation?
			// null start values allow chaining to work, animateProperty will
			// determine them for us (except in ie6? -- ugh)
			top: top + (args.top || 0),
			left: left + (args.left || 0) 
		}
	}, args));
	dojo.connect(_anim, "beforeBegin", _anim, init);
	return _anim; // dojo._Animation
};

dojox.fx.crossFade = function(/* Object */args){
	// summary: Returns an animation cross fading two element simultaneously
	// 
	// args:
	//	args.nodes: Array - two element array of domNodes, or id's
	//
	// all other standard animation args mixins apply. args.node ignored.
	//
	if(dojo.isArray(args.nodes)){
		// simple check for which node is visible, maybe too simple?
		var node1 = args.nodes[0] = dojo.byId(args.nodes[0]);
		var op1 = dojo.style(node1,"opacity");
		var node2 = args.nodes[1] = dojo.byId(args.nodes[1]);
		var op2 = dojo.style(node2, "opacity");

		var _anim = dojo.fx.combine([
			dojo[(op1 == 0 ? "fadeIn" : "fadeOut")](dojo.mixin({
				node: node1
			},args)),
			dojo[(op1 == 0 ? "fadeOut" : "fadeIn")](dojo.mixin({
				node: node2
			},args))
		]);
		return _anim; // dojo._Animation
	}else{
		// improper syntax in args, needs Array
		return false; // Boolean
	}
};

dojox.fx.highlight = function(/*Object*/ args){
	// summary: Highlight a node
	// description:
	//	Returns an animation that sets the node background to args.color
	//	then gradually fades back the original node background color
	//	
	// example:
	//	dojox.fx.highlight({ node:"foo" }).play(); 

	var node = args.node = dojo.byId(args.node);

	args.duration = args.duration || 400;
	
	// Assign default color light yellow
	var startColor = args.color || '#ffff99';
	var endColor = dojo.style(node, "backgroundColor");
	var wasTransparent = (endColor == "transparent" || endColor == "rgba(0, 0, 0, 0)") ? endColor : false;

	var anim = dojo.animateProperty(dojo.mixin({
		properties: {
			backgroundColor: { start: startColor, end: endColor }
		}
	}, args));

	if(wasTransparent){
		dojo.connect(anim, "onEnd", anim, function(){
			node.style.backgroundColor = wasTransparent;
		});
	}

	return anim; // dojo._Animation
};

 
dojox.fx.wipeTo = function(/*Object*/ args){
	// summary: Animate a node wiping to a specific width or height
	//	
	// description:
	//		Returns an animation that will expand the
	//		node defined in 'args' object from it's current to
	//		the height or width value given by the args object.
	//
	//		default to height:, so leave height null and specify width:
	//		to wipeTo a width. note: this may be deprecated by a 
	//
	//      Note that the final value should not include
	//      units and should be an integer.  Thus a valid args object
	//      would look something like this:
	//
	//      dojox.fx.wipeTo({ node: "nodeId", height: 200 }).play();
	//
	//		Node must have no margin/border/padding, so put another
	//		node inside your target node for additional styling.

	args.node = dojo.byId(args.node);
	var node = args.node, s = node.style;

	var dir = (args.width ? "width" : "height");
	var endVal = args[dir];

	var props = {};
	props[dir] = {
		// wrapped in functions so we wait till the last second to query (in case value has changed)
		start: function(){
			// start at current [computed] height, but use 1px rather than 0
			// because 0 causes IE to display the whole panel
			s.overflow = "hidden";
			if(s.visibility == "hidden" || s.display == "none"){
				s[dir] = "1px";
				s.display = "";
				s.visibility = "";
				return 1;
			}else{
				var now = dojo.style(node,dir);
				return Math.max(now, 1);
			}
		},
		end: endVal,
		unit: "px"
	};

	var anim = dojo.animateProperty(dojo.mixin({ properties: props }, args));
	return anim; // dojo._Animation
};

}

if(!dojo._hasResource["dojox.fx"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.fx"] = true;
dojo.provide("dojox.fx");

 

}

if(!dojo._hasResource["widgets.SlideTabContent"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.SlideTabContent"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.SlideTabContent");






dojo.declare(
	"widgets.SlideTabContent", [dijit._Widget, dijit._Templated],
	{			
		templateString:"<div class=\"slideTabContainer\">\n\t<div dojoAttachPoint=\"tab\" style=\"height:${tabContentHeight};\" class=\"slideTabContainerTab\">\n\t\t<div dojoAttachPoint=\"tabLeft\" style=\"height:${tabContentHeight};\" class=\"slideTabContainerTabLeft\"></div>\n\t\t<div dojoAttachPoint=\"tabMiddle\" style=\"height:${tabContentHeight};\" class=\"slideTabContainerTabMiddle\">\n\t\t\t<div dojoAttachPoint=\"tabContainerNode\" class=\"slideTabContainerTabMiddleMiddle\">\n\t\t\t\t<div dojoAttachPoint=\"titleNode\" class=\"tabTitle\" style=\"float:left;overflow:hidden;\">${label}</div>\n\t\t\t\t<div dojoAttachPoint=\"tabIconSpan\" class=\"tabIcon\" style=\"float:left;position:absolute;right:0px;\">\n\t\t\t\t\t<a href=\"javascript:;\">\n\t\t\t\t\t\t<img dojoAttachPoint=\"iconImg\" style=\"width:20px;height:20px;position:relative;top:-3px\"\n\t\t\t\t\t\t\tsrc=\"${imgBasePath}${iconPath}\"></img>\n\t\t\t\t\t</a>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t\t<div dojoAttachPoint=\"tabRight\" style=\"height:${tabContentHeight};\" class=\"slideTabContainerTabRight\"></div>\n\t</div>\t\t\n\t<div dojoAttachPoint=\"middle\" style=\"top:${tabContentHeight};\" class=\"slideTabContainerMiddle\">\n\t\t<div dojoAttachPoint=\"middleLeft\" class=\"slideTabContainerMiddleLeft\"></div>\n\t\t<div dojoAttachPoint=\"middleMiddle\" class=\"slideTabContainerMiddleMiddle\">\n\t\t\t<div dojoAttachPoint=\"containerNode\" style=\"width:100%;height:100%;overflow:hidden;visibility:hidden;\">\n\t\t\t</div>\n\t\t</div>\n\t\t<div dojoAttachPoint=\"middleRight\" class=\"slideTabContainerMiddleRight\"></div>\n\t</div>\t\t\n\t<div dojoAttachPoint=\"bottom\" class=\"slideTabContainerBottom\">\t\n\t\t<div class=\"slideTabContainerBottomLeft\"></div>\n\t\t<div dojoAttachPoint=\"bottomMiddle\" class=\"slideTabContainerBottomMiddle\"></div>\n\t\t<div class=\"slideTabContainerBottomRight\"></div>\n\t</div>\n</div>\n",
		
		tabWidth: 225,
		tabHeight: 30,
		tabContentHeight: 21/*tabHeight - 9*/,
		contentWidth: 380,
		contentHeight: 270,
		
		limitMinTabWidth: 25, 
		
		imgBasePath: EDR.config.imageBaseDir,
		iconPath: "loadsearch23.png",
		closeIconPath: "loadsearch23.png",
//		title: "",
		label: "",		
		animate: true,
		opened: false,
		handlers: [],
		
		postCreate: function() {
			this.inherited(arguments);
			dojo.marginBox(this.domNode, {w:this.tabWidth, h:this.tabHeight});
			this.handlers.push(dojo.connect(this.tabContainerNode, "onclick", this, "onTabClicked"));
		},
		
		startup: function() {
			this.inherited(arguments);
			this.iconImg.setAttribute("alt", this.label);
			this.fitToContent(false);
			if (this.isLeftToRight()) {
				dojo.style(this.tabIconSpan, "right", "0");
			} else {
				dojo.style(this.tabIconSpan, "left", "0");
				this.closeIconPath = "diagonal-up-arrow-reverse23.png";
			}
		},
		
		onTabClicked: function(evt) {
			this.opened ? this.close() : this.open();
		},
		
		beforeOpen: function(id, anim, contentWidth) {
			this.opened = true;
			dojo.style(this.containerNode, "visibility", "visible");
		},
		
		beforeClose: function(id, anim) {
			this.opened = false;
		},
		
		afterOpen: function(id, anim) {
			this.iconImg.src = this.imgBasePath + this.closeIconPath;
			this.titleNode.innerHTML = this.label;
			dojo.publish("afterSlideTabOpened", [{contentId:this.domNode.id}]);
		},
		
		afterClose: function(id, anim) {
			dojo.style(this.containerNode, "visibility", "hidden");
			this.iconImg.src = this.imgBasePath + this.iconPath;
			this.titleNode.innerHTML = this.label;
			dojo.publish("afterSlideTabClosed", [{contentId:this.domNode.id}]);
		},
		
		open: function() {
			if (this.animate) {
				var anim = this.wipeTo({w:this.contentWidth, h:this.contentHeight});
				this.beforeOpen(this.id, anim, this.contentWidth);
				
				var con = dojo.connect(anim, "onEnd", this, function() {
					this.afterOpen(this.id, anim);
					dojo.disconnect(con);
				});		
				anim.play();			
			} else {
				this.beforeOpen(this.id, null);	
				dojo.marginBox(this.domNode, {w:this.contentWidth, h:this.contentHeight});				
				this.afterOpen(this.id, null);
			}
		},
		
		fitToContent: function(show) {
			var singleChild = this.getChildren()[0];
			if (singleChild != null) {
				var size = dojo.marginBox(singleChild.domNode);
				this.contentWidth = size.w + 18;
				this.contentHeight = size.h + this.tabHeight;
			}
			if (show) this.open();
		},
		
		close: function() {						
			if (this.animate) {
				var anim = this.wipeTo({w:this.tabWidth, h:this.tabHeight});
				this.beforeClose(this.id, anim);	
						
				var con = dojo.connect(anim, "onEnd", this, function() {
					this.afterClose(this.id, anim);
					dojo.disconnect(con);
				});
				anim.play();			
			} else {
				this.beforeClose(this.id, anim);
				dojo.marginBox(this.domNode, {w:this.tabWidth, h:this.tabHeight});				
				this.afterClose(this.id, anim);
			}
		},
		
		setTitle: function(title) {
			this.titleNode.innerHTML = title;
		},
		
		wipeTo: function(size) {
			var anims = [];
	       	anims.push(dojox.fx.wipeTo({
                node: this.domNode,
                width: size.w
	        }));
	        anims.push(dojox.fx.wipeTo({
                node: this.domNode,
                height: size.h
	        }));
			return dojo.fx.combine(anims);
		},
		
		resizeTab: function(){
			var anim = this.wipeTo({w:this.tabWidth, h:this.tabHeight});
			if(this.tabWidth < 40){
				dojo.style(this.titleNode, "display", "none");
			} else {
				dojo.style(this.titleNode, "width", (this.tabWidth - 38) + "px");
				dojo.style(this.titleNode, "display", "block");
				dojo.style(this.iconImg, "display", "block");				
			}
			anim.play();
		}
	}
);

}

if(!dojo._hasResource["widgets.SlideTabContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.SlideTabContainer"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.SlideTabContainer");






dojo.declare(
	"widgets.SlideTabContainer", [dijit.layout._LayoutWidget],
	{			
		templateString:"<div>\n\t<div dojoAttachPoint=\"containerNode\">\n\t</div>\n</div>\n",
		
		handlers: [],
		id2panes: {},
		currentPane: null,
		defaultTabWidth: 225,
		reduceWidth: 16,
		numOfChild: 0,
		isOpen: false,
		
		postCreate: function() {
			this.inherited(arguments);
		},
				
		startup: function() {
			this.inherited(arguments);
			
			var children = this.getChildren();
			var self = this;
			dojo.forEach(children, function(pane) {
				self.handlers.push(dojo.connect(pane, "beforeOpen", self, "beforeOpen"));
				self.handlers.push(dojo.connect(pane, "afterOpen", self, "afterOpen"));
				self.handlers.push(dojo.connect(pane, "beforeClose", self, "beforeClose"));
				self.handlers.push(dojo.connect(pane, "afterClose", self, "afterClose"));
				self.id2panes[pane.id] = pane;
				self.numOfChild++;
			});
		},
		
		resize: function() {
			var children = this.getChildren();
			var maxHeight = 1;
			dojo.forEach(children, function(pane) {
				maxHeight = Math.max(maxHeight, dojo.marginBox(pane.domNode).h);
				if (pane.domNode.offsetTop != 0) {
					dojo.style(pane.domNode, "visibility", "hidden");
				} else if (pane.domNode.style.visibility == "hidden") {
					dojo.style(pane.domNode, "visibility", "visible");
				}
			});
			dojo.style(this.domNode, "height", maxHeight + "px");
		},
		
		onTabAnimate: function() {
		},
		
		beforeOpen: function(id, anim, contentWidth) {
			this.opening = true;
			
			var needResize = this.currentPane == null;
			if (this.currentPane != null && id != this.currentPane.id) {
				this.currentPane.close();
			}
			this.currentPane = this.id2panes[id];
			
			if (needResize && anim != null) {
				var cons = [];
				cons.push(dojo.connect(anim, "onAnimate", this, "onTabAnimate"));
				cons.push(dojo.connect(anim, "onEnd", this, function() {
					dojo.forEach(cons, function(con) {
						dojo.disconnect(con);
					});
				}));
			}

			var children = this.id2panes;
			var self = this;
			var tabWidth = 170;
			var availableWidth = dojo.contentBox(this.containerNode).w;
			var allTabWidth = (this.numOfChild - 1) * this.defaultTabWidth + contentWidth;
			if ((availableWidth - allTabWidth) < this.reduceWidth) {
				tabWidth = (availableWidth - contentWidth - this.reduceWidth) / (this.numOfChild - 1);
			}
			
			if(needResize && EDR.isTextAnalyticsEnabled) {
				widgets.analytics.hideAnalyticsPane();
			}
			
			for(var childId in children){
				if(self.currentPane.id != childId){
					dojo.attr(children[childId], "tabWidth", tabWidth);
					children[childId].resizeTab();
				}
			}
		},
				
		beforeClose: function(id, anim) {
			var children = this.id2panes;
			var self = this;
			for(var id in children){
				if(self.currentPane.id!=id){
					dojo.attr(children[id],"tabWidth",self.defaultTabWidth);
					children[id].resizeTab();
				}
			}
			if (this.opening) return;			
			this.currentPane = null;
			
			if(EDR.isTextAnalyticsEnabled) {
				widgets.analytics.hideAnalyticsPane();
			}
			if (anim != null) {
				var cons = [];
				cons.push(dojo.connect(anim, "onAnimate", this, "onTabAnimate"));
				cons.push(dojo.connect(anim, "onEnd", this, function() {
					dojo.forEach(cons, function(con) {
						dojo.disconnect(con);
					});
				}));
			}
			
			if(dojo.isIE <= 7){
				dijit.byId(EDR.prefix+"horizontalSearchPanes").resultsBodyContainer.layout();
			}
			
		},
		
		afterOpen: function(id, anim) {
			this.opening = false;
			this.isOpen = true;
			if(EDR.isTextAnalyticsEnabled) {
				widgets.analytics.showAnalyticsPane();
			}
		},
		
		afterClose: function(id, anim) {
			if (this.opening) return;
			this.isOpen = false;
			if(EDR.isTextAnalyticsEnabled) {
				widgets.analytics.showAnalyticsPane();
			}
		}
	}
);

}

if(!dojo._hasResource["widgets.SearchPane"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.SearchPane"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.SearchPane");









dojo.declare(
	"widgets.SearchPane", [dijit.layout._LayoutWidget, dijit._Templated],
	{
		prefix: EDR.prefix,
		imgBasePath: EDR.config.imageBaseDir,
		
		widgetsInTemplate: true,
		templateString:"<div class=\"searchPane\">\n\t<div dojoAttachPoint=\"queryArea\" style=\"display:block;min-height:100px;\">\n\t\t<div dojoAttachPoint=\"leftSpace\" class=\"leftSpace\">\n\t\t\t&nbsp;\n\t\t</div>\n\t\t<div dojoAttachPoint=\"middleSpace\" class=\"middleSpace\">\n\t\t\t<div dojoType=\"widgets.QueryTextBox\" class=\"queryTextBox\"></div>\n\t\t\t<div dojoAttachPoint=\"containerNode\" class=\"middleSpaceContainer\">\n\t\t\t</div>\n\t\t\t<input dojoAttachPoint=\"paramFilterBy\" type=\"hidden\" name=\"paramFilterBy\" value=\"all\" />\n\t\t</div>\n\t\t<div dojoAttachPoint=\"rightSpace\" class=\"rightSpace\">\n\t\t\t<div class=\"rightSpaceContainer\">\n\t\t\t\t\t<div dojoType=\"widgets.Button\" class=\"buttonWidget\" label=\"${search_label}\"\n\t\t\t\t\t\tdojoAttachEvent=\"onClick: onSearchButtonClicked\" title=\"${messages_tooltip_searchpane_search}\"></div>\n\t\t\t\t\t<div dojoType=\"widgets.Button\" class=\"buttonWidget\" label=\"${clear_label}\"\n\t\t\t\t\t\tdojoAttachEvent=\"onClick: onClearButtonClicked\" title=\"${messages_tooltip_searchpane_clear}\"></div>\n\t\t\t</div>\n\t\t\t<div dojoAttachPoint=\"withResultContainer\" class=\"withinSearchContainer\" title=\"${messages_tooltip_searchpane_addsearch_link}\">\n\t\t\t\t<div id=\"${prefix}withinResultsChkbox\" dojoType=\"dijit.form.CheckBox\" disabled=\"true\">\n\t\t\t\t</div><label dojoAttachPoint=\"withinResultsLabel\"\n\t\t\t\t\t\t\tfor=\"${prefix}withinResultsChkbox\" style=\"color:gray;\">${search_within_result}</label>\n\t\t\t</div>\n\t\t</div>\n\t\t<div dojoAttachPoint=\"helpLink\" class=\"helplink\">\n\t\t\t<a href=\"javascript:;\" title=\"${tooltip_help_general}\" onclick=\"EDR.viewHelp('iiysutmall.htm?noframes=true')\">\n\t\t\t\t<img src=\"${imgBasePath}help_16.png\" alt=\"${tooltip_help_general}\" />\n\t\t\t</a>\n\t\t</div>\n\t</div>\n\t<div dojoAttachPoint=\"noQueryArea\" style=\"display:none;width:100%;height:20px;padding-top:3px;padding-left:20px;\">\n\t\t<a dojoAttachPoint=\"showQueryLink\" dojoAttachEvent=\"onclick: showQueryArea\" \n\t\t\thref=\"javascript:;\" style=\"color:#003063;\">${showarea_label}</a>\n\t</div>\n</div>\n",
		
		slideTabContainer: null,
		queryTextBox: null,
		submitButton: null,
		clearButton: null,
		advSearch: null,
		loadSearch: null,
		searchOption: null,
		
		inAnimation: false,
		maxInputWidth: 750,
		
		handlers: [],
		
		postCreate: function() {
			this.inherited("postCreate", arguments);
		},
		
		startup: function() {
			this.inherited("startup", arguments);
			
			this.slideTabContainer = this.getChildren()[0];
			this.queryTextBox = this._supportingWidgets[0];
			this.submitButton = this._supportingWidgets[1];
			this.clearButton = this._supportingWidgets[2];
			this.searchTypeChk = this._supportingWidgets[3];
			this.advSearch = dijit.byId(EDR.prefix+"advancedSearchPane");
			
			var top = ((dojo.isIE <= 7) ? "1px" : "0px");

			dojo.style(this.containerNode, "position", "relative");
			dojo.style(this.containerNode,  "top", top);
				
			if (EDR.isTextAnalyticsEnabled) {
				dojo.style(this.queryTextBox.domNode, "height", "65px");	
				dojo.style(this.rightSpace, "paddingTop", "22px");
				dojo.style(this.helpLink, "paddingTop", "26px");
			} else {
				dojo.style(this.helpLink, "visibility", "hidden");
			}
			
			this.handlers.push(dojo.connect(this.slideTabContainer, "onTabAnimate", this, "onTabAnimate"));
			this.handlers.push(dojo.connect(this.slideTabContainer, "afterOpen", this, "onTabAnimationEnd"));
			this.handlers.push(dojo.connect(this.slideTabContainer, "afterClose", this, "onTabAnimationEnd"));
			
			dojo.subscribe("collectionChanged", this, function() { 
				var result = dijit.byId(EDR.prefix+"searchManager").getSearchResult()
				var query = "";
				if (EDR.isTextAnalyticsEnabled) {
					query = "*:*";
				} else {
					query = result != null ? result.query : "";
					if (query == null || query == "") return;
					return;
				}
				dijit.byId(EDR.prefix+"searchManager").submitQuickKeywordSearch(query);
			});
			dojo.subscribe("preferenceChanged", this, function() {
				if (!EDR.isTextAnalyticsEnabled) return;
				
				var result = dijit.byId(EDR.prefix+"searchManager").getSearchResult()
				var query = query = result != null ? result.query : "";
				if (query == "" || query == null) query = "*:*";
				dijit.byId(EDR.prefix+"searchManager").submitQuickKeywordSearch(query);
			});			
			dojo.subscribe("preLoad", this, function() { this.setSearchType("search"); });
			dojo.subscribe("refresh", this, "refresh");
			
			var typeAhead = dijit.byId(EDR.prefix+"typeAheadWidget");
			if(typeAhead){
				var input = EDR.isTextAnalyticsEnabled ? this.queryTextBox.textArea : this.queryTextBox.textInput;
				if(input!=null){
					var self = this;
					self.handlers.push(dojo.connect(input,"onfocus",typeAhead,function(e){
						typeAhead.attach(input.id,EDR.contextPath + "/typeAhead?action=getSearchTypeAheadKeywords", true);
						//override
						typeAhead.onExecute = function(e, value){
							if(e.type=="click"){
								self.submitSearch();
							}
						}
					}));
				}
			}
		},
		
		showQueryArea: function() {
			EDR.isQueryAreaHidden = false;
			dojo.style(this.queryArea, "display", "block");
			dojo.style(this.noQueryArea, "display", "none");
			var searchPane = dijit.byId(EDR.prefix+"horizontalSearchPanes");
			searchPane.resultToolbar.toggleShowHideAreaButton(false);
			searchPane.resultBottomBar.show();
			dijit.byId(EDR.prefix+"topBorderContainer").resize();
		},
		
		hideQueryArea: function() {
			EDR.isQueryAreaHidden = true;
			dojo.style(this.queryArea, "display", "none");
			dojo.style(this.noQueryArea, "display", "block");
			var searchPane = dijit.byId(EDR.prefix+"horizontalSearchPanes");
			searchPane.resultToolbar.toggleShowHideAreaButton(true);
			dojo.style(searchPane.resultBottomBar.domNode, "display", "none");
			dijit.byId(EDR.prefix+"topBorderContainer").resize();
		},
		
		submitSearch: function() {
			var params = this.getFormValues();
			if (this.validate(params)) {
				dijit.byId(EDR.prefix+"searchManager").submitSearch(null, this.getSearchType(), params);
				//if (this.isAdvancedSearch()) dijit.byId(EDR.prefix+"advSearchTab").close();
			}
		},
		
		getFormValues: function() {
			var params = {};
			params.keywords = this.queryTextBox.getFullQuery();
//			params.filterBy = this.paramFilterBy.value;
			
			// advanced search parameters
			if (this.isAdvancedSearch()) {
				dojo.mixin(params, this.advSearch.getFormValues());
			}
/*			
			// facet parameters
			var facetTree = dijit.byId(EDR.prefix+"facetTree");
			if (facetTree != null) {
				params = dojo.mixin(params, facetTree.getFormValues());
			}
*/			
			return params;
		},
		
		validate: function(params) {
			// at first, clear errors all previous error messages
			this.advSearch.clearError();
			
			var needKeywords = true;
//				(params.andfacet == null || params.andfacet.length == 0) &&
//				(params.notfacet == null || params.notfacet.length == 0);

			var errors = "";			
			if (this.isAdvancedSearch()) {
				errors = this.advSearch.validate(params, needKeywords);
			} else if (needKeywords) {
				if (params.keywords == null || params.keywords == "")
					errors = EDR.messages.erros_noQueryTerms + "</br></br>";
			}
			if (errors != "") {
				EDR.util.alert(errors);
				return false;
			}			
			return true;
		},
		
		refresh: function() {
			this.reset();
			var query = dijit.byId(EDR.prefix+"searchManager").getSearchResult().query;
			if (query != null && query.length > 0) {
				this.searchTypeChk.setDisabled(false);
				dojo.style(this.withinResultsLabel, "color", "black");
			} else {
				this.searchTypeChk.setDisabled(true);
				dojo.style(this.withinResultsLabel, "color", "gray");
			}
			this.queryTextBox.setFullQuery(query);
		},
		
		reset: function() {
			this.queryTextBox.reset();
			this.advSearch.reset();
		},
		
		getSearchType: function() {
			return this.searchTypeChk.checked ? "refineSearch" : "search";
		},
		
		setSearchType: function(type) {
			if (type == "refineSearch") {
//				this.queryTextBox.setFullQuery("");
			}
			this.searchTypeChk.attr("checked", type == "refineSearch");
		},
		
		isAdvancedSearch: function() {
			var openedPane = this.slideTabContainer.currentPane;
			return openedPane != null && openedPane.id == (EDR.prefix+"advSearchTab");
		},
		
		isAdvancedSearchOptionsEnabled: function() {
			return this.isAdvancedSearch() && this.advSearch.showOption;
		},
				
		resize: function(changeSize, resultSize) {
			var width = this.domNode.clientWidth;
			var wl = Math.floor(width*0.10);
			var wr = Math.floor(width*0.20);
			var wm = width - (wl + wr);
			var delta = wm - this.maxInputWidth;
			if (delta > 0) {
				wm = this.maxInputWidth;
				wl += delta / 2 - 1;
				wr += delta / 2 - 1;
			}
						
			dojo.marginBox(this.leftSpace, {w: wl});
			dojo.marginBox(this.middleSpace, {w: wm});
			//dojo.marginBox(this.rightSpace, {w: wr});
			
			// slideTabContainer is already resized?
			if (this.inAnimation) return;
			
			this.layout();
		},
		
		layout: function() {
			this.slideTabContainer.resize();
		},
		
		relayoutTopContainer: function() {
			// force to relayout top level container			
			this.slideTabContainer.resize();
			dijit.byId(EDR.prefix+"topBorderContainer").layout();			
		},
		
		onSearchButtonClicked: function(evt) {
			this.submitSearch();
		},
		
		onClearButtonClicked: function(evt) {
			this.reset();
			if (EDR.isTextAnalyticsEnabled) {
				dijit.byId(EDR.prefix+"searchManager").submitQuickKeywordSearch("*:*");		
				//dijit.byId(EDR.prefix+"categoryTree").unselectAll();
			}
		},
				
		onTabAnimate: function() {
			this.inAnimation = true;	
			this.relayoutTopContainer();		
		},
		
		onTabAnimationEnd: function(id, anim) {
			this.inAnimation = false;
			var self = this;
			setTimeout(function() { self.relayoutTopContainer(); }, 0);		
		},
		
		destroy: function() {
			dojo.forEach(this.handlers, dojo.disconnect);
			this.inherited(arguments);
		},
		
		// messages
		search_label: EDR.messages.button_search,
		clear_label: EDR.messages.button_clear,
		search_within_result: EDR.messages.prompt_searchWithinResults,
		tooltip_help_general: EDR.messages.tooltip_help_general,
		showarea_label: EDR.messages.searchpane_showqueryarea,
		messages_tooltip_searchpane_search: EDR.messages.tooltip_searchpane_search,
		messages_tooltip_searchpane_clear: EDR.messages.tooltip_searchpane_clear,
		messages_tooltip_searchpane_addsearch_link: EDR.messages.tooltip_searchpane_addsearch_link
	}
);

}

if(!dojo._hasResource["widgets.BasicSearchPane"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.BasicSearchPane"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.BasicSearchPane");




dojo.declare(
	"widgets.BasicSearchPane", [dijit._Widget, dijit._Templated],
	{				
		prefix: EDR.prefix,
		widgetsInTemplate: true,
		templateString:"<div>\n\t<form dojoAttachPoint=\"basicSearchForm\" onSubmit=\"return false;\">\n\t\t<div class=\"searchFormInput\">\n\t\t\t<div class=\"inputRow\">\n\t\t\t\t<label dojoAttachPoint=\"keyLabel\" accesskey=\"k\" for=\"${prefix}basicKeywords\">${prompt_search}:&nbsp;\n\t\t\t\t\t<span dojoAttachPoint=\"keywordErr\" class=\"noError\"></span>\n\t\t\t\t</label>\n\t\t\t\t<br>\n\t\t\t\t<input type=\"text\" class=\"textbox\" name=\"basicKeywords\" id=\"${prefix}basicKeywords\" dojoAttachPoint=\"keywords\"\n\t\t\t\t\tdojoType=\"dijit.form.TextBox\" trim=\"true\" />\t\t\t\n\t\t    </div>\t\n\t\t</div>\t\t\t\t\n\t\t<div>\n\t\t\t<div class=\"inputRow\" style=\"overflow:hidden;\">\n\t\t\t\t<a dojoAttachPoint=\"searchOptionsLink\" href=\"javascript:;\" style=\"float:right;margin-bottom:0px;\">\n\t\t\t\t\t${prompt_searchOptions}\n\t\t\t\t</a>\n\t\t    </div>\t\n\t\t</div>\t\t\n\t</form>\t\t\n</div>\n",
//		keywords: null,
		handlers: [],
		
		// resources
		prompt_search: "",
		prompt_searchOptions: "",
		
		postCreate: function() {
			this.buildMessages();
			this.inherited("postCreate", arguments);
//			this.keywords = dijit.byId("basicKeywords");
			this.handlers.push(dojo.connect(this.keywords.textbox, "onkeypress", this, "submitOnEnter"));	
			this.handlers.push(dojo.connect(this.searchOptionsLink, "onclick", this, "showSearchOptions"));		
		},
		
		buildMessages: function() {
		},
		
		submitOnEnter: function(evt) {
			if (evt.keyCode == dojo.keys.ENTER) {
				dijit.byId(EDR.prefix+"searchPane").onSearchBtnClicked();
			}
		},
		
		showSearchOptions: function(evt) {
			var dlg = dijit.byId(EDR.prefix+"preference");
			if (dlg != null) {
				dlg.showTab(EDR.prefix+"searchOptionsTab");
				EDR.dialog.util.show(dlg);
			}
		},
		
		getFormValues: function() {
			return dojo.formToObject(this.basicSearchForm);			
		},
	
		validate: function(params, needKeywords) {
			if (params == null) params = this.getFormValues();
			
			var errors = "";
			if (needKeywords && (params.basicKeywords == null || params.basicKeywords == "")) {
				errors += EDR.messages.erros_noQueryTerms + "</br></br>";
//				this.markFieldInvalid(this.keywordErr, EDR.messages.error_Search_invalid_param, this.keywords);
			}
			return errors;
		},
		
		clearPane: function() {
			dojo.forEach(this.getDescendants(), function(widget){
				if(widget.reset) widget.reset();
			});
			this.clearError();
		},
		
		clearError: function() {
			this.markFieldValid(this.keywordErr);
		},
				
		markFieldInvalid: function(errorDiv, errorMsg, input) {
			errorDiv.innerHTML = errorMsg;
			errorDiv.className = 'error';
			if (input) input.focus;
		},
		
		markFieldValid: function(errorDiv) {
			errorDiv.innerHTML = "";
			errorDiv.className = 'noError';
		},
		
		destroy: function() {
			dojo.forEach(this.handlers, dojo.disconnect);
			this.inherited("destroy", arguments);
		}
	}
);

}

if(!dojo._hasResource["widgets.AdvancedSearchPane"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.AdvancedSearchPane"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.AdvancedSearchPane");






dojo.declare(
	"widgets.AdvancedSearchPane", [dijit._Widget, dijit._Templated],
	{
		prefix: EDR.prefix,
		imageBaseDir: EDR.config.imageBaseDir,
		
		widgetsInTemplate: true,
		templateString:"<div style=\"padding-top:8px;\">\n\t<form class=\"advSearchForm\" dojoAttachPoint=\"advancedSearchForm\" onSubmit=\"return false;\">\n\t\t<div style=\"width:100%;height:100%;\">\n\t\t\t<div dojoAttachPoint=\"leftPane\" style=\"width:100%;height:100%;float:left;\">\n\t\t\t\t<div class=\"searchFormInput\" style=\"margin-bottom:5px;\">\n\t\t\t\t\t<div class=\"inputRow\" role=\"radiogroup\">\n\t\t\t\t\t\t<input id=\"${prefix}advancedNewSearch\" dojoType=\"dijit.form.RadioButton\" checked=\"true\"\n\t\t\t\t\t\t\t\ttabindex=\"0\" dojoAttachEvent=\"onClick: onNewSearchClicked\" name=\"searchType\"/>\n\t\t\t\t\t\t<label for=\"${prefix}advancedNewSearch\" title=\"${messages_tooltip_searchpane_newsearch_link}\">${label_newsearch}</label>\n\t\t\t\t\t\t<input id=\"${prefix}advancedRefineSearch\" dojoType=\"dijit.form.RadioButton\" style=\"margin-left:5px;\"\n\t\t\t\t\t\t\t tabindex=\"0\" dojoAttachEvent=\"onClick: onRefineSearchClicked\" name=\"searchType\"/>\n\t\t\t\t\t\t<label for=\"${prefix}advancedRefineSearch\" title=\"${messages_tooltip_searchpane_addsearch_link}\">${label_refinesearch}</label>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"searchFormInput\" title=\"${messages_tooltip_allWords}\">\n\t\t\t\t\t<div class=\"inputRow\">\n\t\t\t\t\t\t<label accesskey=\"l\" for=\"${prefix}showResultsWithAllWords\">${prompt_showResultsWith_allWords}:&nbsp;\n\t\t\t\t\t\t\t<span class=\"noError\"></span>\n\t\t\t\t\t\t</label>\n\t\t\t\t\t\t<br>\n\t\t\t\t\t\t<input type=\"text\" class=\"textbox\" id=\"${prefix}showResultsWithAllWords\" name=\"showResultsWithAllWords\"\n\t\t\t\t\t\t\ttabindex=\"0\" dojoType=\"dijit.form.TextBox\" trim=\"true\" />\t\t\t\n\t\t\t\t    </div>\t\n\t\t\t\t</div>\t\t\t\t\n\t\t\t\t<div class=\"searchFormInput\" title=\"${messages_tooltip_exactPhrase}\">\n\t\t\t\t\t<div class=\"inputRow\">\n\t\t\t\t\t\t<label accesskey=\"p\" for=\"${prefix}showResultsWithPhrase\">${prompt_showResultsWith_phrase}:&nbsp;\n\t\t\t\t\t\t\t<span class=\"noError\"></span>\n\t\t\t\t\t\t</label>\n\t\t\t\t\t\t<br>\n\t\t\t\t\t\t<input type=\"text\" class=\"textbox\" id=\"${prefix}showResultsWithPhrase\" name=\"showResultsWithPhrase\"\n\t\t\t\t\t\t\ttabindex=\"0\" dojoType=\"dijit.form.TextBox\" trim=\"true\" />\t\t\t\n\t\t\t\t    </div>\t\n\t\t\t\t</div>\t\t\t\t\n\t\t\t\t<div class=\"searchFormInput\" title=\"${messages_tooltip_anyWords}\">\n\t\t\t\t\t<div class=\"inputRow\">\n\t\t\t\t\t\t<label accesskey=\"a\" for=\"${prefix}showResultsWithAnyWords\">${prompt_showResultsWith_anyWords}:&nbsp;\n\t\t\t\t\t\t\t<span class=\"noError\"></span>\n\t\t\t\t\t\t</label>\n\t\t\t\t\t\t<br>\n\t\t\t\t\t\t<input type=\"text\" class=\"textbox\" id=\"${prefix}showResultsWithAnyWords\" name=\"showResultsWithAnyWords\"\n\t\t\t\t\t\t\ttabindex=\"0\" dojoType=\"dijit.form.TextBox\" trim=\"true\" />\t\t\t\n\t\t\t\t    </div>\t\n\t\t\t\t</div>\t\t\t\t\n\t\t\t\t<div class=\"searchFormInput\" title=\"${messages_tooltip_noneWords}\">\n\t\t\t\t\t<div class=\"inputRow\">\n\t\t\t\t\t\t<label accesskey=\"n\" for=\"${prefix}showResultsWithNoneWords\">${prompt_showResultsWith_noneWords}:&nbsp;\n\t\t\t\t\t\t\t<span class=\"noError\"></span>\n\t\t\t\t\t\t</label>\n\t\t\t\t\t\t<br>\n\t\t\t\t\t\t<input type=\"text\" class=\"textbox\" id=\"${prefix}showResultsWithNoneWords\" name=\"showResultsWithNoneWords\"\n\t\t\t\t\t\t\ttabindex=\"0\" dojoType=\"dijit.form.TextBox\" trim=\"true\" />\t\t\t\n\t\t\t\t    </div>\t\n\t\t\t\t</div>\t\t\t\t\n\t\t\t\t<div class=\"searchFormInput\" title=\"${messages_tooltip_dateRange}\">\t\t\t\t\t\t\n\t\t\t\t\t\t<table cellspacing=\"0\" cellpadding=\"0\" border=\"0\">\n\t\t\t\t\t\t\t<thead class=\"inputRow\">\n\t\t\t\t\t\t\t\t<th style=\"padding-left:2px;\"><span>${text_Search_dateStart}</span></th>\n\t\t\t\t\t\t\t\t<th><span>&nbsp;:&nbsp;</span></th>\n\t\t\t\t\t\t\t\t<th><span>&nbsp;${text_Search_dateEnd}</span></th>\n\t\t\t\t\t\t\t\t<th><span dojoAttachPoint=\"dateError\" class=\"noError\"></span></th>\t\t\n\t\t\t\t\t\t\t</thead>\n\t\t\t\t\t\t\t<tbody  class=\"date-row\">\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t\t<input dojoAttachPoint=\"fromToDate\" type=\"text\" name=\"fromdate\" class=\"date-textbox\"\t\n\t\t\t\t\t\t\t\t\t\ttabindex=\"0\" dojoType=\"widgets.DateTextBox\"\n\t\t\t\t\t\t\t\t\t\tinvalidMessage=\"\"\n\t\t\t\t\t\t\t\t\t\tstyle=\"width:86px\"\n\t\t\t\t\t\t\t\t\t \ttitle=\"${text_Search_dateStart}\"/>\t\t\t\t\n\t\t\t\t\t\t\t\t\t<a href=\"javascript:;\" style=\"margin-left:-5px;\"  dojoAttachEvent=\"onclick: onFromDateRangeClicked\">\n\t\t\t\t\t\t\t\t\t\t<img src=\"${imageBaseDir}datepicker23.png\" alt=\"${text_Search_dateStart}\"/>\n\t\t\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t<span>&nbsp;:&nbsp;</span>\t\t\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t\t<input dojoAttachPoint=\"toToDate\" type=\"text\" name=\"todate\" class=\"date-textbox\"\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\ttabindex=\"0\" dojoType=\"widgets.DateTextBox\"\n\t\t\t\t\t\t\t\t\t\tinvalidMessage=\"\"\n\t\t\t\t\t\t\t\t\t\tstyle=\"width:86px\"\n\t\t\t\t\t\t\t\t\t\ttitle=\"${text_Search_dateEnd}\"/>\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t<a href=\"javascript:;\" style=\"margin-left:-5px;\" dojoAttachEvent=\"onclick: onToDateRangeClicked\">\n\t\t\t\t\t\t\t\t\t\t<img src=\"${imageBaseDir}datepicker23.png\" alt=\"${text_Search_dateEnd}\"/>\n\t\t\t\t\t\t\t\t\t</a>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tbody>\n\t\t\t\t\t\t</table>\n\t\t\t\t</div>\n\t\t\t\t<div style=\"margin-top:10px;\">\n\t\t\t\t\t<div class=\"inputRow\" style=\"overflow:hidden;height:50px;\">\n\t\t\t\t\t\t<div dojoType=\"widgets.Button\" style=\"height:20px;float:left;\" label=\"${label_search}\"\n\t\t\t\t\t\t\t\ttabindex=\"0\" dojoAttachEvent=\"onClick: onSearchButtonClicked\" title=\"${messages_tooltip_searchpane_search}\"></div>\n\t\t\t\t\t\t<div dojoType=\"widgets.Button\" style=\"height:20px;float:left;\" label=\"${label_clear}\"\n\t\t\t\t\t\t\t\ttabindex=\"0\" dojoAttachEvent=\"onClick: onClearButtonClicked\" title=\"${messages_tooltip_searchpane_clear}\"></div>\n\t\t\t\t\t\t<div dojoType=\"widgets.Button\" style=\"height:20px;float:right;\" title=\"${messages_tooltip_searchpane_showoptions_link}\"\n\t\t\t\t\t\t\t\ttabindex=\"0\" dojoAttachEvent=\"onClick: toggleSearchOptions\" label=\"<span style='position:relative;top:-4px;'>${show_options}</span>\n\t\t\t\t\t\t\t\t<img src='${imageBaseDir}move-left23.png' style='position:relative;top:-2px;' alt=''/>\">\n\t\t\t\t\t\t</div>\n\t\t\t\t    </div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div dojoAttachPoint=\"rightPane\"\n\t\t\t\tstyle=\"position:relative;width:${rightPaneWidth}px;height:238px;margin-left:10px;border:1px solid gray;float:left;display:none;\">\n\t\t\t\t<div class=\"dijitTitlePaneTitle dijitOpen\" style=\"width:290px;height:15px;\" title=\"${label_advoptions_title}\">${label_advoptions_title}</div>\n\t\t\t\t<div dojoAttachPoint=\"advOptions\" dojoType=\"widgets.SearchOptions\"\n\t\t\t\t\tstyle=\"width:290px;height:205px;padding:5px;overflow:auto;background-color:white;\">\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t</form>\t\n</div>\n",
		fromDate: null,
		toDate: null,
		slideTabContent: null,
		advButton: null,
//		advOptions: null,
		searchType: "search",
		handlers: [],
		
		leftPaneWidth: 400,
		leftPaneWidthExpanded: 300,
		rightPaneWidth: 300,
		
		showOption: false,
				
		postCreate: function() {
			this.inherited("postCreate", arguments);
			
			this.fromDate = this._supportingWidgets[6];
			this.toDate = this._supportingWidgets[7];
			this.advButton = this._supportingWidgets[10];
			
			var self = this;
			dojo.forEach(this._supportingWidgets, function(widget) {
				if (widget.textbox != null) self.handlers.push(dojo.connect(widget.textbox, "onkeypress", self, "submitOnEnter"));			
			});
//			this.handlers.push(dojo.connect(this.searchOptionsLink, "onclick", this, "toggleSearchOptions"));		

			dojo.subscribe("afterSlideTabOpened", this, "onOpen");
			dojo.subscribe("refresh", this, "refresh");
		},
		
		startup: function() {
			this.inherited("startup", arguments);
			this.slideTabContent = dijit.byId(EDR.prefix+"advSearchTab");
			// to avoid IE's content pane size issue
			if (dojo.isIE == 7) dojo.style(this.advOptions.serchOptionsForm, "width", "95%");
			this.handlers.push(dojo.connect(this.advOptions, "preLoad", this, "preLoad"));
			this.handlers.push(dojo.connect(this.advOptions, "postLoad", this, "postLoad"));
			this.handlers.push(dojo.connect(this.advOptions, "loadErrorHandler", this, "postLoad"));
			this.advOptions.setAdvancedSearchOptions();
		},
		
		onOpen: function(event) {
			if (event.contentId == (EDR.prefix+"advSearchTab")) {
				this.refresh();
			}
		},
		
		onClose: function() {
		},
		
		onSearchButtonClicked: function() {
			var params = this.getFormValues();
			var errors = this.validate(params, true);
			if (errors != "") {
				EDR.util.alert(errors);
				return;
			}			
			dijit.byId(EDR.prefix+"searchManager").submitSearch(null, this.searchType, params);
//			dijit.byId(EDR.prefix+"advSearchTab").close();
		},
		
		onClearButtonClicked: function() {
			this.reset();
		},
		
		onNewSearchClicked: function() {
			this.searchType = "search";
		},
		
		onRefineSearchClicked: function() {
			this.searchType = "refineSearch";
		},
		
		onFromDateRangeClicked: function() {
			this.fromToDate.showPicker();
			this.toToDate.hidePicker();
		},
		
		onToDateRangeClicked: function() {
			this.toToDate.showPicker();
			this.fromToDate.hidePicker();
		},
		
		preLoad: function() {
			var overlay = EDR.ajax.Loading.setIsLoading(this.rightPane);
			overlay.style.top = "0px";
			overlay.style.left = "0px";
			overlay.style.width = "300px";
		},
		
		postLoad: function() {
			EDR.ajax.Loading.clearIsLoading(this.rightPane);
		},
		
		submitOnEnter: function(evt) {
			if (evt.keyCode == dojo.keys.ENTER) {
				this.onSearchButtonClicked();
			}
		},
		
		toggleSearchOptions: function(evt) {
			if (this.showOption) {
				this.showOption = false;
				dojo.style(this.leftPane, "width", this.leftPaneWidth + "px");
				dojo.style(this.domNode, "width", this.leftPaneWidth + "px");
				this.advButton.attr("label", "<span style='position:relative;top:-4px;'>" + this.show_options +
					(this.isLeftToRight() ?
						"</span><img src='"+this.imageBaseDir+"move-left23.png' alt='' style='position:relative;top:-1px;'/>" :
						"</span><img src='"+this.imageBaseDir+"move-right23.png' alt='' style='position:relative;top:-1px;'/>")
				);
				dojo.style(this.rightPane, "display", "none");
			} else {
				this.showOption = true;
				dojo.style(this.leftPane, "width", this.leftPaneWidthExpanded + "px");
				dojo.style(this.domNode, "width", this.leftPaneWidthExpanded + this.rightPaneWidth + 20 + "px");
				this.advButton.attr("label", "<span style='position:relative;top:-4px;'>" + this.hide_options + 
					(this.isLeftToRight() ?
						"</span><img src='"+this.imageBaseDir+"move-right23.png' alt='' style='position:relative;top:-1px;'/>" :
						"</span><img src='"+this.imageBaseDir+"move-left23.png' alt='' style='position:relative;top:-1px;'/>")
				);
				dojo.style(this.rightPane, "display", "block");
			}
/*			
			if (this.showOption) {
				var con = dojo.connect(this.slideTabContent, "afterOpen", dojo.hitch(this, function() {
					this.advOptions.load();
					if (dojo.isIE <= 7) {
						dojo.forEach(dijit.findWidgets(this.advOptions.domNode), function(widget) {
							if (widget.declaredClass == "widgets.Button") {
								widget.adjustButtonWidth();
							}
						});
					}
					dojo.disconnect(con);
				}));
			}*/
			this.slideTabContent.fitToContent(true);
		},
		
		getFormValues: function() {
			var params = dojo.formToObject(this.advancedSearchForm);
			if (this.showOption) {
				params = dojo.mixin(params, this.advOptions.getFormValues());
//				params.advancedSearchOptions = true; // move to ajax.js
			}
			return params;
		},
		
		validate: function(params, needKeywords) {
			var errors = "";
			if (needKeywords) {
				if ( (params.keywords == null || params.keywords == "") && 
					 (params.showResultsWithAllWords == null || params.showResultsWithAllWords == "") &&						
					 (params.showResultsWithPhrase == null || params.showResultsWithPhrase == "") &&						
					 (params.showResultsWithAnyWords == null || params.showResultsWithAnyWords == "") &&						
					 (params.showResultsWithNoneWords == null || params.showResultsWithNoneWords == "")	)
				{
					errors += EDR.messages.erros_noQueryTerms + "</br></br>";
	//				this.markFieldInvalid(this.keywordErr, EDR.messages.error_Search_invalid_param, this.keywords);
				}
			}
			
			var isValidDateFormat = false;
			if (!this.fromDate.isValid()) {
				errors += EDR.messages.error_Search_invalid_date + "</br></br>";
				this.markFieldInvalid(this.dateError, EDR.messages.error_Search_invalid_param, this.fromDateInput);
			} else if (!this.toDate.isValid()) {
				errors += EDR.messages.error_Search_invalid_date + "</br></br>";
				this.markFieldInvalid(this.dateError, EDR.messages.error_Search_invalid_param, this.toDateInput);
			} else {
				isValidDateFormat = true;
			}
			
			var hasBothDate = false;
			var fromDateIsEmpty = EDR.util.String.isWhitespace(this.fromDate.textbox.value);
			var toDateIsEmpty = EDR.util.String.isWhitespace(this.toDate.textbox.value);
			if (!fromDateIsEmpty && toDateIsEmpty) {
				errors += EDR.messages.error_Search_invalid_dateRange + "</br></br>";
				this.markFieldInvalid(this.dateError, EDR.messages.error_Search_invalid_param, this.toDate);
			} else if (fromDateIsEmpty && !toDateIsEmpty) {
				errors += EDR.messages.error_Search_invalid_dateRange + "</br></br>";
				this.markFieldInvalid(this.dateError, EDR.messages.error_Search_invalid_param, this.fromDate);
			} else if (!fromDateIsEmpty && !toDateIsEmpty) {
				hasBothDate = true;
			}
			
			if (isValidDateFormat && hasBothDate) {
				var fdate = this.fromDate.value;
				var tdate = this.toDate.value;
				if (fdate.getTime() > tdate.getTime()) {
					errors += EDR.messages.error_Search_invalid_dateRange_values + "</br></br>";
					this.markFieldInvalid(this.dateError, EDR.messages.error_Search_invalid_param, this.fromDateInput);
				}
			}			
			
			if (this.showOption) {
				errors += this.advOptions.getErrorMessage(params);
			}			
			return errors;
		},
		
		refresh: function() {
			if (this.showOption) {
				this.advOptions.load();
				if (dojo.isIE <= 7) {
					dojo.forEach(dijit.findWidgets(this.advOptions.domNode), function(widget) {
						if (widget.declaredClass == "widgets.Button") {
							widget.adjustButtonWidth();
						}
					});
				}
			}
		},
		
		reset: function() {
			this.searchType = "search";
			dojo.forEach(this._supportingWidgets, function(widget) {
				if (widget.reset) widget.reset();
			});
			this.clearError();
		},
		
		onKeyPress: function(evt) {
			if (evt.keyCode == dojo.keys.ENTER) {
				dijit.byId(EDR.prefix+"searchPane").submitSearch();
			}
		},
		
		clearError: function() {
			this.markFieldValid(this.dateError);
		},
		
		markFieldInvalid: function(errorDiv, errorMsg, input) {
			errorDiv.innerHTML = errorMsg;
			errorDiv.className = 'error';
			if (input) input.focus;
		},
		
		markFieldValid: function(errorDiv) {
			errorDiv.innerHTML = "";
			errorDiv.className = 'noError';
		},
		
		destroy: function() {
			dojo.forEach(this.handlers, dojo.disconnect);
			this.inherited("destroy", arguments);
		},
		
		// messages
		label_newsearch: EDR.messages.searchpane_newsearch,
		label_refinesearch: EDR.messages.searchpane_addsearch,
		label_search: EDR.messages.button_search,
		label_clear: EDR.messages.button_clear,
		label_advoptions_title: EDR.messages.label_advoptions_title,
		prompt_search: EDR.messages.prompt_search,
		prompt_searchOptions: EDR.messages.prompt_searchOptions,
		prompt_showResultsWith_allWords: EDR.messages.prompt_showResultsWith_allWords,
		prompt_showResultsWith_phrase: EDR.messages.prompt_showResultsWith_phrase,
		prompt_showResultsWith_anyWords: EDR.messages.prompt_showResultsWith_anyWords,
		prompt_showResultsWith_noneWords: EDR.messages.prompt_showResultsWith_noneWords,
		text_Search_dateStart: EDR.messages.text_Search_dateStart,
		text_Search_dateEnd: EDR.messages.text_Search_dateEnd,
		show_options: EDR.messages.button_advancedSearch_show,
		hide_options: EDR.messages.button_advancedSearch_hide,
		dateTooltip: "",// from jsp
		
		messages_tooltip_searchpane_newsearch_link: EDR.messages.tooltip_searchpane_newsearch_link,
		messages_tooltip_searchpane_addsearch_link: EDR.messages.tooltip_searchpane_addsearch_link,
		messages_tooltip_searchpane_search: EDR.messages.tooltip_searchpane_search,
		messages_tooltip_searchpane_clear: EDR.messages.tooltip_searchpane_clear,
		messages_tooltip_searchpane_showoptions_link: EDR.messages.tooltip_searchpane_showoptions_link,
		
		messages_tooltip_allWords: EDR.messages.tooltip_allWords,
		messages_tooltip_exactPhrase: EDR.messages.tooltip_exactPhrase,
		messages_tooltip_anyWords: EDR.messages.tooltip_anyWords,
		messages_tooltip_noneWords: EDR.messages.tooltip_noneWords,
		messages_tooltip_dateRange: EDR.messages.tooltip_dateRange
	}
);

}

if(!dojo._hasResource["widgets.ESBorderContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.ESBorderContainer"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.ESBorderContainer");


dojo.declare(
	"widgets.ESBorderContainer", [dijit.layout._LayoutWidget],	
	{
		postCreate: function(){
			this.inherited(arguments);
		},
		
		startup: function() {	
			this.queryContentPane = dijit.byId(EDR.prefix+"queryContentPane");
			this.contentPane = dijit.byId(EDR.prefix+"content");
			this.searchPane = dijit.byId(EDR.prefix+"searchPane");
			this.searchTabWindow = dijit.byId(EDR.prefix+"horizontalSearchPanes");
			this.headerHeight = dojo.marginBox(dojo.byId(EDR.prefix+"header")).h;
			this.slideTabContainer = dijit.byId(EDR.prefix+"slideTabContainer");
			this.body = dojo.body();
			this.inherited(arguments);
		},
		
		resize: function() {
			this.layout();
		},
		
		layout: function() {
			this.queryContentPane.resize();
			this.searchPane.resize();
			if (!this.searchPane.inAnimation) {
				var self = this;
				setTimeout(function() {
					if (!self.searchPane.inAnimation) {
						var queryHeight = dojo.marginBox(self.queryContentPane.domNode).h;
						if(!self.slideTabContainer.isOpen || EDR.isQueryAreaHidden){
							dojo.marginBox(self.contentPane.domNode, {h: dojo.marginBox(self.body).h - queryHeight - self.headerHeight - 9/*bottom*/});
							if (dojo.isIE) {
								self.body.style.overflow = "hidden";
							}
						}else if(dojo.isIE){
							self.body.style.overflow = "auto";
						}		
						dojo.marginBox(self.domNode, {h: dojo.marginBox(self.contentPane.domNode).h + queryHeight});
						self.searchTabWindow.resize();
					}
				}, 0);
			}
		},
		
		resizeCustomButtons: function() {
			// hack to avoid button layout problem in IE7.
			if (dojo.isIE <= 7) {
				dijit.registry.byClass("widgets.Button").forEach(function(widget){
					widget.adjustButtonWidth();
				});
			}
		}
	}
);

}

if(!dojo._hasResource["widgets.LayoutPreference"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.LayoutPreference"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.LayoutPreference");






/*
	LayoutConfiguration Object
	{
		searchPane: [
			"basicSearch",
			"advancedSearch"
			...
		],
		viewLayout: 2 // 1 - 4
	}
*/

dojo.declare(
	"widgets.LayoutPreference",
	[dijit._Widget, dijit._Templated],
	{
		cookieFieldName: "ESLayoutConfig",
		widgetsInTemplate: true,
		templateString:"<div style=\"padding:10px\">\n<div>\n<form>\n<fieldset dojoAttachPoint=\"viewLayoutGroup\" style=\"width:90%;border:1px solid black;padding:10px;\">\n<legend>Default View Layout</legend>\n<input type=\"radio\" name=\"vl\" value=\"1\" dojoType=\"dijit.form.RadioButton\"/>&nbsp;<label>Layout Type1</label><br/>\n<input type=\"radio\" name=\"vl\" value=\"2\" dojoType=\"dijit.form.RadioButton\" checked=\"checked\"/>&nbsp;<label>Layout Type2</label><br/>\n<input type=\"radio\" name=\"vl\" value=\"3\" dojoType=\"dijit.form.RadioButton\"/>&nbsp;<label>Layout Type3</label><br/>\n<input type=\"radio\" name=\"vl\" value=\"4\" dojoType=\"dijit.form.RadioButton\"/>&nbsp;<label>Layout Type4</label><br/>\n</fieldset>\n<br/>\n<fieldset dojoAttachPoint=\"searchPaneGroup\" style=\"width:90%;border:1px solid black;padding:10px;\">\n<legend>Search Pane</legend>\n<input type=\"checkbox\" name=\"sp\" value=\"basicSearchPane\" dojoType=\"dijit.form.CheckBox\" checked=\"checked\"/>&nbsp;<label>Basic Search</label><br/>\n<input type=\"checkbox\" name=\"sp\" value=\"advancedSearchPane\" dojoType=\"dijit.form.CheckBox\" checked=\"checked\"/>&nbsp;<label>Advanced Search</label><br/>\n<input type=\"checkbox\" name=\"sp\" value=\"facetSearchPane\" dojoType=\"dijit.form.CheckBox\" checked=\"checked\"/>&nbsp;<label>Facet</label><br/>\n<input type=\"checkbox\" name=\"sp\" value=\"dynamicFieldChartSearchPane\" dojoType=\"dijit.form.CheckBox\" checked=\"checked\"/>&nbsp;<label>Dynamic Field Chart</label><br/>\n<input type=\"checkbox\" name=\"sp\" value=\"fileSizeSearchPane\" dojoType=\"dijit.form.CheckBox\" checked=\"checked\"/>&nbsp;<label>File Size Chart</label><br/>\n</fieldset>\n</form>\n</div>\n</div>\n",
		
		postCreate: function() {
			this.inherited("postCreate", arguments);
			var config = this.loadFromCookie();
			if (config != null) this.loadConfig(config);
		},

		loadConfig: function(config) {
			var inputs = this.viewLayoutGroup.getElementsByTagName("INPUT");
			for (var i=0; i<inputs.length; i++) {
				if (inputs[i].value == config.viewLayout) {
					dijit.byId(inputs[i].id).setValue(true);
					break;
				}
			}
			
			inputs = this.searchPaneGroup.getElementsByTagName("INPUT");
			for (var i=0; i<inputs.length; i++) {
				for (var j=0; j<config.searchPane.length; j++) {				
					if (inputs[i].value == config.searchPane[j]) {
						dijit.byId(inputs[i].id).setValue(true);
						break;
					} else if (j == (config.searchPane.length - 1)) {
						dijit.byId(inputs[i].id).setValue(false);
					}
				}
			}
		},
		
		saveToCookie: function() {
			alert("Successfully Saved");
			dojo.cookie(this.cookieFieldName, dojo.toJson(this.getCurrentConfig()), {expires: 100}); 
		},
		
		loadFromCookie: function() {
			var config = dojo.fromJson(dojo.cookie(this.cookieFieldName)); 
			if (config != null) this.loadConfig(config);
		},
		
		apply: function() {
			var config = this.getCurrentConfig();
			dijit.byId(EDR.prefix+"tabSearchContent").loadViewConfiguration(config.viewLayout);				
			dijit.byId(EDR.prefix+"searchPane").loadViewConfiguration(config.searchPane);
		},
		
		getCurrentConfig: function() {
			var config = {};			
			var inputs = this.viewLayoutGroup.getElementsByTagName("INPUT");		
			for (var i=0; i<inputs.length; i++) {
				if (inputs[i].checked) {
					config['viewLayout'] = inputs[i].value;
				}
			}
			
			var array = [];
			inputs = this.searchPaneGroup.getElementsByTagName("INPUT");
			for (var i=0; i<inputs.length; i++) {
				if (inputs[i].checked) array.push(inputs[i].value);
			}
			config['searchPane'] = array;
			
			return config;
		}
	}
);

}

if(!dojo._hasResource["widgets.QueryText"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.QueryText"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.QueryText");




dojo.declare(
	"widgets.QueryText", [dijit._Widget, dijit._Templated],
	{		
		templateString:"<div style=\"padding:3px;width:100%;height:100%;\">\n\t<textarea dojoAttachPoint=\"textArea\" wrap=\"soft\" value=\"\" style=\"border:none;width:100%;height:100%;\">\n\t</textarea>\n</div>\n",
		handlers: [],
		
		imgBasePath: EDR.config.imageBaseDir,
		url: "",
				
		postCreate: function() {
			this.inherited("postCreate", arguments);
			this.setFullQuery("");
		},
		
		load: function() {
			this.preLoad();
			
			var self = this;
			var param = {		
		        url: self.url,
		        sync: false,
		        load: function(response, ioArgs) {
					var json = null;
					try {
						json = dojo.fromJson(response);
					} catch (e) {
			        	self.loadErrorHandler(response);
					}
					self.clear();
					self.loadSearchCriteria(json, self.domNode);	
					self.postLoad();					
		        },
		        error: function(response, ioArgs) {
		        	self.loadErrorHandler(response);
		        }
			};		
			dojo.xhrGet(param);
		},
		
		preLoad: function() {
		},
		
		postLoad: function() {
		},
		
		getFullQuery: function() {
			return this.textArea.value;
		},
		
		setFullQuery: function(fullQuery) {
			this.textArea.value = fullQuery;
		},
		
		submit: function() {
			dojo.byId(EDR.prefix+"keywords").value = this.getFullQuery();
			EDR.search.Form.submit();
		},
		
		loadSearchCriteria: function(json) {
			if (json == null) return;
			this.setFullQuery(json.fullQuery);
		},
		
		loadErrorHandler: function(response) {
			//console.debug(response);
		},
		
		clear: function() {
			this.setFullQuery("");
			dojo.forEach(this.handlers, dojo.disconnect);
		},
		
		destroy: function() {
			this.clear();
			this.inherited("destroy", arguments);
		}
	}
);

}

if(!dojo._hasResource["widgets.SearchManager"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.SearchManager"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.SearchManager");



dojo.declare(
	"widgets.SearchManager", [dijit._Widget],
	{				
		timeout: 60000,
		initErrorJson: {},
		isTextAnalyticsEnabled: false,
		collectionCounts: 0,
		query: "",
		view: "",
		facets: "",
		
		_closure: null,
		
		_heartBeatUrl : "search?action=touch",

		_searchResult: null,
		_numberOfDocs: 0,
		_columnDefs: null,

		_showFacets: true,
		_showTopResults: true,
			
		_heartBeat: function() {
			dojo.xhrGet({
				url: this._heartBeatUrl,
				error: dojo.hitch(this, "_heartBeatError"),
				timeout: dojo.hitch(this, "_heartBeatTimeout")
			});
		},
			
		_heartBeatError: function() {
		},
			
		_heartBeatTimeout: function() {
		},

		setShowFacets: function(show) {
			this._showFacets = show;
		},
		
		setShowTopResults: function(show) {
			this._showTopResults = show;
		},
		
		needNarrowResults: function() {
			if(this._searchResult == null) {
				return (this._showFacets || this._showTopResults);
			} else {
				if(this._searchResult.isFacetedSearch) {
					return this._showFacets;
				} else {
					return this._showTopResults;
				}
			}
		},
		
		getSearchResult: function() {
			return this._searchResult;
		},
		
		getColumnDefs: function() {
			return this._columnDefs;
		},
		
		setColumnDefs: function(defs) {
			this._columnDefs = defs;
		},
		
		postCreate: function() {
			this.inherited("postCreate", arguments);

//				dojo.subscribe("postLoad", this, "_showHideNarrowResults");
		},
		
		_showHideNarrowResults: function() {
			var searchPane = dijit.byId(EDR.prefix+"horizontalSearchPanes");
			var leftContentPane = searchPane.leftContentPane;
			var borderContainer = searchPane.resultsBodyContainer;
			var splitter = dojo._isBodyLtr() ? borderContainer._splitters["left"] : borderContainer._splitters["right"]; 
			if((this.needNarrowResults())&&(!EDR.isSmallPortletLayout)) {
					dojo.style(splitter,"display", "block");
					dojo.style(leftContentPane.domNode,"width","250px");
					dojo.style(leftContentPane.domNode,"visibility","visible");			
			} else {
					dojo.style(splitter,"display", "none");
					dojo.style(leftContentPane.domNode,"width","0px"); 
					dojo.style(leftContentPane.domNode,"visibility","hidden");			
			}
			borderContainer.layout();
			dijit.byId(EDR.prefix+"topBorderContainer").layout();
		},
		
		submitQuickRefineSearch: function(params) {
			if(this.isTextAnalyticsEnabled){
				var queryTree = dijit.byId(EDR.prefix+"queryTree");
				if(queryTree.getSelectedCell()!=null){
					params.queryTreeSelectionId = dojo.attr(queryTree.getSelectedCell(),"cellId");
				}
			}
			var args = 	{ 
				url: EDR.contextPath + "/search?action=refineSearch",
				progressText: EDR.messages.prompt_search_searching,
				successCallback: dojo.hitch(this, "processSearchResults"),
//				errorCallback: dojo.hitch(this, "handleSearchError"),
				timeout: this.timeout,
				content: params
			};
			EDR.ajax.Request.post(args);
			return false;
		},
		
		submitSavedSearch: function(params) {
			var docFilterValue = dijit.byId(EDR.prefix+"horizontalSearchPanes").resultToolbar.filterBySelectBox.attr("value");
			if(docFilterValue!="ALL"){
				params.doctypefilter=docFilterValue;
			}
			var resultsPerPageWidget = dijit.byId(EDR.prefix+"resultsPerPage");
			if(resultsPerPageWidget){
				params.resultsPerPage=resultsPerPageWidget.attr("value");
			}
			var args = 	{ 
				url: EDR.contextPath + "/search?action=" + "loadSavedSearch",
				progressText: EDR.messages.prompt_search_searching,
				successCallback: dojo.hitch(this, "processSearchResults"),
//				errorCallback: dojo.hitch(this, "handleSearchError"),
				timeout: this.timeout,
				content: params
			};
			EDR.ajax.Request.post(args);
			return false;
		},
		
		submitNextSearch: function() {
			var docFilterValue = dijit.byId(EDR.prefix+"horizontalSearchPanes").resultToolbar.filterBySelectBox.attr("value");
			var params = {};
			if(docFilterValue!="ALL"){
				params.doctypefilter=docFilterValue;
			}
			var resultsPerPageWidget = dijit.byId(EDR.prefix+"resultsPerPage");
			if(resultsPerPageWidget){
				params.resultsPerPage=resultsPerPageWidget.attr("value");
			}
			var args = 	{ 
				url: EDR.contextPath + "/search?action=" + "loadNextSearch",
				progressText: EDR.messages.prompt_search_searching,
				successCallback: dojo.hitch(this, "processSearchResults"),
//				errorCallback: dojo.hitch(this, "handleSearchError"),
				timeout: this.timeout,
				content: params
			};
			EDR.ajax.Request.post(args);
			return false;
		},

		submitPreviousSearch: function() {
			var docFilterValue = dijit.byId(EDR.prefix+"horizontalSearchPanes").resultToolbar.filterBySelectBox.attr("value");
			var params = {};
			if(docFilterValue!="ALL"){
				params.doctypefilter=docFilterValue;
			}
			var resultsPerPageWidget = dijit.byId(EDR.prefix+"resultsPerPage");
			if(resultsPerPageWidget){
				params.resultsPerPage=resultsPerPageWidget.attr("value");
			}
			var args = 	{ 
				url: EDR.contextPath + "/search?action=" + "loadPreviousSearch",
				progressText: EDR.messages.prompt_search_searching,
				successCallback: dojo.hitch(this, "processSearchResults"),
//				errorCallback: dojo.hitch(this, "handleSearchError"),
				timeout: this.timeout,
				content: params
			};
			EDR.ajax.Request.post(args);
			return false;
		},
		
		submitQuickKeywordSearch: function(keywords, closure, isInitial) {
			if(closure && dojo.isFunction(closure)) {
				this._closure = closure;
			}
			var params = { keywords: keywords };
			if(isInitial) {
				params["isInitial"] = true;
			}
			this.submitSearch(null, "search", params);
		},
		
		submitSearch: function(searchPane, type, params) {
			if(this.isTextAnalyticsEnabled){
				var queryTree = dijit.byId(EDR.prefix+"queryTree");
				if(queryTree.getSelectedCell()!=null){
					params.queryTreeSelectionId = dojo.attr(queryTree.getSelectedCell(),"cellId");
				}
			}
			
			var docFilterValue = dijit.byId(EDR.prefix+"horizontalSearchPanes").resultToolbar.filterBySelectBox.attr("value");
			if(docFilterValue!="ALL"){
				params.doctypefilter=docFilterValue;
			}
			var resultsPerPageWidget = dijit.byId(EDR.prefix+"resultsPerPage");
			if(resultsPerPageWidget){
				params.resultsPerPage=resultsPerPageWidget.attr("value");
			}
			var args = 	{ 
				url: EDR.contextPath + "/search?action=" + type,
				progressText: EDR.messages.prompt_search_searching,
				successCallback: dojo.hitch(this, "processSearchResults"),
//				errorCallback: dojo.hitch(this, "handleSearchError"),
				timeout: this.timeout,
				content: params
			};
			if(params.keywords == "") {
				args.showProgress = false;
			}
			EDR.ajax.Request.post(args);
			return false;
		},
		
		getResultColumnStringFromJson: function(columnObjArray){
			var length = columnObjArray.length;
			var columnStrArray = [];
			for(var i = 0 ; i<length ; i++){
				if(columnObjArray[i].show==true)
					columnStrArray.push(columnObjArray[i].name);
			}
			return columnStrArray;
		},				
		
		processSearchResults: function(response, ioArgs) {
			// publish pre load search results event
			dojo.publish("preLoad");
			try {
				this._searchResult = dojo.fromJson(response);
				if(EDR.isRestoreSessionResults && this._searchResult.fullQuery == "") {
					return;
				}
				EDR.isCategoryTreeEnabled = this._searchResult.isCategoryTreeEnabled;
				if(this._searchResult.allNumberOfResults >= 0) {
					this._numberOfDocs = this._searchResult.allNumberOfResults;
				}
				
				if(!this._columnDefs) {
					var defs = this.getResultColumnStringFromJson(this._searchResult.resultColumns.columns);
					this.setColumnDefs(defs);
				}					
			} catch(e) {
				alert(e);
			}
			// publish post load search results event			
			dojo.publish("postLoad");

			// publish refresh UI components event
			dojo.publish("refresh");
			
			// if closure exists, call it
			if(this._closure) {
				this._closure();
				this._closure = null;
			}
		},
				
		handleSearchError: function(response, ioArgs) {
			// publish Ajax error handling event
			dojo.publish("ajaxError", [response, ioArgs]);			
		},			

		destroy: function() {
			this.inherited("destroy", arguments);
		},

		removeTreeNode: function(searchPane, type, params) {
			var args = 	{ 
				url: EDR.contextPath + "/queryTree?action=" + type,
				progressText: EDR.messages.prompt_search_searching,
				successCallback: dojo.hitch(this, "processSearchResults"),
				timeout: this.timeout,
				content: params
			};
			EDR.ajax.Request.post(args);
			return false;
		}
		
		
	}
);

}

if(!dojo._hasResource["dijit.form.MultiSelect"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.MultiSelect"] = true;
dojo.provide("dijit.form.MultiSelect");



dojo.declare("dijit.form.MultiSelect", dijit.form._FormWidget, {
	// summary:
	//		Widget version of a <select multiple=true> element,
	//		for selecting multiple options.

	// size: Number
	//		Number of elements to display on a page
	//		NOTE: may be removed in version 2.0, since elements may have variable height;
	//		set the size via style="..." or CSS class names instead.
	size: 7,
	
	templateString: "<select multiple='true' ${nameAttrSetting} dojoAttachPoint='containerNode,focusNode' dojoAttachEvent='onchange: _onChange'></select>",

	attributeMap: dojo.delegate(dijit.form._FormWidget.prototype.attributeMap, {
		size: "focusNode"
	}),

	reset: function(){
		// summary:
		//		Reset the widget's value to what it was at initialization time

		// TODO: once we inherit from FormValueWidget this won't be needed
		this._hasBeenBlurred = false;
		this._setValueAttr(this._resetValue, true);
	},

	addSelected: function(/* dijit.form.MultiSelect */ select){
		// summary:
		//		Move the selected nodes of a passed Select widget
		//		instance to this Select widget.
		//
		// example:
		// |	// move all the selected values from "bar" to "foo"
		// | 	dijit.byId("foo").addSelected(dijit.byId("bar"));
		
		select.getSelected().forEach(function(n){
			this.containerNode.appendChild(n);
			// scroll to bottom to see item
			// cannot use scrollIntoView since <option> tags don't support all attributes
			// does not work on IE due to a bug where <select> always shows scrollTop = 0
			this.domNode.scrollTop = this.domNode.offsetHeight; // overshoot will be ignored
			// scrolling the source select is trickier esp. on safari who forgets to change the scrollbar size
			var oldscroll = select.domNode.scrollTop;
			select.domNode.scrollTop = 0;
			select.domNode.scrollTop = oldscroll;
		},this);
	},
					
	getSelected: function(){
		// summary:
		//		Access the NodeList of the selected options directly
		return dojo.query("option",this.containerNode).filter(function(n){
			return n.selected; // Boolean
		}); // dojo.NodeList
	},
	
	_getValueAttr: function(){
		// summary:
		//		Hook so attr('value') works.
		// description:
		//		Returns an array of the selected options' values.
		return this.getSelected().map(function(n){
			return n.value;
		});
	},
	
	_multiValue: true, // for Form

	_setValueAttr: function(/* Array */values){
		// summary:
		//		Hook so attr('value', values) works.
		// description:
		//		Set the value(s) of this Select based on passed values
		dojo.query("option",this.containerNode).forEach(function(n){
			n.selected = (dojo.indexOf(values,n.value) != -1);
		});
	},
		
	invertSelection: function(onChange){
		// summary:
		//		Invert the selection
		// onChange: Boolean
		//		If null, onChange is not fired.
		dojo.query("option",this.containerNode).forEach(function(n){
			n.selected = !n.selected;
		});
		this._handleOnChange(this.attr('value'), onChange==true);
	},

	_onChange: function(/*Event*/ e){
		this._handleOnChange(this.attr('value'), true);
	},
	
	// for layout widgets:
	resize: function(/* Object */size){
		if(size){
			dojo.marginBox(this.domNode, size);
		}
	},
	
	postCreate: function(){
		this._onChange();
	}
});

}

if(!dojo._hasResource["widgets.MultiSelection"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.MultiSelection"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.MultiSelection");





dojo.declare(
	"widgets.MultiSelection", [dijit._Widget, dijit._Templated],
	{				
		prefix: EDR.prefix,
		widgetsInTemplate: true,
		templateString:"<div>\n\t<div style=\"float:left;\" role=\"presentation\">\n\t\t<label tabindex=\"0\" dojoAttachPoint=\"availableListLabel\" for=\"${prefix}availableListInput\">${availableTitle}</label><br>\n\t\t<select tabindex=\"0\" dojoType=\"dijit.form.MultiSelect\" dojoAttachPoint=\"availableList\" id=\"${prefix}availableListInput\"\n\t\t\tmultiple=\"true\" size=\"7\" name=\"availableList\">\n\t\t</select>\n\t</div>\n\t<div dojoAttachPoint=\"btnContainer\" style=\"float:left;width:72px;padding-top:100px;\" role=\"presentation\">\n\t\t<span>\n\t\t\t<button tabindex=\"0\" dojoAttachPoint=\"leftBtn\" title=\"${addBtnTitle}\">&lt;</button>\n\t\t\t<button tabindex=\"0\" dojoAttachPoint=\"rightBtn\" title=\"${removeBtnTitle}\">&gt;</button>\n\t\t</span>\n\t</div>\t\n\t<div style=\"float:left;\" role=\"presentation\">\n\t\t<label tabindex=\"0\" dojoAttachPoint=\"selectedListLabel\" for=\"${prefix}selectedListInput\">${selectedTitle}</label><br>\n\t\t<select tabindex=\"0\" dojoType=\"dijit.form.MultiSelect\" dojoAttachPoint=\"selectedList\" id=\"${prefix}selectedListInput\"\n\t\t\tmultiple=\"true\" name=\"selectedList\">\t\n\t\t</select>\n\t</div>\n</div>\n",
		handlers: [],

		available: null,
		selected: null,
		
		// options parameters
		options: [],
		
		// resources
		availableTitle: EDR.messages.label_candidates,
		selectedTitle: EDR.messages.label_applied,
		addBtnTitle: "",
		removeBtnTitle: "",
				
		postCreate: function() {
			this.inherited("postCreate", arguments);

			//this.available = dijit.byId("availableList");
			this.available = this.availableList;
			this.selected = this.selectedList;
			
			var size = dojo.contentBox(this.domNode);
			var box = {
				w: (size.w - 72) / 2,
				h: (size.h - 20)
			}
			dojo.marginBox(this.available.domNode, box);
			dojo.marginBox(this.selected.domNode, box);
			dojo.style(this.btnContainer, "paddingTop", size.h * 0.4);
					
			this.handlers.push(dojo.connect(this.leftBtn, "onclick", this, "remove"));
			this.handlers.push(dojo.connect(this.rightBtn, "onclick", this, "add"));
		},
		
		add: function() {
			this.available.getSelected().forEach(function(opt){
				for (var i=0; i<this.options.length; i++) {
					if (opt.value == this.options[i].value) {
						this.options[i].selected = true;
						break;
					}
				}
			}, this);
			this.buildOptions();
		},
		
		remove: function() {
			this.selected.getSelected().forEach(function(opt){
				for (var i=0; i<this.options.length; i++) {
					if (opt.value == this.options[i].value) {
						this.options[i].selected = false;
						break;
					}
				}
			}, this);
			this.buildOptions();
		},
		
		buildOptions: function() {
			this.clearOptions();
			
			var options = this.options;
			if (options == null || options.length == 0) return;
			for (var i=0; i<options.length; i++) {
				var option = dojo.doc.createElement("OPTION");
				option.innerHTML = options[i].label;
				option.label = options[i].label;
				option.title = options[i].label;
				option.value = options[i].value;
				
				if (options[i].selected)
					this.selected.domNode.appendChild(option);
				else
					this.available.domNode.appendChild(option);
			}
		},
		
		clearOptions: function() {
			this.selected.domNode.innerHTML = "";
			this.available.domNode.innerHTML = "";
		},
		
		destroy: function() {
			dojo.forEach(this.handlers, dojo.disconnect);
			this.inherited("destroy", arguments);
		}
	}
);

}

if(!dojo._hasResource["widgets.SearchOptions"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.SearchOptions"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.SearchOptions");











dojo.declare(
	"widgets.SearchOptions", [dijit._Widget, dijit._Templated],
	{				
		prefix: EDR.prefix,
		imgBasePath: EDR.config.imageBaseDir,
		widgetsInTemplate: true,
		
		templateString:"<div style=\"overflow-y: auto; overflow-x: hidden;\">\n\t<form dojoAttachPoint=\"serchOptionsForm\"\n\t\tstyle=\"width:100%;\" onSubmit=\"return false;\"><!-- collection -->\n\t\t<div style=\"margin-top: 5px; margin-left:5px; margin-bottom: 10px;\" role=\"radiogroup\">\n\t\t\t<div style=\"margin-bottom: 5px;\">\n\t\t\t\t<label dojoAttachPoint=\"introLabel\">${search_options_intro}${search_options_intro2}</label>\n\t\t\t\t<a href=\"javascript:;\"\n\t\t\t\t\tonclick=\"EDR.viewHelp('iiysulcollext.htm?noframes=true')\"> <img\n\t\t\t\t\tsrc=\"${imgBasePath}help_16.png\" alt=\"${collection_embedded_help}\" title=\"${collection_embedded_help}\"\n\t\t\t\t\tstyle=\"vertical-align: top;\" /></a>\n\t\t\t</div>\n\t\t\t<div style=\"margin-bottom: 5px;\">\n\t\t\t\t<input id=\"${prefix}${id}-facetCollection\" dojoType=\"dijit.form.RadioButton\" value=\"facet\" name=\"searchMode\"></input>\n\t\t\t\t&nbsp;<label for=\"${prefix}${id}-facetCollection\">${label_facetcollection}</label>\n\t\t\t</div>\n\t\t\t<div dojoAttachPoint=\"facetContainer\" style=\"margin-left: 10px; margin-bottom: 5px;\" role=\"radiogroup\"></div>\n\t\t\t<div dojoAttachPoint=\"noFacetContainer\"\n\t\t\t\tstyle=\"margin-left: 10px; margin-bottom: 5px;\"><label\n\t\t\t\tfor=\"federatorCollection\">${label_nofacet}</label></div>\n\t\t\t<div style=\"margin-bottom: 5px;\" dojoAttachPoint=\"federatorMessages\">\n\t\t\t\t<input id=\"${prefix}${id}-federatorCollection\" checked=\"true\"\n\t\t\t\tdojoType=\"dijit.form.RadioButton\" value=\"federator\" name=\"searchMode\"></input>\n\t\t\t\t&nbsp;<label for=\"${prefix}${id}-federatorCollection\">${label_collection}</label>\n\t\t\t</div>\n\t\t\t<div dojoAttachPoint=\"federatorContainer\"\n\t\t\t\tstyle=\"margin-left: 10px; margin-bottom: 5px;\"></div>\n\t\t\t<div dojoAttachPoint=\"noFederatorContainer\"\n\t\t\t\tstyle=\"margin-left: 10px; margin-bottom: 5px;\"><label>${label_nofederator}</label>\n\t\t\t</div>\n\t\t</div>\n\t\t\n\t\t<hr style=\"width: 100%; clear: both;\" />\n\t\t\n\t\t<!-- source -->\n\t\t<div style=\"margin-left:5px;margin-bottom: 10px;\">\n\t\t\t<div>\n\t\t\t\t<div style=\" margin-left:5px;margin-bottom: 5px;\"><label\n\t\t\t\t\ttitle=\"${tooltip_documentsource}\">${label_source_specific}:</label> <img\n\t\t\t\t\tstyle=\"display: none\" src=\"${imgBasePath}/status_indicator_20_slow.gif\" alt=\"${splash_loading}\">\n\t\t\t\t</div>\n\t\t\t\t<div dojoAttachPoint=\"sourceContainer\"></div>\n\t\t\t\t<div dojoAttachPoint=\"noSourceContainer\"><label\n\t\t\t\t\ttitle=\"${tooltip_documentsource}\">${label_nosource}</label>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t\t\n\t\t<!-- file -->\n\t\t<div style=\" margin-left:5px;margin-bottom: 10px;\" role=\"radiogroup\">\n\t\t\t<div style=\"margin-bottom: 5px;\"><label\n\t\t\t\ttitle=\"${tooltip_documenttypes}\">${label_file}:</label> <img\n\t\t\t\tstyle=\"display: none\" src=\"${imgBasePath}/status_indicator_20_slow.gif\" alt=\"${splash_loading}\">\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<input id=\"${prefix}${id}-fileAll\" dojoType=\"dijit.form.RadioButton\"\n\t\t\t\t\tvalue=\"all\" name=\"filetype\"></input> &nbsp;<label for=\"${prefix}${id}-fileAll\"\n\t\t\t\t\ttitle=\"${tooltip_documenttypes}\">${label_file_all}</label>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<input id=\"${prefix}${id}-fileSpecific\" dojoType=\"dijit.form.RadioButton\" value=\"any\" name=\"filetype\"></input>\n\t\t\t\t&nbsp;<label for=\"${prefix}${id}-fileSpecific\" title=\"${tooltip_documenttypes}\">${label_file_specific}:</label>\n\t\t\t\t<input dojoType=\"widgets.Button\" title=\"${tooltip_documenttypes}\"\n\t\t\t\t\tlabel=\"${button_select}\"></input></div>\n\t\t</div>\n\t\t\n\t\t<hr style=\"width: 100%; clear: both;\" />\n\t\t\n\t\t<!-- lang -->\n\t\t<div style=\"margin-left:5px;margin-bottom: 10px;\" role=\"radiogroup\">\n\t\t\t<div style=\"margin-bottom: 5px;\">\n\t\t\t\t<label title=\"${tooltip_languages}\">${label_lang}:</label> <img\n\t\t\t\tstyle=\"display: none\" src=\"${imgBasePath}/status_indicator_20_slow.gif\" alt=\"${splash_loading}\">\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<input id=\"${prefix}${id}-langAll\" dojoType=\"dijit.form.RadioButton\"\n\t\t\t\tvalue=\"all\" name=langtype></input> &nbsp;<label for=\"${prefix}${id}-langAll\"\n\t\t\t\ttitle=\"${tooltip_languages}\">${label_lang_all}</label>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<input id=\"${prefix}${id}-langSpecific\" dojoType=\"dijit.form.RadioButton\" value=\"any\" name=\"langtype\"></input>\n\t\t\t\t&nbsp;<label for=\"${prefix}${id}-langSpecific\" title=\"${tooltip_languages}\">${label_lang_specific}:</label>\n\t\t\t\t<input dojoType=\"widgets.Button\" title=\"${tooltip_languages}\"\n\t\t\t\t\tlabel=\"${button_select}\"></input>\n\t\t\t</div>\n\t\t</div>\n\t\t\n\t\t<!-- scope -->\n\t\t<div style=\"margin-left:5px;margin-bottom: 10px;\">\n\t\t\t<div>\n\t\t\t\t<div style=\"margin-bottom: 5px;\"><label title=\"${tooltip_scopes}\">${label_scope}:</label>\n\t\t\t\t<img style=\"display: none\" src=\"${imgBasePath}/status_indicator_20_slow.gif\" alt=\"${splash_loading}\">\n\t\t\t\t</div>\n\t\t\t\t<div dojoAttachPoint=\"scopeContainer\"></div>\n\t\t\t\t<div dojoAttachPoint=\"noScopeContainer\"><label>${label_noscope}</label></div>\n\t\t\t</div>\n\t\t</div>\n\t</form>\n</div>\n",
		dialog: null,
		handlers: [],
		_autoLoad: false,
		isAdvancedSearchOption: false,
		
		colspan: 4,
		url: "",
		partialLoadUrl: "",
		json: null,		
		
		postCreate: function() {
			this.inherited("postCreate", arguments);
			this.handlers = [];
			
			this.facet = this._supportingWidgets[0];
			this.federator = this._supportingWidgets[1];
			this.fileAll = this._supportingWidgets[2];
			this.fileSpecify = this._supportingWidgets[3];
			this.fileTypeBtn = this._supportingWidgets[4];
			this.langAll = this._supportingWidgets[5];
			this.langSpecify = this._supportingWidgets[6];
			this.langBtn = this._supportingWidgets[7];
			
			if (EDR.isTextAnalyticsEnabled) {
				dojo.style(this.federatorContainer, "display", "none");
				dojo.style(this.noFederatorContainer, "display", "none");
				dojo.style(this.federatorMessages, "display", "none");
				dojo.style(this.facet.domNode, "display", "none");
			}
						
			if (this._autoLoad) this.load();
		},		

		onCollectionChanged: function(evt) {
			this.partialLoad();
		},

		load: function() {
			this.preLoad();					
			var args = 	{ 
				url: this.url,
				successCallback: dojo.hitch(this, function(response, ioArgs) {
					var json = null;
					try {
						json = dojo.fromJson(response);
					} catch (e) {
			        	this.loadErrorHandler(response, ioArgs);
			        	return;
					}
					this.clear();
					this.loadJson(json);	
					this.postLoad();					
				}),
				afterErrorHandlerCallback: dojo.hitch(this, function(response, ioArgs) {
					this.loadErrorHandler(response, ioArgs);
				}),
				showProgress: false
			};
			EDR.ajax.Request.post(args);
		},
		
		partialLoad: function() {
			if (this.isAdvancedSearchOption) {
				this.preLoad();
				var params = this.getFormValues();		
				var args = 	{ 
					url: this.url,
					successCallback: dojo.hitch(this, function(response, ioArgs) {
						var json = null;
						try {
							json = dojo.fromJson(response);
						} catch (e) {
				        	this.loadErrorHandler(response, ioArgs);
				        	return;
						}
						this.clear();
						this.loadJson(json);	
						this.postLoad();					
					}),
					afterErrorHandlerCallback: dojo.hitch(this, function(response, ioArgs) {
						this.partialLoadErrorHandler(response, ioArgs);
					}),
					timeout: this.timeout,
					content: params,
					showProgress: false
				};
				EDR.ajax.Request.post(args);
			} else {
				dijit.byId(EDR.prefix+"preference").changeCollection();
			}
		},
		
		loadJson: function(json) {
			if (json == null) json = this._getNullSearchOptions();
			this.json = json;
			this.buildOptions();
		},
		
		preLoad: function() {
//			EDR.ajax.Loading.setIsLoading(this.domNode);
		},
		
		postLoad: function() {
//			EDR.ajax.Loading.clearIsLoading(this.domNode);
		},
		
		partialPreLoad: function() {
			dojo.forEach(this.domNode.getElementsByTagName("IMG"), function(img) {
				if (img.src.indexOf("status_indicator_20_slow.gif") != -1)
					img.style.display = "";
			});
		},
		
		partialPostLoad: function() {
			dojo.forEach(this.domNode.getElementsByTagName("IMG"), function(img) {
				if (img.src.indexOf("status_indicator_20_slow.gif") != -1)
					img.style.display = "none";
			});
		},
		
		loadErrorHandler: function() {
		},
		
		partialLoadErrorHandler: function() {
			this.partialPostLoad();
		},
				
		getFormValues: function() {
			var values = dojo.formToObject(this.serchOptionsForm);			
			values.documentSourcesAll = dojo.every(dijit.findWidgets(this.sourceContainer), function(widget) {
				return widget.attr("checked");
			});
			if (values.filetype == "all") {
				values.documentTypesAll = true;
			} else {
				values.documentTypesAll = false;
				values.documentTypes = this._getSelectedItemIds(this.json.filetypes.items);
//				if (values.documentTypes.length == 0) values.documentTypesAll = true;
			}
			if (values.langtype == "all") {
				values.languagesAll = true;
			} else {
				values.languagesAll = false;
				values.languages = this._getSelectedItemIds(this.json.languages.items);
//				if (values.languages.length == 0) values.languagesAll = true;
			}
			values.isFacetedSearch = values.searchMode == "facet";
			if (values.scopes == null) values["scopes"] = "";
			return values;
		},
		
		validate: function(params) {
			var errors = "";
			if (!params.isFacetedSearch && (params.collections == null || params.collections.length == null)) {
				errors += this.error_nocollection + "<br/><br/>";
			}
			if (this.json.sourcetypes.length > 0 && (params.documentSources == null || params.documentSources.length == 0)) {
				errors += this.error_nosourcetypes + "<br/><br/>";
			}
			if (errors != "") {
				EDR.util.alert(errors);
				return false;
			}			
			return true;
		},
		
		getErrorMessage: function(params) {
			var errors = "";
			if (!params.isFacetedSearch && (params.collections == null || params.collections.length == null)) {
				errors += this.error_nocollection + "<br/><br/>";
			}
			if (this.json.sourcetypes.length > 0 && (params.documentSources == null || params.documentSources.length == 0)) {
				errors += this.error_nosourcetypes + "<br/><br/>";
			}
			return errors;
		},
		
		buildOptions: function() {
			if (this.json == null) return;			
			this.clear();			
			this.buildCollections();
			this.buildScopes();
			this.buildSourceTypes();
			this.buildFileTypes();
			this.buildLanguages();			
		},
		
		buildCollections: function() {
			this._buildRadioBoxList(this.json.facetCollections, "facetedCollection", this.facetContainer, "onCollectionChanged");
			if (!EDR.isTextAnalyticsEnabled) this._buildCheckBoxList(this.json.collections, "collections", this.federatorContainer);
			
			if (this.json.isFacetedSearch) {
				this.facet.attr("checked", true);
				this.disableFederatorCollections(true);
			} else {
				this.federator.attr("checked", true);
				this.disableFacetCollections(true);
			}

			var noFacet = this.json.facetCollections.length == 0;
			dojo.style(this.facetContainer, "display", noFacet ? "none" : "block");
			dojo.style(this.noFacetContainer, "display", noFacet ? "block" : "none");

			if (!EDR.isTextAnalyticsEnabled) {
				var noFederator = this.json.collections.length == 0;
				dojo.style(this.federatorContainer, "display", noFederator ? "none" : "block");
				dojo.style(this.noFederatorContainer, "display", noFederator ? "block" : "none");
			}
			
			var selectFacet = function() {
				this.json.isFacetedSearch = true;
				this.disableFacetCollections(false);
				this.disableFederatorCollections(true);
				this.onCollectionChanged();
			};
			
			var selectFederator = function() {
				this.json.isFacetedSearch = false;
				this.disableFacetCollections(true);
				this.disableFederatorCollections(false);
				this.onCollectionChanged();
			};
	
			this.handlers.push(dojo.connect(this.facet, "onClick", this, selectFacet));
			this.handlers.push(dojo.connect(this.federator, "onClick", this, selectFederator));
		},
				
		buildSourceTypes: function() {
			this._buildCheckBoxList(this.json.sourcetypes, "documentSources", this.sourceContainer, true);
			var noSource = this.json.sourcetypes.length == 0;
			dojo.style(this.sourceContainer, "display", noSource ? "none" : "block");
			dojo.style(this.noSourceContainer, "display", noSource ? "block" : "none");
		},
		
		buildFileTypes: function() {
			if (this.json.filetypes.all) {
				this.fileAll.attr("checked", true);
				this.fileTypeBtn.setDisabled(true);
			} else {
				this.fileSpecify.attr("checked", true);
				this.fileTypeBtn.setDisabled(false);
			}
			
			selectFileAll = function() {
				this.json.filetypes.all = true;
				this.fileTypeBtn.setDisabled(true);
			}
			
			selectFileSpecify = function() {
				this.json.filetypes.all = false;
				this.fileTypeBtn.setDisabled(false);
			},
			
			showFileTypeSelection = function() {
				var dialog = this._getMultiSelectDialog();
				dialog.titleTextNode.innerHTML = this.label_file;
				
				// close items
				var fileTypes = dojo.clone(this.json.filetypes);
				dialog.multiSelection.options = fileTypes.items;
				dialog.multiSelection.buildOptions();
				
				var self = this;
				var handlers = [];
				handlers.push(dojo.connect(dialog.okButtonNode, "onClick", function() {
					dojo.forEach(handlers, dojo.disconnect);						
					self.json.filetypes.items = dialog.multiSelection.options;
					//EDR.dialog.util.hide(dialog);
				}));
				handlers.push(dojo.connect(dialog.cancelButtonNode, "onClick", function() {
					dojo.forEach(handlers, dojo.disconnect);						
				}));
										
				EDR.dialog.util.show(dialog);
			}
		
			this.handlers.push(dojo.connect(this.fileAll, "onClick", this, selectFileAll));
			this.handlers.push(dojo.connect(this.fileSpecify, "onClick", this, selectFileSpecify));
			this.handlers.push(dojo.connect(this.fileTypeBtn, "onClick", this, showFileTypeSelection));
		},
		
		buildLanguages: function() {
			if (this.json.languages.all) {
				this.langAll.attr("checked", true);
				this.langBtn.setDisabled(true);
			} else {
				this.langSpecify.attr("checked", true);
				this.langBtn.setDisabled(false);
			}
			
			selectLangAll = function() {
				this.json.languages.all = true;
				this.langBtn.setDisabled(true);
			}
			
			selectLangSpecify = function() {
				this.json.languages.all = false;
				this.langBtn.setDisabled(false);
			}
			
			showLanguageSelection = function() {
				var dialog = this._getMultiSelectDialog();
				dialog.titleTextNode.innerHTML = this.label_lang;
				
				// close items
				var languages = dojo.clone(this.json.languages);
				dialog.multiSelection.options = languages.items;
				dialog.multiSelection.buildOptions();
				
				var self = this;
				var handlers = [];
				handlers.push(dojo.connect(dialog.okButtonNode, "onClick", function() {
					dojo.forEach(handlers, dojo.disconnect);						
					self.json.languages.items = dialog.multiSelection.options;
					//EDR.dialog.util.hide(dialog);
				}));
				handlers.push(dojo.connect(dialog.cancelButtonNode, "onClick", function() {
					dojo.forEach(handlers, dojo.disconnect);
				}));
		
				EDR.dialog.util.show(dialog);
			}
		
			this.handlers.push(dojo.connect(this.langAll, "onClick", this, selectLangAll));
			this.handlers.push(dojo.connect(this.langSpecify, "onClick", this, selectLangSpecify));
			this.handlers.push(dojo.connect(this.langBtn, "onClick", this, showLanguageSelection));
		},
		
		buildScopes: function() {
			this._buildCheckBoxList(this.json.scopes, "scopes", this.scopeContainer);
			var noScope = this.json.scopes.length == 0;
			dojo.style(this.scopeContainer, "display", noScope ? "none" : "block");
			dojo.style(this.noScopeContainer, "display", noScope ? "block" : "none");
		},
				
		clear: function() {
			dojo.forEach(this.handlers, dojo.disconnect);
			dojo.forEach(dijit.findWidgets(this.facetContainer), function(widget) {
				widget.destroy();
			});
			dojo.forEach(dijit.findWidgets(this.federatorContainer), function(widget) {
				widget.destroy();
			});
			dojo.forEach(dijit.findWidgets(this.sourceContainer), function(widget) {
				widget.destroy();
			});
			dojo.forEach(dijit.findWidgets(this.scopeContainer), function(widget) {
				widget.destroy();
			});
			dojo.empty(this.facetContainer);
			dojo.empty(this.federatorContainer);
			dojo.empty(this.scopeContainer);
			dojo.empty(this.sourceContainer);
		},
		
		_getSelectedItemIds: function(items) {
			var array = [];
			for (var i=0; i<items.length; i++) {
				if (items[i].selected) array.push(items[i].value);
			}
			return array;
		},
		
		_getMultiSelectDialog: function() {
			if (this.dialog == null) {
				this.dialog = dijit.byId(EDR.prefix+"multiSelectDlg");
			}
			return this.dialog;
		},
				
		_buildCheckBoxList: function(candidates, name, parent, sourceTypeIcon) {
			var array = [];
			for (var i=0; i<candidates.length; i++) {
				var item = candidates[i];
				var chkboxContainer = dojo.create("div", {}, parent);
				var params = {id:this.prefix+this.id + "-" + name + "-" + i, name: name, value: item.value};
				var chkbox = new dijit.form.CheckBox(params);
				array.push(chkbox);
				chkboxContainer.appendChild(chkbox.domNode);
				chkbox.attr('checked', item.selected);
				if (sourceTypeIcon) this._buildSourceTypeIcon(item.value, chkboxContainer);
				dojo.create("label", {"for":this.prefix+this.id + "-" + name + "-" + i, innerHTML: item.label}, chkboxContainer);
			}
			return array;
		},
		
		_buildSourceTypeIcon: function(documentSource, parent) {
			var sourceTypeString = EDR.messages[documentSource + "_tooltip"];
			if(sourceTypeString == null) {
				sourceTypeString = EDR.messages.seedlist_tooltip;
			}
			var iconPath = EDR.config["documentSource_" + documentSource.toLowerCase() + "_icon"];
			if(iconPath == null) {
				iconPath = EDR.config.documentSource_default_icon;
			}
			iconPath = EDR.contextPath + iconPath;
			return dojo.create("img", {src: iconPath, alt:"", style:"vertical-align:bottom;margin-left:5px;margin-right:5px;"}, parent);
		},
		
		_buildRadioBoxList: function(candidates, name, parent, clickEvtHandler) {
			var array = [];
			for (var i=0; i<candidates.length; i++) {
				var item = candidates[i];
				var radioContainer = dojo.create("div", {}, parent);
				var params = {id:this.prefix+this.id + "-" + name + "-" + i, name: name, value: item.value};
				var radio = new dijit.form.RadioButton(params);
				if (clickEvtHandler != null) {
					this.handlers.push(dojo.connect(radio, "onClick", this, clickEvtHandler));
				}
				array.push(radio);
				radioContainer.appendChild(radio.domNode);
				radio.attr('checked', item.selected);
				dojo.create("label", {"for":this.prefix+this.id + "-" + name + "-" + i, innerHTML: item.label}, radioContainer);
			}
			return array;
		},
		
		disableFacetCollections: function(disable) {
			dojo.forEach(dijit.findWidgets(this.facetContainer), function(widget) {
				widget.setDisabled(disable);
			});
			dojo.forEach(this.facetContainer.getElementsByTagName("LABEL"), function(label) {
				label.style.color = disable ? "gray" : "black";
			});
		},
		
		disableFederatorCollections: function(disable) {
			dojo.forEach(dijit.findWidgets(this.federatorContainer), function(widget) {
				widget.setDisabled(disable);
			});
			dojo.forEach(this.federatorContainer.getElementsByTagName("LABEL"), function(label) {
				label.style.color = disable ? "gray" : "black";
			});
		},
		
		setAdvancedSearchOptions: function() {
			this.isAdvancedSearchOption = true;
			this.url = EDR.contextPath + "/preferences?action=getAdvancedSearchOptions";
			this.partialLoadUrl = EDR.contextPath + "/preferences?action=getAdvancedSearchOptions";
			if (dojo.isFF) {
				this.introLabel.innerHTML = this.search_options_intro;
			} else {
				this.introLabel.innerText = this.search_options_intro;
			}
		},
		
		_getNullSearchOptions: function() {
			return {
				isFaceteSearch: false,
				facetCollections: [],
				collections: [],
				scopes: [],
				sourcetypes: [], 
				filetypes: { all: true, items:[] },
				languages: { all: true, items:[] }
			};
		},
				
		destroy: function() {
			dojo.forEach(this.handlers, dojo.disconnect);
			this.inherited("destroy", arguments);
		},
		
		// messages
		tooltip_advancedSearch: EDR.messages.tooltip_advancedSearch,
		collection_embedded_help: EDR.messages.tooltip_help_collection,
		button_select: EDR.messages.button_select,
		search_options_intro: EDR.messages.search_options_intro,
		search_options_intro2: EDR.isAuthorized ? EDR.messages.search_options_intro_authorized : EDR.messages.search_options_intro_unauthorized,
		tooltip_documentsource: EDR.messages.tooltip_documentsources,
		tooltip_documenttypes: EDR.messages.tooltip_documenttypes,
		tooltip_languages: EDR.messages.tooltip_languages,
		tooltip_scopes: EDR.messages.tooltip_scopes,
		label_collection: EDR.messages.label_collection,
		label_facetcollection: EDR.messages.label_facetcollection,
		label_nofacet: EDR.messages.label_nofacet,
		label_nofederator: EDR.messages.label_nofederator,
		label_scope: EDR.messages.label_scope,
		label_noscope: EDR.messages.label_noscope,
		label_scope_title: "",//EDR.messages.label_scope_title,
		label_source: EDR.messages.label_source,
		label_nosource: "",
		label_source_all: EDR.messages.label_source_all,
		label_source_specific: EDR.messages.label_source_specific,
		label_file: EDR.messages.label_file,
		label_file_all: EDR.messages.label_file_all,
		label_file_specific: EDR.messages.label_file_specific,
		label_lang: EDR.messages.label_lang,
		label_lang_all: EDR.messages.label_lang_all,
		label_lang_specific: EDR.messages.label_lang_specific,
		error_nocollection: EDR.messages.error_nocollection,
		error_nosourcetypes: EDR.messages.error_nosourcetypes,
		splash_loading: EDR.messages.splash_loading
	}
);

}

if(!dojo._hasResource["widgets.PreferencesDialog"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.PreferencesDialog"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.PreferencesDialog");




/*
 * This class was created so that we could have a common look-and-feel
 * for all dialogs in the product.  This should be used instead of 
 * dijit.Dialog.  It also adds a property to the standard dijit.Dialog
 * class called isClosable.  Setting this property to false when the 
 * dialog is declared in HTML will prevent the close button from appearing
 * in the title bar.
 */
dojo.declare(
	"widgets.PreferencesDialog", [widgets.customDialog],
	{		
		url: "",
		saveUrl: "",
		saveAdvUrl: "",
		_autoLoad: false,
		timeout: 60000,
		json: null,		
		
		tabContainer: null,
		searchOptions: null,
		facetOptions: null,
		tpaOptions: null,
		resultsOptions: null,
		resultsColumns: null,
		preventDoubleClickFlag: false,
		
		postCreate: function() {
			this.inherited("postCreate", arguments);			
		},
		
		preLoad: function() {
			EDR.ajax.Loading.setIsLoading(this.containerNode);
		},
		
		postLoad: function() {
			EDR.ajax.Loading.clearIsLoading(this.containerNode);
		},
		
		loadErrorHandler: function(response, ioArgs) {
			// publish Ajax error handling event
			dojo.publish("ajaxError", [response, ioArgs]);			
			EDR.ajax.Loading.clearIsLoading(this.containerNode);
		},
		
		saveErrorHandler: function(response, ioArgs) {
			// publish Ajax error handling event
			dojo.publish("ajaxError", [response, ioArgs]);			
			EDR.ajax.Loading.clearIsLoading(this.containerNode);
		},
		
		startup: function() {
			this.inherited("startup", arguments);			
			this.tabContainer = dijit.byId(EDR.prefix+"searchPanePreferenceTab");
			this.searchOptions = dijit.byId(EDR.prefix+"searchOptions");
			this.resultsOptions = dijit.byId(EDR.prefix+"resultsOptions");
			this.resultsColumns = dijit.byId(EDR.prefix+"resultsColumns");
			var searchManager = dijit.byId(EDR.prefix+"searchManager");
			if(searchManager) {
				if(!searchManager.isTextAnalyticsEnabled){	
					this.facetOptions = dijit.byId(EDR.prefix+"facetOptions");
					this.tpaOptions = dijit.byId(EDR.prefix+"tpaOptions");
				}else{
					this.analyticsFacetOption = dijit.byId(EDR.prefix+"analyticsFacetOption");
					this.analyticsTimeSeriesOption = dijit.byId(EDR.prefix+"analyticsTimeSeriesOption");
					this.analyticsDeviationsOption = dijit.byId(EDR.prefix+"analyticsDeviationsOption");
					this.analyticsTrendsOption = dijit.byId(EDR.prefix+"analyticsTrendsOption");
					this.analyticsFacetPairsOption = dijit.byId(EDR.prefix+"analyticsFacetPairsOption");
				}
			}
		},
		
		load: function() {
			var args = 	{ 
				url: this.url,
				showProgress: false,
				successCallback: dojo.hitch(this, function(response, ioArgs) {
					var json = null;
					try {
						json = dojo.fromJson(response);
					} catch (e) {
			        	this.loadErrorHandler(response, ioArgs);
			        	return;
					}
					this.clear();
					this.loadJson(json);	
					this.postLoad();		
				}),
				afterErrorHandlerCallback: dojo.hitch(this, function(response, ioArgs) {
					this.loadErrorHandler(response, ioArgs);
				}),
				timeout: this.timeout
			};
			
			this.preLoad();					
			EDR.ajax.Request.post(args);
		},
		
		changeCollection: function() {
			var params = this.getFormValues();
			// if (!this.validate(params)) return;
			this.preLoad();			
			var args = 	{ 
				url: this.url,
				successCallback: dojo.hitch(this, function(response, ioArgs) {
					var json = null;
					try {
						json = dojo.fromJson(response);
					} catch (e) {
			        	this.loadErrorHandler(response, ioArgs);
			        	return;
					}
					this.clear();
					this.loadJson(json);	
					this.postLoad();		
				}),
				afterErrorHandlerCallback: dojo.hitch(this, function(response, ioArgs) {
					this.loadErrorHandler(response, ioArgs);
				}),
				timeout: this.timeout,
				content: params,
				showProgress: false
			};
			EDR.ajax.Request.post(args);
		},
		
		save: function() {
			var params = this.getFormValues();
			if (!this.validate(params)) return false;
			
			this.preLoad();			
			var args = 	{ 
				url: this.saveUrl,
				successCallback: dojo.hitch(this, function(response, ioArgs) {
					var json = null;
					try {
						json = dojo.fromJson(response);
					} catch (e) {
			        	this.saveErrorHandler(response, ioArgs);
			        	return;
					}
					if (json.error) {
			        	this.saveErrorHandler(response, ioArgs);
			        	return;
					}
					this.saved(json);
					this.postLoad();					
					this.cancelFunction();
				}),
				afterErrorHandlerCallback: dojo.hitch(this, function(response, ioArgs) {
					this.saveErrorHandler(response, ioArgs);
				}),
				timeout: this.timeout,
				content: params,
				showProgress: false
			};
			EDR.ajax.Request.post(args);
			return true;
		},
		
		saved: function(json) {
			// Changed collection has category tree or not
			EDR.isCategoryTreeEnabled = json.isCategoryTreeEnabled;
			
			//for a display of banner's collections
			var isCollectionChanged = dijit.byId(EDR.prefix+"bannerId").setCollections(json.collections, json.isFacetedSearch);
			if (isCollectionChanged) {
				dojo.publish("collectionChanged");
			} else {
				dojo.publish("preferenceChanged");
			}
			
			//enable/disable export toolbar button
			var resultToolbar = dijit.byId(EDR.prefix+"horizontalSearchPanes").resultToolbar;
			resultToolbar.enableExportButton(json.isExportEnabled);
			resultToolbar.changeOptionsState(json.isDocCacheEnabled);
			resultToolbar.enableDeepInspectionButton(json.isDeepInspectionEnabled);
			resultToolbar.changeSecureMode(json.isSecureCollection);
			//change a display for resultsPerPage on toolbar
			resultToolbar.updateResultPerPage(json.resultsRange);
			
			//change number of results for type ahead
			var typeAheadWidget = dijit.byId(EDR.prefix+"typeAheadWidget");
			typeAheadWidget.setNumberOfResults(json.typeAheadNumberOfResults);
			typeAheadWidget.setMode(json.typeAheadMode);
			
			//change analytics result range
			if(EDR.isTextAnalyticsEnabled) {
				this.analyticsFacetOption.afterSaveApplyChanges(json.facets, isCollectionChanged);
				this.analyticsDeviationsOption.afterSaveApplyChanges(json.deviations, isCollectionChanged);
				this.analyticsTrendsOption.afterSaveApplyChanges(json.trends, isCollectionChanged);
				this.analyticsFacetPairsOption.afterSaveApplyChanges(json.facetPairs, isCollectionChanged);
			}
		},
		
		/***************** [Begin] temp fix for adv options ***************************/
		
		savedAdvancedOptions: function(json) {
			//for a display of banner's collections
			var isCollectionChanged = dijit.byId(EDR.prefix+"bannerId").setCollections(json.collections, json.isFacetedSearch);
			if (isCollectionChanged) dijit.byId(EDR.prefix+"categoryTree").forceReload();
			
			//enable/disable export toolbar button
			var resultToolbar = dijit.byId(EDR.prefix+"horizontalSearchPanes").resultToolbar; 
			resultToolbar.enableExportButton(json.isExportEnabled);
			resultToolbar.changeOptionsState(json.isDocCacheEnabled);
			resultToolbar.enableDeepInspectionButton(json.isDeepInspectionEnabled);
			//change a display for resultsPerPage on toolbar
			resultToolbar.updateResultPerPage(json.resultsRange);
		},
		
		/***************** [End] temp fix for adv options ***************************/
		
		loadJson: function(json) {
			this.json = json;
			if (json.searchOptions != null) {
				this.searchOptions.loadJson(json.searchOptions);
			}
			if (json.preferences.resultsOptions != null) {
				this.resultsOptions.loadJson(json.preferences.resultsOptions);
			}
			if (json.preferences.resultColumns != null) {
				this.resultsColumns.buildPreferences(json.preferences.resultColumns);
			}
			var searchManager = dijit.byId(EDR.prefix+"searchManager");
			if(searchManager) {
				if(!searchManager.isTextAnalyticsEnabled){
					if (json.preferences.facetOptions != null) {
						this.facetOptions.loadJson(json.preferences.facetOptions);
					}
					if (json.preferences.tpaOptions != null) {
						this.tpaOptions.loadJson(json.preferences.tpaOptions);
					}
				}else{
					if(json.preferences.analyticsOptions.facets!=null){
						this.analyticsFacetOption.loadJson(json.preferences.analyticsOptions.facets);
					}
					if(json.preferences.analyticsOptions.timeSeries!=null){
						this.analyticsTimeSeriesOption.loadJson(json.preferences.analyticsOptions.timeSeries);
					}
					if(json.preferences.analyticsOptions.deviations!=null){
						this.analyticsDeviationsOption.loadJson(json.preferences.analyticsOptions.deviations);
					}	
					if(json.preferences.analyticsOptions.trends!=null){
						this.analyticsTrendsOption.loadJson(json.preferences.analyticsOptions.trends);
					}					
					if(json.preferences.analyticsOptions.facetPairs!=null){
						this.analyticsFacetPairsOption.loadJson(json.preferences.analyticsOptions.facetPairs);
					}				
				}
			}
		},
		
		getFormValues: function() {
			var params = this.searchOptions.getFormValues();
			params = dojo.mixin(params,this.resultsColumns.getFormValues(),this.resultsOptions.getFormValues());
			
			var searchManager = dijit.byId(EDR.prefix+"searchManager");
			if(searchManager) {
				if(!searchManager.isTextAnalyticsEnabled){
					params = dojo.mixin(params,this.facetOptions.getFormValues(),this.tpaOptions.getFormValues());
				}else{
					params = dojo.mixin(params,
								this.analyticsFacetOption.getFormValues(),
								this.analyticsTimeSeriesOption.getFormValues(),
								this.analyticsDeviationsOption.getFormValues(),
								this.analyticsTrendsOption.getFormValues(),
								this.analyticsFacetPairsOption.getFormValues()
								);
				}
			}
			return params;
		},
		
		validate: function(params) {
			var panes = EDR.isTextAnalyticsEnabled ?
				[this.searchOptions, this.resultsOptions, this.resultsColumns, 
					this.analyticsFacetOption, this.analyticsTimeSeriesOption, this.analyticsDeviationsOption,
					this.analyticsTrendsOption, this.analyticsFacetPairsOption] :
				[this.searchOptions, this.resultsOptions, this.resultsColumns, this.facetOptions, this.tpaOptions];
					
			for (var i=0; i<panes.length; i++) {
				if (!panes[i].validate(params)) return false;
			}
			return true;
		},
		
		clear: function() {
		},
		
		showTab: function(id) {
			this.tabContainer.selectChild(id);
		},
		
		show: function() {
			this.preventDoubleClickFlag=false;
			this.load();
			this.inherited(arguments);
		},
		
		okFunction: function() {
			if(!this.preventDoubleClickFlag){
				this.preventDoubleClickFlag=true;
				if (!this.save()) {
					this.preventDoubleClickFlag = false;
					return;
				}
				
				var searchManager = dijit.byId(EDR.prefix+"searchManager");
				if(searchManager) {
					if(searchManager.getSearchResult()!=null){
						if(!searchManager.isTextAnalyticsEnabled){
							this.facetOptions.applyChanges();
							this.tpaOptions.applyChanges();
						}
						this.resultsColumns.afterSaveApplyChanges();
					}
				}
			}
		},
		
		cancelFunction: function() {
			this.inherited("cancelFunction", arguments);
		},
		
		//messages
		preferences_saved: ""
	}
);

}

if(!dojo._hasResource["widgets.MyProfileContent"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.MyProfileContent"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.MyProfileContent");




dojo.declare(
"widgets.MyProfileContent",
[dijit._Widget, dijit._Templated],
{	
	imcUrl: "",
	
	templateString:"<div class=\"MyProfileContent\" style=\"padding-left: 10px; padding-right: 10px; padding-bottom: 10px;\">\n\t<h2 dojoAttachPoint=\"credentialsTitle\"></h2>\n\t<div dojoAttachPoint=\"errorDiv\" style=\"color: #FF0000; display: none;\">\n\t\t<img src=\"${imgBasePath}error23.png\" width=\"23\" height=\"23\" style=\"float: left;\" alt=\"${messages_errors_dialog_information}\" />\n\t\t<span dojoAttachPoint=\"errorDescription\"></span>\n\t</div>\n\t<div dojoAttachPoint=\"descriptionDiv\" style=\"margin-bottom: 1em;\"></div>\n\t<div dojoAttachPoint=\"credentialsDiv\">\n\t\t<form dojoAttachPoint=\"promptsForm\" name=\"myProfileForm\" action=\"${imcUrl}\">\n\t\t\t<table dojoAttachPoint=\"credentialsTable\" style=\"border: solid 1px black;\">\n\t\t\t\t<thead>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<th>${messages_myProfile_column1}</th><th>${messages_myProfile_column2}</th><th>${messages_myProfile_column3}</th><th>${messages_myProfile_column4}</th>\t\t\t\n\t\t\t\t\t</tr>\n\t\t\t\t</thead>\n\t\t\t\t<tbody dojoAttachPoint=\"credentialsTableBody\">\n\t\t\t\t</tbody>\n\t\t\t</table>\n\t\t\t<input dojoAttachPoint=\"hiddenCount\" type=\"hidden\" name=\"count\" value=\"0\" />\n\t\t</form>\n\t</div>\n</div>\n",
	
	imgBasePath: EDR.config.imageBaseDir,
	
	testData: '',
	
	_userPrompts: [],//array
	
	messages_myProfile_column1 : EDR.messages.myProfile_column1,
	messages_myProfile_column2 : EDR.messages.myProfile_column2,
	messages_myProfile_column3 : EDR.messages.myProfile_column3,
	messages_myProfile_column4 : EDR.messages.myProfile_column4,
	messages_errors_dialog_information: EDR.messages.errors_dialog_information,
	
	postMixInProperties: function() {
		this.imcUrl = EDR.contextPath + "/imc";
	},
	
	postCreate: function() {
		this.inherited("postCreate", arguments);

		this.credentialsTitle.innerHTML = EDR.messages.text_imc_display_label;
		this._setDescription();
	},
	
	_setDescription: function(securedSourcesPresent) {
		var message;
		var dlg = dijit.byId(EDR.prefix+"myProfileDlg");
		if(securedSourcesPresent) {
			message = EDR.messages.text_imc_display_help;
			dojo.style(this.credentialsTitle, "display", "block");
			dojo.style(this.credentialsDiv, "display", "block");
		} else {
			message = EDR.messages.text_imc_unavailable;
			dojo.style(this.credentialsTitle, "display", "none");
			dojo.style(this.credentialsDiv, "display", "none");
		}
		this.descriptionDiv.innerHTML = message;
	},
	
	startup: function() {
		this.inherited("startup", arguments);	
	},
	
	onDialogOpen: function() {
		var args = {
			url: this.imcUrl,
			handleAs: "json",
			load: dojo.hitch(this, "_onImcInfoLoaded"),
			error: dojo.hitch(this, "_onImcInfoLoadError"),
			timeout: dojo.hitch(this, "_onImcInfoLoadTimeout")
		};
		if(this.testData) {
			args.url = this.testData;
		}
		dojo.xhrGet(args);
	},
	
	onSubmit: function() {
		this._disableButtons(true);
		var args = {
			form: this.promptsForm,
			handleAs: "json",
			load: dojo.hitch(this, "_onSubmitResponseLoaded"),
			error: dojo.hitch(this, "_onSubmitResponseError"),
			timeout: dojo.hitch(this, "_onSubmitResponseTimeout")
		};
		dojo.xhrPost(args);
	},
	
	_onSubmitResponseLoaded: function(response) {
		this._disableButtons(false);
		if(response) {
			var success = response.success;
			
			if(success) {
				this._clearError();
			} else {
				var error = response.errors[0].key;
				var domain = response.errors[0].domain;
				this._showError(error, domain);
			}
		}
	},
	
	_clearError: function() {
		//clear error text and hide error div
		dojo.style(this.errorDiv, "display", "none");
		dojo.empty(this.errorDescription);
	},
	
	_showError: function(key, domain) {
		//set error message and show error div
		var key = key.replace(/\./g,"_");
		var message = EDR.messages[key];
		message = message.replace(/\{0\}/, domain);
		this.errorDescription.innerHTML = message; 
		dojo.style(this.errorDiv, "display", "block");
	},
	
	_onSubmitResponseError: function(response) {
		this._disableButtons(false);		
	},
	
	_onSubmitResponseTimeout: function(response) {
		this._disableButtons(false);		
	},	
	
	_onImcInfoLoaded: function(data) {
		var securedSourcesPresent = (data.securedSourcesPresent == "true");
		this._updateTable(data);
		this._setDescription(securedSourcesPresent);
		this._enableOkButton(securedSourcesPresent);
	},
	
	_onImcInfoLoadTimeout: function(data) {
		
	},
	_onImcInfoLoadError: function(data) {
		
	},
	
	_disableButtons: function(disable) {
		var dlg = dijit.byId(EDR.prefix+"myProfileDlg");
		if(dlg) {
			var okButton = dlg.okButtonWidget;
			var cancelButton = dlg.cancelButtonWidget;
			if(okButton) {
				okButton.setDisabled(disable);
			}
			if(cancelButton) {
				cancelButton.setDisabled(disable);
			}
		}
	},
	
	_enableOkButton: function(enable) {
		var dlg = dijit.byId(EDR.prefix+"myProfileDlg");
		if(dlg) {
			var okButton = dlg.okButtonWidget;
			if(okButton) {
				okButton.setDisabled(!enable);
			}
		}
	},
	
	
	_updateTable: function(data) {
		var tbody = this.credentialsTableBody;
		dojo.empty(tbody);
		var prompts = data.prompts;
		for(var i=0; i<prompts.length; i++) {
			var prompt = prompts[i];
			var tr = dojo.create("tr", null, tbody);
			this._renderEnabled(tr, prompt, i);
			this._renderDomain(tr, prompt, i);
			this._renderUsername(tr, prompt, i);
			this._renderPassword(tr, prompt, i);
		}
		this.hiddenCount.value = prompts.length;
	},
	
	_renderEnabled: function(tr, prompt, index) {
		var td = dojo.create("td", null, tr);
		var args = {
			name: "enabled." + index,
			type: "checkbox",
			value: "checked"
		}
		if(prompt.enabled) {
			args.checked = "checked";
		}
		var input = dojo.create("input", args, td);
		
		
	},
	
	_renderDomain: function(tr, prompt, index) {
		var td = dojo.create("td", {innerHTML: prompt.domain}, tr);
		var hidden = dojo.create("input", {type: "hidden", value: prompt.domain, name: "domain."+index}, td);
	},
	
	_renderUsername: function(tr, prompt, index) {
		var td = dojo.create("td", null, tr);
		var input = dojo.create("input", {type: "text", value:prompt.username, name: "username."+index}, td);
	},
	
	_renderPassword: function(tr, prompt, index) {
		var td = dojo.create("td", null, tr);
		var input = dojo.create("input", {type: "password", value:prompt.password, name:"password."+index}, td);
	},

	__dummy__: ''
}
);

}

if(!dojo._hasResource["widgets.MyProfileDialog"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.MyProfileDialog"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.MyProfileDialog");





dojo.declare(
	"widgets.MyProfileDialog", [widgets.customDialog],
	{		
		_content: null,
		
		isClosable: false,
		
		okButtonLabel: EDR.messages.button_apply,
		cancelButtonLabel: EDR.messages.K0001I_COMMON_CLOSE,
		
		postCreate: function() {
			this.inherited("postCreate", arguments);
		},
		
		startup: function() {
			this.inherited("startup", arguments);
		},
		
		show: function() {
			this.inherited(arguments);
			
			var content = dijit.byId(EDR.prefix+"myProfileContent");
			if(content){
				content.onDialogOpen();
			}
		},
		

		okFunction: function() {
			var content = dijit.byId(EDR.prefix+"myProfileContent");
			if(content){
				content.onSubmit();
			}			
		},
		
		cancelFunction: function() {
			this.inherited("cancelFunction", arguments);
		}
	}
);

}

if(!dojo._hasResource["widgets.MultiAccordionContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.MultiAccordionContainer"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.MultiAccordionContainer");



dojo.declare(
	"widgets.MultiAccordionContainer", [dijit.layout._LayoutWidget],	
	{
		titlePaneHeight: 21,
		paddingHeight: 10,
		paneSpace: 5,
		duration: 500,
		handlers: [],
		
		facetPanes: [],
		traPanes: [],
		
		postCreate: function() {
			this.inherited(arguments);
			dojo.subscribe("postLoad", this, "updatePanes");
			dojo.subscribe("collectionChanged", this, "collectionChanged");
		},
		
		startup: function() {
			this.inherited(arguments);
			var self = this;
			dojo.forEach(this.getChildren(), function(pane) {
				dojo.style(pane.containerNode, "width", "100%");
				dojo.style(pane.containerNode, "height", "100%");				
				pane.toggle = function(){
					this.open =! this.open;
					this.open ? self.openPane(this) : self.closePane(this);
					this._onShow();
					this._setCss();
				}
				
				self.removeChild(pane);
				
				dojo.style(pane.domNode, "display", "none");
				if (pane.id.indexOf(EDR.prefix+"dynamicFieldChartTitlePane") == -1) {
					self.facetPanes.push(pane);
				} else {
					self.traPanes.push(pane);
				}
			});
		},
		
		updatePanes: function() {
			var mgr = dijit.byId(EDR.prefix+"searchManager");
			if (mgr) {
//				if (mgr.getSearchResult().isFacetedSearch || EDR.isTextAnalyticsEnabled) {
					this.showFacetPanes();
//				} else {
//					this.showTopResultAnalysisPanes();
//				}
				if(!mgr.isTextAnalyticsEnabled){
					mgr.setShowFacets(mgr.getSearchResult().showFacet);
					mgr.setShowTopResults(mgr.getSearchResult().showTPA);
					mgr._showHideNarrowResults();
				}
			}
		},
		
		collectionChanged: function() {
		   if (EDR.isTextAnalyticsEnabled) return;
		   this.clearPanes();
		},
		
		showFacetPanes: function() {
			this.clearPanes();
			dojo.forEach(this.facetPanes, dojo.hitch(this, function(pane) {
				if (pane.id.indexOf("documentLabelSearchTitlePane") != -1 && !EDR.isCategoryTreeEnabled) {					
				} else {
					dojo.style(pane.domNode, "display", "block");
					this.addChild(pane);
					if (EDR.isTextAnalyticsEnabled) pane.toggle = function() {}
				}
			}));
			this.resize();
		},
		
		showTopResultAnalysisPanes: function() {
			this.clearPanes();
			dojo.forEach(this.traPanes, dojo.hitch(this, function(pane) {
				dojo.style(pane.domNode, "display", "block");
				this.addChild(pane);
			}));
			this.resize();
		},
		
		clearPanes: function() {
			dojo.forEach(this.getChildren(), dojo.hitch(this, function(pane) {
				dojo.style(pane.domNode, "display", "none");
				this.removeChild(pane);
			}));
		},
		
		openPane: function(pane) {
			var self = this;
			var anims = [];
			var info = this._setupLayout();
			dojo.forEach(info.openPanes, function(pane) {
				anims.push(self._buildOpenAnimation(pane, info.wipeHeight));
			});						
			var anim = dojo.fx.combine(anims);
			var con = dojo.connect(anim, "onEnd", this, function() {
			 	this.layout();
			 	if (pane != null && pane.onOpenPane != null)
			 		pane.onOpenPane();
			 	dojo.disconnect(con);
			});
			anim.play();
		},
		
		closePane: function(pane) {
			var self = this;
			var anims = [];
			var info = this._setupLayout();
			dojo.forEach(info.openPanes, function(pane) {
				anims.push(self._buildOpenAnimation(pane, info.wipeHeight));
			});						
			anims.push(self._buildCloseAnimation(pane));
			var anim = dojo.fx.combine(anims);
			var con = dojo.connect(anim, "onEnd", this, function() { 
				this.layout();
			 	if (pane != null && pane.onOpenPane != null)
			 		pane.onClosePane();
			 	dojo.disconnect(con);
			});
			anim.play();
		},
		
		resize: function() {
			var searchManager = dijit.byId(EDR.prefix+"searchManager");
			if(searchManager) {
				if(!searchManager.isTextAnalyticsEnabled){
					var height = dojo.contentBox(this.domNode.parentNode).h;
					//The div's height of "narrow your results" is 20px
					dojo.style(this.domNode, "height", (height-20)+"px");
				}
			}
			// nothing to to for width:100%;height:100%;
			this.layout();
		},
		
		layout: function() {
			var info = this._setupLayout();
			var self = this;
			dojo.forEach(info.closePanes, function(pane) {
				dojo.style(pane.hideNode, "display", "none");
				dojo.style(pane.wipeNode, "display", "none");
				dojo.marginBox(pane.wipeNode, {h:0});
				pane.resize({h:this.titlePaneHeight + this.paneSpace});
			});
			dojo.forEach(info.openPanes, function(pane) {
				dojo.style(pane.hideNode, "display", "block");
				dojo.style(pane.wipeNode, "display", "block");
				dojo.marginBox(pane.wipeNode, {h:info.wipeHeight});
				pane.resize({h:info.wipeHeight + this.titlePaneHeight + this.paneSpace});
			});
		},		
		
		_setupLayout: function() {
			var openPanes = [];
			var closePanes = [];
			dojo.forEach(this.getChildren(), function(pane) {
				pane.open ? openPanes.push(pane) : closePanes.push(pane);
			});			
			var size = dojo.contentBox(this.domNode);
			var h = size.h - ((this.titlePaneHeight + this.paneSpace) * (closePanes.length + openPanes.length));
			var wipeHeight = 0;
			if (openPanes.length > 0)
				wipeHeight = Math.floor(h / openPanes.length) - this.paddingHeight;
			wipeHeight = Math.max(0, wipeHeight);
			
			return {
				openPanes: openPanes,
				closePanes: closePanes,
				wipeHeight: wipeHeight
			};
		},
		
		_buildOpenAnimation: function(pane, end) {
			var self = this;
			var animation = dojo.animateProperty(
		    	{
		    	    node: pane.wipeNode,
		    	    duration: self.duration,
		    	    properties: {
		    	    	height: {start: pane.wipeNode.clientHeight, end: end}
		            },
		            onBegin: function(n) {
						dojo.style(pane.hideNode, "display", "block");
						dojo.style(pane.wipeNode, "display", "block");
		            }
		        });
		    return animation;
		},
		
		_buildCloseAnimation: function(pane) {
			var self = this;
			var animation = dojo.animateProperty(
		    	{
		    	    node: pane.wipeNode,
		    	    duration: self.duration,
		    	    properties: {
		    	    	height: {start: pane.wipeNode.clientHeight, end: 0}
		            },
		            onEnd: function(n) {
						dojo.style(pane.hideNode, "display", "none");
						dojo.style(pane.wipeNode, "display", "none");
		            }
		        });
		    return animation;
		},
		
		destroy: function() {
			dojo.forEach(this.handlers, dojo.disconnect);
			this.inherited(arguments);
		}		
	}
);

}

if(!dojo._hasResource["widgets.FacetItems"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.FacetItems"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.FacetItems");







dojo.declare(
	"widgets.FacetItems", [widgets.FacetBase, dijit._Templated],
	{		
		prefix: EDR.prefix,
		widgetsInTemplate: true,
		templateString:"<div>\n\t<!-- main toolbar -->\n\t<div dojoType=\"widgets.Toolbar\">\n\t\t<div class=\"facet-dlg-toolbar clearfix\">\n\t\t\t<div class=\"facet-dlg-counts\">\n\t\t\t\t<div><span dojoAttachPoint=\"facetNameSpan\"></span></div>\n        \t\t<div><span dojoAttachPoint=\"facetSelectedSpan\"></span></div>\n\t\t\t</div>\n\t\t\t<div class=\"facet-dlg-filter\">\n\t\t\t\t<label id=\"${prefix}facetItemFilterText\">${messages_facetItems_label_filter}</label>: <input type=\"text\" size=\"20\"\n\t\t\t\t\tdojoAttachPoint=\"filterText\" dojoAttachEvent=\"onkeypress: onFilterChanged\" id=\"${prefix}facetItemFilterText\"></input>  \t\t        \n\t\t    </div>\n\t\t</div>\n\t</div>\n\t\n\t<!-- lower toolbar -->\n\t<div class=\"dijit dijitToolbar ToolbarContainer lowerFacetResultToolbarContainer\">\n\t\t<div class=\"ToolbarContainerMiddle\">\n\t\t\t<div class=\"ToolbarContainerMiddleLeft\"></div>\n\t\t\t<div class=\"ToolbarContainerMiddleMiddle\">\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t<div class=\"ToolbarContent\">\n\t\t\t\t    <div class=\"facet-dlg-sort\">\n\t\t\t\t    \t<span class=\"label\">${messages_facetItems_label_sortBy}:</span>\n\t\t\t\t    \t<span class=\"label\">\n\t\t\t\t    \t\t<a href=\"javascript:;\" style=\"font-weight:bold; color:#339999;\"\n\t\t\t\t    \t\t\tdojoAttachEvent=\"onclick: onCountSortClicked\">${messages_facetItems_label_count}</a>\n\t\t\t\t    \t</span>\n\t\t\t\t\t\t<span class=\"facet-dlg-sort-values\">   \n\t\t\t\t    \t  \t<img dojoAttachPoint=\"desArrowImg\" src=\"${imgBasePath}arrow_down_blue8.png\" alt=\"\" title=\"\"/>\n\t\t\t\t    \t  \t<img dojoAttachPoint=\"ascArrowImg\" src=\"${imgBasePath}arrow_up8_d.png\" alt=\"\" title=\"\"/>\n\t\t\t\t      \t</span>\t  \n\t\t\t\t    </div>\t\t    \n\t\n\t\t\t\t    <div class=\"facet-dlg-show\">\n\t\t\t\t      <span class=\"label\">${messages_facetItems_label_show}:</span>\n\t\t\t\t      <span class=\"facet-dlg-show-values\">\n\t\t\t\t      \t<span dojoAttachPoint=\"allLabel\" style=\"font-weight: bold;\">${messages_facetItems_label_all}</span>\n\t\t\t\t\t    <a dojoAttachPoint=\"allLink\" href=\"javascript:;\"\n\t\t\t\t\t    \tdojoAttachEvent=\"onclick: onShowAllClicked\" style=\"display:none;\">${messages_facetItems_label_all}</a>\n\t\t\t\t\t    | \n\t\t\t\t      \t<span dojoAttachPoint=\"includeLabel\" style=\"font-weight: bold; display:none\">${messages_facetItems_label_include}</span>\n\t\t\t\t\t    <a dojoAttachPoint=\"includeLink\" href=\"javascript:;\"\n\t\t\t\t\t    \tdojoAttachEvent=\"onclick: onShowIncludeClicked\">${messages_facetItems_label_include}</a>\n<!-- \n\t\t\t\t    \t| \n\t\t\t\t      \t<span dojoAttachPoint=\"excludeLabel\" style=\"font-weight: bold; display: none;\">Exclude</span>\n\t\t\t\t\t    <a dojoAttachPoint=\"excludeLink\" href=\"javascript:;\"\n\t\t\t\t\t    \tdojoAttachEvent=\"onclick: onShowExcludeClicked\">Exclude</a>\n -->\n \t\t\t\t      </span>\n\t\t\t\t    </div>\n\t\t\t  \n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t\t<div class=\"ToolbarContainerBottom\">\t\n\t\t\t<div class=\"ToolbarContainerBottomLeft\"></div>\n\t\t\t<div class=\"ToolbarContainerBottomMiddle\"></div>\n\t\t</div>\n\t</div>\n\t\n\t<!-- space -->\n\t<div style=\"width:100%;height:5px;\"></div>\n\t\n\t<!-- facet items table -->\n\t<div dojoAttachPoint=\"facetTableContainer\" class=\"facet-dlg-content\" style=\"overflow-x:auto;overflow-y:hidden;position:relative;\">\n\t\t<table dojoAttachPoint=\"facetTable\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\"\n\t\t\tstyle=\"position:absolute;left:0px;top;0px; white-space:nowrap; table-layout:fixed; z-Index:1;\">\n\t\t\t<tbody><tr dojoAttachPoint=\"itemsRow\"></tr></tbody>\n\t\t</table>\n\t\t<table dojoAttachPoint=\"dummyTable\" style=\"height:100%;\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n\t\t\t<tbody><tr><td class=\"facet-column\" dojoAttachPoint=\"dummyCell\"></td></tr></tbody>\n\t\t</table>\n\t\t<span dojoAttachPoint=\"hiddenSpan\" style=\"visibility:hidden;position:absolute;\"></span>\n\t</div>\n</div>\n",
		_autoLoad: false,
		url: "",
		
		itemIdPrefix: "dlg_",
		facetName: "",
		facetPath: "",
		maxSize: 0,
		store: null,
		json: null,
		
		filterTimer: null,
		filterDuration: 500,
		filter: {itemLabel:"*"},
		showType: "all", /* "andfacets" "notfacets" */
		queryOptions: {ignoreCase: true},
		descending: true,
		sort: [],

		pageWidth: 200,
		labelWidth: 150,
		labelHeight: 20,
		
		itemLength: 0,
		numOfPageRows: 20,
		numOfPages: 3,
		numOfVisiblePages: 3,
		beginOffset: 0,
		endOffset: 0,
		maxScrollLeft: 0,
		maxScrollDelta: 0,
				
		messages_facetItems_label_filter : EDR.messages.facetItems_label_filter,
		messages_facetItems_label_sortBy  : EDR.messages.facetItems_label_sortBy ,
		messages_facetItems_label_count  : EDR.messages.facetItems_label_count ,
		messages_facetItems_label_show  : EDR.messages.facetItems_label_show ,
		messages_facetItems_label_all  : EDR.messages.facetItems_label_all ,
		messages_facetItems_label_include  : EDR.messages.facetItems_label_include ,
				
		postCreate: function() {
			this.inherited("postCreate", arguments);
			this.handlers.push(dojo.connect(this.facetTableContainer, "onscroll", this, "onScroll"));
			
			if (this._autoLoad && this.url != null && this.url.length != 0) {
				this.load(this.url);
			} else {
				this.json = this._getNullGroups();
				this._buildDummyTable(dojo.contentBox(this.domNode).w);
			}
		},
		
		startup: function() {
			this.inherited("startup", arguments);
//			this.filterText.focus();
		},
		
		load: function(url) {
			var params = this.getRequestParams();			
			var args = 	{ 
				url: this.url,
				showProgress: false,
				successCallback: dojo.hitch(this, function(response, ioArgs) {
					var json = null;
					try {
						json = dojo.fromJson(response);
					} catch (e) {
			        	this.loadErrorHandler(response, ioArgs);
			        	return;
					}
					this.clear();
					this.loadJson(json);	
					this.postLoad();		
				}),
				afterErrorHandlerCallback: dojo.hitch(this, function(response, ioArgs) {
					this.loadErrorHandler(response, ioArgs);
				}),
				content: params,
				timeout: this.timeout
			};			
			this.preLoad();					
			EDR.ajax.Request.post(args);
		},
		
		preLoad: function() {
			EDR.ajax.Loading.setIsLoading(this.facetTableContainer);
		},
		
		postLoad: function() {
			EDR.ajax.Loading.clearIsLoading(this.facetTableContainer);
		},
		
		loadErrorHandler: function() {
			EDR.ajax.Loading.clearIsLoading(this.facetTableContainer);
		},
		
		getRequestParams: function() {
			return params = {
				facetName: this.facetName,
				facetPath: this.facetPath,
				facetId: this.facetId,
				maxSize: this.maxSize
			};
		},
				
		onFilterChanged: function(evt) {
			if (this.filterTimer != null) {
				clearTimeout(this.filterTimer);
				this.filterTimer = null;
			}

			var self = this;
		 	this.filterTimer = setTimeout(function() {
		 		var filter = "*" + self.filterText.value + "*";
		 		if (self.filter.itemLabel != filter) {
		 			self.filter.itemLabel = filter;
		 			self.rerender(self.json);
		 		}	
		    }, this.filterDuration);
		},	
		
		clearFilter: function(evt) {
			if (this.filterTimer != null) {
				clearTimeout(this.filterTimer);
				this.filterTimer = null;
			}
			this.filter.itemLabel = "*";
			this.filterText.value = "";
		},
		
		onCountSortClicked: function(evt) {
			if (this.descending) {
				this.desArrowImg.src = this.imgBasePath + "arrow_down8_d.png";
				this.ascArrowImg.src = this.imgBasePath + "arrow_up_blue8.png";
				this.sort = [{
					attribute: "count",
					descending: false
				}];
			} else {
				this.desArrowImg.src = this.imgBasePath + "arrow_down_blue8.png";
				this.ascArrowImg.src = this.imgBasePath + "arrow_up8_d.png";
				this.sort = [];
			}
			this.descending = !this.descending;
		 	this.rerender(this.json);
		},
		
		toggleCheckBoxEventHandler: function(chkbox) {
			this.inherited(arguments);
			this.facetSelectedSpan.innerHTML = "(" + this.andfacets.count + " " + "selected" + ")";
		},
		
		onScroll: function(evt) {
			var scrollLeft = Math.abs(parseInt(this.facetTableContainer.scrollLeft));			
			var scrollDelta = scrollLeft % this.pageWidth;
			var pages = Math.floor(scrollLeft / this.pageWidth); 
			
			var prevBeginOffset = this.beginOffset;
			var prevEndOffset = this.endOffset;
			
			if (scrollLeft == this.maxScrollLeft) {
				this.endOffset = this.itemLength;	
				this.beginOffset = this.numOfPageRows * pages;
				dojo.style(this.facetTable, "left", this.maxScrollDelta + "px");				
			} else if (scrollLeft == 0) {
				this.beginOffset = 0;
				this.endOffset = this.beginOffset + this.numOfPageRows * this.numOfVisiblePages;		
				dojo.style(this.facetTable, "left", 0 + "px");							
			} else {
				this.beginOffset = this.numOfPageRows * pages;
				this.endOffset = this.beginOffset + this.numOfPageRows * this.numOfVisiblePages;		
				dojo.style(this.facetTable, "left", scrollLeft - scrollDelta + "px");
			}			

			if (prevBeginOffset != this.beginOffset || prevEndOffset != this.endOffset)			
				this.updateRange();
		},
		
		onShowAllClicked: function(evt) {
			dojo.style(this.allLabel, "display", "");
			dojo.style(this.allLink, "display", "none");
			dojo.style(this.includeLabel, "display", "none");
			dojo.style(this.includeLink, "display", "");
/*			dojo.style(this.excludeLabel, "display", "none");
			dojo.style(this.excludeLink, "display", "");*/
			
			this.showType = "all";
			this.rerender(this.json);
		},

		onShowIncludeClicked: function(evt) {
			dojo.style(this.allLabel, "display", "none");
			dojo.style(this.allLink, "display", "");
			dojo.style(this.includeLabel, "display", "");
			dojo.style(this.includeLink, "display", "none");
/*			dojo.style(this.excludeLabel, "display", "none");
			dojo.style(this.excludeLink, "display", ""); */
			
			this.showType = "andfacets";
			this.rerender(this.json);
		},
/*		
		onShowExcludeClicked: function(evt) {
			dojo.style(this.allLabel, "display", "none");
			dojo.style(this.allLink, "display", "");
			dojo.style(this.includeLabel, "display", "none");
			dojo.style(this.includeLink, "display", "");
			dojo.style(this.excludeLabel, "display", "");
			dojo.style(this.excludeLink, "display", "none");
			
			this.showType = "notfacets";
			this.rerender(this.json);
		},
*/		
		render: function(facet) {
			this.buildViewConstants(facet.items);
			
			var self = this;
			this.store = new dojo.data.ItemFileReadStore({data: facet});
			this._overrideStoreFunction(this.store);
			var request = this.store.fetch({
				query: this.filter,
				queryOptions: this.queryOptions,
				sort: this.sort,				
				start: this.beginOffset,
				count: this.endOffset - this.beginOffset,
				onComplete: function(items) {
					var len = Math.ceil(items.length / self.numOfPageRows);
					for (var i=0; i<len; i++) {
						self.buildFacetItemColumn(
							items,
							i*self.numOfPageRows,
							Math.min((i+1)*self.numOfPageRows, items.length),
							self.itemsRow
						);
					}
				}
			});
		},
		
		rerender: function(facet) {
			if (facet == null) facet = this.json;
			this.buildViewConstants(facet.items);
			this.updateRange();			
		},
		
		buildViewConstants: function(items) {
		
			// calculate constans
			this.facetTableContainer.scrollLeft = 0;
			this.itemLength = this.getFilteredItemsLength(items, this.filter.itemLabel);
						
			var size = dojo.contentBox(this.domNode);
			this.numOfPages = Math.ceil(this.itemLength / this.numOfPageRows);
			this.numOfVisiblePages = Math.min(Math.ceil(size.w / this.pageWidth), this.numOfPages);
			
			var dummyWidth = Math.max(this.numOfPages * this.pageWidth, size.w);
			this.maxScrollLeft = dummyWidth - size.w;
			this.maxScrollDelta = Math.max((this.numOfPages - this.numOfVisiblePages) * this.pageWidth, 0);
			
			this._buildDummyTable(dummyWidth);
			
//			dojo.style(this.dummyTable, "width", dummyWidth + "px");
//			dojo.style(this.facetTable, "width", this.numOfVisiblePages * this.pageWidth + "px");
			
			var width = this.numOfVisiblePages * this.pageWidth;
			var height = this.numOfPageRows * this.labelHeight;
			dojo.marginBox(this.facetTable, {
					w: width,
					h: height
			});
			
			this.beginOffset = 0;
			this.endOffset = this.numOfVisiblePages * this.numOfPageRows;
			
			// update view labels
			this.facetNameSpan.innerHTML = this.itemLength + " " + this.json.facetLabel;
			this.facetSelectedSpan.innerHTML = "(" + this.andfacets.count + " " + "selected" + ")";
		},

		updateColumn: function(column, beginOffset, endOffset) {
			var self = this;
			if (beginOffset == 0 && endOffset == 0) {
				self.updateFacetItemColumn(null, 0, 0, column);
			} else {
				var request = this.store.fetch(
					{
						query: this.filter,
						queryOptions: this.queryOptions,
						sort: this.sort,
						start: beginOffset,
						count: endOffset - beginOffset,
						onComplete: function(items) {
							self.updateFacetItemColumn(items, beginOffset, endOffset, column);
						}
					}
				);
			}
		},
		
		updateRange: function() {
			this.beginOffset = Math.max(0, this.beginOffset);
			this.endOffset = Math.min(this.endOffset, this.itemLength);
			
			var columns = this.facetTable.rows[0].cells;
			var len = Math.ceil((this.endOffset - this.beginOffset) / this.numOfPageRows);
			
			for (var i=0; i<len; i++) {
				this.updateColumn(
					columns[i],
					this.beginOffset + i * this.numOfPageRows,
					Math.min(this.endOffset, this.beginOffset + (i+1) * this.numOfPageRows)
				);
			} 
			for (var i=len; i<columns.length; i++) {
				this.updateColumn(
					columns[i],
					0, 0 // render empty cell
				);
			}
		},

		getFilteredItemsLength: function(items, filter) {
			if (filter == "*") return items.length;
			
			var regexp = dojo.data.util.filter.patternToRegExp(filter, true);
			var count = 0;
			for (var i=0; i<items.length; i++) {
				var label = this.store == null ? items[i].itemLabel : this.store.getValue(items[i], "itemLabel");
				if (label.match(regexp))
					count++;
			}
			return count;
		},		
		
		buildItemLabel: function(item) {
			return "<span style='padding-left:5px;'>" + this._getTruncatedLabel(item, this.labelWidth) + "</span>";
		},
		
		loadJson: function(facet) {
			if (facet == null) return;			
			this.json = facet;
			this.render(facet);
		},
		
		buildFacetItemColumn: function(items, beginOffset, endOffset, parent) {
			var column = dojo.doc.createElement("TD");
			dojo.addClass(column, "facet-column");
			dojo.style(column, "width", this.pageWidth + "px");

			for (var i=beginOffset; i<endOffset; i++) {
				var itemElem = this.buildFacetItemElem(items[i]);
				dojo.addClass(itemElem, "facet-row");
				dojo.addClass(itemElem, i % 2 == 0 ? "even" : "odd");
				column.appendChild(itemElem);
				dojo.marginBox(itemElem, {h:this.labelHeight});			
			}			
			parent.appendChild(column);
		},
		
		updateFacetItemColumn: function(items, beginOffset, endOffset, column) {
			var itemDivs = dojo.query("> DIV", column);
			var itemIndex = 0;
			if (items == null || items.length == 0) {
				dojo.style(column, "display", "none");
			} else {
				dojo.style(column, "display", dojo.isIE ? "block" : "table-cell");
				for (var i=0; i<itemDivs.length; i++) {
					if (itemIndex < items.length) {
						var item = items[itemIndex];
						var parent = itemDivs[i];
						
						dojo.style(parent, "display", "block");
						
						var facetInput = parent.firstChild;					
						facetInput.setAttribute("value", item.postParamValue + "");
						
						facetInput.chkbox.attr("checked", this.andfacets.contains(item.postParamValue + ""));
						
						var labelLink = facetInput.nextSibling.nextSibling;
						labelLink.setAttribute("itemId", item.itemId + "");
						labelLink.innerHTML = this.buildItemLabel(item);
						var labelTitle = dojo.string.substitute(EDR.messages.tooltip_facet_quick, ['"' + item.itemLabel + '"']);
						labelLink.title = labelTitle;
						//this.handlers.push(dojo.connect(labelLink, "onclick", this, this.facetSelectedEventHandler));
												
						var text = labelLink.nextSibling;
						parent.removeChild(text);
						text = dojo.doc.createTextNode(" (" + item.count + ")");
						parent.appendChild(text);	
						
						itemIndex++;				
/*						
						var andImg = facetInput.nextSibling.firstChild;
						var notImg = facetInput.nextSibling.nextSibling.firstChild;
						
						if (facetInput.name == "andfacet") {
							if (!this.andfacets.contains(item.postParamValue)) {
								this.toggleAndImgEventHandler(
									{type: "click", currentTarget: andImg.parentNode, viewOnly:true}
								);								
							}
						} else if (facetInput.name == "notfacet") {
							if (!this.notfacets.contains(item.postParamValue)) {
								this.toggleNotImgEventHandler(
									{type: "click", currentTarget: notImg.parentNode, viewOnly:true}
								);								
							}
						}
						if (facetInput.name == "facet") {
							if (this.andfacets.contains(item.postParamValue)) {
								this.toggleAndImgEventHandler(
									{type: "click", currentTarget: andImg.parentNode, viewOnly:true}
								);								

							} else if (this.notfacets.contains(item.postParamValue)) {
								this.toggleNotImgEventHandler(
									{type: "click", currentTarget: notImg.parentNode, viewOnly:true}
								);						
							}
						}
*/		
					} else {
						dojo.style(itemDivs[i], "display", "none");
					}
				}
			}
		},
		
		clear: function() {
			dojo.forEach(dijit.findWidgets(this.facetTable), function(widget) {
				widget.destroy();
			});			
			dojo.empty(this.itemsRow);
			dojo.empty(this.dummyCell);
			this.clearFilter();
			this.store = null;		
		},
		
		_buildDummyTable: function(dummyWidth) {
			this.dummyCell.innerHTML = "";
			for (var i=0; i<this.numOfPageRows; i++) {
				var div = dojo.doc.createElement("DIV");
				dojo.addClass(div, "facet-row");
				dojo.addClass(div, i % 2 == 0 ? "even" : "odd");				
				this.dummyCell.appendChild(div);
				dojo.marginBox(div, {w:dummyWidth, h:this.labelHeight});			
			}
			
			var height = this.numOfPageRows * this.labelHeight;
			if (dojo.isIE == 7) height += 15;
			dojo.marginBox(this.dummyTable, {
					w: dummyWidth,
					h: height
			});
		},
		
		// build ellipssed strings
		_getTruncatedLabel: function(item, width) {
			var label = item.itemLabel + "";
			var count = " (" + item.count + ")";
			if (this._getStringExtent(label + count) < width) {
				return label;
			} else {
				var ellipse = "... (" + item.count + ")";
				var labelWidth = width - this._getStringExtent(ellipse);
				if (labelWidth > 0) { 	
					for (var i=0; i<label.length; i++) {
						var s = label.slice(0, i);
						if (labelWidth < this._getStringExtent(s) && i > 0) {
							return label.slice(0, i-1) + "...";
						}
					}				
				}
				return ellipse;
			}
		},
		
		_getStringExtent: function(str) {
			this.hiddenSpan.innerHTML = str;
			var size = this.hiddenSpan.offsetWidth;
			this.hiddenSpan.innerHTML = "";
			return size;
		},
		
		_overrideStoreFunction: function(store) {
			// hack to enable facet selectoin filter
			var self = this;
			var tf = store._containsValue;
			store._containsValue = function(item) {
				if (self.showType == "andfacets" && !self.andfacets.contains(item.postParamValue + "")) {
					return false;
				} else if (self.showType == "notfacets" && !self.notfacets.contains(item.postParamValue + "")) {
					return false;
				}
				return tf.apply(store, arguments);
			};
		},
		
		_getNullGroups: function() {
			return {
				facetLabel: "",
				facetId: "-",
				items: [],
				facets: []
			};
		}
	}
);

}

if(!dojo._hasResource["widgets.ResultToolbar"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.ResultToolbar"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.ResultToolbar");








dojo.declare(
"widgets.ResultToolbar",
[dijit._Widget, dijit._Templated],
{
	prefix: EDR.prefix,
	imgBasePath: EDR.config.imageBaseDir,
	testData: "",
	_testMode: false,
	
	collectionsCount: 0,
	
	widgetsInTemplate: true,

	switchDetailsButton: null,
	
	_detailsExpanded: false,
	
	_lastQuery: '',
	
	moreAmount: 5,
		
	exportEnabled: false,
	docCacheEnabled: false,
	deepInspectionEnabled: false,
	
	defaultPerPageOption : [10,25,50,100],
	filterBySelectBox: null,
	perPageSelectBox : null,
	
	_secureMode: false,
	_currentPage: -1,
	_startPage: -1,
	_endPage: -1,
	_lastPage: -1,
	
	messages_tooltip_saveSearchDialogButton: EDR.messages.tooltip_saveSearchDialogButton,
	messages_tooltip_exportButton: EDR.messages.export_button_tooltip,
	messages_tooltip_deepInspectionButton: EDR.messages.tooltip_deepInspection,	
	messages_tooltip_searcBackwardButton: EDR.messages.tooltip_searcBackwardButton,
	messages_tooltip_searcForwardButton: EDR.messages.tooltip_searcForwardButton,
	messages_tooltip_expandResults_open: EDR.messages.tooltip_expandResults_open,
	messages_tooltip_expandResults_close: EDR.messages.tooltip_expandResults_close,
	messages_tooltip_resultsFilterBy: EDR.messages.tooltip_resultsFilterBy,
	messages_tooltip_resultsPerPage: EDR.messages.tooltip_resultsPerPage,
	messages_tooltip_openConfigDialogButton: EDR.messages.tooltip_openConfigDialogButton,	
	messages_toolbars_document_type_show: EDR.messages.toolbars_document_type_show,
	messages_button_save: EDR.messages.button_save,
	messages_tooltip_documents_next: EDR.messages.tooltip_documents_next,
	messages_tooltip_documents_previous: EDR.messages.tooltip_documents_previous,
	messages_tooltip_documents_first: EDR.messages.tooltip_documents_first,
	messages_tooltip_documents_last: EDR.messages.tooltip_documents_last,
	messages_tooltip_help: EDR.messages.tooltip_help,
	messages_tooltip_show_queryarea: EDR.messages.searchpane_showqueryarea,
	messages_tooltip_hide_queryarea: EDR.messages.searchpane_hidequeryarea,
	messages_resulttoolbar_label_resultsPerPage: EDR.messages.resulttoolbar_label_resultsPerPage,
	messages_resulttoolbar_button_label_reset: EDR.messages.resulttoolbar_button_label_reset,
	messages_resulttoolbar_button_tooltip_reset: EDR.messages.resulttoolbar_button_tooltip_reset,
		
	templateString:"<div class=\"dijit dijitToolbar ToolbarContainer results-toolbar\" waiRole=\"toolbar\">\n\t<div class=\"ToolbarContainerTop\">\t\n\t\t<div class=\"ToolbarContainerTopLeft\"></div>\n\t\t<div class=\"ToolbarContainerTopMiddle\"></div>\n\t</div>\n\t<div class=\"ToolbarContainerMiddle\" style=\"position:relative;\">\n\t\t<div class=\"ToolbarContainerMiddleLeft\"></div>\n\t\t<div class=\"ToolbarContainerMiddleMiddle\" dojoAttachPoint=\"toolbarContainerMiddleMiddleNode\" style=\"position:relative;\">\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t<div class=\"ToolbarContent\">\n\t\t\t\t<div dojoAttachPoint=\"containerNode\" style=\"position:relative;\">\n\t\t\t\t\t<!-- Toolbar Content Start -->\n\t\n\t\t\t\t\t<table class=\"ResultToolbarTable\" cellpadding=\"0\">\n\t\t\t\t\t\t<tr dojoAttachPoint=\"toolbarInfo\" class=\"ResultToolbarInfo\">\n\t\t\t\t\t\t\t<td colspan=\"3\" dojoAttachPoint=\"toolbarPrompt\"></td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr dojoAttachPoint=\"toolbarBody\">\n\t\t\t\t\t\t\t<td class=\"ResultToolbarCount\">\n\t\t\t\t\t\t\t\t<div dojoAttachPoint=\"resultCountDiv\">\n\t\t\t\t\t\t\t\t\t<div dojoAttachPoint=\"resultCountRangeDiv\"></div>\n\t\t\t\t\t\t\t\t\t<div dojoAttachPoint=\"resultCountAllDiv\"><span dojoAttachPoint=\"resultCountLeftParen\">(</span><span dojoAttachPoint=\"resultCountAllSpan\"></span><span dojoAttachPoint=\"resultCountRightParen\">)</span></div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</td> \n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t<td dojoAttachPoint=\"toolbarButtonNode\" class=\"ResultToolbarButtons\">\n\t\t\t\t\t\t\t\t<div dojoType=\"dijit.form.Button\"\n\t\t\t\t\t\t\t\t\ticonClass=\"resetSearchButtonIcon\" \n\t\t\t\t\t\t\t\t\tname=\"resetSearchButton\" \n\t\t\t\t\t\t\t\t\tstyle=\"display: none;\"\n\t\t\t\t\t\t\t   \t\talt=\"${messages_resulttoolbar_button_label_reset}\"\n\t\t\t\t\t\t\t   \t\ttitle=\"${messages_resulttoolbar_button_tooltip_reset}\"\n\t\t\t\t\t\t\t   \t\tdojoAttachPoint=\"resetSearchButton\"\n\t\t\t\t\t\t\t   \t\tdojoAttachEvent=\"onClick: _resetButtonClicked\"></div>\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t<div dojoType=\"dijit.form.Button\"\n\t\t\t\t\t\t\t\t\ticonClass=\"showSearchAreaButtonIcon\" \n\t\t\t\t\t\t\t\t\tstyle=\"display: none;\"\n\t\t\t\t\t\t\t\t\tname=\"showHideSearchAreaButton\"\n\t\t\t\t\t\t\t   \t\talt=\"${messages_tooltip_hide_queryarea}\"\n\t\t\t\t\t\t\t   \t\ttitle=\"${messages_tooltip_hide_queryarea}\"\n\t\t\t\t\t\t\t   \t\tdojoAttachPoint=\"showHideSearchAreaButton\"\n\t\t\t\t\t\t\t   \t\tdojoAttachEvent=\"onClick: _showHideSearchAreaClicked\"></div>\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t<div dojoType=\"dijit.form.Button\"\n\t\t\t\t\t\t\t\t\ticonClass=\"saveSearchDialogIcon\" \n\t\t\t\t\t\t\t\t\tname=\"saveSearchDialogButton\"\n\t\t\t\t\t\t\t   \t\talt=\"${messages_tooltip_saveSearchDialogButton}\"\n\t\t\t\t\t\t\t   \t\ttitle=\"${messages_tooltip_saveSearchDialogButton}\"\n\t\t\t\t\t\t\t   \t\tdojoAttachEvent=\"onClick: openSaveDialog\"></div>\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t<div dojoType=\"dijit.form.Button\"\n\t\t\t\t\t\t\t\t\ticonClass=\"exportSearchDialogIcon\" \n\t\t\t\t\t\t\t\t\tname=\"exportSearchDialogButton\"\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"exportSearchDialogButton\"\n\t\t\t\t\t\t\t   \t\talt=\"${messages_tooltip_exportButton}\"\n\t\t\t\t\t\t\t   \t\ttitle=\"${messages_tooltip_exportButton}\"\n\t\t\t\t\t\t\t   \t\tdojoAttachEvent=\"onClick: openExportDialog\"\n\t\t\t\t\t\t\t   \t\tstyle=\"display:none;\"\n\t\t\t\t\t\t\t   \t\t></div>\n\t\t\t\t\t\t\t\t<div dojoType=\"dijit.form.Button\"\n\t\t\t\t\t\t\t\t\tstyle=\"display:none;\"\n\t\t\t\t\t\t\t\t\ticonClass=\"deepInspectionDialogIcon\" \n\t\t\t\t\t\t\t\t\tname=\"deepInspectionDialogButton\" \n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"deepInspectionDialogButton\"\n\t\t\t\t\t\t\t   \t\talt=\"${messages_tooltip_deepInspectionButton}\"\n\t\t\t\t\t\t\t   \t\ttitle=\"${messages_tooltip_deepInspectionButton}\"\n\t\t\t\t\t\t\t   \t\tdojoAttachEvent=\"onClick: openDeepInspectionDialog\"\n\t\t\t\t\t\t\t   \t\t></div>\n\t\t\t\t\t\t\t\t<div dojoType=\"dijit.form.Button\"\n\t\t\t\t\t\t\t\t\tstyle=\"display:none;\"\n\t\t\t\t\t\t\t\t\ticonClass=\"cognosIntegrationDialogIcon\" \n\t\t\t\t\t\t\t\t\tname=\"cognosIntegrationDialogButton\"\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"cognosIntegrationDialogButton\"\n\t\t\t\t\t\t\t   \t\talt=\"\"\n\t\t\t\t\t\t\t   \t\ttitle=\"\"\n\t\t\t\t\t\t\t   \t\tdojoAttachEvent=\"onClick: openCognosIntegrationDialog\"\n\t\t\t\t\t\t\t   \t\t></div>\n\t\t\t\t\t\t\t\t<div dojoType=\"dijit.ToolbarSeparator\"></div>\n\t\t\t\t\t\t\t\t<div dojoType=\"dijit.form.Button\" \n\t\t\t\t\t\t\t   \t\ticonClass=\"searchBackwardIcon\" \n\t\t\t\t\t\t       \t\tname=\"searcBackwardButton\" \n\t\t\t\t\t\t       \t\tdojoAttachPoint=\"searchBackwardButton\"\n\t\t\t\t\t\t       \t\tdisabled=\"disabled\"\n\t\t\t\t\t\t\t   \t\talt=\"${messages_tooltip_searcBackwardButton}\"\n\t\t\t\t\t\t\t   \t\ttitle=\"${messages_tooltip_searcBackwardButton}\"></div>\n\t\t\t\t\t\t   \t\t<div dojoType=\"dijit.form.Button\" \n\t\t\t\t\t\t\t   \t\ticonClass=\"searchForwardIcon\" \n\t\t\t\t\t\t       \t\tname=\"searcForwardButton\"\n\t\t\t\t\t\t       \t\tdojoAttachPoint=\"searchForwardButton\"\n\t\t\t\t\t\t       \t\tdisabled=\"disabled\"\n\t\t\t\t\t\t\t   \t\talt=\"${messages_tooltip_searcForwardButton}\"\n\t\t\t\t\t\t\t   \t\ttitle=\"${messages_tooltip_searcForwardButton}\"></div>\n\t\t\t\t\t\t\t\t<div dojoType=\"dijit.ToolbarSeparator\"></div>\n\t\t\t\t\t\t       \t<div dojoType=\"dijit.form.Button\" \n\t\t\t\t\t\t\t   \t\ticonClass=\"expandResultsIcon\" \n\t\t\t\t\t\t       \t\tname=\"expandResultsButton\" \n\t\t\t\t\t\t       \t\tdojoAttachPoint=\"expandResultsButton\"\n\t\t\t\t\t\t\t   \t\talt=\"${messages_tooltip_expandResults_open}\"\n\t\t\t\t\t\t\t   \t\ttitle=\"${messages_tooltip_expandResults_open}\"></div>\n\t\t\t\t\t\t\t   \t<div dojoType=\"dijit.ToolbarSeparator\"></div>\n\t\t\t\t\t\t\t   \t<div dojoType=\"dijit.form.Button\" \n\t\t\t\t\t\t\t   \t\ticonClass=\"openConfigDialogIcon\" \n\t\t\t\t\t\t       \t\tname=\"openConfigDialogButton\" \n\t\t\t\t\t\t       \t\tdojoAttachPoint=\"openConfigDialogButton\"\n\t\t\t\t\t\t\t   \t\talt=\"${messages_tooltip_openConfigDialogButton}\"\n\t\t\t\t\t\t\t   \t\ttitle=\"${messages_tooltip_openConfigDialogButton}\"></div>\n\t\t\t\t\t\t\t   \t\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t<td class=\"ResultToolbarDocumentButtons\">\n\t\t\t\t\t\t\t\t<table dojoAttachPoint=\"documentButtons\">\n\t\t\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t\t\t<!-- Filter by -->\n\t\t\t\t\t\t\t\t\t\t<td class=\"ResultToolbarFilterByParent\">\n\t\t\t\t\t\t\t\t\t\t\t<div dojoAttachPoint=\"resultsFilterByDiv\" class=\"ResultToolbarContent\"\n\t\t\t\t\t\t\t\t\t\t\t title=\"${messages_tooltip_resultsFilterBy}\" alt=\"${messages_tooltip_resultsFilterBy}\">\n\t\t\t\t\t\t\t\t\t\t\t<label dojoAttachPoint=\"resultsFilterByLabel\" for=\"${prefix}resultsFilterBy\" class=\"results-filter-by-msg\">${messages_toolbars_document_type_show}:</label>\n\t\t\t\t\t\t\t\t\t\t\t<select id=\"${prefix}resultsFilterBy\" dojoAttachPoint=\"resultsFilterByNode\"></select>\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t</td>\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t<!-- Results per page -->\n\t\t\t\t\t\t\t\t\t\t<td class=\"ResultToolbarPerPageParent\">\n\t\t\t\t\t\t\t\t\t\t\t<div dojoAttachPoint=\"resultsPerPageDiv\" class=\"results-per-page\" class=\"ResultToolbarContent\"\n\t\t\t\t\t\t\t\t\t\t\t title=\"${messages_tooltip_resultsPerPage}\" alt=\"${messages_tooltip_resultsPerPage}\">\n\t\t\t\t\t\t\t\t\t\t\t\t<label dojoAttachPoint=\"resultsPerPageLabel\" for=\"${prefix}resultsPerPage\" dojoAttachPoint=\"resultsPerPageLabel\">${messages_resulttoolbar_label_resultsPerPage}:</label>\n\t<!--  \t\t\t\t\t\t\t\t\t\t\t<select dojoType=\"dojox.form.DropDownSelect\" id=\"${prefix}resultsPerPage\" \n\t\t\t\t\t\t\t\t\t\t\t\t\tonchange=\"EDR.bean.Email.switchResultsPerPage\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t<option value=\"10\">10</option>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<option value=\"25\">25</option>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<option value=\"50\">50</option>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<option  value=\"100\">100</option>\n\t\t\t\t\t\t\t\t\t\t\t\t</select>-->\n\t\t\t\t\t\t\t\t\t\t\t\t<select id=\"${prefix}resultsPerPage\" dojoAttachPoint=\"resultsPerPageNode\"></select>\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t</td>\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t<td class=\"ResultToolbarPaginationParent\">\n\t\t\t\t\t\t\t\t\t\t<!-- Pagination -->\n\t\t\t\t\t\t\t\t\t\t\t<div dojoAttachPoint=\"resultsPagination\" class=\"ResultToolbarContent\" dir=\"ltr\">\n\t\t\t\t\t\t\t\t\t\t\t\t<!-- Previous More -->\n\t\t\t\t\t\t\t\t  \t\t    \t<a href=\"javascript:;\" tabindex=\"0\"\n\t\t\t\t\t\t\t\t\t\t\t\t\ttitle=\"${messages_tooltip_documents_first}\"\n\t\t\t\t\t\t\t\t    \t\t    \tonclick=\"\">\n\t\t\t\t\t\t\t\t\t    \t\t    <img dojoAttachPoint=\"previousMoreImg\" buttonType=\"previous\" amount=\"more\" alt=\"${messages_tooltip_documents_first}\"  />\n\t\t\t\t\t\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\t\t\t\t\t\t<!-- Previous -->\n\t\t\t\t\t\t\t\t    \t\t    <a href=\"javascript:;\" tabindex=\"0\" \n\t\t\t\t\t\t\t\t   \t\t    \t    title=\"${messages_tooltip_documents_previous}\"\n\t\t\t\t\t\t\t\t   \t\t    \t    onclick=\"\">\n\t\t\t\t\t\t\t\t\t    \t\t    <img dojoAttachPoint=\"previousImg\" alt=\"${messages_tooltip_documents_previous}\" buttonType=\"previous\" amount=\"one\" />   \n\t\t\t\t\t\t\t\t\t\t\t    </a>\n\t\t\t\t\t\t\t\t\t\t\t    <!-- Page Numbers -->\n\t\t\t\t\t\t\t\t\t\t\t\t<span dojoAttachPoint=\"pageNumbers\"></span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t<!-- Next -->\n\t\t\t\t\t\t\t\t    \t\t    <a href=\"javascript:;\" tabindex=\"0\"\n\t\t\t\t\t\t\t\t\t\t\t\t\ttitle=\"${messages_tooltip_documents_next}\"\n\t\t\t\t\t\t\t\t   \t\t\t    \tonclick=\"\">\n\t\t\t\t\t\t\t\t\t    \t\t    <img dojoAttachPoint=\"nextImg\" alt=\"${messages_tooltip_documents_next}\" buttonType=\"next\" amount=\"one\" />\t\t    \t\t    \n\t\t\t\t\t\t\t\t\t    \t\t</a>\n\t\t\t\t\t\t\t\t\t\t\t\t<!-- Next More-->\n\t\t\t\t\t\t\t\t   \t\t    \t<a href=\"javascript:;\" tabindex=\"0\"\n\t\t\t\t\t\t\t\t\t    \t\t    title=\"${messages_tooltip_documents_last}\"\n\t\t\t\t\t\t\t\t\t\t    \t\tonclick=\"\">\n\t\t\t\t\t\t\t\t\t\t\t    \t<img dojoAttachPoint=\"nextMoreImg\" buttonType=\"next\" amount=\"more\" alt=\"${messages_tooltip_documents_last}\" />\n\t\t\t\t\t\t\t\t\t\t\t    </a>\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t<!-- Pagination end -->\n\t\t\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t\t</table>\n\t\t\t\t\t\t\t</td>\t\t\t\n\t\t\t\t\t\t\t<!-- help -->\n\t\t\t\t\t\t\t<td class=\"ResultToolbarHelp\" dojoAttachPoint=\"helpContainer\">\n\t\t\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t\t\t<a dojoAttachPoint=\"eachTabHelp\" href=\"javascript:;\" style=\"text-decoration:none;\" onclick=\"EDR.viewHelp('iiysutmdoc.htm?noframes=true')\">\n\t\t\t\t\t\t\t\t\t\t<img src=\"${imgBasePath}help_16.png\" style=\"vertical-align:top;\" title=\"${messages_tooltip_help}\" alt=\"${messages_tooltip_help}\" />\n\t\t\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\t\t</div>\t\t\t\t\t\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t<!-- help end -->\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t</table>\n\t\t\t\t<!-- Toolbar Content End -->\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\t<div class=\"ToolbarContainerBottom\">\t\n\t\t<div class=\"ToolbarContainerBottomLeft\"></div>\n\t\t<div class=\"ToolbarContainerBottomMiddle\"></div>\n\t</div>\n</div>\n",
	
	_getIconImagePath: function(name/*previous or next*/, amount/*page or more*/, type/*n(ormal),d(isable),h(ighlighted)*/) {
		var amountString = (amount == "page" ? "page" : "set");
		var typeString = "";
		if(type == "d") {
			typeString = "_d";
		} else if(type == "h") {
			typeString = "_h";
		}
		return dojo.moduleUrl("widgets", "templates/images/" + name + "_" + amountString +"12" + typeString +".png");
	},

	postCreate: function() {
		this.previousMoreImg.src = this._getIconImagePath("previous", "more", "d");
		this.previousImg.src = this._getIconImagePath("previous", "page", "d");
		this.nextImg.src = this._getIconImagePath("next", "page", "d");
		this.nextMoreImg.src = this._getIconImagePath("next", "more", "d");
	
		dojo.subscribe("postLoad", this, "_processSearchResults");
      dojo.subscribe("collectionChanged", this, "_processCollectionChanged");

		this.searchBackwardButton.connect(this.searchBackwardButton, "onClick", dojo.hitch(this, "_searchBackwardButtonClick"));
		
		this.searchForwardButton.connect(this.searchForwardButton, "onClick", dojo.hitch(this, "_searchForwardButtonClick"));
		
		var expandButton = this.expandResultsButton;
		expandButton.connect(expandButton, "onClick", dojo.hitch(this, "_expandResultsButtonClick"));
		
		var openConfigButton = this.openConfigDialogButton;
		openConfigButton.connect(openConfigButton, "onClick", dojo.hitch(this, "_openConfigDialogButtonClick"));
		
		var prevNextButtons = ["previousMoreImg", "previousImg", "nextImg", "nextMoreImg"];
		for(var i=0; i<prevNextButtons.length; ++i) {
			this.connect(this[prevNextButtons[i]], "onclick", dojo.hitch(this, "_onPrevNextButtonClick"));
			this.connect(this[prevNextButtons[i]].parentNode, "onkeypress", dojo.hitch(this, "_onPrevNextButtonEnter"));
			this.connect(this[prevNextButtons[i]], "onmouseover", dojo.hitch(this, "_onPrevNextButtonMouseOver"));
			this.connect(this[prevNextButtons[i]], "onmouseout", dojo.hitch(this, "_onPrevNextButtonMouseOut"));
		}
		
		if(this.collectionsCount < 1) {
			this._setPromptMessage(EDR.messages.text_collection_none);
		} else {
			this._setPromptMessage(EDR.messages.prompt_beforeSearch);
		}
		
//		if(EDR.isTextAnalyticsEnabled) {
//			dojo.subscribe("verticalFacetChanged", this, "_verticalFacetChanged");
//			dojo.subscribe("horizontalFacetChanged", this, "_horizontalFacetChanged");
//			this.connect(dijit.byId("verticalListTarget"), "openDropDown", dojo.hitch(this, "_onOpenDropDown") );
//			this.connect(dijit.byId("verticalListTarget"), "closeDropDown", dojo.hitch(this, "_onCloseDropDown") );
//			this.connect(dijit.byId("verticalMaxRows"), "openDropDown", dojo.hitch(this, "_onOpenDropDown") );
//			this.connect(dijit.byId("verticalMaxRows"), "closeDropDown", dojo.hitch(this, "_onCloseDropDown") );
//			this.connect(dijit.byId("horizontalListTarget"), "openDropDown", dojo.hitch(this, "_onOpenDropDown") );
//			this.connect(dijit.byId("horizontalListTarget"), "closeDropDown", dojo.hitch(this, "_onCloseDropDown") );
//			this.connect(dijit.byId("horizontalMaxRows"), "openDropDown", dojo.hitch(this, "_onOpenDropDown") );
//			this.connect(dijit.byId("horizontalMaxRows"), "closeDropDown", dojo.hitch(this, "_onCloseDropDown") );
//		}
		
		if(this.testData != "") {
			this._testMode = true;
			this._renderTestdata();
		}
		
		//document type
		var length = EDR.config.documentTypes.length;
		dojo.create("option",{value:"ALL",innerHTML:EDR.messages.toolbars_document_type_all.toUpperCase()},this.resultsFilterByNode);
		for(var i = 0 ; i < length ; i++){
			dojo.create("option",{value:EDR.config.documentTypes[i],innerHTML:EDR.config.documentTypes[i].toUpperCase()},this.resultsFilterByNode);
		}
		
		if(!EDR.isRestoreSessionResults) {
			this.filterBySelectBox = new dojox.form.DropDownSelect({onChange: function(value){
				EDR.bean.Email.switchFilterBy(value);
			}},this.resultsFilterByNode);			
		} else {
			this.filterBySelectBox = new dojox.form.DropDownSelect({onChange: function(value){
				if(!EDR.bean.Email.ignoreChange){
					EDR.bean.Email.switchFilterBy(value);
				}
			}},this.resultsFilterByNode);
			
		}
		
		this.buildResultPerPage();
		
		if (EDR.isTextAnalyticsEnabled) {
			dojo.style(this.resetSearchButton.domNode, "display", "");	
			dojo.style(this.showHideSearchAreaButton.domNode, "display", "");	
			dojo.style(this.deepInspectionDialogButton.domNode, "display", "");	
			dojo.style(this.cognosIntegrationDialogButton.domNode, "display", "");	
		} else {
			dojo.style(this.helpContainer, "display", "none");
		}
		if(dojo.isIE <= 7) {
			dojo.style(this.toolbarButtonNode,"width","360px");
		}
	},
	
	buildResultPerPage: function(){
		var perPageLength = this.defaultPerPageOption.length;
		
		for(var i = 0 ; i < perPageLength ; i++){
			dojo.create("option",{value:this.defaultPerPageOption[i], innerHTML:this.defaultPerPageOption[i]},this.resultsPerPageNode);
		}
		var configValue = EDR.config.preferences_resultsRange;
		//if there is a config value differed from default values
		if(!this.hasConfigValue(configValue)){
			var configOption = dojo.create("option",{value:configValue, innerHTML:configValue},this.resultsPerPageNode,"first");
		}
		this.perPageSelectBox = new dojox.form.DropDownSelect({id:EDR.prefix+"resultsPerPage"},this.resultsPerPageNode);
		this.perPageSelectBox.attr("value", configValue);
		
		if(!EDR.isRestoreSessionResults) {
			this.perPageSelectBox.onChange = function(value) {
				EDR.bean.Email.switchResultsPerPage(value);	
			};			
		} else {
			this.perPageSelectBox.onChange = function(value) {
				if(!EDR.bean.Email.ignoreChange) {
					EDR.bean.Email.switchResultsPerPage(value);	
				}
			};
		}
		
	},
	
	hasConfigValue: function(configValue){
		return (dojo.some(this.defaultPerPageOption, function(value) {
			return value == configValue;
		}));
	},
	
	//this method is called after preferences are saved
	updateResultPerPage: function(configValue){
		this.clearResultPerPage();
		var resultsPerPageNode = dojo.byId(EDR.prefix+"resultsPerPageSelect");
		var perPageLength = this.defaultPerPageOption.length;
		for(var i = 0 ; i < perPageLength ; i++){
			var configOption = dojo.create("option",{value:this.defaultPerPageOption[i], innerHTML:this.defaultPerPageOption[i]},resultsPerPageNode);
		}
		if(!this.hasConfigValue(configValue)){
			var configOption = dojo.create("option",{value:configValue, innerHTML:configValue},resultsPerPageNode,"first");
		}
		this.perPageSelectBox = new dojox.form.DropDownSelect({id:EDR.prefix+"resultsPerPage"},resultsPerPageNode);
		this.perPageSelectBox.attr("value", configValue);
		
		if(!EDR.isRestoreSessionResults) {
			this.perPageSelectBox.onChange = function(value) {
				EDR.bean.Email.switchResultsPerPage(value);
			};
		} else {
			this.perPageSelectBox.onChange = function(value) {
				if(!EDR.bean.Email.ignoreChange) {
					EDR.bean.Email.switchResultsPerPage(value);
				}
			};
		}
	},
	
	clearResultPerPage: function(){
		if(this.perPageSelectBox){
			this.perPageSelectBox.destroy();
			dojo.create("select",{id:EDR.prefix+"resultsPerPageSelect",dojoAttachPoint:"resultsPerPageNode"},this.resultsPerPageDiv);
		}
	},
	
//	_onOpenDropDown: function() {
//		widgets.analytics.hideAnalyticsPane();
//	},
//	
//	_onCloseDropDown: function() {
//		widgets.analytics.showAnalyticsPane();
//	},
	
	showDocumentButtons: function() {
		dojo.style(this.documentButtons, "display", "");
		dojo.style(this.resultCountRangeDiv, "visibility", "visible");
		dojo.style(this.resultCountLeftParen, "visibility", "visible");
		dojo.style(this.resultCountRightParen, "visibility", "visible");
		dojo.style(this.showHideSearchAreaButton, "display", "hidden");
		if (EDR.isTextAnalyticsEnabled && this.deepInspectionEnabled) {
			this.hideDeepInspectionButton();
		}
		if (EDR.isTextAnalyticsEnabled /*&& this.cognosIntegrationEnabled*/) {
			this.hideCognosIntegrationButton();
		}
//		dojo.style(this.analyticsButtons, "display", "none");
	},
	
	hideDocumentButtons: function() {
		dojo.style(this.documentButtons, "display", "none");
		dojo.style(this.resultCountRangeDiv, "visibility", "hidden");
		dojo.style(this.resultCountLeftParen, "visibility", "hidden");
		dojo.style(this.resultCountRightParen, "visibility", "hidden");
//		dojo.style(this.analyticsButtons, "display", "");
		if (EDR.isTextAnalyticsEnabled && this.deepInspectionEnabled) {
			this.showDeepInspectionButton();
		}
		if (EDR.isTextAnalyticsEnabled /*&& this.cognosIntegrationEnabled*/) {
			this.showCognosIntegrationButton();
		}
		if(dojo.isIE<=7){
			var td = this.pageNumbers.parentNode.parentNode;
			dojo.style(td,"width",dojo.contentBox(td).w);
			dojo.style(this.resultsPagination,dojo.contentBox(td).w);
		}
	},
	
	_showHideSearchAreaClicked: function() {
		if (EDR.isQueryAreaHidden) {
			dijit.byId(EDR.prefix+"searchPane").showQueryArea();
		} else {
			dijit.byId(EDR.prefix+"searchPane").hideQueryArea();
		}
	},
	
	toggleShowHideAreaButton: function(isHidden) {
		if (isHidden) {
			this.showHideSearchAreaButton.attr("alt", this.messages_tooltip_show_queryarea);
			this.showHideSearchAreaButton.attr("title", this.messages_tooltip_show_queryarea);
		} else {
			this.showHideSearchAreaButton.attr("alt", this.messages_tooltip_hide_queryarea);
			this.showHideSearchAreaButton.attr("title", this.messages_tooltip_hide_queryarea);
		}
	},
	
	enableDeepInspectionButton: function(enabled) {
		if (!EDR.isTextAnalyticsEnabled) return;
		this.deepInspectionEnabled = enabled;
		if (this.deepInspectionEnabled && this.documentButtons.style.display == "none") {
			this.showDeepInspectionButton();
		} else {
			this.hideDeepInspectionButton();
		}
	},
	
	showDeepInspectionButton: function() {
		dojo.style(this.deepInspectionDialogButton.domNode, "display", "");		
	},
	
	hideDeepInspectionButton: function() {
		dojo.style(this.deepInspectionDialogButton.domNode, "display", "none");		
	},
	
	showCognosIntegrationButton: function() {
		dojo.style(this.cognosIntegrationDialogButton.domNode, "display", "");		
	},
	
	hideCognosIntegrationButton: function() {
		dojo.style(this.cognosIntegrationDialogButton.domNode, "display", "none");		
	},
	
	enableExportButton: function(enabled) {
		dojo.style(this.exportSearchDialogButton.domNode, "display", enabled ? "" : "none");		
	},
	
	changeOptionsState: function(docCacheEnabled) {
		var exportSearch = dijit.byId(EDR.prefix+"exportSearchContent");
		exportSearch.changeOptionsState(docCacheEnabled);
	},
	
	changeSecureMode: function(secure) {
		this._secureMode = secure;
		
		if(this._secureMode) {
			dojo.style(this.nextMoreImg.parentNode, "display", "none");	
			dojo.style(this.previousMoreImg.parentNode, "display", "none");
			dojo.style(this.pageNumbers, "display", "none");
			dojo.style(this.resultCountAllSpan, "display", "none");
			dojo.style(this.resultCountLeftParen, "display", "none");
			dojo.style(this.resultCountRightParen, "display", "none");
		} else {
			dojo.style(this.nextMoreImg.parentNode, "display", "");	
			dojo.style(this.previousMoreImg.parentNode, "display", "");
			dojo.style(this.pageNumbers, "display", "");
			dojo.style(this.resultCountAllSpan, "display", "");
			dojo.style(this.resultCountLeftParen, "display", "");
			dojo.style(this.resultCountRightParen, "display", "");
		}
		
	},
	
	_setPromptMessage: function(message) {
		// hide other parts
		if(dojo.isIE && dojo.isIE <= 7) {
			dojo.style(this.toolbarInfo, "display", "block");
		} else {
			dojo.style(this.toolbarInfo, "display", "table-row");
		}
		dojo.style(this.toolbarBody, "display", "none");
		this.toolbarPrompt.innerHTML = message;
	},
	
	_prepareDisplayResults: function(searchResult) {
		// show hidden parts
		dojo.style(this.toolbarInfo, "display", "none");
		if(dojo.isIE && dojo.isIE <= 7) {
			dojo.style(this.toolbarBody, "display", "block");
		} else {
		dojo.style(this.toolbarBody, "display", "table-row");
		}
		
		if (this.searchBackwardButton != null) {
			this.searchBackwardButton.setDisabled(this._testMode ? false : !searchResult.hasPreviousQuery);
		}
		if (this.searchForwardButton != null) {
			this.searchForwardButton.setDisabled(this._testMode ? false : !searchResult.hasNextQuery);
		}
	},
	
	_renderTestdata: function() {
		var args = {
			url: this.testData,
			handleAs: "json",
			load: dojo.hitch(this, "_onTestdataLoadComplete")
		};
		dojo.xhrGet(args);
	},	
	
	_onTestdataLoadComplete: function(data) {
		this._prepareDisplayResults();
		this._processSearchResults_0(data);
	},
	
	_searchBackwardButtonClick: function(evt) {
		dijit.byId(EDR.prefix+"searchManager").submitPreviousSearch();
	},
	
	_searchForwardButtonClick: function(evt) {
		dijit.byId(EDR.prefix+"searchManager").submitNextSearch();
	},
	
	_expandResultsButtonClick: function(evt) {
		var button = this.expandResultsButton;
		if(this._detailsExpanded) {
			this._detailsExpanded = false;
			dojo.attr(button,"iconClass", "expandResultsIcon");
			dojo.attr(button,"alt",this.messages_tooltip_expandResults_open);
			dojo.attr(button,"title",this.messages_tooltip_expandResults_open);
		} else {
			this._detailsExpanded = true;
			dojo.attr(button,"iconClass", "collapseResultsIcon");
			dojo.attr(button,"alt",this.messages_tooltip_expandResults_close);
			dojo.attr(button,"title",this.messages_tooltip_expandResults_close);
		}
		dojo.publish("expandDetails", [this._detailsExpanded]);		
	},
	
	_openConfigDialogButtonClick: function(evt) {
		var dlg = dijit.byId(EDR.prefix+"preference");
		if(!dlg) {
			dojo.require["dojo.parser"];
			dojo.parser.parse(EDR.prefix+"preference-Container");
			dlg = dijit.byId(EDR.prefix+"preference");
		}
		dlg.showTab(EDR.prefix+"resultsOptionsTab");
		EDR.dialog.util.show(dlg);
	},
	
	openSaveDialog: function(evt) {
		var content = dijit.byId(EDR.prefix+"saveSearchContent"); 
		if(!content) {
			dojo.parser.parse(EDR.prefix+"saveSearchDialog-Container");
			content = dijit.byId(EDR.prefix+"saveSearchContent");
		}
		content.setQuery(this._lastQuery);		
		var dialog = dijit.byId(EDR.prefix+"saveSearchDialog");
		dialog.attr("title", EDR.messages.dialog_saveSearch);
		dialog.okButtonNode.setLabel(this.messages_button_save);
		dialog.okButtonNode.titleNode.title = this.messages_button_save;
		EDR.dialog.util.show(dialog);
	},
	
	openExportDialog: function(evt) {
		var dialog = dijit.byId(EDR.prefix+"exportSearchContent");
		dialog.clear();
		var dialog = dijit.byId(EDR.prefix+"exportSearchDialog");
//		dialog.attr("title", "Export This Query");
		EDR.dialog.util.show(dialog);
	},
	
	openDeepInspectionDialog: function(evt) {
		var dialog = dijit.byId(EDR.prefix+"deepInspectionContent");
		dialog.clear();
		var dialog = dijit.byId(EDR.prefix+"deepInspectionDialog");
//		dialog.attr("title", "Export This Query");
		EDR.dialog.util.show(dialog);
	},
	
	openCognosIntegrationDialog: function(evt) {
		var dialog = dijit.byId(EDR.prefix+"cognosIntegrationContent");
		dialog.clear();
		var dialog = dijit.byId(EDR.prefix+"cognosIntegrationDialog");
//		dialog.attr("title", "Export This Query");
		EDR.dialog.util.show(dialog);		
	},
	
	updateResultCount: function(start/*int*/, end/*int*/, all/*int*/, estimated/*int*/) {
		var message = EDR.messages.text_results_range;
		message = message.replace("\{0\}", start <= end ? start : end);
		message = message.replace("\{1\}", end);
		message = message.replace("\{2\}", this._secureMode ? estimated : all);
		
		var str = EDR.messages.text_results_all;
		if(EDR.isTextAnalyticsEnabled) {
			var numberOfDocs = dijit.byId(EDR.prefix+"searchManager")._numberOfDocs;
			var allString = estimated + "/" + numberOfDocs;
			str = str.replace(/\{0\}/g, allString);
		} else {
			str = str.replace(/\{0\}/g, estimated);	
		}		
		
		this.resultCountRangeDiv.innerHTML = message;
		this.resultCountAllSpan.innerHTML = str;
	},
	

	updatePageLink: function(current, start, end, hasNext, hasPrev) {
		dojo.empty(this.pageNumbers);
		for(var i = start; i<=end; i++) {
			if(i == current) {
				dojo.create("span", {className: "current", innerHTML: i, id: EDR.prefix+"results-current-page"}, this.pageNumbers);
			} else {
				var a = dojo.create("a", {innerHTML: i, id: EDR.prefix+"results-page-"+i, className: "active", href: "javascript:;"}, this.pageNumbers);
				//for IE
				a.onclick=function(){
					var num=i;
					return function(){
						EDR.bean.Email.pageThruEmails(num);
					};
				}();
			}
			dojo.place(dojo.doc.createTextNode(" "), this.pageNumbers);
		}
		if(this._secureMode) {
			this._enableNext(hasNext);
			this._enablePrev(hasPrev);
		} else {
			if(start < current) {
				this._enablePrev(true);
			} else {
				this._enablePrev(false);
			}
			if(current < end) {
				this._enableNext(true);
			} else {
				this._enableNext(false);
			}
			if(current - start > 1) {
				this._enablePrevMore(true);
			} else {
				this._enablePrevMore(false);
			}
			if(end - current > 1) {
				this._enableNextMore(true);
			} else {
				this._enableNextMore(false);
			}
		}
	},

	_enablePrev: function(flag) {
		this._enableButton(flag, "previous");
	},
	
	_enablePrevMore: function(flag) {
		this._enableButton(flag, "previous", true);
	},	
	
	_enableNext: function(flag) {
		this._enableButton(flag, "next");
	},

	_enableNextMore: function(flag) {
		this._enableButton(flag, "next", true);
	},
	
	_enableButton: function(flag, type, more) {
		var buttonImg = this[type + (more? "More":"") + "Img"];
		dojo.attr(buttonImg, "enable", flag);
		if(flag) {
			dojo.attr(buttonImg, "src", EDR.contextPath + "/images/" + type + "_" + (more? "set" : "page") + "12.png");
		} else {
			dojo.attr(buttonImg, "src", EDR.contextPath + "/images/" + type + "_" + (more? "set" : "page") + "12_d.png");
		}
	},
	
	_onPrevNextButtonMouseOver: function(evt) {
		var img = evt.target;
		if(dojo.attr(img, "enable")) {
			var type = dojo.attr(img, "buttonType");
			var more = dojo.attr(img, "amount") == "more";
			dojo.attr(img, "src", EDR.contextPath + "/images/" + type + "_" + (more? "set" : "page") + "12_h.png");
		}
	},

	_onPrevNextButtonMouseOut: function(evt) {
		var img = evt.target;
		if(dojo.attr(img, "enable")) {
			var type = dojo.attr(img, "buttonType");
			var more = dojo.attr(img, "amount") == "more";
			dojo.attr(img, "src", EDR.contextPath + "/images/" + type + "_" + (more? "set" : "page") + "12.png");			
		}
	},
	
	prevNextButtonExecute: function(img) {
		if(dojo.attr(img, "enable")) {
			var type = dojo.attr(img, "buttonType");
			var amountType = dojo.attr(img, "amount");
			var amount = 1;
//			if(amountType == "more") {
//				amount = this.moreAmount;
//			}
			var pageTo = this._currentPage;
			if(!this._secureMode) {
				if(type == "previous") {
					pageTo -= amount;
					if(pageTo < 1 || amountType == "more") {
						pageTo = 1;
					}
				} else {
					pageTo += amount;
					if(pageTo > this._lastPage || amountType == "more") {
						pageTo = this._lastPage;
					}
				}
				EDR.bean.Email.pageThruEmails(pageTo);
			} else {
				if(type == "previous") {
					pageTo = "previous";
				} else {
					pageTo = "next";
				}
				EDR.bean.Email.pageThruEmails(pageTo);
			}
		}
	},

	_onPrevNextButtonClick: function(evt) {
		this.prevNextButtonExecute(evt.target);		
	},
	
	_onPrevNextButtonEnter: function(evt) {
		if(evt.keyCode == dojo.keys.ENTER){
			this.prevNextButtonExecute(evt.target.getElementsByTagName("img")[0]);
		}
	},
	
	_processSearchResults: function(evt) {
		var m = dijit.byId(EDR.prefix+"searchManager");
		var searchResult = m.getSearchResult();
		
		this._lastQuery = searchResult.fullQuery;
		this._prepareDisplayResults(searchResult);
		this._processSearchResults_0(searchResult);
	},
	
	_processSearchResults_0: function(searchResult) {
		var availableCount = searchResult.availableNumberOfResults;
		var estimatedCount = searchResult.estimatedNumberOfResults;
		var resultsPerPage = searchResult.resultsPerPage;
		var lastPage = this._lastPage = Math.ceil(availableCount / resultsPerPage);
		
		var pageStart = searchResult.pageStartRange;
		var pageEnd = searchResult.pageEndRange;
		this.updateResultCount(pageStart + 1, pageEnd, availableCount, estimatedCount);
		
		var currentPage = this._currentPage = searchResult.currentPage;
		var startPage = this._startPage = searchResult.startPage;
		var endPage = this._endPage = searchResult.endPage;
		var hasNext = searchResult.pageEndRange - searchResult.pageStartRange >= searchResult.resultsPerPage ? true : false;
		var hasPrev = searchResult.pageStartRange > 0 ? true : false;
		this.updatePageLink(currentPage, startPage, endPage, hasNext, hasPrev);
		
		if(EDR.isRestoreSessionResults) {
			var currentPerPage = this.perPageSelectBox.attr("value");
			if(currentPerPage != searchResult.resultsPerPage) {
				EDR.bean.Email.ignoreChange = true;
				this.perPageSelectBox.attr("value", searchResult.resultsPerPage);
				EDR.bean.Email.ignoreChange = false;
			}
			
			var currentFilterType = this.filterBySelectBox.attr("value");
			if(currentFilterType != searchResult.resultsFilterType) {
				EDR.bean.Email.ignoreChange = true;
				this.filterBySelectBox.attr("value", searchResult.resultsFilterType);
				EDR.bean.Email.ignoreChange = false;
			}
		}
	},
	
	_processCollectionChanged: function() {
	   if (EDR.isTextAnalyticsEnabled) return;
      this._setPromptMessage(EDR.messages.prompt_beforeSearch);
	},
	
	_verticalFacetChanged: function(message) {
		var verticalFacetId = message.verticalFacetLabel || message.verticalFacetId;
		this.verticalFacetIdSpan.innerHTML = verticalFacetId;
	},
	
	_horizontalFacetChanged: function(message) {
		var horizontalFacetId = message.horizontalFacetLabel || message.horizontalFacetId;
		this.horizontalFacetIdSpan.innerHTML = horizontalFacetId;
	},
	
	_resetButtonClicked: function(evt) {
		dijit.byId(EDR.prefix+"searchManager").submitQuickKeywordSearch("*:*");		
		//dijit.byId(EDR.prefix+"categoryTree").unselectAll();
	},
	
	
	__dummy__: ''
});

}

if(!dojo._hasResource["widgets.ResultBottomBar"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.ResultBottomBar"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.ResultBottomBar");





dojo.declare(
"widgets.ResultBottomBar",
[dijit._Widget, dijit._Templated],
{
	_height: 0,
	
	_visible: false,
	
	widgetsInTemplate: true,
	templateString:"<div style='padding-left: 2em;padding-top: 0.3em; padding-bottom: 0.3em;max-height: 4em;' class=\"ResultBottomBar\">\n\t<div dojoAttachPoint='promptSearchFor' style='width: 100%;font-size: 120%;'></div>\n</div>\n",
	
	_lastQuery: '',
	_lastQueryLanguage: '',
	_lastSpellCorrections: null,
	_messageTemplate: EDR.messages.resultbottombar_label_searchedFor,
	
	postCreate: function() {
		if(EDR.isTextAnalyticsEnabled) {
			this._messageTemplate = EDR.messages.resulttoolbar_label_exploredOn;
		}
		this._height = dojo.contentBox(this.domNode).h;
		dojo.style(this.domNode, "display", "none");
		
		dojo.subscribe("postLoad", this, "_processSearchResults");
      dojo.subscribe("collectionChanged", this, "_processCollectionChanged");
	},
	

	show: function() {
		if (EDR.isQueryAreaHidden) return;
		this._visible = true;
		var anim = dojo.fx.wipeIn({node: this.domNode, duration: 1000});
		var _this = this;
		anim.onEnd = function() {
			var resultsBorderLayout = dijit.byId(EDR.prefix+"horizontalSearchPanes");
			if(resultsBorderLayout) {
				resultsBorderLayout.resize();
			}
			_this.domNode.style.overflow = "auto";
		};
		anim.play();
	},
	
	hide: function() {
		var anim = dojo.fx.wipeOut({node: this.domNode, duration: 1000});
		anim.play();
		this._visible = false;
	},

	_processSearchResults: function(evt) {
		var m = dijit.byId(EDR.prefix+"searchManager");
		var searchResult = m.getSearchResult();
		
		this.updateInfo(searchResult);
	},
	
	_processCollectionChanged: function() {
      if (EDR.isTextAnalyticsEnabled) return;
      this.hide();
      // hide it imeediately
      dojo.style(this.domNode, "display", "none");
	},
	
	showMessage: function(message) {
		this.domNode.style.overflow = "auto";
		dojo.empty(this.promptSearchFor);
		this.promptSearchFor.appendChild(dojo.doc.createTextNode(message));
		if(!this._visible) {
			this.show();
		}
	},
	
	revertMessage: function() {
		if (this._lastQuery != null && this._lastQuery.length != 0) {
			var m = dijit.byId(EDR.prefix+"searchManager");
			var searchResult = m.getSearchResult();

			var message = this._messageTemplate.replace("\{0\}", this._lastQuery);
			message += this.getQueryLanguage(this._lastQueryLanguage);
			message += this.getSpellCorrection(this._lastSpellCorrections, searchResult);
			message += this.getSynonymExpansion(this._synonymExpansions, this._userFeedBack, this._userFeedBackConcepts);
			this.promptSearchFor.innerHTML = message;
		} else {
			this.promptSearchFor.innerHTML = "";
			if(this._visible) {
				this.hide();
			}
		}
	},
	
	updateInfo: function(result) {
		var node = this.promptSearchFor;
		dojo.empty(node);
		
		var query = this._lastQuery = result.fullQuery;
		var message = this._messageTemplate.replace("\{0\}", query);
		node.appendChild(dojo.doc.createTextNode(message));
		dojo.style(this.domNode, "height", "auto");
		
		var queryLanguage = this._lastQueryLanguage = result.queryLanguage;
		dojo.create("span", {innerHTML: this.getQueryLanguage(queryLanguage)}, node);
		
		var spellCorrections = this._lastSpellCorrections = result.spellCorrections;;
		dojo.create("span", {innerHTML: this.getSpellCorrection(spellCorrections, result)}, node);
		
		var synonymExpansions = this._synonymExpansions = result.synonymExpansions;
		var userFeedBack = this._userFeedBack = result.userFeedBack;
		var userFeedBackConcepts = this._userFeedBackConcepts = result.userFeedBackConcepts;
		dojo.create("span", {innerHTML: this.getSynonymExpansion(synonymExpansions, userFeedBack, userFeedBackConcepts)}, node);
		
		if(result.dupEliminated) {
//			message += "<br />"+ EDR.messages.text_results_omitted;
//			message += "&nbsp";
			dojo.create("br", null, node);
			node.appendChild(dojo.doc.createTextNode(EDR.messages.text_results_omitted + " "));
//			var link = '<a onclick="EDR.bean.Email.searchAllResults()" href="javascript:;">' + EDR.messages.text_results_show_duplicates + '</a>';
//			message += link;
			dojo.create("a", {href: "javascript:;", innerHTML: EDR.messages.text_results_show_duplicates}, node);
			a.onclick = function() {
				EDR.bean.Email.searchAllResults();
			}
		}
		
		if(result.predefinedResults) {
//			message += "<br /><b>"+ EDR.messages.text_field_predefinedLinks + "</b>";
			dojo.create("br", null, node);
			dojo.create("b", {innerHTML: EDR.messages.text_field_predefinedLinks}, node);
			var results = result.predefinedResults;
			for(var i=0; i<results.length; i++) {
//				var content = '<br /><a href="' + results[i].documentID + '">' + results[i].title + '</a>: ' + results[i].description;
//				message += content;
				dojo.create("br", null, node);
				dojo.create("a", {href: results[i].documentID, innerHTML: results[i].title}, node);
				node.appendChild(dojo.doc.createTextNode(": " + results[i].description));
			}
		}
		// extraQueryData
		if(EDR.config["extraQueryData_show"] == "true") {
			var aclMessage = EDR.messages.prompt_show_ACL + ":" + result.decodedSecurityContext;
			node.appendChild(dojo.doc.createTextNode(aclMessage));
		}
		
//		this.promptSearchFor.innerHTML = message;
		if(!this._visible) {
			this.show();
		}
		// temp fix
		var resultsBorderLayout = dijit.byId(EDR.prefix+"horizontalSearchPanes");
		if(resultsBorderLayout) {
			resultsBorderLayout.resize();
		}
	},
	
	getQueryLanguage: function(queryLang) {
		var message = "&nbsp;&nbsp;" + this.escapeHtml(EDR.messages.resultsOption_label_lang) + ":&nbsp;" + this.escapeHtml(queryLang);
		return message;
	},

	getSpellCorrection: function(spellCorrections, result) {
		var message = "";
		var fullQuery = result.fullQuery;
		for (var i=0; i<spellCorrections.length; i++) {
			var suggestions = spellCorrections[i].data;
			var misspelled = spellCorrections[i].qSubstr;
			var words = "";
			for (var j=0; j<suggestions.length; j++) {
				var suggestion = this.escapeSingleQuoteAndBackSlash(this.escapeHtml(suggestions[j]));
				var match = suggestion.match(/^&quot;(.*)&quot;$/); 
				if(match) {
					suggestion = match[1];
				}
				if(EDR.config["spellCorrections_keepOriginalQueryTerms"] == "true") {
					suggestion = fullQuery.replace(misspelled, suggestion);
					suggestion = suggestion.replace(/"/g, "&quot;")
				}
				words += "&nbsp;&nbsp;" + "<a onclick=\"EDR.dijit.byId('"+EDR.prefix+"searchManager').submitQuickKeywordSearch('" + suggestion + "');\"" +
					" href='javascript:;'><b>" + this.escapeHtml(suggestions[j]) + "</b></a>";
			}
			message += "<span style='margin-left:10px;'>/</span>";
			message += "<span style='margin-left:15px;'>" + EDR.messages.text_field_spellCorrections.replace("\{0\}", words) + "</span>";
		}
		return message;
	},
	
	getSynonymExpansion: function(synonymExpansions, userFeedBack, userFeedBackConcepts) {
		var message = "&nbsp;&nbsp;";
		// synonym expansion
		for (var i=0; i<synonymExpansions.length; i++) {
         var item = synonymExpansions[i];
		   var from = this.escapeHtml(item.querySubstring);
		   var to = this.escapeHtml(item.expandedQuery);
			message += "<span style='margin-left:10px;'>/</span>";
			message += "<span style='margin-left:12px;'>" + 
				EDR.messages.text_field_synonymExpansion.replace("\{0\}", from).
					replace("\{1\}", to) + "</span>";
		}
		
		// user feedback
		if (userFeedBack != null) {
			message += "<span style='margin-left:10px;'>/</span>";
			message += "<span style='margin-left:12px;'>" + 
			EDR.messages.text_field_synonymExpansionSemantic + ":" + this.escapeHtml(userFeedBack) + "</span>";		
		}
		
		// user feedback concepts
		if (userFeedBack && userFeedBackConcepts) {
			message += "<span style='margin-left:10px;'>/</span>";
			if(userFeedBackConcepts) {
				message += "<span style='margin-left:12px;'>" + 
				EDR.messages.text_field_synonymExpansionSemanticConcepts + ":" + this.escapeHtml(userFeedBackConcepts) + "</span>";		
			}
		}
		
		return message;
	},
	
	escapeHtml: function(value) {
	     return value
	         .replace(/&/g, "&amp;")
	         .replace(/</g, "&lt;")
	         .replace(/>/g, "&gt;")
	         .replace(/"/g, "&quot;");
	},
	
	escapeSingleQuoteAndBackSlash: function(value) {
	     return value
	     	.replace(/\\/g, "\\\\")
	     	.replace(/'/g, "\\'");
	},
	
	__dummy__: ''
});

}

if(!dojo._hasResource["widgets.ResultsBorderContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.ResultsBorderContainer"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.ResultsBorderContainer");



dojo.declare(
"widgets.ResultsBorderContainer",
dijit.layout.BorderContainer,
{
	postCreate: function() {
		this.inherited("postCreate", arguments);
		this.connect(dijit.byId(EDR.prefix+"results-container"), "resize", "layout");
	},	
	
	layout: function() {
		var parentNode = this.domNode.parentNode;
		var parentHeight = dojo.contentBox(parentNode).h;
		var offsetTop = this.domNode.offsetTop;
		var height = parentHeight - offsetTop;
		dojo.style(this.domNode, "height", height + "px");

		this.inherited(arguments);
	}
});

}

if(!dojo._hasResource["widgets.ResultsHeader"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.ResultsHeader"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.ResultsHeader");





dojo.declare(
"widgets.ResultsHeader",
[dijit._Widget, dijit._Templated],
{
	widgetsInTemplate: false,
	templateString:"<div>\n  <table class=\"resizableTable searchResultsHeaderTable\" dojoAttachPoint=\"searchResultsHeaderTable\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" scrollableContent=\"email-results-border\" style=\"border-top:1px solid black; border-bottom: 1px solid black;\">\n    <thead>\n      <tr dojoAttachPoint=\"headerRow\"></tr>\n    </thead>\n  </table>\n</div>\n\n",
	_headerWidth: {"title": 340},
	FILETYPE_WIDTH: 160,
	FILETYPE: "filetype",
	THUMBNAIL_WIDTH: 140,
	THUMBNAIL: "thumbnail",
	DEFAULT_WIDTH: 90,
	
	postCreate: function() {
//		this.sortImgRelevance.src = dojo.moduleUrl("widgets", "templates/images/arrow_down_blue8.png");
	
		dojo.subscribe("headerColumnsChanged", this, "_onChangeHeaderColumns");	
		dojo.subscribe("headerColumnsResized", this, "_onResized");
		dojo.subscribe("postLoad", this, "_onChangeHeaderColumns");
	},
	
	getWidth: function(columnName) {
		if(columnName) {
		var th = dojo.byId(EDR.prefix+"resultsHeader_"+columnName);
		if(th) {
			return th.clientWidth;
		} else {
			return -1;
		}
		} else {
			// return whole width
			return this.searchResultsHeaderTable.clientWidth;
	
		}
	},
	
	_onResized: function() {
		var row = this.headerRow;
		var cols = row.cells;
		var length = cols.length;
		var resizers = dojo.query("div.columnResizer",this.headerRow);
		var sumWidth = 0;
		for(var i=0; i<length; i++) {
			var width = dojo.contentBox(resizers[i].parentNode).w;
			this._headerWidth[dojo.attr(cols[i], "columnName")] = width;
			sumWidth += width;
		}
		var container = dijit.byId(EDR.prefix+"documentViewId").domNode;
		if(length>0){
			var contentWidth = dojo.contentBox(container.parentNode.parentNode).w; 
			if(sumWidth < contentWidth){
				var index = (dojo.isIE <= 8 && length > 1) ? length - 2 : length - 1; 
				var width = dojo.contentBox(resizers[index].parentNode.parentNode).w;
				var change = contentWidth - sumWidth;
				var newWidth = width + change;
				this._headerWidth[dojo.attr(cols[index], "columnName")] = newWidth;
				dojo.contentBox(resizers[index].parentNode.parentNode,{w:newWidth});
				dojo.contentBox(container,{w:(sumWidth+change-2)});
			}else{
				dojo.contentBox(container,{w:sumWidth-2});
			}
		}
	},
	
	_renderHeader: function(cols) {
		var searchManager = dijit.byId(EDR.prefix+"searchManager");
		
		dojo.empty(this.headerRow);
		
		var _capitalize = function(str) {
			return (str.substring(0,1).toUpperCase() + str.substring(1));
		};
		
		var tr = this.headerRow;
//		if(!searchManager || searchManager.needNarrowResults())
//		{
//			this._renderNarrowresults(tr);
//		}
		
		var sortKey = "relevance";
		var sortKeys = [];
		var sortableFields = [];
		var sortOrder = "dsc";

		if(searchManager) {
			var results = searchManager.getSearchResult();
			if(results) {
				sortKey = results.sortKey;
				sortKeys = sortKey.split(":");
				for(var i=0; i<sortKeys.length; ++i) {
					if(sortKeys[i] == "[Relevance]") {
						sortKeys[i] = "relevance";
					} else if(sortKeys[i] == "[Date]") {
						sortKeys[i] = "date";
					}
				}
				sortOrder = results.sortOrder;
				if(sortOrder != null) {
					var sortOrders = sortOrder.split(":");
					sortOrder = sortOrders[0];
				}
				
				var columns = results.resultColumns.columns;
				for(var i=0; i<columns.length; ++i) {
					if(columns[i].sortable) {
						sortableFields.push(columns[i].name);
					}
				}
			} else {
				// use default values
			}
		}
		
		for(var i=0; i<cols.length; i++) {
			var col = cols[i];
			this._renderHeaderColumn(tr, col, sortKeys, sortOrder, sortableFields);
		}
	},
	
	_renderNarrowresults: function(tr) {
		var th = dojo.create("th", {style: "width: 216px;max-width:216px;min-width:216px;", columnName: "narrowresults"}, tr);
		var outerDiv = dojo.create("div", {className: "tableHeaderCell searchResultSelection", resizeableColumnBodyPrefixID: "searchResultCol1", id:EDR.prefix+"searchResultSelectionHeaderCell",style:"width:214px"}, th);
//		var outerDiv = dojo.create("div", {className: "tableHeaderCell searchResultSelection", id:"searchResultSelectionHeaderCell", style:"width:214px"}, th);
		dojo.attr(outerDiv, "columnWidth", 216);
		var contentDiv = dojo.create("div", {className: "tableHeaderCellContent", style: "width: 210px;", innerHTML: EDR.messages.columns_narrowresults}, outerDiv);
		this._addColumnResizer(outerDiv, false);
	},
	
	_renderHeaderColumn: function(tr, col, sortKeys, sortOrder, sortableFields) {
		//example
		//<th id="resultsHeader_columnName">
        //  <div style="width: 100px" class="tableHeaderCell searchResultFlags" resizeableColumnBodyPrefixID="searchResultCol_relevance">
		//    <div class="tableHeaderCellContent">
		//      <span>
		//        <a class="sortKey currentKey" href="javascript:;">
		//          Relevance<img dojoAttachPoint="sortImgRelevance" src="images/arrow_down_blue8.png" 
		//            title="" alt=""/><span class="tableHeaderCellContentSpacer">&nbsp;</span></a>
		//      </span>
		//    </div>
        //    <div class="columnResizer" onmousedown="EDR.util.ResizableTable.startResize(event)">|</div>
		//  </div>
		//</th>
		//
	var width;
		if(!width) {
			if(this._headerWidth[col]) {
				width = this._headerWidth[col];
			} else {
				//initialize
				if(col==this.FILETYPE){
					this._headerWidth[col] = width = this.FILETYPE_WIDTH;
				}else if(col==this.THUMBNAIL){
					this._headerWidth[col] = width = this.THUMBNAIL_WIDTH;
				}else{
					this._headerWidth[col] = width = this.DEFAULT_WIDTH;
				}
			}
		}
		var args = {id: EDR.prefix+"resultsHeader_"+col, columnName: col};
		var th = dojo.create("th", args, tr);
//		if(col != "thumbnail") {
			dojo.style(th, "width", width + "px");
//		}
		var outerDiv = dojo.create("div", {className: "tableHeaderCell searchResultFlags", resizeableColumnBodyPrefixID: "searchResultCol_"+col}, th);
		dojo.attr(outerDiv, "columnWidth", width);
		var contentDiv = dojo.create("div", {className: "tableHeaderCellContent"}, outerDiv);
		var span;
		if(dojo.indexOf(sortableFields, col) >= 0) {
			span = dojo.create("span", null, contentDiv);
			if(EDR.messages["tooltip_columns_"+col]) {
				dojo.attr(span,"title",EDR.messages["tooltip_columns_"+col]);
			} else {
				var tooltipSortField;
				if(sortKeys[0] == col) {
					if(sortOrder == "ascending") {
						tooltipSortField = EDR.messages.tooltip_sortBy_fieldDescending;
					} else {
						tooltipSortField = EDR.messages.tooltip_sortBy_fieldAscending;
					}
				} else {
					if(sortOrder == "ascending") {
						tooltipSortField = EDR.messages.tooltip_sortBy_fieldAscending;
					} else {
						tooltipSortField = EDR.messages.tooltip_sortBy_fieldDescending;
					}				
				}
				dojo.attr(span,"title",tooltipSortField);
			}
			
			var imgTag = "";
			if(sortKeys[0] == col) {
				if(sortOrder == "descending") {
					var sortedDescending = EDR.messages.prompt_descending_active;
					imgTag = "<img src='" + EDR.contextPath + "/images/arrow_down_blue8.png' alt='"+ sortedDescending +"' title='"+ sortedDescending+"'>";
				} else {
					var sortedAscending = EDR.messages.prompt_ascending_active;
					imgTag = "<img src='" + EDR.contextPath + "/images/arrow_up_blue8.png' alt='"+ sortedAscending +"' title='"+ sortedAscending +"'>";
				}
//				if(sortKeys.length > 1) {
//					imgTag += "<span class='tableHeaderSortByNumber'>" + (sortKeysIndex+1) + "</span>";
//				}				
			}
			
			var field = col;
			if(col == "relevance") field = "[Relevance]";
			var a = dojo.create("a", {href: "javascript:;",innerHTML: (EDR.messages["columns_"+col]?EDR.messages["columns_"+col]:col) + imgTag + "<span class='tableHeaderCellContentSpacer'>&nbsp;</span>"}, span);
			var columnField=field;
			var nextSortOrder;
			if(field == "[Relevance]") {
				nextSortOrder = "descending";
			} else if(field == sortKeys[0] || (field == "date" && sortKeys[0] == "[Date]")) {
				nextSortOrder = sortOrder == "descending" ? "ascending" : "descending";
			} else {
				nextSortOrder = sortOrder;
			}			
			a.onclick=function(field, order){
				return function(){
					EDR.bean.Email.sortByField(columnField, nextSortOrder);
				};
			}(columnField, nextSortOrder);
			
			dojo.addClass(a, "sortKey");
			if(col == sortKeys[0]) {
				dojo.addClass(a, "currentKey");
			}
		} else {
			var headerText = EDR.messages["columns_"+col];
			if(!headerText) {
				headerText = col;
			}
			span = dojo.create("span", {innerHTML: headerText + "<span class='tableHeaderCellContentSpacer'>&nbsp;</span>"}, contentDiv);	
			var tooltip = EDR.messages["tooltip_columns_"+col] ? EDR.messages["tooltip_columns_"+col] : col;
			dojo.attr(span,"title", tooltip);
		}
		this._addColumnResizer(outerDiv, true);		
	},
	
	_addColumnResizer: function(div, resizable) {
		var args ={innerHTML: "|",className: "columnResizer"};
		if(resizable) {
//			args.onmousedown = "EDR.util.ResizableTable.startResize(event)";
			args.onmousedown=function(event){
				EDR.util.ResizableTable.startResize(event);
			};
		}
		//<div class="columnResizer" onmousedown="EDR.util.ResizableTable.startResize(event)">|</div>
		var resizer = dojo.create("div", args, div);
	},
	
	_onChangeHeaderColumns: function(args) {
		var searchManager = dijit.byId(EDR.prefix+"searchManager");
		var cols = searchManager.getColumnDefs();
		this._renderHeader(cols);
	},

	onShow: function() {
		dijit.byId(EDR.prefix+"resultsBody").processCachedSearchResults();
	},
	
	onHide: function() {
	},

	__dummy__: ''
});

}

if(!dojo._hasResource["dojox.image.LightboxNano"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.image.LightboxNano"] = true;
dojo.provide("dojox.image.LightboxNano");


(function(d){

var getViewport = function(){
		//	summary: Returns the dimensions and scroll position of the viewable area of a browser window
		var scrollRoot = (d.doc.compatMode == "BackCompat") ? d.body() : d.doc.documentElement,
			scroll = dojo._docScroll();
		return { w: scrollRoot.clientWidth, h: scrollRoot.clientHeight, l: scroll.x, t: scroll.y };
	},
	abs = "absolute";

d.declare("dojox.image.LightboxNano", null, {
	//	summary:
	//		A simple "nano" version of the lightbox. 
	//
	//	description:
	//		Very lightweight lightbox which only displays a larger image.  There is
	//		no support for a caption or description.  The lightbox can be closed by
	//		clicking any where or pressing any key.  This widget is intended to be
	//		used on <a> and <img> tags.  Upon creation, if the domNode is <img> tag,
	//		then it is wrapped in an <a> tag, then a <div class="enlarge"> is placed
	//		inside the <a> and can be styled to display an icon that the original
	//		can be enlarged.
	//
	//	example:
	//	|	<a dojoType="dojox.image.LightboxNano" href="/path/to/largeimage.jpg"><img src="/path/to/thumbnail.jpg"></a>
	//
	//	example:
	//	|	<img dojoType="dojox.image.LightboxNano" src="/path/to/thumbnail.jpg" href="/path/to/largeimage.jpg">

	//	href: string
	//		URL to the large image to show in the lightbox.
	href: "",

	//	duration: int
	//		The delay in milliseconds of the LightboxNano open and close animation.
	duration: 500,

	//	preloadDelay: int
	//		The delay in milliseconds after the LightboxNano is created before preloading the larger image.
	preloadDelay: 5000,

	constructor: function(p, n){
		// summary: Initializes the DOM node and connect onload event
		var _this = this;

		d.mixin(_this, p);
		n = dojo.byId(n);

		if(!/a/i.test(n.tagName)){
			var a = d.create("a", { href: _this.href, "class": n.className }, n, "after");
			n.className = "";
			a.appendChild(n);
			n = a;
		}

		d.style(n, {
			display: "block",
			position: "relative"
		});
		_this._createDiv("dojoxEnlarge", n);

		_this._node = n;
		d.setSelectable(n, false);
		_this._onClickEvt = d.connect(n, "onclick", _this, "_load");

		setTimeout(function(){
			(new Image()).src = _this.href;
			_this._hideLoading();
		}, _this.preloadDelay);
	},

	destroy: function(){
		// summary: Destroys the LightboxNano and it's DOM node
		var a = this._connects || [];
		a.push(this._onClickEvt);
		d.forEach(a, d.disconnect);
		d.destroy(this._node);
	},

	_createDiv: function(/*String*/cssClass, /*DomNode*/refNode, /*boolean*/display){
		// summary: Creates a div for the enlarge icon and loading indicator layers
		return d.create("div", { "class": cssClass, style: { position: abs, display: display ? "" : "none" } }, refNode); // DomNode
	},
	
	_load: function(/*Event*/e){
		// summary: Creates the large image and begins to show it
		var _this = this;

		d.stopEvent(e);

		if(!_this._loading){
			_this._loading = true;
			_this._reset();

			var n = d.query("img", _this._node)[0],
				a = d._abs(n, true),
				c = d.contentBox(n),
				b = d._getBorderExtents(n),
				i = _this._img = d.create("img", {
					style: {
						visibility: "hidden",
						cursor: "pointer",
						position: abs,
						top: 0,
						left: 0,
						zIndex: 9999999
					}
				}, d.body()),
				ln = _this._loadingNode;

			if(ln == null){
				_this._loadingNode = ln = _this._createDiv("dojoxLoading", _this._node, true)
				var l = d.marginBox(ln);
				d.style(ln, {
					left: parseInt((c.w - l.w) / 2) + "px",
					top: parseInt((c.h - l.h) / 2) + "px"
				});
			}

			c.x = a.x - 10 + b.l;
			c.y = a.y - 10 + b.t;
			_this._start = c;

			_this._connects = [d.connect(i, "onload", _this, "_show")];

			i.src = _this.href;
		}
	},

	_hideLoading: function(){
		// summary: Hides the animated loading indicator
		if(this._loadingNode){
			d.style(this._loadingNode, "display", "none");
		}
		this._loadingNode = false;
	},

	_show: function(){
		// summary: The image is now loaded, calculate size and display
		var _this = this,
			vp = getViewport(),
			w = _this._img.width,
			h = _this._img.height,
			vpw = parseInt((vp.w - 20) * 0.9),
			vph = parseInt((vp.h - 20) * 0.9),
			dd = d.doc,
			bg = _this._bg = d.create("div", {
				style: {
					backgroundColor: "#000",
					opacity: 0.0,
					position: abs,
					zIndex: 9999998
				}
			}, d.body()),
			ln = _this._loadingNode;

		if(_this._loadingNode){
			_this._hideLoading();
		}
		d.style(_this._img, {
			border: "10px solid #fff",
			visibility: "visible"
		});
		d.style(_this._node, "visibility", "hidden");

		_this._loading = false;

		_this._connects = _this._connects.concat([
			d.connect(dd, "onmousedown", _this, "_hide"),
			d.connect(dd, "onkeypress", _this, "_key"),
			d.connect(window, "onresize", _this, "_sizeBg")
		]);

		if(w > vpw){
			h = h * vpw / w;
			w = vpw;
		}
		if(h > vph){
			w = w * vph / h;
			h = vph;
		}

		_this._end = {
			x: (vp.w - 20 - w) / 2 + vp.l,
			y: (vp.h - 20 - h) / 2 + vp.t,
			w: w,
			h: h
		};

		_this._sizeBg();

		d.fx.combine([
			_this._anim(_this._img, _this._coords(_this._start, _this._end)),
			_this._anim(bg, { opacity: 0.5 })
		]).play();
	},

	_sizeBg: function(){
		// summary: Resize the background to fill the page
		var dd = d.doc.documentElement;
		d.style(this._bg, {
			top: 0,
			left: 0,
			width: dd.scrollWidth + "px",
			height: dd.scrollHeight + "px"
		});
	},

	_key: function(/*Event*/e){
		// summary: A key was pressed, so hide the lightbox
		d.stopEvent(e);
		this._hide();
	},

	_coords: function(/*Object*/s, /*Object*/e){
		// summary: Returns animation parameters with the start and end coords
		return {
			left:	{ start: s.x, end: e.x },
			top:	{ start: s.y, end: e.y },
			width:	{ start: s.w, end: e.w },
			height:	{ start: s.h, end: e.h }
		}; // object
	},

	_hide: function(){
		// summary: Closes the lightbox
		var _this = this;
		d.forEach(_this._connects, d.disconnect);
		_this._connects = [];
		d.fx.combine([
			_this._anim(_this._img, _this._coords(_this._end, _this._start), "_reset"),
			_this._anim(_this._bg, {opacity:0})
		]).play();
	},

	_reset: function(){
		// summary: Destroys the lightbox
		d.style(this._node, "visibility", "visible");
		d.forEach([this._img, this._bg], function(n){
			d.destroy(n);
			n = null;
		});
		this._node.focus();
	},

	_anim: function(node, args, onEnd){
		// summary: Creates the lightbox open/close and background fadein/out animations
		return d.animateProperty({
			node: node,
			duration: this.duration,
			properties: args,
			onEnd: onEnd ? d.hitch(this, onEnd) : null
		}); // object
	}
});

})(dojo);

}

if(!dojo._hasResource["widgets.ResultsBody"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.ResultsBody"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.ResultsBody");






dojo.declare(
"widgets.ResultsBody",
dijit._Widget,
{
	
	_columns: null,
	_columnsWidth: null,
	
	_detailsExpanded: false,
	
	testData: "",	//path of testdata
	_testMode: false,
	
	_cachedResults: null,
//	_cachedHtml: '',
	_cachedArray: [],
	
	widgetsInTemplate: false,
	templateString:"<table class=\"email-list\" border=\"0\" cellspacing=\"0\" cellpadding=\"3\" tabindex=\"0\"><tbody dojoAttachPoint=\"tbody\"></tbody></table>\n",
	
	postCreate: function() {
		if(this.testData != "") {
			this._renderTestdata();
		}
//		dojo.subscribe("postLoad", this, "_processSearchResults");
		dojo.subscribe("expandDetails", this, "_expandDetails");
		dojo.subscribe("headerColumnsChanged", this, "_onHeaderColumnsChanged");
		dojo.subscribe("headerColumnsResized", this, "_onHeaderColumnsChanged");
		
		this.connect(this.domNode.parentNode, "onscroll", "_onScroll");

		window["ica_g_openPreview"] = function (event, rowNum) {
			var resultsObj = dijit.byId(EDR.prefix+"searchManager").getSearchResult();
			var result = resultsObj.results[rowNum];
			
			var previewNode = null;
			if(EDR.isTextAnalyticsEnabled) {
				var analyticsPreviewWidget = dijit.byId(EDR.prefix+"analyticsPreviewContent");
				analyticsPreviewWidget.setDocumentParams(result, resultsObj.fullQuery);
				previewNode = analyticsPreviewWidget.previewSplitContainer.domNode;
			}else{
				var content = dijit.byId(EDR.prefix+"previewContent");
				if(!content) {
					dojo.parser.parse(EDR.prefix+"previewDialog-Container");
					content = dijit.byId(EDR.prefix+"previewContent");
				}
				content.setDocumentParams(result, resultsObj.fullQuery);
			}
			var previewContainer = dijit.byId(EDR.prefix+"previewContainer").domNode;
			var windowSize = dojo.contentBox(dojo.body());
			dojo.style(previewContainer, "width", "800px");
			dojo.style(previewContainer, "height", "600px");
			if(windowSize.w < 820) {
				dojo.style(previewContainer, "width", (windowSize.w - 40) + "px");
			}
			if(windowSize.h < 680) {
				dojo.style(previewContainer, "height", (windowSize.h - 100) + "px");
				if(previewNode){
					dojo.style(previewNode, "height", (windowSize.h - 150) + "px");
				}				
			} else {
				if(previewNode) {
					dojo.style(previewNode, "height", "550px");	
				}
			}
			EDR.dialog.util.showById(EDR.prefix+"previewDialog");			
		};

		window["ica_g_onkeydown"] = function(event, rowNum) {
			var evt = dojo.fixEvent(event);
			if(evt.keyCode == dojo.keys.ENTER) {
				ica_g_openPreview(event, rowNum);
			}
		};	
	},
	
	processCachedSearchResults: function() {
		if (this._cachedResults != null) {
			this.renderSearchResult(this._cachedResults);
		}
		this._cachedResults = null;
	},
	
	_processSearchResults: function(evt) {
		var m = dijit.byId(EDR.prefix+"searchManager");
		if(m) {
			var result = m.getSearchResult();
			if(result) {
				if (this.isVisible) {
					this.renderSearchResult(result);
				} else {
					this._cachedResults = result;
				}
			}
		}
	},
	
	refresh: function() {
		this._processSearchResults();
	},
	
	_onHeaderColumnsChanged: function() {
		var m = dijit.byId(EDR.prefix+"searchManager");
		if(m) {
			var result = m.getSearchResult();
			if(result) {
				this._columns = m.getColumnDefs();
				this.renderSearchResult(result);
			}
		}		
	},
	
	_renderTestdata: function() {
		var args = {
			url: this.testData,
			handleAs: "json",
			load: dojo.hitch(this, "_onTestdataLoadComplete")
		};
		dojo.xhrGet(args);
	},
	
	_onTestdataLoadComplete: function(response,ioArgs) {
		this.renderSearchResult(response);
	},
	
	renderSearchResult: function(searchResult) {
		this.clear();
		var results = searchResult.results;
		
		var resultsHeader = dijit.byId(EDR.prefix+"resultsHeader");
		dojo.style(EDR.prefix+"resultsBody", "width", resultsHeader.getWidth() + "px");
		
		if(!this._columns) return;
		
		var columnsLen = this._columns.length;
		this._columnsWidth = new Array();
		for(var i=0; i < columnsLen; i++) {
			var column = this._columns[i];
			var width = resultsHeader.getWidth(column);
			this._columnsWidth.push(width);
		}
		
//		this._cachedHtml += "<table class='email-list' style='width:100%' border='0' cellspacing='0' cellpadding='3' tabindex='0'><tbody dojoAttachPoint='tbody'>";
		this._cachedArray.push("<table class='email-list' style='width:100%' border='0' cellspacing='0' cellpadding='3' tabindex='0'><tbody dojoAttachPoint='tbody'>");
		for(var i=0; i<results.length; i++) {
			this._renderResult(results[i], i, searchResult);
		}
//		this._cachedHtml += "</tbody></table>";
		this._cachedArray.push("</tbody></table>");
//		this.domNode.innerHTML = this._cachedHtml;
		this.domNode.innerHTML = this._cachedArray.join("");

		this._onScroll();
		
		if(EDR.isStretchHeight) {
			this._calcHeight();
		}
	},
	
	_calcHeight: function() {
		var minHeight = 800;
		var strMinHeight = EDR.config.style_minHeight;
		if(strMinHeight && strMinHeight.length > 2) {
			strMinHeight = strMinHeight.substring(0, strMinHeight.length - 2);
			minHeight = strMinHeight - 0;
		}
		
		var bannerHeight = dojo.marginBox(EDR.prefix + "header").h;
		var queryPaneHeight = dojo.marginBox(EDR.prefix + "queryContentPane").h;
		var tabWindow = dijit.byId(EDR.prefix + "horizontalSearchPanes");
		var resultToolbarHeight = dojo.marginBox(tabWindow.resultToolbar.domNode).h;
		var resultBottomBarHeight = dojo.marginBox(tabWindow.resultBottomBar.domNode).h;
		var resultsHeaderHeight = dojo.marginBox(dijit.byId(EDR.prefix + "resultsHeader").domNode).h;
		var resultsBodyHeight = dojo.marginBox(dijit.byId(EDR.prefix + "resultsBody").domNode).h;
		var diff = minHeight - (bannerHeight + queryPaneHeight + resultToolbarHeight + resultBottomBarHeight + resultsHeaderHeight + resultsBodyHeight);
		if(diff > 0) {
			resultsBodyHeight += diff;
		}
		
		dojo.marginBox(EDR.prefix + "resultsBodyContainer", {h: resultsBodyHeight});
		var borderContainer = tabWindow.resultsBodyContainer;
		dojo.marginBox(borderContainer.domNode, {h: resultsHeaderHeight + resultsBodyHeight });
		var horizontalSearchPanesHeight = resultToolbarHeight + resultBottomBarHeight + resultsHeaderHeight + resultsBodyHeight;
		dojo.marginBox(tabWindow.domNode, {h:horizontalSearchPanesHeight});
		dojo.marginBox(EDR.prefix + "content", {h: horizontalSearchPanesHeight + 18});
	
		var topBorderContainer = dijit.byId(EDR.prefix + "topBorderContainer");
		dojo.marginBox(topBorderContainer.domNode, {h: queryPaneHeight + horizontalSearchPanesHeight + 18});
		
		if(EDR.isPortlet) {
			var totalHeight = bannerHeight + queryPaneHeight + horizontalSearchPanesHeight + 18;
			dojo.marginBox(EDR.prefix + "overallContainer", {h: totalHeight});
		}
	},
	
	_scrollStart: -1,
	
	_onScroll: function(evt) {
		var now = new Date() - 0;
		var _this = this;
		var execute = function() {

			var node = _this.domNode.parentNode;
			var height = dojo.contentBox(node).h;
			var scrollTop = node.scrollTop;
			
			var from = to = 0;
			var table = _this.domNode.firstChild;
			var rows = table.rows;
			var length = rows.length;
			for(var i=0; i<length; i++) {
				var tr = rows[i];
				var coords = dojo.coords(tr);
				if(coords.t < scrollTop) {
					from = i;
				}
				if(coords.t + coords.h < scrollTop + height) {
					to = i;
				} else {
					break;
				}
			}
			from = Math.floor(from/2);
			to = Math.ceil(to/2);
			
			_this._createImageObjects(from, to + 3, table);
			
		};
		if(now - this._scrollStart > 500) {
			this._scrollStart = now;
			setTimeout(execute, 500);
		}
	},
	
	_createImageObjects: function(from, to, table) {
		var _this = this;
		var rows = table.rows;
		var m = dijit.byId(EDR.prefix+"searchManager");
		if(m) {
			var result = m.getSearchResult();
			if(result) {
				var results = result.results;
				var tooltipText = EDR.messages.tooltip_columns_thumbnail;
				for(var i = from; i < to + 1; i++) {
					var r = results[i];
					if(r && r.thumbnail) {
						var td = dojo.query("td.result-column-thumbnail", rows[i*2])[0];						
						if(td) {
							if(dojo.query("a", td).length > 0) {
								continue;
							}
							var div = td.firstChild;
							var imgSrc = EDR.contextPath + "/getimage?did=" + encodeURIComponent(r.documentID) + "&cid=" + encodeURIComponent(r.collectionID); 
							var a = dojo.create("a", {onclick:"return false"}, div);
							var img = dojo.create("img", {"src":imgSrc, "title":tooltipText,"alt": r.documentID}, a);
							if(EDR.isStretchHeight) {
								img.onload = function() {
									_this._calcHeight();
								};
							}

							if(dojo.isIE) {
								var setSize = function(a, img) {
									return function() {
										var imgWidth; var imgHeight;
										imgWidth = img.width;
										imgHeight = img.height;
										
										var ratio = 1;
										if(imgWidth > imgHeight) {
											ratio = imgWidth / 120;
										} else {
											ratio = imgHeight / 120;
										}
										if(ratio != 0) {
											var newWidth = Math.floor(imgWidth / ratio);
											var newHeight = Math.floor(imgHeight / ratio);
											img.width = newWidth + "";
											img.height = newHeight + "";
											a.style.width = newWidth + "px";
											a.style.height = newHeight + 2 + "px";
										}
										dojo.style(img, "border", "1px solid black");
									};
								};
								
								var imgWidth; var imgHeight;
								imgWidth = img.width;
								imgHeight = img.height;
								if(imgHeight == 30) {
									img.onload = (function(func) {
										return function() {
											setTimeout(func, 100);
										};
									})(setSize(a,img));
								} else {
									(setSize(a,img))();
								}
							
							} else {
								dojo.style(img, "border", "1px solid black");								
								img.height = "120";
							}
							
							if(!(dojo.isIE && dojo.isIE <= 7)) {
								var nano = new dojox.image.LightboxNano({
									href: imgSrc
								}, a);					
							}
						}
					}
				}
			}
		}

	},
	
	_renderResult: function(result, rowNum, resultsObj) {
		if(!this._columns) return;
		
		var _capitalize = function(str) {
			return (str.substring(0,1).toUpperCase() + str.substring(1));
		};

		if(rowNum % 2 == 0) {
//			this._cachedHtml += "<tr id='" + EDR.prefix + "email-row-" + rowNum + "' class='email-entry-row-header even'>";
			this._cachedArray.push("<tr id='" + EDR.prefix + "email-row-" + rowNum + "' class='email-entry-row-header even'>");
		} else {
//			this._cachedHtml += "<tr id='" + EDR.prefix + "email-row-" + rowNum + "' class='email-entry-row-header odd'>";
			this._cachedArray.push("<tr id='" + EDR.prefix + "email-row-" + rowNum + "' class='email-entry-row-header odd'>");
		}
		
		for(var i=0; i<this._columns.length; i++) {
			var column = this._columns[i];
			var width = this._columnsWidth[i];
			var tr = null;
			if(dojo.isFunction(this["_render" + _capitalize(column)] )) {
				this["_render" + _capitalize(column)](result, tr, rowNum, width, resultsObj);
			} else {
				this._renderDefaultColumn(result, column, tr, rowNum, width);
			}
		}
//		this._cachedHtml += "</tr>";
		this._cachedArray.push("</tr>");

		if(rowNum % 2 == 0) {
//			this._cachedHtml += "<tr id='" + EDR.prefix + "email-row-" + rowNum + "' class='email-entry-row-header even'>";
			this._cachedArray.push("<tr id='" + EDR.prefix + "email-row-" + rowNum + "' class='email-entry-row-header even'>");
		} else {
//			this._cachedHtml += "<tr id='" + EDR.prefix + "email-row-" + rowNum + "' class='email-entry-row-header odd'>";
			this._cachedArray.push("<tr id='" + EDR.prefix + "email-row-" + rowNum + "' class='email-entry-row-header odd'>");
		}

		this._renderDescription(result, tr, rowNum);
//		this._cachedHtml += "</tr>";
		this._cachedArray.push("</tr>");
	},
	
	_renderFiletype: function(result, tr, rowNum, width, resultsObj) {
		var documentSource = result.documentSource;
		var protocol = result.protocol;
		var sourceTypeString = EDR.messages[documentSource + "_tooltip"];
		if(sourceTypeString == null) {
			sourceTypeString = documentSource || "";
		}
		var iconPath;
		if(documentSource == "seedlist") {
			iconPath = EDR.config["documentSource_" + documentSource + "_" + protocol + "_icon"];
		} else {
			iconPath = EDR.config["documentSource_" + documentSource + "_icon"];
		}
		
		if(iconPath == null) {
			iconPath = EDR.config.documentSource_default_icon;
		}
		iconPath = EDR.contextPath + iconPath;

//		this._cachedHtml += "<td class='result-column-filetype' tabindex='0' ";
		this._cachedArray.push("<td class='result-column-filetype' tabindex='0' ");
		
		if(EDR.isTextAnalyticsEnabled) {
//			this._cachedHtml += "title='" + EDR.messages.tooltip_analytics_preview + "' ";
			this._cachedArray.push("title='" + EDR.messages.tooltip_analytics_preview + "' ");
		} else {
//			this._cachedHtml += "title='" + EDR.messages.tooltip_search_preview + "' ";
			this._cachedArray.push("title='" + EDR.messages.tooltip_search_preview + "' ");
		}
		
//		this._cachedHtml += "style='min-width:"+width+"px;width:"+width+"px' onclick='ica_g_openPreview(event,"+ rowNum +")' onkeydown='ica_g_onkeydown(event,"+rowNum+")'>";
		this._cachedArray.push("style='min-width:"+width+"px;width:"+width+"px' onclick='ica_g_openPreview(event,"+ rowNum +")' onkeydown='ica_g_onkeydown(event,"+rowNum+")'>");
		
//		this._cachedHtml += "<div style='overflow:hidden;width:"+ width + "px'></div>";
		this._cachedArray.push("<div style='overflow:hidden;width:"+ width + "px'></div>");
		
		var iconTooltip = EDR.messages[documentSource + "_tooltip"];
		if(iconTooltip == null) {
			iconTooltip = sourceTypeString;
		}
		var iconAlt = EDR.messages[documentSource];
		
//		this._cachedHtml += "<img id='" + EDR.prefix + "email-list-type-"+rowNum+"' src='" + iconPath + "' title='" + iconTooltip + "' alt='" + iconAlt + "' />";
		this._cachedArray.push("<img id='" + EDR.prefix + "email-list-type-"+rowNum+"' src='" + iconPath + "' title='" + iconTooltip + "' alt='" + iconAlt + "' />");
//		this._cachedHtml += "<span style='vertical-align:top'>" + sourceTypeString +"</span>";
		this._cachedArray.push("<span style='vertical-align:top'>" + sourceTypeString +"</span>");
		
//		this._cachedHtml += "</td>";
		this._cachedArray.push("</td>");
	},
	
	_renderRelevance: function(result, tr, rowNum, width) {
//		this._cachedHtml += "<td class='result-column-score searchResultCol_relevance' style='min-width:"+ width+"px;width:"+width+"px'>";
//		this._cachedHtml += "<div style='overflow:hidden;'>" + result.score + "%";
//		this._cachedHtml += "</div></td>";
		this._cachedArray.push("<td class='result-column-score searchResultCol_relevance' style='min-width:"+ width+"px;width:"+width+"px'>");
		this._cachedArray.push("<div style='overflow:hidden;'>" + result.score + "%");
		this._cachedArray.push("</div></td>");
	},
	
	_renderDate: function(result, tr, rowNum, width) {
//		this._cachedHtml += "<td class='result-column-date' style='min-width:"+width+"px;width:"+width+"px'>";
//		this._cachedHtml += "<div style='overflow:hidden'>"+result.date+"</div>";
//		this._cachedHtml +="</div></td>";
		this._cachedArray.push("<td class='result-column-date' style='min-width:"+width+"px;width:"+width+"px'>");
		this._cachedArray.push("<div style='overflow:hidden'>"+result.date+"</div>");
		this._cachedArray.push("</div></td>");
	},
	
	_renderTitle: function(result, tr, rowNum, width) {
//		this._cachedHtml += "<td class='result-column-title' style='min-width:"+width+"px;width:"+width+"px'>";
		this._cachedArray.push("<td class='result-column-title' style='min-width:"+width+"px;width:"+width+"px'>");
		
		var uri = result.documentURI;
		var clientUrl = result.clientUrl;
		var content = "";
		var target = (EDR.config.default_link_target != "null" ? EDR.config.default_link_target : "_blank");
		if(uri) {
			if(uri.toLowerCase().indexOf("http://") == 0) {
				if(EDR.config.http_link_target != "null") {
					target = EDR.config.http_link_target;
				}
			} else if(uri.toLowerCase().indexOf("https://") == 0) {
				if(EDR.config.https_link_target != "null") {
					target = EDR.config.https_link_target;
				}
			} else if(uri.toLowerCase().indexOf("notes://") == 0) {
				if(EDR.config.notes_link_target != "null") {
					target = EDR.config.notes_link_target;
				}
			}
		}

		if(!(EDR.config.forceTitleLink && EDR.config.forceTitleLink == "true") && (!uri || uri == "")) {
			content = result.title;
		} else {
			content = "<a href='" + uri + "'" + (target != "" ? "' target='_blank'>" : ">") + result.title + "</a>";
		}
		// client viewer
		if(EDR.config.clientViewer_show  && EDR.config.clientViewer_show == "true") {
			if(clientUrl != "") {
				var clientIcon = "images/document.gif";
				if(EDR.config["client_" + result.documentSource +"_icon"] != null) {
					clientIcon = EDR.config["client_" + result.documentSource +"_icon"];
				}
				content += " <a href='" + clientUrl + "' style='font-size: smaller;'><img src='"+ EDR.contextPath + "/" + clientIcon + "' title='" + EDR.messages.clientViewer + "'/>" + EDR.messages.button_clientViewer + "</a>";
			}
			
		}
		
//		this._cachedHtml += "<div style='overflow:hidden;width:"+width+"px";
		this._cachedArray.push("<div style='overflow:hidden;width:"+width+"px");
		if(!result.firstOfASite) {
//			this._cachedHtml += ";padding-left:2em";
			this._cachedArray.push(";padding-left:2em");
		}
//		this._cachedHtml += "'>";
//		this._cachedHtml += content;
//		this._cachedHtml += "</div></td>";
		this._cachedArray.push("'>");
		this._cachedArray.push(content);
		this._cachedArray.push("</div></td>");
	},
	
	_renderThumbnail: function(result, tr, rowNum, width) {
//		this._cachedHtml += "<td class='result-column-thumbnail' rowSpan='2' style='min-width:"+width+"px;width:"+width+"px'>";
//		this._cachedHtml += "<div style='overflow:hidden;width:" + width + "px'>";
//		this._cachedHtml += "&nbsp;</div></td>";
		this._cachedArray.push("<td class='result-column-thumbnail' rowSpan='2' style='min-width:"+width+"px;width:"+width+"px'>");
		this._cachedArray.push("<div style='overflow:hidden;width:" + width + "px'>");		
		this._cachedArray.push("&nbsp;</div></td>");
	},
	
	_renderDefaultColumn: function(result, column, tr, rowNum, width) {
//		this._cachedHtml += "<td class='result-column-default' style='min-width:"+width+"px;width:"+width+"px'>";
//		this._cachedHtml += "<div style='width:"+width+"px'>";
//		this._cachedHtml += result["fields"][column] ? result["fields"][column] : "&nbsp;";
//		this._cachedHtml += "</div></td>";
		this._cachedArray.push("<td class='result-column-default' style='min-width:"+width+"px;width:"+width+"px'>");
		this._cachedArray.push("<div style='width:"+width+"px'>");		
		this._cachedArray.push(result["fields"][column] ? result["fields"][column] : "&nbsp;");
		this._cachedArray.push("</div></td>");
	},
	
	_renderDescription: function(result, tr, rowNum) {
		var colSpan  = (dojo.indexOf(this._columns,"thumbnail") != -1) ? this._columns.length-1 : this._columns.length;
//		this._cachedHtml += "<td class='email-entry-row-body " + (rowNum % 2 == 0 ? "even" : "odd") + " body' colSpan='" + colSpan +"'";
		this._cachedArray.push("<td class='email-entry-row-body " + (rowNum % 2 == 0 ? "even" : "odd") + " body' colSpan='" + colSpan +"'");
//		this._cachedHtml += "<div class='" +  (result.wbrInserted ? "result-column-description-container-forcebr" : "result-column-description-container") + "'";
		this._cachedArray.push("<div class='" +  (result.wbrInserted ? "result-column-description-container-forcebr" : "result-column-description-container") + "'");
		if(!result.firstOfASite) {
//			this._cachedHtml += " style='padding-left:3em'";
			this._cachedArray.push(" style='padding-left:3em'");
		}
//		this._cachedHtml += ">";
//		this._cachedHtml += "<div class='result-column-description'>" + result.description + "</div>";
//		this._cachedHtml += "<div class='results-document-details'";		
		this._cachedArray.push(">");
		this._cachedArray.push("<div class='result-column-description'>" + result.description + "</div>");
		this._cachedArray.push("<div class='results-document-details'");
		if(!this._detailsExpanded) {
//			this._cachedHtml += " style='display:none'";
			this._cachedArray.push(" style='display:none'");
		}
//		this._cachedHtml += ">";
		this._cachedArray.push(">");
		this._renderDetailField("Document ID", result.displayedDocumentID);
		this._renderDetailField("Title", result.displayedTitle);
		this._renderDetailField("Language", result.language);
		this._renderDetailField("Source", result.documentSource);
		if(result.documentType != null) {
			this._renderDetailField("Type", result.documentType);
		}
//		this._cachedHtml += "<hr />";
		this._cachedArray.push("<hr />");
		if(result.scopes != null && result.scopes.length != 0) {
			this._renderDetailField("Scopes", result.scopes);
		}
		if(result.fields != null) {
			var fields = result.fields;
			for(var name in fields) {
				if(name.indexOf('_') == 0) continue;
				this._renderDetailField(name, fields[name]);
			}
		}
//		this._cachedHtml += "</div>";
		this._cachedArray.push("</div>");
		if(!result.firstOfASite) {
//			this._cachedHtml += "<div class='results-samesite-link'>";
			this._cachedArray.push("<div class='results-samesite-link'>");
			var link = EDR.contextPath + "/search?action=sameGroup&site=" + result.encodedID;
//			this._cachedHtml += "<a href='javascript:' onclick='EDR.bean.Email.searchSameGroup(\""+link+"\")'>" + EDR.messages.link_search_site + "</a>";
//			this._cachedHtml += "</div>";			
			this._cachedArray.push("<a href='javascript:' onclick='EDR.bean.Email.searchSameGroup(\""+link+"\")'>" + EDR.messages.link_search_site + "</a>");
			this._cachedArray.push("</div>");
		}		

//		this._cachedHtml += "</div></td>";
		this._cachedArray.push("</div></td>");
	},
	
	_renderDetailField: function(label, value) {
//		this._cachedHtml += "<span><b>"+label+"</b>:&nbsp;" + (value != "" ? value : "&nbsp;");
//		this._cachedHtml += "</span><br />";		
		this._cachedArray.push("<span><b>"+label+"</b>:&nbsp;" + (value != "" ? value : "&nbsp;"));
		this._cachedArray.push("</span><br />");
	},
	
	_expandDetails: function(flag) {
		if(flag) {
			dojo.query("div.results-document-details", this.domNode).style("display", "block");
		} else {
			dojo.query("div.results-document-details", this.domNode).style("display", "none");
		}
		this._detailsExpanded = flag;
		if(EDR.isStretchHeight) {
			this._calcHeight();
		}
	},
	
	clear: function() {
		dojo.empty(this.domNode);
//		this._cachedHtml = "";
		this._cachedArray = [];
	},

	_onResized: function(){
		this._onHeaderColumnsChanged();
	},

	__dummy__: ''
});

}

if(!dojo._hasResource["dijit.form._Spinner"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form._Spinner"] = true;
dojo.provide("dijit.form._Spinner");



dojo.declare(
	"dijit.form._Spinner",
	dijit.form.RangeBoundTextBox,
	{
		// summary:
		//		Mixin for validation widgets with a spinner.
		// description:
		//		This class basically (conceptually) extends `dijit.form.ValidationTextBox`.
		//		It modifies the template to have up/down arrows, and provides related handling code.

		// defaultTimeout: Number
		//		Number of milliseconds before a held arrow key or up/down button becomes typematic
		defaultTimeout: 500,

		// timeoutChangeRate: Number
		//		Fraction of time used to change the typematic timer between events.
		//		1.0 means that each typematic event fires at defaultTimeout intervals.
		//		< 1.0 means that each typematic event fires at an increasing faster rate.
		timeoutChangeRate: 0.90,

		// smallDelta: Number
		//	  Adjust the value by this much when spinning using the arrow keys/buttons
		smallDelta: 1,

		// largeDelta: Number
		//	  Adjust the value by this much when spinning using the PgUp/Dn keys
		largeDelta: 10,

		templateString:"<div class=\"dijit dijitReset dijitInlineTable dijitLeft\"\n\tid=\"widget_${id}\"\n\tdojoAttachEvent=\"onmouseenter:_onMouse,onmouseleave:_onMouse,onmousedown:_onMouse\" waiRole=\"presentation\"\n\t><div class=\"dijitInputLayoutContainer\"\n\t\t><div class=\"dijitReset dijitSpinnerButtonContainer\"\n\t\t\t>&nbsp;<div class=\"dijitReset dijitLeft dijitButtonNode dijitArrowButton dijitUpArrowButton\"\n\t\t\t\tdojoAttachPoint=\"upArrowNode\"\n\t\t\t\tdojoAttachEvent=\"onmouseenter:_onMouse,onmouseleave:_onMouse\"\n\t\t\t\tstateModifier=\"UpArrow\"\n\t\t\t\t><div class=\"dijitArrowButtonInner\">&thinsp;</div\n\t\t\t\t><div class=\"dijitArrowButtonChar\">&#9650;</div\n\t\t\t></div\n\t\t\t><div class=\"dijitReset dijitLeft dijitButtonNode dijitArrowButton dijitDownArrowButton\"\n\t\t\t\tdojoAttachPoint=\"downArrowNode\"\n\t\t\t\tdojoAttachEvent=\"onmouseenter:_onMouse,onmouseleave:_onMouse\"\n\t\t\t\tstateModifier=\"DownArrow\"\n\t\t\t\t><div class=\"dijitArrowButtonInner\">&thinsp;</div\n\t\t\t\t><div class=\"dijitArrowButtonChar\">&#9660;</div\n\t\t\t></div\n\t\t></div\n\t\t><div class=\"dijitReset dijitValidationIcon\"><br></div\n\t\t><div class=\"dijitReset dijitValidationIconText\">&Chi;</div\n\t\t><div class=\"dijitReset dijitInputField\"\n\t\t\t><input class='dijitReset' dojoAttachPoint=\"textbox,focusNode\" type=\"${type}\" dojoAttachEvent=\"onkeypress:_onKeyPress\"\n\t\t\t\twaiRole=\"spinbutton\" autocomplete=\"off\" ${nameAttrSetting}\n\t\t/></div\n\t></div\n></div>\n",
		baseClass: "dijitSpinner",

		adjust: function(/* Object */ val, /*Number*/ delta){
			// summary:
			//		Overridable function used to adjust a primitive value(Number/Date/...) by the delta amount specified.
			// 		The val is adjusted in a way that makes sense to the object type.
			// tags:
			//		protected extension
			return val;
		},

		_arrowState: function(/*Node*/ node, /*Boolean*/ pressed){
			// summary:
			//		Called when an arrow key is pressed to update the relevant CSS classes
			this._active = pressed;
			this.stateModifier = node.getAttribute("stateModifier") || "";
			this._setStateClass();
		},

		_arrowPressed: function(/*Node*/ nodePressed, /*Number*/ direction, /*Number*/ increment){
			// summary:
			//		Handler for arrow button or arrow key being pressed
			if(this.disabled || this.readOnly){ return; }
			this._arrowState(nodePressed, true);
			this._setValueAttr(this.adjust(this.attr('value'), direction*increment), false);
			dijit.selectInputText(this.textbox, this.textbox.value.length);
		},

		_arrowReleased: function(/*Node*/ node){
			// summary:
			//		Handler for arrow button or arrow key being released
			this._wheelTimer = null;
			if(this.disabled || this.readOnly){ return; }
			this._arrowState(node, false);
		},

		_typematicCallback: function(/*Number*/ count, /*DOMNode*/ node, /*Event*/ evt){
			var inc=this.smallDelta;
			if(node == this.textbox){
				var k=dojo.keys;
				var key = evt.charOrCode; 
				inc = (key == k.PAGE_UP || key == k.PAGE_DOWN) ? this.largeDelta : this.smallDelta;
				node = (key == k.UP_ARROW ||key == k.PAGE_UP) ? this.upArrowNode : this.downArrowNode;
			}
			if(count == -1){ this._arrowReleased(node); }
			else{ this._arrowPressed(node, (node == this.upArrowNode) ? 1 : -1, inc); }
		},

		_wheelTimer: null,
		_mouseWheeled: function(/*Event*/ evt){
			// summary:
			//		Mouse wheel listener where supported

			dojo.stopEvent(evt);	
			// FIXME: Safari bubbles

			// be nice to DOH and scroll as much as the event says to
			var scrollAmount = evt.detail ? (evt.detail * -1) : (evt.wheelDelta / 120);
			if(scrollAmount !== 0){
				var node = this[(scrollAmount > 0 ? "upArrowNode" : "downArrowNode" )];
				
				this._arrowPressed(node, scrollAmount, this.smallDelta);

				if(!this._wheelTimer){
					clearTimeout(this._wheelTimer);
				}
				this._wheelTimer = setTimeout(dojo.hitch(this,"_arrowReleased",node), 50);
			}
			
		},

		postCreate: function(){
			this.inherited(arguments);

			// extra listeners
			this.connect(this.domNode, !dojo.isMozilla ? "onmousewheel" : 'DOMMouseScroll', "_mouseWheeled");
			this._connects.push(dijit.typematic.addListener(this.upArrowNode, this.textbox, {charOrCode:dojo.keys.UP_ARROW,ctrlKey:false,altKey:false,shiftKey:false}, this, "_typematicCallback", this.timeoutChangeRate, this.defaultTimeout));
			this._connects.push(dijit.typematic.addListener(this.downArrowNode, this.textbox, {charOrCode:dojo.keys.DOWN_ARROW,ctrlKey:false,altKey:false,shiftKey:false}, this, "_typematicCallback", this.timeoutChangeRate, this.defaultTimeout));
			this._connects.push(dijit.typematic.addListener(this.upArrowNode, this.textbox, {charOrCode:dojo.keys.PAGE_UP,ctrlKey:false,altKey:false,shiftKey:false}, this, "_typematicCallback", this.timeoutChangeRate, this.defaultTimeout));
			this._connects.push(dijit.typematic.addListener(this.downArrowNode, this.textbox, {charOrCode:dojo.keys.PAGE_DOWN,ctrlKey:false,altKey:false,shiftKey:false}, this, "_typematicCallback", this.timeoutChangeRate, this.defaultTimeout));
			if(dojo.isIE){
				var _this = this;
				this.connect(this.domNode, "onresize",
					function(){ setTimeout(dojo.hitch(_this,
						function(){
				        		var sz = this.upArrowNode.parentNode.offsetHeight;
							if(sz){
								this.upArrowNode.style.height = sz >> 1;
								this.downArrowNode.style.height = sz - (sz >> 1);
								this.focusNode.parentNode.style.height = sz;
							}
							// cause IE to rerender when spinner is moved from hidden to visible
							this._setStateClass();
						}), 0);
					}
				);
			}
		}
});

}

if(!dojo._hasResource["dojo.number"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.number"] = true;
dojo.provide("dojo.number");







/*=====
dojo.number = {
	// summary: localized formatting and parsing routines for Number
}

dojo.number.__FormatOptions = function(){
	//	pattern: String?
	//		override [formatting pattern](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	//		with this string
	//	type: String?
	//		choose a format type based on the locale from the following:
	//		decimal, scientific, percent, currency. decimal by default.
	//	places: Number?
	//		fixed number of decimal places to show.  This overrides any
	//		information in the provided pattern.
	//	round: Number?
	//		5 rounds to nearest .5; 0 rounds to nearest whole (default). -1
	//		means do not round.
	//	currency: String?
	//		an [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code, a three letter sequence like "USD"
	//	symbol: String?
	//		localized currency symbol
	//	locale: String?
	//		override the locale used to determine formatting rules
	this.pattern = pattern;
	this.type = type;
	this.places = places;
	this.round = round;
	this.currency = currency;
	this.symbol = symbol;
	this.locale = locale;
}
=====*/

dojo.number.format = function(/*Number*/value, /*dojo.number.__FormatOptions?*/options){
	// summary:
	//		Format a Number as a String, using locale-specific settings
	// description:
	//		Create a string from a Number using a known localized pattern.
	//		Formatting patterns appropriate to the locale are chosen from the
	//		[CLDR](http://unicode.org/cldr) as well as the appropriate symbols and
	//		delimiters.  See <http://www.unicode.org/reports/tr35/#Number_Elements>
	//		If value is Infinity, -Infinity, or is not a valid JavaScript number, return null.
	// value:
	//		the number to be formatted

	options = dojo.mixin({}, options || {});
	var locale = dojo.i18n.normalizeLocale(options.locale);
	var bundle = dojo.i18n.getLocalization("dojo.cldr", "number", locale);
	options.customs = bundle;
	var pattern = options.pattern || bundle[(options.type || "decimal") + "Format"];
	if(isNaN(value) || Math.abs(value) == Infinity){ return null; } // null
	return dojo.number._applyPattern(value, pattern, options); // String
};

//dojo.number._numberPatternRE = /(?:[#0]*,?)*[#0](?:\.0*#*)?/; // not precise, but good enough
dojo.number._numberPatternRE = /[#0,]*[#0](?:\.0*#*)?/; // not precise, but good enough

dojo.number._applyPattern = function(/*Number*/value, /*String*/pattern, /*dojo.number.__FormatOptions?*/options){
	// summary:
	//		Apply pattern to format value as a string using options. Gives no
	//		consideration to local customs.
	// value:
	//		the number to be formatted.
	// pattern:
	//		a pattern string as described by
	//		[unicode.org TR35](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	// options: dojo.number.__FormatOptions?
	//		_applyPattern is usually called via `dojo.number.format()` which
	//		populates an extra property in the options parameter, "customs".
	//		The customs object specifies group and decimal parameters if set.

	//TODO: support escapes
	options = options || {};
	var group = options.customs.group;
	var decimal = options.customs.decimal;

	var patternList = pattern.split(';');
	var positivePattern = patternList[0];
	pattern = patternList[(value < 0) ? 1 : 0] || ("-" + positivePattern);

	//TODO: only test against unescaped
	if(pattern.indexOf('%') != -1){
		value *= 100;
	}else if(pattern.indexOf('\u2030') != -1){
		value *= 1000; // per mille
	}else if(pattern.indexOf('\u00a4') != -1){
		group = options.customs.currencyGroup || group;//mixins instead?
		decimal = options.customs.currencyDecimal || decimal;// Should these be mixins instead?
		pattern = pattern.replace(/\u00a4{1,3}/, function(match){
			var prop = ["symbol", "currency", "displayName"][match.length-1];
			return options[prop] || options.currency || "";
		});
	}else if(pattern.indexOf('E') != -1){
		throw new Error("exponential notation not supported");
	}
	
	//TODO: support @ sig figs?
	var numberPatternRE = dojo.number._numberPatternRE;
	var numberPattern = positivePattern.match(numberPatternRE);
	if(!numberPattern){
		throw new Error("unable to find a number expression in pattern: "+pattern);
	}
	if(options.fractional === false){ options.places = 0; }
	return pattern.replace(numberPatternRE,
		dojo.number._formatAbsolute(value, numberPattern[0], {decimal: decimal, group: group, places: options.places, round: options.round}));
}

dojo.number.round = function(/*Number*/value, /*Number?*/places, /*Number?*/increment){
	//	summary:
	//		Rounds to the nearest value with the given number of decimal places, away from zero
	//	description:
	//		Rounds to the nearest value with the given number of decimal places, away from zero if equal.
	//		Similar to Number.toFixed(), but compensates for browser quirks. Rounding can be done by
	//		fractional increments also, such as the nearest quarter.
	//		NOTE: Subject to floating point errors.  See dojox.math.round for experimental workaround.
	//	value:
	//		The number to round
	//	places:
	//		The number of decimal places where rounding takes place.  Defaults to 0 for whole rounding.
	//		Must be non-negative.
	//	increment:
	//		Rounds next place to nearest value of increment/10.  10 by default.
	//	example:
	//		>>> dojo.number.round(-0.5)
	//		-1
	//		>>> dojo.number.round(162.295, 2)
	//		162.29  // note floating point error.  Should be 162.3
	//		>>> dojo.number.round(10.71, 0, 2.5)
	//		10.75
	var factor = 10 / (increment || 10);
	return (factor * +value).toFixed(places) / factor; // Number
}

if((0.9).toFixed() == 0){
	// (isIE) toFixed() bug workaround: Rounding fails on IE when most significant digit
	// is just after the rounding place and is >=5
	(function(){
		var round = dojo.number.round;
		dojo.number.round = function(v, p, m){
			var d = Math.pow(10, -p || 0), a = Math.abs(v);
			if(!v || a >= d || a * Math.pow(10, p + 1) < 5){
				d = 0;
			}
			return round(v, p, m) + (v > 0 ? d : -d);
		}
	})();
}

/*=====
dojo.number.__FormatAbsoluteOptions = function(){
	//	decimal: String?
	//		the decimal separator
	//	group: String?
	//		the group separator
	//	places: Integer?|String?
	//		number of decimal places.  the range "n,m" will format to m places.
	//	round: Number?
	//		5 rounds to nearest .5; 0 rounds to nearest whole (default). -1
	//		means don't round.
	this.decimal = decimal;
	this.group = group;
	this.places = places;
	this.round = round;
}
=====*/

dojo.number._formatAbsolute = function(/*Number*/value, /*String*/pattern, /*dojo.number.__FormatAbsoluteOptions?*/options){
	// summary: 
	//		Apply numeric pattern to absolute value using options. Gives no
	//		consideration to local customs.
	// value:
	//		the number to be formatted, ignores sign
	// pattern:
	//		the number portion of a pattern (e.g. `#,##0.00`)
	options = options || {};
	if(options.places === true){options.places=0;}
	if(options.places === Infinity){options.places=6;} // avoid a loop; pick a limit

	var patternParts = pattern.split(".");
	var maxPlaces = (options.places >= 0) ? options.places : (patternParts[1] && patternParts[1].length) || 0;
	if(!(options.round < 0)){
		value = dojo.number.round(value, maxPlaces, options.round);
	}

	var valueParts = String(Math.abs(value)).split(".");
	var fractional = valueParts[1] || "";
	if(options.places){
		var comma = dojo.isString(options.places) && options.places.indexOf(",");
		if(comma){
			options.places = options.places.substring(comma+1);
		}
		valueParts[1] = dojo.string.pad(fractional.substr(0, options.places), options.places, '0', true);
	}else if(patternParts[1] && options.places !== 0){
		// Pad fractional with trailing zeros
		var pad = patternParts[1].lastIndexOf("0") + 1;
		if(pad > fractional.length){
			valueParts[1] = dojo.string.pad(fractional, pad, '0', true);
		}

		// Truncate fractional
		var places = patternParts[1].length;
		if(places < fractional.length){
			valueParts[1] = fractional.substr(0, places);
		}
	}else{
		if(valueParts[1]){ valueParts.pop(); }
	}

	// Pad whole with leading zeros
	var patternDigits = patternParts[0].replace(',', '');
	pad = patternDigits.indexOf("0");
	if(pad != -1){
		pad = patternDigits.length - pad;
		if(pad > valueParts[0].length){
			valueParts[0] = dojo.string.pad(valueParts[0], pad);
		}

		// Truncate whole
		if(patternDigits.indexOf("#") == -1){
			valueParts[0] = valueParts[0].substr(valueParts[0].length - pad);
		}
	}

	// Add group separators
	var index = patternParts[0].lastIndexOf(',');
	var groupSize, groupSize2;
	if(index != -1){
		groupSize = patternParts[0].length - index - 1;
		var remainder = patternParts[0].substr(0, index);
		index = remainder.lastIndexOf(',');
		if(index != -1){
			groupSize2 = remainder.length - index - 1;
		}
	}
	var pieces = [];
	for(var whole = valueParts[0]; whole;){
		var off = whole.length - groupSize;
		pieces.push((off > 0) ? whole.substr(off) : whole);
		whole = (off > 0) ? whole.slice(0, off) : "";
		if(groupSize2){
			groupSize = groupSize2;
			delete groupSize2;
		}
	}
	valueParts[0] = pieces.reverse().join(options.group || ",");

	return valueParts.join(options.decimal || ".");
};

/*=====
dojo.number.__RegexpOptions = function(){
	//	pattern: String?
	//		override pattern with this string.  Default is provided based on
	//		locale.
	//	type: String?
	//		choose a format type based on the locale from the following:
	//		decimal, scientific, percent, currency. decimal by default.
	//	locale: String?
	//		override the locale used to determine formatting rules
	//	strict: Boolean?
	//		strict parsing, false by default
	//	places: Number|String?
	//		number of decimal places to accept: Infinity, a positive number, or
	//		a range "n,m".  Defined by pattern or Infinity if pattern not provided.
	this.pattern = pattern;
	this.type = type;
	this.locale = locale;
	this.strict = strict;
	this.places = places;
}
=====*/
dojo.number.regexp = function(/*dojo.number.__RegexpOptions?*/options){
	//	summary:
	//		Builds the regular needed to parse a number
	//	description:
	//		Returns regular expression with positive and negative match, group
	//		and decimal separators
	return dojo.number._parseInfo(options).regexp; // String
}

dojo.number._parseInfo = function(/*Object?*/options){
	options = options || {};
	var locale = dojo.i18n.normalizeLocale(options.locale);
	var bundle = dojo.i18n.getLocalization("dojo.cldr", "number", locale);
	var pattern = options.pattern || bundle[(options.type || "decimal") + "Format"];
//TODO: memoize?
	var group = bundle.group;
	var decimal = bundle.decimal;
	var factor = 1;

	if(pattern.indexOf('%') != -1){
		factor /= 100;
	}else if(pattern.indexOf('\u2030') != -1){
		factor /= 1000; // per mille
	}else{
		var isCurrency = pattern.indexOf('\u00a4') != -1;
		if(isCurrency){
			group = bundle.currencyGroup || group;
			decimal = bundle.currencyDecimal || decimal;
		}
	}

	//TODO: handle quoted escapes
	var patternList = pattern.split(';');
	if(patternList.length == 1){
		patternList.push("-" + patternList[0]);
	}

	var re = dojo.regexp.buildGroupRE(patternList, function(pattern){
		pattern = "(?:"+dojo.regexp.escapeString(pattern, '.')+")";
		return pattern.replace(dojo.number._numberPatternRE, function(format){
			var flags = {
				signed: false,
				separator: options.strict ? group : [group,""],
				fractional: options.fractional,
				decimal: decimal,
				exponent: false};
			var parts = format.split('.');
			var places = options.places;
			if(parts.length == 1 || places === 0){flags.fractional = false;}
			else{
				if(places === undefined){ places = options.pattern ? parts[1].lastIndexOf('0')+1 : Infinity; }
				if(places && options.fractional == undefined){flags.fractional = true;} // required fractional, unless otherwise specified
				if(!options.places && (places < parts[1].length)){ places += "," + parts[1].length; }
				flags.places = places;
			}
			var groups = parts[0].split(',');
			if(groups.length>1){
				flags.groupSize = groups.pop().length;
				if(groups.length>1){
					flags.groupSize2 = groups.pop().length;
				}
			}
			return "("+dojo.number._realNumberRegexp(flags)+")";
		});
	}, true);

	if(isCurrency){
		// substitute the currency symbol for the placeholder in the pattern
		re = re.replace(/([\s\xa0]*)(\u00a4{1,3})([\s\xa0]*)/g, function(match, before, target, after){
			var prop = ["symbol", "currency", "displayName"][target.length-1];
			var symbol = dojo.regexp.escapeString(options[prop] || options.currency || "");
			before = before ? "[\\s\\xa0]" : "";
			after = after ? "[\\s\\xa0]" : "";
			if(!options.strict){
				if(before){before += "*";}
				if(after){after += "*";}
				return "(?:"+before+symbol+after+")?";
			}
			return before+symbol+after;
		});
	}

//TODO: substitute localized sign/percent/permille/etc.?

	// normalize whitespace and return
	return {regexp: re.replace(/[\xa0 ]/g, "[\\s\\xa0]"), group: group, decimal: decimal, factor: factor}; // Object
}

/*=====
dojo.number.__ParseOptions = function(){
	//	pattern: String
	//		override pattern with this string.  Default is provided based on
	//		locale.
	//	type: String?
	//		choose a format type based on the locale from the following:
	//		decimal, scientific, percent, currency. decimal by default.
	//	locale: String
	//		override the locale used to determine formatting rules
	//	strict: Boolean?
	//		strict parsing, false by default
	//	currency: Object
	//		object with currency information
	this.pattern = pattern;
	this.type = type;
	this.locale = locale;
	this.strict = strict;
	this.currency = currency;
}
=====*/
dojo.number.parse = function(/*String*/expression, /*dojo.number.__ParseOptions?*/options){
	// summary:
	//		Convert a properly formatted string to a primitive Number, using
	//		locale-specific settings.
	// description:
	//		Create a Number from a string using a known localized pattern.
	//		Formatting patterns are chosen appropriate to the locale
	//		and follow the syntax described by
	//		[unicode.org TR35](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	// expression:
	//		A string representation of a Number
	var info = dojo.number._parseInfo(options);
	var results = (new RegExp("^"+info.regexp+"$")).exec(expression);
	if(!results){
		return NaN; //NaN
	}
	var absoluteMatch = results[1]; // match for the positive expression
	if(!results[1]){
		if(!results[2]){
			return NaN; //NaN
		}
		// matched the negative pattern
		absoluteMatch =results[2];
		info.factor *= -1;
	}

	// Transform it to something Javascript can parse as a number.  Normalize
	// decimal point and strip out group separators or alternate forms of whitespace
	absoluteMatch = absoluteMatch.
		replace(new RegExp("["+info.group + "\\s\\xa0"+"]", "g"), "").
		replace(info.decimal, ".");
	// Adjust for negative sign, percent, etc. as necessary
	return absoluteMatch * info.factor; //Number
};

/*=====
dojo.number.__RealNumberRegexpFlags = function(){
	//	places: Number?
	//		The integer number of decimal places or a range given as "n,m".  If
	//		not given, the decimal part is optional and the number of places is
	//		unlimited.
	//	decimal: String?
	//		A string for the character used as the decimal point.  Default
	//		is ".".
	//	fractional: Boolean|Array?
	//		Whether decimal places are allowed.  Can be true, false, or [true,
	//		false].  Default is [true, false]
	//	exponent: Boolean|Array?
	//		Express in exponential notation.  Can be true, false, or [true,
	//		false]. Default is [true, false], (i.e. will match if the
	//		exponential part is present are not).
	//	eSigned: Boolean|Array?
	//		The leading plus-or-minus sign on the exponent.  Can be true,
	//		false, or [true, false].  Default is [true, false], (i.e. will
	//		match if it is signed or unsigned).  flags in regexp.integer can be
	//		applied.
	this.places = places;
	this.decimal = decimal;
	this.fractional = fractional;
	this.exponent = exponent;
	this.eSigned = eSigned;
}
=====*/

dojo.number._realNumberRegexp = function(/*dojo.number.__RealNumberRegexpFlags?*/flags){
	// summary:
	//		Builds a regular expression to match a real number in exponential
	//		notation

	// assign default values to missing paramters
	flags = flags || {};
	//TODO: use mixin instead?
	if(!("places" in flags)){ flags.places = Infinity; }
	if(typeof flags.decimal != "string"){ flags.decimal = "."; }
	if(!("fractional" in flags) || /^0/.test(flags.places)){ flags.fractional = [true, false]; }
	if(!("exponent" in flags)){ flags.exponent = [true, false]; }
	if(!("eSigned" in flags)){ flags.eSigned = [true, false]; }

	// integer RE
	var integerRE = dojo.number._integerRegexp(flags);

	// decimal RE
	var decimalRE = dojo.regexp.buildGroupRE(flags.fractional,
		function(q){
			var re = "";
			if(q && (flags.places!==0)){
				re = "\\" + flags.decimal;
				if(flags.places == Infinity){ 
					re = "(?:" + re + "\\d+)?"; 
				}else{
					re += "\\d{" + flags.places + "}"; 
				}
			}
			return re;
		},
		true
	);

	// exponent RE
	var exponentRE = dojo.regexp.buildGroupRE(flags.exponent,
		function(q){ 
			if(q){ return "([eE]" + dojo.number._integerRegexp({ signed: flags.eSigned}) + ")"; }
			return ""; 
		}
	);

	// real number RE
	var realRE = integerRE + decimalRE;
	// allow for decimals without integers, e.g. .25
	if(decimalRE){realRE = "(?:(?:"+ realRE + ")|(?:" + decimalRE + "))";}
	return realRE + exponentRE; // String
};

/*=====
dojo.number.__IntegerRegexpFlags = function(){
	//	signed: Boolean?
	//		The leading plus-or-minus sign. Can be true, false, or `[true,false]`.
	//		Default is `[true, false]`, (i.e. will match if it is signed
	//		or unsigned).
	//	separator: String?
	//		The character used as the thousands separator. Default is no
	//		separator. For more than one symbol use an array, e.g. `[",", ""]`,
	//		makes ',' optional.
	//	groupSize: Number?
	//		group size between separators
	//	groupSize2: Number?
	//		second grouping, where separators 2..n have a different interval than the first separator (for India)
	this.signed = signed;
	this.separator = separator;
	this.groupSize = groupSize;
	this.groupSize2 = groupSize2;
}
=====*/

dojo.number._integerRegexp = function(/*dojo.number.__IntegerRegexpFlags?*/flags){
	// summary: 
	//		Builds a regular expression that matches an integer

	// assign default values to missing paramters
	flags = flags || {};
	if(!("signed" in flags)){ flags.signed = [true, false]; }
	if(!("separator" in flags)){
		flags.separator = "";
	}else if(!("groupSize" in flags)){
		flags.groupSize = 3;
	}
	// build sign RE
	var signRE = dojo.regexp.buildGroupRE(flags.signed,
		function(q){ return q ? "[-+]" : ""; },
		true
	);

	// number RE
	var numberRE = dojo.regexp.buildGroupRE(flags.separator,
		function(sep){
			if(!sep){
				return "(?:\\d+)";
			}

			sep = dojo.regexp.escapeString(sep);
			if(sep == " "){ sep = "\\s"; }
			else if(sep == "\xa0"){ sep = "\\s\\xa0"; }

			var grp = flags.groupSize, grp2 = flags.groupSize2;
			//TODO: should we continue to enforce that numbers with separators begin with 1-9?  See #6933
			if(grp2){
				var grp2RE = "(?:0|[1-9]\\d{0," + (grp2-1) + "}(?:[" + sep + "]\\d{" + grp2 + "})*[" + sep + "]\\d{" + grp + "})";
				return ((grp-grp2) > 0) ? "(?:" + grp2RE + "|(?:0|[1-9]\\d{0," + (grp-1) + "}))" : grp2RE;
			}
			return "(?:0|[1-9]\\d{0," + (grp-1) + "}(?:[" + sep + "]\\d{" + grp + "})*)";
		},
		true
	);

	// integer RE
	return signRE + numberRE; // String
}

}

if(!dojo._hasResource["dijit.form.NumberTextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.NumberTextBox"] = true;
dojo.provide("dijit.form.NumberTextBox");




/*=====
dojo.declare(
	"dijit.form.NumberTextBox.__Constraints",
	[dijit.form.RangeBoundTextBox.__Constraints, dojo.number.__FormatOptions, dojo.number.__ParseOptions]
);
=====*/

dojo.declare("dijit.form.NumberTextBoxMixin",
	null,
	{
		// summary:
		//		A mixin for all number textboxes
		// tags:
		//		protected

		// Override ValidationTextBox.regExpGen().... we use a reg-ex generating function rather
		// than a straight regexp to deal with locale (plus formatting options too?)
		regExpGen: dojo.number.regexp,

		/*=====
		// constraints: dijit.form.NumberTextBox.__Constraints
		//		Minimum/maximum allowed values.
		constraints: {},
		======*/

		// value: Number
		//		The value of this NumberTextBox as a javascript Number (ie, not a String).
		//		If the displayed value is blank, the value is NaN, and if the user types in
		//		an gibberish value (like "hello world"), the value is undefined
		//		(i.e. attr('value') returns undefined).
		//
		//		Symetrically, attr('value', NaN) will clear the displayed value,
		//		whereas attr('value', undefined) will have no effect.
		value: NaN,

		// editOptions: [protected] Object
		//		Properties to mix into constraints when the value is being edited.
		//		This is here because we edit the number in the format "12345", which is
		//		different than the display value (ex: "12,345")
		editOptions: { pattern: '#.######' },

		/*=====
		_formatter: function(value, options){
			// summary:
			//		_formatter() is called by format().   It's the base routine for formatting a number,
			//		as a string, for example converting 12345 into "12,345".
			// value: Number
			//		The number to be converted into a string.
			// options: dojo.number.__FormatOptions?
			//		Formatting options
			// tags:
			//		protected extension

			return "12345";		// String
		},
		 =====*/
		_formatter: dojo.number.format,

		postMixInProperties: function(){
			if(typeof this.constraints.max != "number"){
				this.constraints.max = 9e+15;
			}
			this.inherited(arguments);
		},

		_onFocus: function(){
			if(this.disabled){ return; }
			var val = this.attr('value');
			if(typeof val == "number" && !isNaN(val)){
				var formattedValue = this.format(val, this.constraints);
				if(formattedValue !== undefined){
					this.textbox.value = formattedValue;
				}
			}
			this.inherited(arguments);
		},

		format: function(/*Number*/ value, /*dojo.number.__FormatOptions*/ constraints){
			// summary:
			//		Formats the value as a Number, according to constraints.
			// tags:
			//		protected

			if(typeof value != "number") { return String(value) }
			if(isNaN(value)){ return ""; }
			if(("rangeCheck" in this) && !this.rangeCheck(value, constraints)){ return String(value) }
			if(this.editOptions && this._focused){
				constraints = dojo.mixin(dojo.mixin({}, this.editOptions), constraints);
			}
			return this._formatter(value, constraints);
		},

		/*=====
		parse: function(value, constraints){
			// summary:
			//		Parses the string value as a Number, according to constraints.
			// value: String
			//		String representing a number
			// constraints: dojo.number.__ParseOptions
			//		Formatting options
			// tags:
			//		protected

			return 123.45;		// Number
		},
		=====*/
		parse: dojo.number.parse,

		_getDisplayedValueAttr: function(){
			var v = this.inherited(arguments); 
			return isNaN(v) ? this.textbox.value : v;
		},

		filter: function(/*Number*/ value){
			// summary:
			//		This is called with both the display value (string), and the actual value (a number).
			//		When called with the actual value it does corrections so that '' etc. are represented as NaN.
			//		Otherwise it dispatches to the superclass's filter() method.
			//
			//		See `dijit.form.TextBox.filter` for more details.
			return (value === null || value === '' || value === undefined) ? NaN : this.inherited(arguments); // attr('value', null||''||undefined) should fire onChange(NaN)
		},

		serialize: function(/*Number*/ value, /*Object?*/options){
			// summary:
			//		Convert value (a Number) into a canonical string (ie, how the number literal is written in javascript/java/C/etc.)
			// tags:
			//		protected
			return (typeof value != "number" || isNaN(value))? '' : this.inherited(arguments);
		},

		_setValueAttr: function(/*Number*/ value, /*Boolean?*/ priorityChange, /*String?*/formattedValue){
			// summary:
			//		Hook so attr('value', ...) works.
			if(value !== undefined && formattedValue === undefined){
				if(typeof value == "number"){
					if(isNaN(value)){ formattedValue = '' }
					else if(("rangeCheck" in this) && !this.rangeCheck(value, this.constraints)){
						formattedValue = String(value);
					}
				}else if(!value){ // 0 processed in if branch above, ''|null|undefined flow thru here
					formattedValue = '';
					value = NaN;
				}else{ // non-numeric values
					formattedValue = String(value);
					value = undefined;
				}
			}
			this.inherited(arguments, [value, priorityChange, formattedValue]);
		},


		_getValueAttr: function(){
			// summary:
			//		Hook so attr('value') works.
			//		Returns Number, NaN for '', or undefined for unparsable text
			var v = this.inherited(arguments); // returns Number for all values accepted by parse() or NaN for all other displayed values

			// If the displayed value of the textbox is gibberish (ex: "hello world"), this.inherited() above
			// returns NaN; this if() branch converts the return value to undefined.
			// Returning undefined prevents user text from being overwritten when doing _setValueAttr(_getValueAttr()).
			// A blank displayed value is still returned as NaN.
			if(isNaN(v) && this.textbox.value !== ''){ // if displayed value other than ''
				var n = Number(this.textbox.value); // check for exponential notation that parse() rejected (erroneously?)
				return (String(n)===this.textbox.value)? n : undefined; // return exponential Number or undefined for random text
			}else{ return v } // Number or NaN for ''
		}
	}
);

dojo.declare("dijit.form.NumberTextBox",
	[dijit.form.RangeBoundTextBox,dijit.form.NumberTextBoxMixin],
	{
		// summary:
		//		A validating, serializable, range-bound text box.
	}
);

}

if(!dojo._hasResource["dijit.form.NumberSpinner"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.NumberSpinner"] = true;
dojo.provide("dijit.form.NumberSpinner");




dojo.declare("dijit.form.NumberSpinner",
	[dijit.form._Spinner, dijit.form.NumberTextBoxMixin],
	{
	// summary:
	//		Extends NumberTextBox to add up/down arrows and pageup/pagedown for incremental change to the value
	//
	// description:
	//		A `dijit.form.NumberTextBox` extension to provide keyboard accessible value selection
	//		as well as icons for spinning direction. When using the keyboard, the typematic rules
	//		apply, meaning holding the key will gradually increarease or decrease the value and
	// 		accelerate.
	//		
	// example:
	//	| new dijit.form.NumberSpinner({ constraints:{ max:300, min:100 }}, "someInput");

	// Override required=false from ValidationTextBox
	required: true,

	adjust: function(/* Object */val, /* Number*/delta){
		// summary:
		//		Change Number val by the given amount
		// tags:
		//		protected

		var tc = this.constraints, 
			v = isNaN(val), 
			gotMax = !isNaN(tc.max), 
			gotMin = !isNaN(tc.min)
		;
		if(v && delta != 0){ // blank or invalid value and they want to spin, so create defaults
			val = (delta > 0) ? 
				gotMin ? tc.min : gotMax ? tc.max : 0 :
				gotMax ? this.constraints.max : gotMin ? tc.min : 0
			;
		}
		var newval = val + delta;
		if(v || isNaN(newval)){ return val; }
		if(gotMax && (newval > tc.max)){
			newval = tc.max;
		}
		if(gotMin && (newval < tc.min)){
			newval = tc.min;
		}
		return newval;
	},
	
	_onKeyPress: function(e){
		if((e.charOrCode == dojo.keys.HOME || e.charOrCode == dojo.keys.END) && !e.ctrlKey && !e.altKey){
			var value = this.constraints[(e.charOrCode == dojo.keys.HOME ? "min" : "max")];
			if(value){
				this._setValueAttr(value,true);
			}
			// eat home or end key whether we change the value or not
			dojo.stopEvent(e);
		}
	}
	
});

}

if(!dojo._hasResource["dijit.form.FilteringSelect"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.FilteringSelect"] = true;
dojo.provide("dijit.form.FilteringSelect");



dojo.declare(
	"dijit.form.FilteringSelect",
	[dijit.form.MappedTextBox, dijit.form.ComboBoxMixin],
	{
		// summary:
		//		An enhanced version of the HTML SELECT tag, populated dynamically
		//
		// description:
		//		An enhanced version of the HTML SELECT tag, populated dynamically. It works
		//		very nicely with very large data sets because it can load and page data as needed.
		//		It also resembles ComboBox, but does not allow values outside of the provided ones.
		//		If OPTION tags are used as the data provider via markup, then the
		//		OPTION tag's child text node is used as the displayed value when selected
		//		while the OPTION tag's value attribute is used as the widget value on form submit.
		//		To set the default value when using OPTION tags, specify the selected
		//		attribute on 1 of the child OPTION tags.
		//
		//		Similar features:
		//			- There is a drop down list of possible values.
		//			- You can only enter a value from the drop down list.  (You can't
		//				enter an arbitrary value.)
		//			- The value submitted with the form is the hidden value (ex: CA),
		//				not the displayed value a.k.a. label (ex: California)
		// 
		//		Enhancements over plain HTML version:
		//			- If you type in some text then it will filter down the list of
		//				possible values in the drop down list.
		//			- List can be specified either as a static list or via a javascript
		//				function (that can get the list from a server)

		_isvalid: true,

		// required: Boolean
		//		True if user is required to enter a value into this field.
		required: true,

		_lastDisplayedValue: "",

		isValid: function(){
			// Overrides ValidationTextBox.isValid()
			return this._isvalid || (!this.required && this.attr('displayedValue') == ""); // #5974
		},

		_callbackSetLabel: function(	/*Array*/ result, 
						/*Object*/ dataObject, 
						/*Boolean?*/ priorityChange){
			// summary:
			//		Callback function that dynamically sets the label of the
			//		ComboBox

			// setValue does a synchronous lookup,
			// so it calls _callbackSetLabel directly,
			// and so does not pass dataObject
			// still need to test against _lastQuery in case it came too late
			if((dataObject && dataObject.query[this.searchAttr] != this._lastQuery)||(!dataObject && result.length && this.store.getIdentity(result[0])!= this._lastQuery)){
				return;
			}
			if(!result.length){
				//#3268: do nothing on bad input
				//this._setValue("", "");
				//#3285: change CSS to indicate error
				this.valueNode.value = "";
				dijit.form.TextBox.superclass._setValueAttr.call(this, "", priorityChange || (priorityChange===undefined && !this._focused));
				this._isvalid = false;
				this.validate(this._focused);
				this.item = null;
			}else{
				this._setValueFromItem(result[0], priorityChange);
			}
		},

		_openResultList: function(/*Object*/ results, /*Object*/ dataObject){
			// Overrides ComboBox._openResultList()

			// #3285: tap into search callback to see if user's query resembles a match
			if(dataObject.query[this.searchAttr] != this._lastQuery){
				return;
			}
			this._isvalid = results.length != 0; // FIXME: should this be greater-than?
			this.validate(true);
			dijit.form.ComboBoxMixin.prototype._openResultList.apply(this, arguments);
		},

		_getValueAttr: function(){
			// summary:
			//		Hook for attr('value') to work.

			// don't get the textbox value but rather the previously set hidden value
			// TODO: seems suspicious that we need this; how is FilteringSelect different
			// than another MappedTextBox widget?
			return this.valueNode.value;
		},

		_getValueField: function(){
			// Overrides ComboBox._getValueField()
			return "value";
		},

		_setValue: function(	/*String*/ value, 
					/*String*/ displayedValue,
					/*Boolean?*/ priorityChange){
			// summary:
			//		Internal function for setting the displayed value and hidden value.
			//		Differs from _setValueAttr() in that _setValueAttr() only takes a single
			//		value argument, and has to look up the displayed value from that.
			// tags:
			//		private
			this.valueNode.value = value;
			dijit.form.FilteringSelect.superclass._setValueAttr.call(this, value, priorityChange, displayedValue);
			this._lastDisplayedValue = displayedValue;
		},

		_setValueAttr: function(/*String*/ value, /*Boolean?*/ priorityChange){
			// summary:
			//		Hook so attr('value', value) works.
			// description:
			//		Sets the value of the select.
			//		Also sets the label to the corresponding value by reverse lookup.
			if(!this._onChangeActive){ priorityChange = null; }
			this._lastQuery = value;

			if(value === null || value === ''){
				this._setDisplayedValueAttr('', priorityChange);
				return;
			}

			//#3347: fetchItemByIdentity if no keyAttr specified
			var self = this;
			this.store.fetchItemByIdentity({
				identity: value, 
				onItem: function(item){
					self._callbackSetLabel([item], undefined, priorityChange);
				}
			});
		},

		_setValueFromItem: function(/*item*/ item, /*Boolean?*/ priorityChange){
			//	summary:
			//		Set the displayed valued in the input box, and the hidden value
			//		that gets submitted, based on a dojo.data store item.
			//	description:
			//		Users shouldn't call this function; they should be calling
			//		attr('displayedValue', value) or attr('value', ...) instead
			// tags:
			//		private
			this._isvalid = true;
			this.item = item; // Fix #6381
			this._setValue(	this.store.getIdentity(item), 
							this.labelFunc(item, this.store), 
							priorityChange);
		},

		labelFunc: function(/*item*/ item, /*dojo.data.store*/ store){
			// summary:
			//		Computes the label to display based on the dojo.data store item.
			// returns:
			//		The label that the ComboBox should display
			// tags:
			//		private
			
			// Use toString() because XMLStore returns an XMLItem whereas this
			// method is expected to return a String (#9354)
			return store.getValue(item, this.searchAttr).toString();	// String
		},

		_doSelect: function(/*Event*/ tgt){
			// summary:
			//		Overrides ComboBox._doSelect(), the method called when an item in the menu is selected.
			//	description:
			//		FilteringSelect overrides this to set both the visible and
			//		hidden value from the information stored in the menu.
			this._setValueFromItem(tgt.item, true);
		},

		_getDisplayQueryString: function(/*String*/ text){
			return text.replace(/([\\\*\?])/g, "\\$1");
		},

		_setDisplayedValueAttr: function(/*String*/ label, /*Boolean?*/ priorityChange){
			// summary:
			//		Hook so attr('displayedValue', label) works.
			// description:
			//		Sets textbox to display label. Also performs reverse lookup
			//		to set the hidden value.

			// When this is called during initialization it'll ping the datastore
			// for reverse lookup, and when that completes (after an XHR request)
			// will call setValueAttr()... but that shouldn't trigger an onChange()
			// event, even when it happens after creation has finished
			if(!this._created){
				priorityChange = false;
			}

			if(this.store){
				this._hideResultList();
				var query = dojo.clone(this.query); // #6196: populate query with user-specifics
				// escape meta characters of dojo.data.util.filter.patternToRegExp().
				this._lastQuery = query[this.searchAttr] = this._getDisplayQueryString(label);
				// if the label is not valid, the callback will never set it,
				// so the last valid value will get the warning textbox set the
				// textbox value now so that the impending warning will make
				// sense to the user
				this.textbox.value = label;
				this._lastDisplayedValue = label;
				var _this = this;
				var fetch = {
					query: query, 
					queryOptions: {
						ignoreCase: this.ignoreCase, 
						deep: true
					}, 
					onComplete: function(result, dataObject){
						_this._fetchHandle = null;
						dojo.hitch(_this, "_callbackSetLabel")(result, dataObject, priorityChange);
					},
					onError: function(errText){
						_this._fetchHandle = null;
						console.error('dijit.form.FilteringSelect: ' + errText);
						dojo.hitch(_this, "_setValue")("", label, false);
					}
				};
				dojo.mixin(fetch, this.fetchProperties);
				this._fetchHandle = this.store.fetch(fetch);
			}
		},

		postMixInProperties: function(){
			this.inherited(arguments);
			this._isvalid = !this.required;
		},

		undo: function(){
			this.attr('displayedValue', this._lastDisplayedValue);
		}
	}
);

}

if(!dojo._hasResource["dijit.form.HorizontalSlider"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.HorizontalSlider"] = true;
dojo.provide("dijit.form.HorizontalSlider");








dojo.declare(
	"dijit.form.HorizontalSlider",
	[dijit.form._FormValueWidget, dijit._Container],
{
	// summary:
	//		A form widget that allows one to select a value with a horizontally draggable handle

	templateString:"<table class=\"dijit dijitReset dijitSlider\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" rules=\"none\" dojoAttachEvent=\"onkeypress:_onKeyPress\"\n\t><tr class=\"dijitReset\"\n\t\t><td class=\"dijitReset\" colspan=\"2\"></td\n\t\t><td dojoAttachPoint=\"containerNode,topDecoration\" class=\"dijitReset\" style=\"text-align:center;width:100%;\"></td\n\t\t><td class=\"dijitReset\" colspan=\"2\"></td\n\t></tr\n\t><tr class=\"dijitReset\"\n\t\t><td class=\"dijitReset dijitSliderButtonContainer dijitSliderButtonContainerH\"\n\t\t\t><div class=\"dijitSliderDecrementIconH\" tabIndex=\"-1\" style=\"display:none\" dojoAttachPoint=\"decrementButton\"><span class=\"dijitSliderButtonInner\">-</span></div\n\t\t></td\n\t\t><td class=\"dijitReset\"\n\t\t\t><div class=\"dijitSliderBar dijitSliderBumper dijitSliderBumperH dijitSliderLeftBumper dijitSliderLeftBumper\" dojoAttachEvent=\"onmousedown:_onClkDecBumper\"></div\n\t\t></td\n\t\t><td class=\"dijitReset\"\n\t\t\t><input dojoAttachPoint=\"valueNode\" type=\"hidden\" ${nameAttrSetting}\n\t\t\t/><div class=\"dijitReset dijitSliderBarContainerH\" waiRole=\"presentation\" dojoAttachPoint=\"sliderBarContainer\"\n\t\t\t\t><div waiRole=\"presentation\" dojoAttachPoint=\"progressBar\" class=\"dijitSliderBar dijitSliderBarH dijitSliderProgressBar dijitSliderProgressBarH\" dojoAttachEvent=\"onmousedown:_onBarClick\"\n\t\t\t\t\t><div class=\"dijitSliderMoveable dijitSliderMoveableH\" \n\t\t\t\t\t\t><div dojoAttachPoint=\"sliderHandle,focusNode\" class=\"dijitSliderImageHandle dijitSliderImageHandleH\" dojoAttachEvent=\"onmousedown:_onHandleClick\" waiRole=\"slider\" valuemin=\"${minimum}\" valuemax=\"${maximum}\"></div\n\t\t\t\t\t></div\n\t\t\t\t></div\n\t\t\t\t><div waiRole=\"presentation\" dojoAttachPoint=\"remainingBar\" class=\"dijitSliderBar dijitSliderBarH dijitSliderRemainingBar dijitSliderRemainingBarH\" dojoAttachEvent=\"onmousedown:_onBarClick\"></div\n\t\t\t></div\n\t\t></td\n\t\t><td class=\"dijitReset\"\n\t\t\t><div class=\"dijitSliderBar dijitSliderBumper dijitSliderBumperH dijitSliderRightBumper dijitSliderRightBumper\" dojoAttachEvent=\"onmousedown:_onClkIncBumper\"></div\n\t\t></td\n\t\t><td class=\"dijitReset dijitSliderButtonContainer dijitSliderButtonContainerH\" style=\"right:0px;\"\n\t\t\t><div class=\"dijitSliderIncrementIconH\" tabIndex=\"-1\" style=\"display:none\" dojoAttachPoint=\"incrementButton\"><span class=\"dijitSliderButtonInner\">+</span></div\n\t\t></td\n\t></tr\n\t><tr class=\"dijitReset\"\n\t\t><td class=\"dijitReset\" colspan=\"2\"></td\n\t\t><td dojoAttachPoint=\"containerNode,bottomDecoration\" class=\"dijitReset\" style=\"text-align:center;\"></td\n\t\t><td class=\"dijitReset\" colspan=\"2\"></td\n\t></tr\n></table>\n",

	// Overrides FormValueWidget.value to indicate numeric value
	value: 0,

	// showButtons: Boolean
	//		Show increment/decrement buttons at the ends of the slider?
	showButtons: true,

	// minimum:: Integer
	//		The minimum value the slider can be set to.
	minimum: 0,

	// maximum: Integer
	//		The maximum value the slider can be set to.
	maximum: 100,

	// discreteValues: Integer
	//		If specified, indicates that the slider handle has only 'discreteValues' possible positions,
	//      and that after dragging the handle, it will snap to the nearest possible position.
	//      Thus, the slider has only 'discreteValues' possible values.
	//
	//		For example, if minimum=10, maxiumum=30, and discreteValues=3, then the slider handle has
	//		three possible positions, representing values 10, 20, or 30.
	//
	//		If discreteValues is not specified or if it's value is higher than the number of pixels
	//		in the slider bar, then the slider handle can be moved freely, and the slider's value will be
	//		computed/reported based on pixel position (in this case it will likely be fractional,
	//      such as 123.456789).
	discreteValues: Infinity,

	// pageIncrement: Integer
	//		If discreteValues is also specified, this indicates the amount of clicks (ie, snap positions)
	//      that the slider handle is moved via pageup/pagedown keys.
    //      If discreteValues is not specified, it indicates the number of pixels.
	pageIncrement: 2,

	// clickSelect: Boolean
	//		If clicking the slider bar changes the value or not
	clickSelect: true,

	// slideDuration: Number
	//		The time in ms to take to animate the slider handle from 0% to 100%,
	//		when clicking the slider bar to make the handle move.
	slideDuration: dijit.defaultDuration,

	// Flag to _Templated
	widgetsInTemplate: true,

	attributeMap: dojo.delegate(dijit.form._FormWidget.prototype.attributeMap, {
		id: ""
	}),

	baseClass: "dijitSlider",

	_mousePixelCoord: "pageX",
	_pixelCount: "w",
	_startingPixelCoord: "x",
	_startingPixelCount: "l",
	_handleOffsetCoord: "left",
	_progressPixelSize: "width",

	_onKeyPress: function(/*Event*/ e){
		if(this.disabled || this.readOnly || e.altKey || e.ctrlKey){ return; }
		switch(e.charOrCode){
			case dojo.keys.HOME:
				this._setValueAttr(this.minimum, true);
				break;
			case dojo.keys.END:
				this._setValueAttr(this.maximum, true);
				break;
			// this._descending === false: if ascending vertical (min on top)
			// (this._descending || this.isLeftToRight()): if left-to-right horizontal or descending vertical
			case ((this._descending || this.isLeftToRight()) ? dojo.keys.RIGHT_ARROW : dojo.keys.LEFT_ARROW):
			case (this._descending === false ? dojo.keys.DOWN_ARROW : dojo.keys.UP_ARROW):
			case (this._descending === false ? dojo.keys.PAGE_DOWN : dojo.keys.PAGE_UP):
				this.increment(e);
				break;
			case ((this._descending || this.isLeftToRight()) ? dojo.keys.LEFT_ARROW : dojo.keys.RIGHT_ARROW):
			case (this._descending === false ? dojo.keys.UP_ARROW : dojo.keys.DOWN_ARROW):
			case (this._descending === false ? dojo.keys.PAGE_UP : dojo.keys.PAGE_DOWN):
				this.decrement(e);
				break;
			default:
				return;
		}
		dojo.stopEvent(e);
	},

	_onHandleClick: function(e){
		if(this.disabled || this.readOnly){ return; }
		if(!dojo.isIE){
			// make sure you get focus when dragging the handle
			// (but don't do on IE because it causes a flicker on mouse up (due to blur then focus)
			dijit.focus(this.sliderHandle);
		}
		dojo.stopEvent(e);
	},
	
	_isReversed: function(){
		// summary:
		//		Returns true if direction is from right to left
		// tags:
		//		protected extension
		return !this.isLeftToRight();
	},

	_onBarClick: function(e){
		if(this.disabled || this.readOnly || !this.clickSelect){ return; }
		dijit.focus(this.sliderHandle);
		dojo.stopEvent(e);
		var abspos = dojo.coords(this.sliderBarContainer, true);
		var pixelValue = e[this._mousePixelCoord] - abspos[this._startingPixelCoord];
		this._setPixelValue(this._isReversed() ? (abspos[this._pixelCount] - pixelValue) : pixelValue, abspos[this._pixelCount], true);
		this._movable.onMouseDown(e);
	},

	_setPixelValue: function(/*Number*/ pixelValue, /*Number*/ maxPixels, /*Boolean, optional*/ priorityChange){
		if(this.disabled || this.readOnly){ return; }
		pixelValue = pixelValue < 0 ? 0 : maxPixels < pixelValue ? maxPixels : pixelValue;
		var count = this.discreteValues;
		if(count <= 1 || count == Infinity){ count = maxPixels; }
		count--;
		var pixelsPerValue = maxPixels / count;
		var wholeIncrements = Math.round(pixelValue / pixelsPerValue);
		this._setValueAttr((this.maximum-this.minimum)*wholeIncrements/count + this.minimum, priorityChange);
	},

	_setValueAttr: function(/*Number*/ value, /*Boolean, optional*/ priorityChange){
		// summary:
		//		Hook so attr('value', value) works.
		this.valueNode.value = this.value = value;
		dijit.setWaiState(this.focusNode, "valuenow", value);
		this.inherited(arguments);
		var percent = (value - this.minimum) / (this.maximum - this.minimum);
		var progressBar = (this._descending === false) ? this.remainingBar : this.progressBar;
		var remainingBar = (this._descending === false) ? this.progressBar : this.remainingBar;
		if(this._inProgressAnim && this._inProgressAnim.status != "stopped"){
			this._inProgressAnim.stop(true);
		}
		if(priorityChange && this.slideDuration > 0 && progressBar.style[this._progressPixelSize]){
			// animate the slider
			var _this = this;
			var props = {};
			var start = parseFloat(progressBar.style[this._progressPixelSize]);
			var duration = this.slideDuration * (percent-start/100);
			if(duration == 0){ return; }
			if(duration < 0){ duration = 0 - duration; }
			props[this._progressPixelSize] = { start: start, end: percent*100, units:"%" };
			this._inProgressAnim = dojo.animateProperty({ node: progressBar, duration: duration, 
				onAnimate: function(v){ remainingBar.style[_this._progressPixelSize] = (100-parseFloat(v[_this._progressPixelSize])) + "%"; },
				onEnd: function(){ delete _this._inProgressAnim; },
				properties: props
			})
			this._inProgressAnim.play();
		}
		else{
			progressBar.style[this._progressPixelSize] = (percent*100) + "%";
			remainingBar.style[this._progressPixelSize] = ((1-percent)*100) + "%";
		}
	},

	_bumpValue: function(signedChange){
		if(this.disabled || this.readOnly){ return; }
		var s = dojo.getComputedStyle(this.sliderBarContainer);
		var c = dojo._getContentBox(this.sliderBarContainer, s);
		var count = this.discreteValues;
		if(count <= 1 || count == Infinity){ count = c[this._pixelCount]; }
		count--;
		var value = (this.value - this.minimum) * count / (this.maximum - this.minimum) + signedChange;
		if(value < 0){ value = 0; }
		if(value > count){ value = count; }
		value = value * (this.maximum - this.minimum) / count + this.minimum;
		this._setValueAttr(value, true);
	},

	_onClkBumper: function(val){
		if(this.disabled || this.readOnly || !this.clickSelect){ return; }
		this._setValueAttr(val, true);
	},

	_onClkIncBumper: function(){
		this._onClkBumper(this._descending === false ? this.minimum : this.maximum);
	},

	_onClkDecBumper: function(){
		this._onClkBumper(this._descending === false ? this.maximum : this.minimum);
	},

	decrement: function(e){
		// summary:
		//		Decrement slider by 1 unit
		// tags:
		//		private
		this._bumpValue(e.charOrCode == dojo.keys.PAGE_DOWN ? -this.pageIncrement : -1);
	},

	increment: function(e){
		// summary:
		//		Increment slider by 1 unit
		// tags:
		//		private
		this._bumpValue(e.charOrCode == dojo.keys.PAGE_UP ? this.pageIncrement : 1);
	},

	_mouseWheeled: function(/*Event*/ evt){
		// summary:
		//		Event handler for mousewheel where supported
		dojo.stopEvent(evt);
		// FIXME: this adds mouse wheel support for safari, though stopEvent doesn't prevent
		// it from bleeding to window?!
		var janky = !dojo.isMozilla;
		var scroll = evt[(janky ? "wheelDelta" : "detail")] * (janky ? 1 : -1);
		this[(scroll < 0 ? "decrement" : "increment")](evt);
	},

	startup: function(){
		dojo.forEach(this.getChildren(), function(child){
			if(this[child.container] != this.containerNode){
				this[child.container].appendChild(child.domNode);
			}
		}, this);
	},

	_typematicCallback: function(/*Number*/ count, /*Object*/ button, /*Event*/ e){
		if(count == -1){ return; }
		this[(button == (this._descending? this.incrementButton : this.decrementButton))? "decrement" : "increment"](e);
	},

	postCreate: function(){
		if(this.showButtons){
			this.incrementButton.style.display="";
			this.decrementButton.style.display="";
			this._connects.push(dijit.typematic.addMouseListener(
				this.decrementButton, this, "_typematicCallback", 25, 500));
			this._connects.push(dijit.typematic.addMouseListener(
				this.incrementButton, this, "_typematicCallback", 25, 500));
		}
		this.connect(this.domNode, !dojo.isMozilla ? "onmousewheel" : "DOMMouseScroll", "_mouseWheeled");

		// define a custom constructor for a SliderMover that points back to me
		var _self = this;
		var mover = function(){
			dijit.form._SliderMover.apply(this, arguments);
			this.widget = _self;
		};
		dojo.extend(mover, dijit.form._SliderMover.prototype);

		this._movable = new dojo.dnd.Moveable(this.sliderHandle, {mover: mover});
		//find any associated label element and add to slider focusnode.
		var label=dojo.query('label[for="'+this.id+'"]');
		if(label.length){
			label[0].id = (this.id+"_label");
			dijit.setWaiState(this.focusNode, "labelledby", label[0].id);
		}
		dijit.setWaiState(this.focusNode, "valuemin", this.minimum);
		dijit.setWaiState(this.focusNode, "valuemax", this.maximum);

		this.inherited(arguments);
	},

	destroy: function(){
		this._movable.destroy();
		if(this._inProgressAnim && this._inProgressAnim.status != "stopped"){
			this._inProgressAnim.stop(true);
		}
		this.inherited(arguments);	
	}
});

dojo.declare("dijit.form._SliderMover",
	dojo.dnd.Mover,
{
	onMouseMove: function(e){
		var widget = this.widget;
		var abspos = widget._abspos;
		if(!abspos){
			abspos = widget._abspos = dojo.coords(widget.sliderBarContainer, true);
			widget._setPixelValue_ = dojo.hitch(widget, "_setPixelValue");
			widget._isReversed_ = widget._isReversed();
		}
		var pixelValue = e[widget._mousePixelCoord] - abspos[widget._startingPixelCoord];
		widget._setPixelValue_(widget._isReversed_ ? (abspos[widget._pixelCount]-pixelValue) : pixelValue, abspos[widget._pixelCount], false);
	},
	
	destroy: function(e){
		dojo.dnd.Mover.prototype.destroy.apply(this, arguments);
		var widget = this.widget;
		widget._abspos = null;
		widget._setValueAttr(widget.value, true);
	}
});



}

if(!dojo._hasResource["dijit.form.HorizontalRule"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.HorizontalRule"] = true;
dojo.provide("dijit.form.HorizontalRule");




dojo.declare("dijit.form.HorizontalRule", [dijit._Widget, dijit._Templated],
{
	// summary:
	//		Hash marks for `dijit.form.HorizontalSlider`

	templateString: '<div class="dijitRuleContainer dijitRuleContainerH"></div>',

	// count: Integer
	//		Number of hash marks to generate
	count: 3,

	// container: String
	//		For HorizontalSlider, this is either "topDecoration" or "bottomDecoration",
	//		and indicates whether this rule goes above or below the slider.
	container: "containerNode",

	// ruleStyle: String
	//		CSS style to apply to individual hash marks
	ruleStyle: "",

	_positionPrefix: '<div class="dijitRuleMark dijitRuleMarkH" style="left:',
	_positionSuffix: '%;',
	_suffix: '"></div>',

	_genHTML: function(pos, ndx){
		return this._positionPrefix + pos + this._positionSuffix + this.ruleStyle + this._suffix;
	},

	// _isHorizontal: [protected extension] Boolean
	//		VerticalRule will override this...
	_isHorizontal: true,

	postCreate: function(){
		var innerHTML;
		if(this.count==1){
			innerHTML = this._genHTML(50, 0);
		}else{
			var i;
			var interval = 100 / (this.count-1);
			if(!this._isHorizontal || this.isLeftToRight()){
				innerHTML = this._genHTML(0, 0);
				for(i=1; i < this.count-1; i++){
					innerHTML += this._genHTML(interval*i, i);
				}
				innerHTML += this._genHTML(100, this.count-1);
			}else{
				innerHTML = this._genHTML(100, 0);
				for(i=1; i < this.count-1; i++){
					innerHTML += this._genHTML(100-interval*i, i);
				}
				innerHTML += this._genHTML(0, this.count-1);
			}
		}
		this.domNode.innerHTML = innerHTML;
	}
});

}

if(!dojo._hasResource["dijit.form.HorizontalRuleLabels"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.HorizontalRuleLabels"] = true;
dojo.provide("dijit.form.HorizontalRuleLabels");



dojo.declare("dijit.form.HorizontalRuleLabels", dijit.form.HorizontalRule,
{
	// summary:
	//		Labels for `dijit.form.HorizontalSlider`

	templateString: '<div class="dijitRuleContainer dijitRuleContainerH dijitRuleLabelsContainer dijitRuleLabelsContainerH"></div>',

	// labelStyle: String
	//		CSS style to apply to individual text labels
	labelStyle: "",

	// labels: String[]?
	//		Array of text labels to render - evenly spaced from left-to-right or bottom-to-top.
	//		Alternately, minimum and maximum can be specified, to get numeric labels.
	labels: [],

	// numericMargin: Integer
	//		Number of generated numeric labels that should be rendered as '' on the ends when labels[] are not specified
	numericMargin: 0,

	// numericMinimum: Integer
	//		Leftmost label value for generated numeric labels when labels[] are not specified
	minimum: 0,

	// numericMaximum: Integer
	//		Rightmost label value for generated numeric labels when labels[] are not specified
	maximum: 1,

	// constraints: Object
	//		pattern, places, lang, et al (see dojo.number) for generated numeric labels when labels[] are not specified
	constraints: {pattern:"#%"},

	_positionPrefix: '<div class="dijitRuleLabelContainer dijitRuleLabelContainerH" style="left:',
	_labelPrefix: '"><span class="dijitRuleLabel dijitRuleLabelH">',
	_suffix: '</span></div>',

	_calcPosition: function(pos){
		// summary:
		//		Returns the value to be used in HTML for the label as part of the left: attribute
		// tags:
		//		protected extension
		return pos;
	},

	_genHTML: function(pos, ndx){
		return this._positionPrefix + this._calcPosition(pos) + this._positionSuffix + this.labelStyle + this._labelPrefix + this.labels[ndx] + this._suffix;
	},

	getLabels: function(){
		// summary:
		//		Overridable function to return array of labels to use for this slider.
		//		Can specify a getLabels() method instead of a labels[] array, or min/max attributes.
		// tags:
		//		protected extension

		// if the labels array was not specified directly, then see if <li> children were
		var labels = this.labels;
		if(!labels.length){
			// for markup creation, labels are specified as child elements
			labels = dojo.query("> li", this.srcNodeRef).map(function(node){
				return String(node.innerHTML);
			});
		}
		this.srcNodeRef.innerHTML = '';
		// if the labels were not specified directly and not as <li> children, then calculate numeric labels
		if(!labels.length && this.count > 1){
			var start = this.minimum;
			var inc = (this.maximum - start) / (this.count-1);
			for (var i=0; i < this.count; i++){
				labels.push((i<this.numericMargin||i>=(this.count-this.numericMargin))? '' : dojo.number.format(start, this.constraints));
				start += inc;
			}
		}
		return labels;
	},

	postMixInProperties: function(){
		this.inherited(arguments);
		this.labels = this.getLabels();
		this.count = this.labels.length;
	}
});



}

if(!dojo._hasResource["widgets.ResultsOptions"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.ResultsOptions"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.ResultsOptions");











dojo.declare(
	"widgets.ResultsOptions", [dijit._Widget, dijit._Templated],
	{
		prefix: EDR.prefix,
		imgBasePath: EDR.config.imageBaseDir,
		widgetsInTemplate: true,
		templateString:"<div>\n\t<form dojoAttachPoint=\"resultsOptionsForm\" style=\"width:100%;height:100%;\">\n\t\t<div dojoAttachPoint=\"topContainer\" style=\"width:98%;padding:5px;\">\n\t\t\t<div><label>${label_intro1}${label_intro2}</label></div><br/>\n\t\t\t<div dojoAttachPoint=\"topLeftContainer\" style=\"width:32%;float:left;\">\n\t\t\t\t<div title=\"${tooltip_resultsOption_num_results}\">\n\t\t\t\t\t<label for=\"${prefix}numberOfResults\">${label_number}:</label><br/>\n\t\t\t\t\t<input id=\"${prefix}numberOfResults\" dojoAttachPoint=\"resultsRange\" dojoType=\"dijit.form.NumberSpinner\" name=\"resultsRange\"\n\t\t\t\t\t\tvalue=\"10\" smallDelta=\"5\" largeDelta=\"25\" constraints=\"{min:1,max:100,places:0}\">\n\t\t\t\t\t</input><br/><br/>\n\t\t\t\t</div>\n\t\t\t\t<div title=\"${tooltip_resultsOption_query_lang}\">\n\t\t\t\t\t<label for=\"${prefix}queryLang\">${label_lang}:</label><br/>\n\t\t\t\t\t<select id=\"${prefix}queryLang\" dojoAttachPoint=\"queryLanguage\" dojoType=\"dijit.form.FilteringSelect\" name=\"queryLanguage\" searchAttr=\"label\" labelAttr=\"label\">\n\t\t\t\t\t</select><br/><br/>\n\t\t\t\t</div>\n\t\t\t\t<div title=\"${tooltip_resultsOption_mode}\">\n\t\t\t\t\t<label for=\"${prefix}queryMode\">${label_mode}:</label>\n\t\t\t\t\t<a href=\"javascript:;\" onclick=\"EDR.viewHelp('iiysulprefqmode.htm?noframes=true')\" title=\"${tooltip_help_querymode}\">\n\t\t\t\t\t\t<img src=\"${imgBasePath}help_16.png\" alt=\"${tooltip_help_querymode}\" style=\"vertical-align:top;\">\n\t\t\t\t\t</a>\n\t\t\t\t\t<br/>\n\t\t\t\t\t<select id=\"${prefix}queryMode\" dojoAttachPoint=\"queryMode\" dojoType=\"dijit.form.FilteringSelect\" name=\"queryMode\" searchAttr=\"label\" labelAttr=\"label\">\n\t\t\t\t\t</select><br/><br/>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div dojoAttachPoint=\"topRightContainer\" style=\"width:21%;float:left;\">\n\t\t\t\t<div title=\"${tooltip_resultsOption_sort_by}\">\n\t\t\t\t\t<label for=\"${prefix}sortBy\">${label_sortby}:</label><br/>\n\t\t\t\t\t<select id=\"${prefix}sortBy\" dojoAttachPoint=\"sortBy\" dojoType=\"dijit.form.FilteringSelect\" name=\"sortBy\" searchAttr=\"label\" labelAttr=\"label\" style=\"width: 120px;\">\n\t\t\t\t\t</select><br/><br/>\n\t\t\t\t</div>\n\t\t\t\t<div title=\"${tooltip_resultsOption_sort_order}\">\n\t\t\t\t\t<label for=\"${prefix}sortOrder\">${label_sortorder}:</label><br/>\n\t\t\t\t\t<select id=\"${prefix}sortOrder\" dojoAttachPoint=\"sortByOrder\" dojoType=\"dijit.form.FilteringSelect\" name=\"sortByOrder1\" searchAttr=\"label\" labelAttr=\"label\" style=\"width: 120px;\">\n\t\t\t\t\t</select><br/><br/>\n\t\t\t\t</div>\n\t\t\t</div>\n\n\t\t\t<div dojoAttachPoint=\"topRightContainer2\" style=\"width:21%;float:left;\">\n\t\t\t\t<div title=\"${tooltip_resultsOption_sort_by}\">\n\t\t\t\t\t<label for=\"${prefix}sortBy2\">${label_sortby2}:</label><br/>\n\t\t\t\t\t<select id=\"${prefix}sortBy2\" dojoAttachPoint=\"sortBy2\" dojoType=\"dijit.form.FilteringSelect\" name=\"sortBy2\" searchAttr=\"label\" labelAttr=\"label\" style=\"width: 120px;\">\n\t\t\t\t\t</select><br/><br/>\n\t\t\t\t</div>\n\t\t\t\t<div title=\"${tooltip_resultsOption_sort_order}\">\n\t\t\t\t\t<label for=\"${prefix}sortOrder2\">${label_sortorder2}:</label><br/>\n\t\t\t\t\t<select id=\"${prefix}sortOrder2\" dojoAttachPoint=\"sortByOrder2\" dojoType=\"dijit.form.FilteringSelect\" name=\"sortByOrder2\" searchAttr=\"label\" labelAttr=\"label\" style=\"width: 120px;\">\n\t\t\t\t\t</select><br/><br/>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t\n\t\t\t<div dojoAttachPoint=\"topRightContainer3\" style=\"width:21%;float:left;\">\n\t\t\t\t<div title=\"${tooltip_resultsOption_sort_by}\">\n\t\t\t\t\t<label for=\"${prefix}sortBy3\">${label_sortby3}:</label><br/>\n\t\t\t\t\t<select id=\"${prefix}sortBy3\" dojoAttachPoint=\"sortBy3\" dojoType=\"dijit.form.FilteringSelect\" name=\"sortBy3\" searchAttr=\"label\" labelAttr=\"label\" style=\"width: 120px;\">\n\t\t\t\t\t</select><br/><br/>\n\t\t\t\t</div>\n\t\t\t\t<div title=\"${tooltip_resultsOption_sort_order}\">\n\t\t\t\t\t<label for=\"${prefix}sortOrder3\">${label_sortorder3}:</label><br/>\n\t\t\t\t\t<select id=\"${prefix}sortOrder3\" dojoAttachPoint=\"sortByOrder3\" dojoType=\"dijit.form.FilteringSelect\" name=\"sortByOrder3\" searchAttr=\"label\" labelAttr=\"label\" style=\"width: 120px;\">\n\t\t\t\t\t</select><br/><br/>\n\t\t\t\t</div>\n\t\t\t</div>\t\t\t\t\t\t\n\t\t\t\n\t\t</div>\n\t\t<hr style=\"width:100%;clear:both;\"/>\n\t\t<div dojoAttachPoint=\"middleContainer\" style=\"padding:5px;width:98%;\" title=\"${tooltip_resultsOption_summary}\">\n\t\t\t<label for=\"${prefix}summaryLength\">${label_summarylen}:</label>\n\t\t\t<div style=\"text-align:center;\">\n\t\t\t\t<div dojoAttachPoint=\"summaryLength\" dojoType=\"dijit.form.HorizontalSlider\" name=\"summaryLength\"\n\t\t\t\t\tminimum=\"1\" value=\"1\" maximum=\"5\"\n\t\t\t\t\tdiscreteValues=\"5\" showButtons=\"false\" intermediateChanges=\"true\" slideDuration=\"0\"\n\t\t\t\t\tstyle=\"width:70%;height:40px;margin-left:auto;margin-right:auto;\" id=\"${prefix}summaryLength\">\n\t\t\t\t\t\t<div dojoType=\"dijit.form.HorizontalRule\" container=\"bottomDecoration\" count=5 style=\"height:5px;\"></div>\n\t\t\t\t\t\t<ol dojoType=\"dijit.form.HorizontalRuleLabels\" container=\"bottomDecoration\" style=\"height:1em;font-size:75%;\">\n\t\t\t\t\t\t\t<li><span style=\"white-space:nowrap;\">${label_summarymin}</span></li>\n\t\t\t\t\t\t\t<li><span style=\"white-space:nowrap;\">${label_summarymax}</span></li>\n\t\t\t\t\t\t</ol>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t\t<hr style=\"width:100%;clear:both;\"/>\n\t\t<div style=\"width:98%;padding:5px;\">\n\t\t\t<div style=\"width:48%;float:left;\">\n\t\t\t\t<div title=\"${tooltip_resultsOption_typeAhead_numberOfResults}\">\n\t\t\t\t\t<label for=\"${prefix}typeAheadNumberOfResults\">${label_resultsOption_typeAhead_numberOfResults}:</label><br/>\n\t\t\t\t\t<input id=\"${prefix}typeAheadNumberOfResults\" dojoAttachPoint=\"typeAheadNumberOfResults\" dojoType=\"dijit.form.NumberSpinner\" name=\"typeAheadNumberOfResults\"\n\t\t\t\t\t\tvalue=\"10\" smallDelta=\"5\" largeDelta=\"25\" constraints=\"{min:1,max:100,places:0}\">\n\t\t\t\t\t</input><br/><br/>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div style=\"width:48%;float:left;\">\n\t\t\t\t<div title=\"${tooltip_resultsOption_typeAhead_mode}\">\n\t\t\t\t\t<label for=\"${prefix}typeAheadMode\">${label_resultsOption_typeAhead_mode}:</label>\n\t\t\t\t\t<a href=\"javascript:;\" onclick=\"EDR.viewHelp('iiysultypeahead.htm?noframes=true')\" title=\"${tooltip_help_typeAheadMode}\">\n\t\t\t\t\t\t<img src=\"${imgBasePath}help_16.png\" alt=\"${tooltip_help_typeAheadMode}\" style=\"vertical-align:top;\">\n\t\t\t\t\t</a>\n\t\t\t\t\t<br/>\n\t\t\t\t\t<select id=\"${prefix}typeAheadMode\" dojoAttachPoint=\"typeAheadMode\" dojoType=\"dijit.form.FilteringSelect\" name=\"typeAheadMode\" searchAttr=\"label\" labelAttr=\"label\" style=\"width:295px;\">\n\t\t\t\t\t</select><br/><br/>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t\t<hr style=\"width:100%;clear:both;\"/>\n\t\t<div dojoAttachPoint=\"bottomContainer\" style=\"width:98%;padding:5px;\">\n\t\t\t<div dojoAttachPoint=\"bottomLeftContainer\" style=\"width:49%;float:left;\">\n\t\t\t\t<div title=\"${tooltip_resultsOption_quick_links}\" role=\"radiogroup\">\n\t\t\t\t\t<label>${label_quicklinks}:</label><br/>\n\t\t\t\t\t<input id=\"${prefix}quickLinkYes\" dojoAttachPoint=\"predefinedQueryYes\" dojoType=\"dijit.form.RadioButton\" value=\"Yes\" name=\"predefinedResults\"/>\n\t\t\t\t\t<label for=\"${prefix}quickLinkYes\">${label_yes}</label>&nbsp;\n\t\t\t\t\t<input id=\"${prefix}quickLinkNo\" dojoAttachPoint=\"predefinedQueryNo\" dojoType=\"dijit.form.RadioButton\" value=\"No\" name=\"predefinedResults\"/>\n\t\t\t\t\t<label for=\"${prefix}quickLinkNo\">${label_no}</label><br/><br/>\n\t\t\t\t</div>\n\t\t\t\t<div title=\"${tooltip_resultsOption_spell_correct}\" role=\"radiogroup\">\n\t\t\t\t\t<label>${label_spell}:</label><br/>\n\t\t\t\t\t<input id=\"${prefix}spellYes\" dojoAttachPoint=\"spellCorrectionYes\" dojoType=\"dijit.form.RadioButton\" value=\"Yes\" name=\"spellCorrections\"/>\n\t\t\t\t\t<label for=\"${prefix}spellYes\">${label_yes}</label>&nbsp;\n\t\t\t\t\t<input id=\"${prefix}spellNo\" dojoAttachPoint=\"spellCorrectionNo\" dojoType=\"dijit.form.RadioButton\" value=\"No\" name=\"spellCorrections\"/>\n\t\t\t\t\t<label for=\"${prefix}spellNo\">${label_no}</label><br/><br/>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div dojoAttachPoint=\"bottomRightContainer\" style=\"width:49%;float:left;\">\n\t\t\t\t<div title=\"${tooltip_resultsOption_collapse_results}\" role=\"radiogroup\">\n\t\t\t\t\t<label>${label_collapse}:</label><br/>\n\t\t\t\t\t<input id=\"${prefix}collapseYes\" dojoAttachPoint=\"siteCollapsingYes\" dojoType=\"dijit.form.RadioButton\" value=\"Yes\" name=\"siteCollapsing\"/>\n\t\t\t\t\t<label for=\"${prefix}collapseYes\">${label_yes}</label>&nbsp;\n\t\t\t\t\t<input id=\"${prefix}collapseNo\" dojoAttachPoint=\"siteCollapsingNo\" dojoType=\"dijit.form.RadioButton\" value=\"No\" name=\"siteCollapsing\"/>\n\t\t\t\t\t<label for=\"${prefix}collapseNo\">${label_no}</label><br/><br/>\n\t\t\t\t</div>\n\t\t\t\t<div title=\"${tooltip_resultsOption_search_synonyms}\" role=\"radiogroup\">\n\t\t\t\t\t<label>${label_synonym}:</label><br/>\n\t\t\t\t\t<input id=\"${prefix}synonymYes\" dojoAttachPoint=\"synonymExpansionsAutomatic\" dojoType=\"dijit.form.RadioButton\" value=\"Automatic\" name=\"synonymExpansions\"/>\n\t\t\t\t\t<label for=\"${prefix}synonymYes\">${label_yes}</label>&nbsp;\n\t\t\t\t\t<!-- div style=\"height:2px;\">&nbsp;</div>\n\t\t\t\t\t<input id=\"${prefix}semanticYes\" dojoType=\"dijit.form.RadioButton\" value=\"Semantic\" name=\"synonymExpansions\"/>\n\t\t\t\t\t<label for=\"${prefix}semanticYes\">${label_semanticyes}</label><br/>\n\t\t\t\t\t<div style=\"height:2px;\">&nbsp;</div-->\n\t\t\t\t\t<input id=\"${prefix}synonymNo\" dojoAttachPoint=\"synonymExpansionsOff\" dojoType=\"dijit.form.RadioButton\" value=\"Off\" name=\"synonymExpansions\"/>\n\t\t\t\t\t<label for=\"${prefix}synonymNo\">${label_no}</label><br/><br/>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t</form>\t\n</div>\n",
		_autoLoad: false,
		handlers: [],
		
		_sortByItems: null, // sortBy items for 2nd, 3rd keys

		json: null,
				
		postCreate: function() {
			this.inherited("postCreate", arguments);

			if (this._autoLoad) this.loadJson();
			
			this.typeAheadNumberOfResults.domNode.style.marginTop = "2px";
			this.handlers.push(dojo.connect(this.sortBy,"onChange",this,this._onSortByChange));
			this.handlers.push(dojo.connect(this.sortBy2,"onChange",this,this._onSortBy2Change));
			this.handlers.push(dojo.connect(this.sortBy3,"onChange",this,this._onSortBy3Change));
			this.handlers.push(dojo.connect(this.queryMode,"onChange",this,this._onQueryModeChange));
			this.handlers.push(dojo.connect(this.typeAheadMode,"onChange",this,this._onTypeAheadModeChange));
			if(dojo.isIE){
				//for IE to avoid right align
				this.handlers.push(dojo.connect(this.typeAheadMode, "_selectOption", this, this._moveFocusOnTypeAheadMode));
				if(EDR.isPortlet) {
					this.domNode.style.overflow = "auto";
				}
			}
		},		
		
		loadJson: function(json) {
			if (json == null) json = this._getNullResultsOptions();
			this.json = json;
			this.buildOptions();
		},
				
		getFormValues: function() {
			var values = dojo.formToObject(this.resultsOptionsForm);
			return values;
		},
		
		validate: function(params) {
			var errors = "";

			if (!this.resultsRange.isValid()) {
				errors += this.label_number + " : " + this.resultsRange.invalidMessage + "<br/><br/>";
			}
			if (!this.queryLanguage.isValid()) {
				errors += this.label_lang + " : " + this.queryLanguage.invalidMessage + "<br/><br/>";
			}
			if (!this.queryMode.isValid()) {
				errors += this.label_mode + " : " + this.queryMode.invalidMessage + "<br/><br/>";
			}
			if (!this.sortBy.isValid()) {
				errors += this.label_sortby + " : " + this.sortBy.invalidMessage + "<br/><br/>";
			}
			if (!this.sortBy2.isValid()) {
				errors += this.label_sortby2 + " : " + this.sortBy2.invalidMessage + "<br/><br/>";
			}
			if (!this.sortBy3.isValid()) {
				errors += this.label_sortby3 + " : " + this.sortBy3.invalidMessage + "<br/><br/>";
			}			
			if (!this.sortByOrder.isValid()) {
				errors += this.label_sortorder + " : " + this.sortByOrder.invalidMessage + "<br/><br/>";
			}
			if (!this.sortByOrder2.isValid()) {
				errors += this.label_sortorder2 + " : " + this.sortByOrder2.invalidMessage + "<br/><br/>";
			}
			if (!this.sortByOrder3.isValid()) {
				errors += this.label_sortorder3 + " : " + this.sortByOrder3.invalidMessage + "<br/><br/>";
			}			
			if (!this.typeAheadNumberOfResults.isValid()) {
				errors += this.label_resultsOption_typeAhead_numberOfResults + " : " + this.typeAheadNumberOfResults.invalidMessage + "<br/><br/>";
			}
						
			if (!this.typeAheadMode.isValid()) {
				errors += this.label_resultsOption_typeAhead_mode + " : " + this.typeAheadMode.invalidMessage + "<br/><br/>";
			}
			
			if (errors != "") {
				EDR.util.alert(errors);
				return false;
			}			
			return true;
		},
		
		buildOptions: function() {
			if (this.json == null) return;			
			this.clear();
			var self = this;
			
			// result range
			this.resultsRange.attr("value", this.json.resultsRange);

			// query language
			var store = new dojo.data.ItemFileReadStore({data:{
				 identifier:"value",
				 items:this.json.queryLanguage
			}});
			this.queryLanguage.attr("store", store);
			
			// query mode
			var queryModeJson = this._getQueryModeJson();
			store = new dojo.data.ItemFileReadStore({data:{
				 identifier:"value",
				 items:queryModeJson
			}});
			this.queryMode.attr("store", store);
		
			// sort by
			store = new dojo.data.ItemFileReadStore({data:{
				identifier:"value",
				items:this.json.sortBy
			}});
			this.sortBy.attr("store", store);
			
			var clonedArray = dojo.fromJson(dojo.toJson(this.json.sortBy));
			for(var i=0;i<clonedArray.length;++i) {
				//remove "[Relevance]"
				if(clonedArray[i].value == "[Relevance]") {
					clonedArray.splice(i, 1); //delete
					break;
				}
			}
			var noneItem = {
					label: EDR.messages.prompt_selection_none,
					selected: false,
					value: "[None]"				
			};
			clonedArray.unshift(noneItem);
			
			this._sortByItems = dojo.fromJson(dojo.toJson(clonedArray));

			store = new dojo.data.ItemFileReadStore({data:{
				identifier:"value",
				items:clonedArray
			}});
			this._sortBy2Array = clonedArray;
			this.sortBy2.attr("store", store);
			
			clonedArray = dojo.fromJson(dojo.toJson(clonedArray));
			store = new dojo.data.ItemFileReadStore({data:{
				identifier:"value",
				items:clonedArray
			}});
			this._sortBy3Array = clonedArray;
			this.sortBy3.attr("store", store);
		
			// sort by order
			var sortByOrderJson = this._getSortByOrderJson();
			clonedArray = dojo.fromJson(dojo.toJson(sortByOrderJson));
			store = new dojo.data.ItemFileReadStore({data:{
				 identifier:"value",
				 items:clonedArray
			}});
			this.sortByOrder.attr("store", store);
			
			clonedArray = dojo.fromJson(dojo.toJson(sortByOrderJson));
			store = new dojo.data.ItemFileReadStore({data:{
				 identifier:"value",
				 items:clonedArray
			}});			
			this.sortByOrder2.attr("store", store);
			
			clonedArray = dojo.fromJson(dojo.toJson(sortByOrderJson));
			store = new dojo.data.ItemFileReadStore({data:{
				 identifier:"value",
				 items:clonedArray
			}});
			this.sortByOrder3.attr("store", store);
		
			// summary length
			this.summaryLength.attr("value", this.json.summaryLength);
			
			// type ahead number of results
			this.typeAheadNumberOfResults.attr("value", this.json.typeAheadNumberOfResults);

			// type ahead mode
			var typeAheadModeJson = this._getTypeAheadModeJson();
			store = new dojo.data.ItemFileReadStore({data:{
				 identifier:"value",
				 items:typeAheadModeJson
			}});
			this.typeAheadMode.attr("store", store);
			
			if(this.json.typeAheadMode=="allOff"){
				this.typeAheadMode.attr("disabled",true);
				this.typeAheadNumberOfResults.attr("disabled",true);
			}
						
			// quick links
			this["predefinedQuery" + (this.json.predefinedQuery  == "Yes"? "Yes" : "No")].attr("checked", true);
			
			// spell correction
			this["spellCorrection" + (this.json.spellCorrection == "Yes" ? "Yes" : "No")].attr("checked", true);
			
			// site collapsing
			this["siteCollapsing" + (this.json.siteCollapsing == "Yes" ? "Yes" : "No")].attr("checked", true);
			
			// synonym expansion
			if (this.json.synonymExpansions == "Automatic") {
				this.synonymExpansionsAutomatic.attr("checked", true);
			} else if (this.json.synonymExpansions == "Semantic") {
//				this.synonymExpansionsSemantic.attr("checked", true);
				this.synonymExpansionsAutomatic.attr("checked", true);
			} else {
				this.synonymExpansionsOff.attr("checked", true);
			}
			
			
			for (var i=0; i<this.json.queryLanguage.length; i++) {
				var item = this.json.queryLanguage[i];
				if (item.selected) {
					self.queryLanguage.attr("value", item.value);
					break;
				}
			}
			
			for (var i=0; i<queryModeJson.length; i++) {
				var item = queryModeJson[i];
				if (item.value == this.json.queryMode) {
					self.queryMode.attr("value", item.value);
					break;
				}
			}
			
			for (var i=0; i<typeAheadModeJson.length; i++) {
				var item = typeAheadModeJson[i];
				if (item.value == this.json.typeAheadMode) {
					self.typeAheadMode.attr("value", item.value);
					break;
				}
			}
			
			for (var i=0; i<this.json.sortBy.length; i++) {
				var item = this.json.sortBy[i];
				if (item.selected) {
					self.sortBy.attr("value", item.value);
					break;
				}
			}
			if(this.json.sortBy2) {
				self.sortBy2.attr("value", this.json.sortBy2);	
			} else {
				self.sortBy2.attr("value", "[None]");	
			}

			if(this.json.sortBy3) {
				self.sortBy3.attr("value", this.json.sortBy3);	
			} else {
				self.sortBy3.attr("value", "[None]");	
			}
			
			if(this.json.sortByOrder1) {
				self.sortByOrder.attr("value", this.json.sortByOrder1);
			} else {
				self.sortByOrder.attr("value", "descending");
			}
			
			if(this.json.sortByOrder2) {
				self.sortByOrder2.attr("value", this.json.sortByOrder2);
			} else {
				self.sortByOrder2.attr("value", "descending");
			}

			if(this.json.sortByOrder3) {
				self.sortByOrder3.attr("value", this.json.sortByOrder3);
			} else {
				self.sortByOrder3.attr("value", "descending");
			}			
		},
		
		clear: function() {
/*			dojo.forEach(this.queryLanguage.getOptions(), dojo.hitch(this, function(option) {
				this.queryLanguage.removeOption(option);
			}));
			dojo.forEach(this.sortBy.getOptions(), dojo.hitch(this, function(option) {
				this.sortBy.removeOption(option);
			})); */
		},
		
		_getNullResultsOptions: function() {
/*			return {
				resultsRange: 25,
				queryLanguage: [{value:"en", label:"English", selected:true}],
				sortBy: [{value:"relevance", label:"Relevance", selected:true}],
				sortByOrder: "descending",
				predefinedQuery: "No", 
				spellCorrection: "Yes",
				queryMode: "baseform",
				siteCollapsing: "Yes",
				synonymExpansions: "Semantic",
				summaryLength: 3				
			};*/
			return {
				"resultsRange":'10',
				queryLanguage:[],
				sortBy:[
					{"label":'filesize',"value":'filesize',selected:false},
					{"label":'lastmodifiedtime',"value":'lastmodifiedtime',selected:false},
					{"label":'modifieddate',"value":'modifieddate',selected:false},
					{"label":'postedtime',"value":'postedtime',selected:false},
					{"label":'[Relevance]',"value":'[Relevance]',selected:false},
					{"label":'[Date]',"value":'[Date]',selected:false}
				],
				"sortByOrder":'',
				"predefinedQuery":'No',
				"spellCorrection":'Yes',
				"queryMode":'engine',
				"siteCollapsing":'Yes',
				"synonymExpansions":'Semantic',
				"summaryLength":1,
				"typeAheadNumberOfResults":10,
				"typeAheadMode":"queryLog,term"
			};
		},
		
		_getQueryModeJson: function() {
			if (this._queryModeJson == null) {
				this._queryModeJson = [
					{value:"engine", label:this.label_mode_engine},
					{value:"baseform", label:this.label_mode_baseform},
					{value:"exact", label:this.label_mode_exact},
					{value:"baseform_exact", label:this.label_mode_baseformexact}
				];
			}
			return this._queryModeJson;
		},
		
		_getSortByOrderJson: function() { 
			if (this._sortByOrder == null) {
				this._sortByOrder = [
					{value:"descending", label:this.label_descending},
					{value:"ascending", label:this.label_ascending}
				];
			}
			return this._sortByOrder;
		},
		
		_getTypeAheadModeJson: function() {
			if (this._typeAheadModeJson == null) {
				this._typeAheadModeJson = [
					{value:"off", label:EDR.messages.resultsOption_label_typeAhead_mode_off},
					{value:"queryLog", label:EDR.messages.resultsOption_label_typeAhead_mode_queryLog},
					{value:"term", label:EDR.messages.resultsOption_label_typeAhead_mode_term},
					{value:"queryLog,term", label:EDR.messages.resultsOption_label_typeAhead_mode_queryLogFirst},
					{value:"term,queryLog", label:EDR.messages.resultsOption_label_typeAhead_mode_termFirst}
				];
			}
			return this._typeAheadModeJson;
		},
				
		destroy: function() {
			dojo.forEach(this.handlers, dojo.disconnect);
			this.inherited("destroy", arguments);
		},
		
		_onSortByChange: function(value){
			var input = this.sortByOrder;
			if(value=='[Relevance]'){
				input.setValue("descending");
				input.attr("disabled",true);
				if(this.sortBy2.attr("value") != true) {
					this.sortBy2.attr("value", "[None]");
				}
				if(this.sortBy3.attr("disabled") != true) {
					this.sortBy3.attr("value", "[None]");			
				}
				this.sortBy2.attr("disabled", true);
				this.sortBy3.attr("disabled", true);
				this.sortByOrder2.attr("disabled", true);
				this.sortByOrder3.attr("disabled", true);
			}else{
				input.attr("disabled",false);
				this.sortBy2.attr("disabled", false);
				
				if(value == this.sortBy2.attr("value")) {
					this.sortBy2.attr("value", "[None]");
				}
				var newItems = dojo.fromJson(dojo.toJson(this._sortByItems));
				var filteredItems = [];
				for(var i=0; i<newItems.length;++i) {
					var itemValue = newItems[i].value;
					if(itemValue != value && itemValue != this.sortBy.attr("value")) {
						filteredItems.push(newItems[i]);
					}
				}
				var store = new dojo.data.ItemFileReadStore({data:{
					identifier:"value",
					items:filteredItems
				}});
				this.sortBy2.attr("store", store);
				
				if(value == this.sortBy3.attr("value")) {
					this.sortBy3.attr("value", "[None]");
				}
				var newItems = dojo.fromJson(dojo.toJson(this._sortByItems));
				var filteredItems = [];
				for(var i=0; i<newItems.length;++i) {
					var itemValue = newItems[i].value;
					if(itemValue != value && itemValue != this.sortBy.attr("value") && itemValue != this.sortBy2.attr("value")) {
						filteredItems.push(newItems[i]);
					}
				}
				var store = new dojo.data.ItemFileReadStore({data:{
					identifier:"value",
					items:filteredItems
				}});
				this.sortBy3.attr("store", store);					
			
			}
		},
		
		_onSortBy2Change: function(value){
			if(value=='[None]'){
				this.sortBy3.attr("value", "[None]");
				this.sortBy3.attr("disabled", true);
				this.sortByOrder2.attr("disabled", true);
			}else{
				this.sortBy3.attr("disabled", false);
				this.sortByOrder2.attr("disabled", false);
				
				if(value == this.sortBy3.attr("value")) {
					this.sortBy3.attr("value", "[None]");
				}
				var newItems = dojo.fromJson(dojo.toJson(this._sortByItems));
				var filteredItems = [];
				for(var i=0; i<newItems.length;++i) {
					var itemValue = newItems[i].value;
					if(itemValue != value && itemValue != this.sortBy.attr("value") && itemValue != this.sortBy2.attr("value")) {
						filteredItems.push(newItems[i]);
					}
				}
				var store = new dojo.data.ItemFileReadStore({data:{
					identifier:"value",
					items:filteredItems
				}});
				this.sortBy3.attr("store", store);					
				
			}
		},
		
		_onSortBy3Change: function(value){
			if(value=='[None]'){
				this.sortByOrder3.attr("disabled", true);
			}else{
				this.sortByOrder3.attr("disabled", false);
			}
		},
		
		_onQueryModeChange: function(value){
			var input = this.queryMode;
			switch(value){
				case "engine":
					input.attr("title",this.tooltip_resultsOption_mode);
					break;
				case "baseform":
					input.attr("title",this.tooltip_resultsOption_mode_base);
					break;
				case "exact":
					input.attr("title",this.tooltip_resultsOption_mode_exact);
					break;
				case "baseform_exact":
					input.attr("title",this.tooltip_resultsOption_mode_both);
					break;
			}
		},
		
		_onTypeAheadModeChange: function(value){
			var input = this.typeAheadMode;
			switch(value){
				case "off":
					input.attr("title", EDR.messages.resultsOption_label_typeAhead_mode_off);
					break;
				case "queryLog":
					input.attr("title", EDR.messages.resultsOption_label_typeAhead_mode_queryLog);
					break;
				case "term":
					input.attr("title", EDR.messages.resultsOption_label_typeAhead_mode_term);
					break;
				case "queryLog,term":
					input.attr("title", EDR.messages.resultsOption_label_typeAhead_mode_queryLogFirst);
					break;
				case "term,queryLog":
					input.attr("title", EDR.messages.resultsOption_label_typeAhead_mode_termFirst);
					break;
			}
		},
		
		_moveFocusOnTypeAheadMode: function(){
			var fieldRange = this.typeAheadMode.textbox.createTextRange();
			fieldRange.moveStart("character", 0);
			fieldRange.collapse();
			fieldRange.select();
		},
		
		// messages
		label_intro1: EDR.messages.resultsOption_label_title,
		label_intro2: EDR.isAuthorized ? EDR.messages.search_options_intro_authorized : EDR.messages.search_options_intro_unauthorized,
		label_number: EDR.messages.resultsOption_label_number,
		label_lang: EDR.messages.resultsOption_label_lang,
		label_mode: EDR.messages.resultsOption_label_mode,
		label_sortby: EDR.messages.resultsOption_label_sortby,
		label_sortby2: EDR.messages.resultsOption_label_sortby + " (" + EDR.messages.order_2 + ")",
		label_sortby3: EDR.messages.resultsOption_label_sortby + " (" + EDR.messages.order_3 + ")",		
		label_sortorder: EDR.messages.resultsOption_label_sortorder,
		label_sortorder2: EDR.messages.resultsOption_label_sortorder + " (" + EDR.messages.order_2 + ")",
		label_sortorder3: EDR.messages.resultsOption_label_sortorder + " (" + EDR.messages.order_3 + ")",		
		label_summarylen: EDR.messages.resultsOption_label_summarylen,
		label_summarymin: EDR.messages.resultsOption_label_summarymin,
		label_summarymax: EDR.messages.resultsOption_label_summarymax,
		label_quicklinks: EDR.messages.resultsOption_label_quicklinks,
		label_spell: EDR.messages.resultsOption_label_spell,
		label_collapse: EDR.messages.resultsOption_label_collapse,
		label_synonym: EDR.messages.resultsOption_label_synonym,
		label_yes: EDR.messages.resultsOption_label_yes,
		label_no: EDR.messages.resultsOption_label_no,
		label_semanticyes: EDR.messages.resultsOption_label_semanticyes,
		label_mode_engine: EDR.messages.resultsOption_label_mode_engine,
		label_mode_baseform: EDR.messages.resultsOption_label_mode_baseform,
		label_mode_exact: EDR.messages.resultsOption_label_mode_exact,
		label_mode_baseformexact: EDR.messages.resultsOption_label_mode_baseformexact,		
		label_ascending: EDR.messages.resultsOption_label_ascending,
		label_descending: EDR.messages.resultsOption_label_descending,
		label_resultsOption_typeAhead_numberOfResults: EDR.messages.resultsOption_label_typeAhead_numberOfResults,
		label_resultsOption_typeAhead_mode: EDR.messages.resultsOption_label_typeAhead_mode,
		
		tooltip_resultsOption_num_results: EDR.messages.tooltip_resultsOption_num_results,
		tooltip_resultsOption_query_lang: EDR.messages.tooltip_resultsOption_query_lang,
		tooltip_resultsOption_mode: EDR.messages.tooltip_resultsOption_mode,
		tooltip_resultsOption_mode_base: EDR.messages.tooltip_resultsOption_mode_base,
		tooltip_resultsOption_mode_exact: EDR.messages.tooltip_resultsOption_mode_exact,
		tooltip_resultsOption_mode_both: EDR.messages.tooltip_resultsOption_mode_both,
		tooltip_resultsOption_sort_by: EDR.messages.tooltip_resultsOption_sort_by,
		tooltip_resultsOption_sort_order: EDR.messages.tooltip_resultsOption_sort_order,
		tooltip_resultsOption_summary: EDR.messages.tooltip_resultsOption_summary,
		tooltip_resultsOption_quick_links: EDR.messages.tooltip_resultsOption_quick_links,
		tooltip_resultsOption_spell_correct: EDR.messages.tooltip_resultsOption_spell_correct,
		tooltip_resultsOption_collapse_results: EDR.messages.tooltip_resultsOption_collapse_results,
		tooltip_resultsOption_search_synonyms: EDR.messages.tooltip_resultsOption_search_synonyms,
		tooltip_help_querymode: EDR.messages.tooltip_help_querymode,
		tooltip_resultsOption_typeAhead_numberOfResults: EDR.messages.tooltip_resultsOption_typeAhead_numberOfResults,
		tooltip_resultsOption_typeAhead_mode: EDR.messages.tooltip_resultsOption_typeAhead_mode,
		tooltip_help_typeAheadMode: EDR.messages.tooltip_help_typeAheadMode
	}
);

}

if(!dojo._hasResource["widgets.ResultsColumns"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.ResultsColumns"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.ResultsColumns");






dojo.declare(
"widgets.ResultsColumns",
[dijit._Widget, dijit._Templated],
{
	widgetsInTemplate: true,
	
	_checkedIconPath: dojo.moduleUrl("widgets", "templates/images/check_kiso_sel13.png"),
	
	_uncheckedIconPath: dojo.moduleUrl("widgets", "templates/images/check_kiso_unsel13.png"),
	
	templateString:"<div class=\"ResultsColumns\">\n\t<div style=\"padding:5px;\">\n\t\t<div class=\"errorMsg\" style=\"display: none;\"></div>\n\t\t\n\t\t<div class=\"dialog-instructions\" style=\"line-height: 1.5em;\">${messages_preferences_resultsColumns_show}${label_intro2}</div>\n\t\t<div class=\"setColumnData\">\n\t\t\t<div class=\"setColumnsHeader\">\n\t\t\t\t<table class=\"setColumnsHeaderTable\">\n\t\t\t\t\t<thead>\n\t\t\t\t\t<th class=\"setColumnsHeaderShow\">${messages_preferences_resultsColumns_header1}</th>\n\t\t\t\t\t<th class=\"setColumnsHeaderHeader\">${messages_preferences_resultsColumns_header2}</th>\n\t\t\t\t\t</thead>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t\t<div class=\"setColumnsValues\"> \n\t\t\t\t<table width=\"100%\">\n\t\t\t\t\t<tbody dojoAttachPoint=\"columnsTableBody\">\n\t\t\t\t\t<!--\n\t\t\t\t\t<tr class=\"odd selected focused\" originalClass=\"odd\">\n\t\t\t\t\t\t\t<td class=\"columnCheckbox\">\n\t\t\t\t\t\t\t\t<img class=\"checked\" alt=\"\" title=\"\" tabindex=\"0\" width=\"13\" height=\"13\" />\n\t\t\t\t\t\t\t</td>\t\n\t\t\t\t\t\t\t<td class=\"columnName\">\n\t\t\t\t\t\t\t\t<a href=\"javascript:;\">Narrow Your Results</a>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr class=\"odd selected focused\" originalClass=\"odd\">\n\t\t\t\t\t\t\t<td class=\"columnCheckbox\">\n\t\t\t\t\t\t\t\t<img class=\"checked\" alt=\"\" title=\"\" tabindex=\"0\" />\n\t\t\t\t\t\t\t</td>\t\n\t\t\t\t\t\t\t<td class=\"columnName\">\n\t\t\t\t\t\t\t\t<a href=\"javascript:;\">File Type</a>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr class=\"odd selected focused\" originalClass=\"odd\">\n\t\t\t\t\t\t\t<td class=\"columnCheckbox\">\n\t\t\t\t\t\t\t\t<img src=\"images/check_kiso_sel13.png\" style=\"cursor:pointer;\" alt=\"\" title=\"\" tabindex=\"0\" />\n\t\t\t\t\t\t\t</td>\t\n\t\t\t\t\t\t\t<td class=\"columnName\">\n\t\t\t\t\t\t\t\t<a href=\"javascript:;\">Relevance</a>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr class=\"odd selected focused\" originalClass=\"odd\">\n\t\t\t\t\t\t\t<td class=\"columnCheckbox\">\n\t\t\t\t\t\t\t\t<img src=\"images/check_kiso_sel13.png\" style=\"cursor:pointer;\" alt=\"\" title=\"\" tabindex=\"0\" />\n\t\t\t\t\t\t\t</td>\t\n\t\t\t\t\t\t\t<td class=\"columnName\">\n\t\t\t\t\t\t\t\t<a href=\"javascript:;\">Date</a>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr class=\"odd selected focused\" originalClass=\"odd\">\n\t\t\t\t\t\t\t<td class=\"columnCheckbox\">\n\t\t\t\t\t\t\t\t<img src=\"images/check_kiso_sel13.png\" style=\"cursor:pointer;\" alt=\"\" title=\"\" tabindex=\"0\" />\n\t\t\t\t\t\t\t</td>\t\n\t\t\t\t\t\t\t<td class=\"columnName\">\n\t\t\t\t\t\t\t\t<a href=\"javascript:;\">Thumbnail</a>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t-->\t\t\t\t\n\t\t\t\t\t</tbody>\n\t\t\t\t</table>\n\t\t\t\t<img src=\"${imgBasePath}blank.gif\" alt=\"\" style=\"display: none\"/>\n\t\t\t</div>\n\t\t\t<div class=\"setColumnsValuesButtons\">\n\t\t\t\t<div>\n\t\t\t\t\t<div dojoAttachPoint=\"setColumnsValuesMoveTop\" style=\"width:200px;\"\n\t\t\t\t\tdojoType=\"widgets.Button\"\n\t\t\t\t\tdojoAttachEvent=\"onClick:onMoveTopClick\"\n\t\t\t\t\tdisabled=\"disabled\"\n\t\t\t\t\ttitle=\"${messages_preferences_resultsColumns_moveToFirst}\">${messages_preferences_resultsColumns_moveToFirst}</div>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<div dojoAttachPoint=\"setColumnsValuesMoveUp\" style=\"width:200px;\"\n\t\t\t\t\t\t\t\tdojoType=\"widgets.Button\"\n\t\t\t\t\t\t\t\tdojoAttachEvent=\"onClick:onMoveUpClick\"\n\t\t\t\t\t\t\t\tdisabled=\"disabled\"\n\t\t\t\t\t\t\t\ttitle=\"${messages_preferences_resultsColumns_moveBefore}\">${messages_preferences_resultsColumns_moveBefore}</div>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<div dojoAttachPoint=\"setColumnsValuesMoveDown\" style=\"width:200px;\" \n\t\t\t\t\t\tdojoType=\"widgets.Button\"\n\t\t\t\t\t\tdojoAttachEvent=\"onClick:onMoveDownClick\"\n\t\t\t\t\t\ttitle=\"${messages_preferences_resultsColumns_moveAfter}\">${messages_preferences_resultsColumns_moveAfter}</div>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<div dojoAttachPoint=\"setColumnsValuesMoveBottom\" style=\"width:200px;\" \n\t\t\t\t\t\t\t\tdojoType=\"widgets.Button\"\n\t\t\t\t\t\t\t\tdojoAttachEvent=\"onClick:onMoveBottomClick\"\n\t\t\t\t\t\t\t\ttitle=\"${messages_preferences_resultsColumns_moveToLast}\">${messages_preferences_resultsColumns_moveToLast}</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\n\t\t</div>\n\t</div>\n</div>\n",
	
	imgBasePath: EDR.config.imageBaseDir,
	
	testData: "",
	
	_rowCount: 0,
	_selectedRow: 0,
	_focusedRow: 0,
	
	label_intro2: EDR.isAuthorized ? EDR.messages.search_options_intro_authorized : EDR.messages.search_options_intro_unauthorized,
	messages_preferences_resultsColumns_show: EDR.messages.preferences_resultsColumns_show,
	messages_preferences_resultsColumns_moveToFirst: EDR.messages.preferences_resultsColumns_moveToFirst,
	messages_preferences_resultsColumns_moveBefore: EDR.messages.preferences_resultsColumns_moveBefore,
	messages_preferences_resultsColumns_moveAfter: EDR.messages.preferences_resultsColumns_moveAfter,
	messages_preferences_resultsColumns_moveToLast: EDR.messages.preferences_resultsColumns_moveToLast,
	messages_preferences_resultsColumns_header1: EDR.messages.preferences_resultsColumns_header1,
	messages_preferences_resultsColumns_header2: EDR.messages.preferences_resultsColumns_header2,
	
	postCreate: function() {
/*		if(this.testData) {
			this._renderTestdata();
		}*/
//		dojo.subscribe("postLoad", this, "applyChanges");
	},
	
	startup: function() {
		this.setColumnsValuesMoveTop.adjustButtonWidth();
		this.setColumnsValuesMoveBottom.adjustButtonWidth();
		this.setColumnsValuesMoveUp.adjustButtonWidth();
		this.setColumnsValuesMoveDown.adjustButtonWidth();
	},
	
	getFormValues: function() {
		var values={};
		var trs = dojo.query("tr",this.columnsTableBody);
		var str="";
		var length = trs.length;
		for(var i=0; i<length; i++){
			if(dojo.attr(trs[i],"checked")==false) {
				str += "$";
			}
			str += dojo.attr(trs[i],"columnName");
			if(i<length-1)
				str += ",";
		}
		values["resultColumns"]=str;
		return values;
	},
	
	validate: function(params) {
			var errors = "";
			if (errors != "") {
				EDR.util.alert(errors);
				return false;
			}			
			return true;
	},
	
/*	_renderTestdata: function() {
		var args = {
				url: this.testData,
				handleAs: "json",
				load: dojo.hitch(this, "_onTestdataLoaded")
		};
		dojo.xhrGet(args);
	},*/
	
/*	_onTestdataLoaded: function(data) {
		this._initColumnsTable(data);
	},*/
	
	_initColumnsTable: function(data) {
		var columns = data.columns;
		this._rowCount = columns.length;
		
		for(var i=0; i<columns.length; i++) {
			var column = columns[i];
			var name = column.name;
			var id = "column_" + column.name;
			var show = column.show;
			var oddEven = (i % 2 == 0 ? "even" : "odd");
			var originalClass = oddEven;
			
			var args;
			if(i==0) {
				args = { className: "even selected focused" };
			} else {
				args = { className: oddEven};
			}
			args.columnName = name;
			args.checked = true;
			args.onclick = dojo.hitch(this, "_onRowClick");
			var tr = dojo.create("tr", args, this.columnsTableBody);
			var td = dojo.create("td", {className: "columnCheckbox"}, tr);
			var img = dojo.create("img", {style: "cursor: pointer;", id:EDR.prefix+"setSearchColumns-"+i, tabindex:0, onkeypress:dojo.hitch(this, "_onCheckButtonKeyPress") ,onclick: dojo.hitch(this, "_onCheckButtonClick")}, td);
			if(column.show) {
				img.src = this._checkedIconPath;
				tr.checked = true;
			} else {
				img.src = this._uncheckedIconPath;
				tr.checked = false;
			}
			
			td = dojo.create("td", {className: "columnName"}, tr);
			var labelText = EDR.messages["columns_"+column.name] ? EDR.messages["columns_"+column.name] : column.name;
			var label = dojo.create("a", {href: "javascript:;", innerHTML: labelText}, td);
		}
	},
	
	_onRowClick: function(evt) {
		var tbody = this.columnsTableBody;
		var lastFocused = tbody.rows[this._focusedRow];
		var lastSelected = tbody.rows[this._selectedRow];
		
		dojo.removeClass(lastFocused, "focused");
		dojo.removeClass(lastSelected, "selected");
		
		function getEventTargetRow(node) {
			if(node.tagName == "TR") {
				return node;	
			} else {
				return getEventTargetRow(node.parentNode);
			}
		}
		
		var row = getEventTargetRow(evt.target);

		this._selectedRow = row.rowIndex;
		this._focusedRow = row.rowIndex;
		dojo.addClass(row, "selected");		
		dojo.addClass(row, "focused");
		
//		this._updateButtonState();		
		this._updateButtonState(this._isThum(row));
	},
	
	_updateButtonState: function(_isThum) {
		if(_isThum){
			this.setColumnsValuesMoveUp.setDisabled(true);
			this.setColumnsValuesMoveDown.setDisabled(true);
			if(this._focusedRow == 0) {
				this.setColumnsValuesMoveTop.setDisabled(true);
				this.setColumnsValuesMoveBottom.setDisabled(false);				
			}else{
				this.setColumnsValuesMoveTop.setDisabled(false);	
				this.setColumnsValuesMoveBottom.setDisabled(true);							
			}
		}else{
/*			if(this._focusedRow != 0) {
				this.setColumnsValuesMoveTop.setDisabled(false);
				this.setColumnsValuesMoveUp.setDisabled(false);
			}
			if(this._focusedRow != this._rowCount - 1){
				this.setColumnsValuesMoveDown.setDisabled(false);
				this.setColumnsValuesMoveBottom.setDisabled(false);			
			}
			if(this._focusedRow == 0) {
				this.setColumnsValuesMoveTop.setDisabled(true);
				this.setColumnsValuesMoveUp.setDisabled(true);
			}
			if (this._focusedRow == this._rowCount - 1) {
				this.setColumnsValuesMoveDown.setDisabled(true);
				this.setColumnsValuesMoveBottom.setDisabled(true);
			}*/
			if(this._checkThumRowFirst()){
				this.setColumnsValuesMoveTop.setDisabled(true);
				if(this._focusedRow==1){
					this.setColumnsValuesMoveUp.setDisabled(true);
					this.setColumnsValuesMoveDown.setDisabled(false);
					this.setColumnsValuesMoveBottom.setDisabled(false);					
				}
				else if(this._focusedRow==this._rowCount - 1){
					this.setColumnsValuesMoveUp.setDisabled(false);
					this.setColumnsValuesMoveDown.setDisabled(true);
					this.setColumnsValuesMoveBottom.setDisabled(true);					
				}
				else{
					this.setColumnsValuesMoveUp.setDisabled(false);
					this.setColumnsValuesMoveDown.setDisabled(false);
					this.setColumnsValuesMoveBottom.setDisabled(false);						
				}					
			}else{
				this.setColumnsValuesMoveBottom.setDisabled(true);
				if(this._focusedRow==this._rowCount - 2){
					this.setColumnsValuesMoveTop.setDisabled(false);
					this.setColumnsValuesMoveUp.setDisabled(false);
					this.setColumnsValuesMoveDown.setDisabled(true);
				}
				else if(this._focusedRow==0){
					this.setColumnsValuesMoveTop.setDisabled(true);
					this.setColumnsValuesMoveUp.setDisabled(true);
					this.setColumnsValuesMoveDown.setDisabled(false);
				}else{
					this.setColumnsValuesMoveTop.setDisabled(false);
					this.setColumnsValuesMoveUp.setDisabled(false);
					this.setColumnsValuesMoveDown.setDisabled(false);
				}
			}
		}		
		this._updateRowState();
	},
	
	_updateRowState: function() {
		var tbody = this.columnsTableBody;
		for(var i=0; i<tbody.rows.length; i++) {
			var row = tbody.rows[i];
			
			if(i % 2 == 0) {
				if(dojo.hasClass(row, "odd")) {
					dojo.removeClass(row, "odd");
					dojo.addClass(row, "even");
				}
			} else {
				if(dojo.hasClass(row, "even")) {
					dojo.removeClass(row, "even");
					dojo.addClass(row, "odd");					
				}
			}
		}
	},
	
	onMoveUpClick: function(evt) {
		var tbody = this.columnsTableBody;
		
		var focusedRow = tbody.rows[this._focusedRow];
		if(this._focusedRow != 0) {
			dojo.place(focusedRow, tbody.rows[this._focusedRow - 1], "before");
			--this._focusedRow;
		}
		this._updateButtonState(this._isThum(focusedRow));
		
	},
	
	onMoveDownClick: function(evt) {
		var tbody = this.columnsTableBody;
		
		var focusedRow = tbody.rows[this._focusedRow];
		if(this._focusedRow != this._rowCount - 1) {
			dojo.place(focusedRow, tbody.rows[this._focusedRow + 1], "after");
			++this._focusedRow;
		}
		this._updateButtonState(this._isThum(focusedRow));
	},
	
	onMoveTopClick: function(evt) {
		var tbody = this.columnsTableBody;
		
		var focusedRow = tbody.rows[this._focusedRow];
		if(this._focusedRow != 0) {
			dojo.place(focusedRow, tbody.rows[0], "before");
			this._focusedRow = 0;
		}
		this._updateButtonState(this._isThum(focusedRow));		
	},
	
	onMoveBottomClick: function(evt) {
		var tbody = this.columnsTableBody;
		
		var focusedRow = tbody.rows[this._focusedRow];
		if(this._focusedRow != this._rowCount - 1){
			dojo.place(focusedRow, tbody.rows[this._rowCount - 1], "after");
			this._focusedRow = this._rowCount - 1;
		}
		this._updateButtonState(this._isThum(focusedRow));			
	},
	
	checkButtonExecute: function(img){
		if(this.validate()){
			var tr = img.parentNode.parentNode;
			if(tr.checked) {
				if(this._checkSomeColumn()){
					img.src = this._uncheckedIconPath;
					tr.checked = false;
				}
			} else {
				img.src = this._checkedIconPath;
				tr.checked = true;
			}
		}		
	},
	
	_onCheckButtonClick: function(evt) {
			this.checkButtonExecute(evt.target);
	},
	
	_onCheckButtonKeyPress: function(evt){
		if((evt.keyCode == dojo.keys.ENTER)||(evt.charCode == dojo.keys.SPACE)){
			this.checkButtonExecute(evt.target);
		}		
	},
	
	_isThum: function(tr){
		if((dojo.attr(tr,"columnName"))=="thumbnail")
			return true;
		return false;
	},
	
	_checkThumRowFirst: function(){
		var tbody = this.columnsTableBody;
		if(tbody.rows[0]==dojo.query("tr[columnName='thumbnail']",tbody)[0])
			return true;
		else
			return false;
	},
	
	_checkSomeColumn: function(){
		var trs = dojo.query("tr",this.columnsTableBody);
		var checkSomeArray = dojo.filter(trs, function(tr) {
			return tr.checked == true;
		});
		if (checkSomeArray.length==1) {
			var errors = "Please check at least a column in the Result Columns Tab.";
			EDR.util.alert(errors);
			return false;
		}
		return true;
	},
	
	buildPreferences: function(preferencesJson){
		this.clear();
		if (preferencesJson == null) preferencesJson = this._getNullResultsPreferences();
		this._initColumnsTable(preferencesJson);
	},
	
	//after save dialog
	afterSaveApplyChanges: function(){
		var tbody = this.columnsTableBody;
		var trs = tbody.rows;
		var columnDefs = [];
		for(var i=0; i<trs.length; i++) {
			if(trs[i].checked) {
				columnDefs.push(dojo.attr(trs[i], "columnName"));	
			}
		}
		var manager = dijit.byId(EDR.prefix+"searchManager");
		if(manager.getSearchResult()!=null){
			manager.setColumnDefs(columnDefs);
			dojo.publish("headerColumnsChanged");
		}
	},
	
	//after search
	applyChanges: function() {
		var manager = dijit.byId(EDR.prefix+"searchManager");
		var results = manager.getSearchResult();
		if(results!=null){
			var results = manager.getSearchResult();
			if(EDR.customizing) {
				var customizerResults = dijit.byId(EDR.prefix+"customizerResults");
				var columnDefsStr =  customizerResults.resultsColumns.value;
				if(columnDefsStr != null) {
					var columnDefs = columnDefsStr.split(",");
					var resultColumnStrArray = dojo.filter(columnDefs, function(elem){ return !(elem.length == 0 || elem[0] == '$'); });
				} else {
					var resultColumnStrArray = this.getResultColumnStringFromJson(results.resultColumns.columns);
				}
			} else {
				var resultColumnStrArray = this.getResultColumnStringFromJson(results.resultColumns.columns);
			}
			manager.setColumnDefs(resultColumnStrArray);
			dojo.publish("headerColumnsChanged");
		}
	},
	
	getResultColumnStringFromJson: function(columnObjArray){
		var length = columnObjArray.length;
		var columnStrArray = [];
		for(var i = 0 ; i<length ; i++){
			if(columnObjArray[i].show==true)
				columnStrArray.push(columnObjArray[i].name);
		}
		return columnStrArray;
	},
	
	clear: function() {
		dojo.empty(this.columnsTableBody);
	},
	
	_getNullResultsPreferences: function() {
		return {
			columns:[{name:"thumbnail",show:true},{name:"filetype",show:true},{name:"relevance",show:true},{name:"date",show:false},{name:"title",show:true}]
		};
	},
	__dummy__ :''
});

}

if(!dojo._hasResource["widgets.FacetOptions"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.FacetOptions"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.FacetOptions");





dojo.declare(
	"widgets.FacetOptions", [dijit._Widget, dijit._Templated],
	{
		prefix: EDR.prefix,
		imgBasePath: EDR.config.imageBaseDir,
		widgetsInTemplate: true,
		templateString:"<div>\n\t<form dojoAttachPoint=\"facetOptionsForm\" style=\"width:100%;height:100%;\" onSubmit=\"return false;\">\n\t\t<div style=\"padding:5px;\">\n\t\t\t<label>${label_intro}&nbsp;</label>\n\t\t\t<a href=\"javascript:;\" onclick=\"EDR.viewHelp('iiysulfacets.htm?noframes=true')\">\n\t\t\t\t<img src=\"${imgBasePath}help_16.png\" title=\"${label_tooltip_help}\" alt=\"${label_tooltip_help}\" style=\"vertical-align: top;\" />\n\t\t\t</a>\n\t\t\t<br/><br/>\n\t\t\t<label>${label_intro2}</label><br/><br/>\n\t\t\t<label>${label_showfacet}:</label><br/>\n\t\t\t<div style=\"height:4px;\">&nbsp;</div>\n\t\t\t<div role=\"radiogroup\">\n\t\t\t\t<input id=\"${prefix}showFacetYes\" dojoType=\"dijit.form.RadioButton\" value=\"Yes\" checked=\"true\" name=\"showFacet\"/>\n\t\t\t\t<label for=\"${prefix}showFacetYes\">${label_yes}</label>&nbsp;\n\t\t\t\t<input id=\"${prefix}showFacetNo\" dojoType=\"dijit.form.RadioButton\" value=\"No\" name=\"showFacet\"/>\n\t\t\t\t<label for=\"${prefix}showFacetNo\">${label_no}</label>\n\t\t\t</div>\n\t\t</div>\n\t\t<div style=\"padding:5px;\">\n\t\t\t<label for=\"${prefix}facetTypeAheadNumberOfResultsId\">${label_typeahead}:</label><br/>\n\t\t\t<input id=\"${prefix}facetTypeAheadNumberOfResultsId\" dojoAttachPoint=\"numberOfResults\" dojoType=\"dijit.form.NumberSpinner\" name=\"facetTypeAheadNumberOfResults\"\n\t\t\t\ttitle=\"${label_typeahead_tooltip}\"\n\t\t\t\tvalue=\"10\" smallDelta=\"5\" largeDelta=\"25\" constraints=\"{min:1,max:100,places:0}\">\n\t\t\t</input>\n\t\t</div>\n\t\t<div style=\"padding:5px;\">\n\t\t\t<label for=\"${prefix}documentLabelTypeAheadNumberOfResults\">${label_documentLabel_typeahead}:</label><br/>\n\t\t\t<input id=\"documentLabelTypeAheadNumberOfResultsId\" dojoAttachPoint=\"documentLabelNumberOfResults\" dojoType=\"dijit.form.NumberSpinner\" name=\"documentLabelTypeAheadNumberOfResults\"\n\t\t\t\ttitle=\"${label_documentLabel_typeahead_tooltip}\"\n\t\t\t\tvalue=\"10\" smallDelta=\"5\" largeDelta=\"25\" constraints=\"{min:1,max:100,places:0}\">\n\t\t\t</input>\n\t\t</div>\n\t</form>\t\n</div>\n",
		handlers: [],
		
		json: null,
		
		postCreate: function() {
			this.inherited("postCreate", arguments);
			this.showFacetYes = this._supportingWidgets[0];
			this.showFacetNo = this._supportingWidgets[1];
			if (this._autoLoad) this.loadJson();
		},		
		
		loadJson: function(json) {
			if (json == null) json = this._getNullResultsOptions();
			this.json = json;
			this.buildOptions();
		},
				
		getFormValues: function() {
			var values = dojo.formToObject(this.facetOptionsForm);
			return values;
		},
		
		validate: function(params) {
			var errors = "";
			
			if (!this.numberOfResults.isValid()) {
				errors += this.label_typeahead + " : " + this.numberOfResults.invalidMessage + "<br/><br/>";
			}
			if (!this.numberOfResults.isValid()) {
				errors += this.label_documentLabel_typeahead + " : " + this.documentLabelNumberOfResults.invalidMessage + "<br/><br/>";
			}
			
			if (errors != "") {
				EDR.util.alert(errors);
				return false;
			}			
			return true;
		},
		
		buildOptions: function() {
			if (this.json == null) return;			
			this.clear();			
			this["showFacet" + (this.json.showFacet == "Yes"? "Yes" : "No")].attr("checked", true);
			this.numberOfResults.attr("value", this.json.facetTypeAheadNumberOfResults);
			this.documentLabelNumberOfResults.attr("value", this.json.documentLabelTypeAheadNumberOfResults);
		},
		
		clear: function() {
		},
		
		_getNullResultsOptions: function() {
			return {
				showFacet: true
			};
		},
				
		destroy: function() {
			dojo.forEach(this.handlers, dojo.disconnect);
			this.inherited("destroy", arguments);
		},
		
		applyChanges: function() {
			// facet type ahead
			var facetTypeAhead = dijit.byId(EDR.prefix+"facetTypeAheadWidget");
			if (facetTypeAhead) {
				facetTypeAhead.maxSize = this.numberOfResults.value;
			}
			
			// show/hide facet panes
			var newValue = this.showFacetYes.attr("checked");
			var searchManager = dijit.byId(EDR.prefix+"searchManager");
			if(searchManager) {
				searchManager.setShowFacets(newValue);
				searchManager._showHideNarrowResults();
				dojo.publish("headerColumnsChanged");
			}
		},
		
		// messages
		label_typeahead: EDR.messages.facetOption_typeahead,
		label_typeahead_tooltip: EDR.messages.facetOption_tooltip_numberOfResults,
		label_documentLabel_typeahead: EDR.messages.facetOption_documentLabel_typeahead,
		label_documentLabel_typeahead_tooltip: EDR.messages.documentlabelOption_tooltip_numberOfResults,
		label_intro: EDR.messages.facetOption_intro,
		label_intro2: EDR.isAuthorized ? EDR.messages.search_options_intro_authorized : EDR.messages.search_options_intro_unauthorized,
		label_tooltip_help: EDR.messages.tooltip_help,		
		label_showfacet: EDR.messages.facetOption_show,
		label_yes: EDR.messages.common_yes,
		label_no: EDR.messages.common_no
	}
);

}

if(!dojo._hasResource["widgets.DocumentLabelTree"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.DocumentLabelTree"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.DocumentLabelTree");







dojo.declare(
	"widgets.DocumentLabelTree", [widgets.FacetTree],
	{		
		prefix: EDR.prefix + "_documentLabel_",
		
		initDialog: function() {
			this.facetTypeAheadWidget = dijit.byId(EDR.prefix+"documentLabelTypeAheadWidget");
			this.facetDialogContent = dijit.byId(EDR.prefix+"documentLabelDialogContent");
			this.facetDialog = dijit.byId(EDR.prefix+"documentLabelDialog");
			this.handlers.push(dojo.connect(this.facetDialog.okButtonNode, "onClick", this, "onFacetDialogApplied"));
			this.handlers.push(dojo.connect(this.facetDialog.cancelButtonNode, "onClick", this, "onFacetDialogCanceled"));
			this.handlers.push(dojo.connect(this.facetDialogContent, "facetSelectedEventHandler", this, "facetSelectedEventHandler"));
		},
	
		buildFacetGroupContentElem: function(facet) {
			var content = dojo.doc.createElement("DIV");
			dojo.addClass(content, "refinement-title-body");
			
			var arrowImg = dojo.doc.createElement("IMG");
			dojo.addClass(arrowImg, "arrow-img");
			arrowImg.src = this.imgBasePath + (this.isLeftToRight() ? "arrow_right8.png" : "arrow_left8.png");
			arrowImg.alt = dojo.string.substitute(EDR.messages.tooltip_facet_expandcollapse, [facet.facetLabel]);
			
			if (facet.items == null || facet.items.length == 0) dojo.style(arrowImg, "visibility", "hidden");
			
			var label = dojo.doc.createElement("DIV");
			dojo.addClass(label, "label");
			
			var tooltip = dojo.string.substitute(EDR.messages.tooltip_facet_quick, ['"' + facet.facetLabel + '"']);
			var a = dojo.create("a", {href:"javascript:;", title:tooltip, innerHTML:facet.facetLabel, style:"font-weight:bold;"}, label);
			dojo.create("span", {innerHTML:"&nbsp(" + facet.count + ")"}, label);
//			label.innerHTML = facet.facetLabel;
			
			this.handlers.push(dojo.connect(a, "onclick", this, function(evt) { 
				if (evt != null && evt.stopPropagation) evt.stopPropagation();
				this.andfacets.clear();
				this.andfacets.add(facet.postParamValue);
				this.submitSearch("refineSearch");
			}));
			
			var magContainer = dojo.create("div", {}, null);
			dojo.addClass(magContainer, "maglink");
			
			var magLink = dojo.create("a", {href:"javascript:;", title:tooltip}, magContainer);
			var magImg = dojo.create("img", {src:this.imgBasePath + "mag-glass12_h.png"}, magLink);
			this.handlers.push(dojo.connect(magLink, "onclick", this, function(evt) { 
				if (evt != null && evt.stopPropagation) evt.stopPropagation();
				this.andfacets.clear();
				this.andfacets.add(facet.postParamValue);
				this.submitSearch("refineSearch");
			}));
			
			this.handlers.push(dojo.connect(content, "onmouseover", this, function(evt) { 
				magLink.style.visibility = "visible";
			}));
			this.handlers.push(dojo.connect(content, "onmouseout", this, function(evt) { 
				magLink.style.visibility = "hidden";
			}));
			
			content.appendChild(arrowImg);
			content.appendChild(label);
			content.appendChild(magContainer);
			
			return content;
		},
		
		getFormValues: function() {
			var values = {};
			if (this.andfacets.count > 0) values.andDocumentLabels = this.andfacets.toArray();
			if (this.notfacets.count > 0) values.notDocumentLabels = this.notfacets.toArray();
			return values;
		},
		
		preLoad: function() {
			EDR.ajax.Loading.setIsLoading(this.domNode);
		},
		
		postLoad: function() {
			EDR.ajax.Loading.clearIsLoading(this.domNode);
		},
		
		loadErrorHandler: function(response) {
			EDR.ajax.Loading.clearIsLoading(this.domNode);
		},
		
		label_showmore: EDR.messages.tooltip_showmoredocumentlabel,
		label_typeahead: EDR.messages.tooltip_documentlabel_typeahead		
	}
);

}

if(!dojo._hasResource["widgets.TopResultAnalysisOptions"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.TopResultAnalysisOptions"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.TopResultAnalysisOptions");





dojo.declare(
	"widgets.TopResultAnalysisOptions", [dijit._Widget, dijit._Templated],
	{				
		prefix: EDR.prefix,
		imgBasePath: EDR.config.imageBaseDir,
		widgetsInTemplate: true,
		templateString:"<div>\n\t<form dojoAttachPoint=\"tpaOptionsForm\" style=\"width:100%;height:100%;\" onSubmit=\"return false;\">\n\t\t<div style=\"padding:5px;\">\n\t\t\t<label>${label_intro}&nbsp;</label>\n\t\t\t<a href=\"javascript:;\" onclick=\"EDR.viewHelp('iiysultopresults.htm?noframes=true')\">\n\t\t\t\t<img src=\"${imgBasePath}help_16.png\" title=\"${label_tooltip_help}\" alt=\"${label_tooltip_help}\" style=\"vertical-align: top;\">\n\t\t\t</a>\n\t\t\t<br/><br/>\n\t\t\t<label>${label_intro2}</label><br/><br/>\n\t\t\t<label>${label_showtpa}:</label>\n\t\t\t<div style=\"height:4px;\">&nbsp;</div>\n\t\t\t<div role=\"radiogroup\">\n\t\t\t\t<input id=\"${prefix}showTPAYes\" dojoType=\"dijit.form.RadioButton\" value=\"Yes\" checked=\"true\" name=\"showTPA\"/>\n\t\t\t\t<label for=\"${prefix}showTPAYes\">${label_yes}</label>&nbsp;\n\t\t\t\t<input id=\"${prefix}showTPANo\" dojoType=\"dijit.form.RadioButton\" value=\"No\" name=\"showTPA\"/>\n\t\t\t\t<label for=\"${prefix}showTPANo\">${label_no}</label>\n\t\t\t</div>\n\t\t</div>\n\t</form>\t\n</div>\n",
		handlers: [],

		json: null,
		
		postCreate: function() {
			this.inherited("postCreate", arguments);
			this.showTPAYes = this._supportingWidgets[0];
			this.showTPANo = this._supportingWidgets[1];
			if (this._autoLoad) this.loadJson();
		},		
		
		loadJson: function(json) {
			if (json == null) json = this._getNullResultsOptions();
			this.json = json;
			this.buildOptions();
		},
				
		getFormValues: function() {
			var values = dojo.formToObject(this.tpaOptionsForm);
			return values;
		},
		
		validate: function(params) {
			var errors = "";
			if (errors != "") {
				EDR.util.alert(errors);
				return false;
			}			
			return true;
		},
		
		buildOptions: function() {
			if (this.json == null) return;			
			this.clear();			
			this["showTPA" + (this.json.showTPA == "Yes"? "Yes" : "No")].attr("checked", true);
		},
		
		clear: function() {
		},
		
		_getNullResultsOptions: function() {
			return {
				showTPA: true
			};
		},
				
		destroy: function() {
			dojo.forEach(this.handlers, dojo.disconnect);
			this.inherited("destroy", arguments);
		},
		
		applyChanges: function() {
			var newValue = this.showTPAYes.attr("checked");
			var searchManager = dijit.byId(EDR.prefix+"searchManager");
			if(searchManager) {
				searchManager.setShowTopResults(newValue);
				searchManager._showHideNarrowResults();
				dojo.publish("headerColumnsChanged");
			}
		},
		
		// messages
		label_intro: EDR.messages.topResultAnalysisOption_intro,
		label_intro2: EDR.isAuthorized ? EDR.messages.search_options_intro_authorized : EDR.messages.search_options_intro_unauthorized,
		label_showtpa: EDR.messages.topResultAnalysisOption_show,
		label_tooltip_help: EDR.messages.tooltip_help,		
		label_yes: EDR.messages.common_yes,
		label_no: EDR.messages.common_no
	}
);

}

if(!dojo._hasResource["widgets.ESTitlePane"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.ESTitlePane"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.ESTitlePane");



dojo.declare(
	"widgets.ESTitlePane",
	[dijit.TitlePane],
	{
		imgBasePath: EDR.config.imageBaseDir,
		settingsPaneId: "",
		handlers: [],
		
		title_tooltip: "",
		icon_tooltip: "",
		icon_alt: "",
		
		postCreate: function() {
			this.handlers = [];
			this.inherited(arguments);
			this.modifyTemplate();
		},
		
		modifyTemplate: function() {
			this.titleNode.title = this.title_tooltip;
			var src = this.imgBasePath + "edit_display_srch_16.png";
			var a = dojo.create("A", {src:"javascript:;", tabindex:0, style:
				this.isLeftToRight() ? "position:absolute;right:8px;top:1px;" : "position:absolute;left:8px;top:1px;"
				}, this.titleBarNode)
			var img = dojo.create("IMG", {
				src:src,
				alt:this.icon_alt,
				title:this.icon_tooltip
			}, a);
			this.handlers.push(dojo.connect(a, "onclick", this, "onSettingsButtonClicked"));
			this.handlers.push(dojo.connect(a, "onkeypress", this, "onSettingsButtonClicked"));
		},
		
		onSettingsButtonClicked: function(evt) {
			if (evt.type != "click" && evt.keyCode != dojo.keys.ENTER && evt.charCode != dojo.keys.SPACE) return;
			
			var dlg = dijit.byId(EDR.prefix+"preference");
			if (dlg != null && this.settingsPaneId != null && this.settingsPaneId.length > 0) {
				dlg.showTab(this.settingsPaneId);
				EDR.dialog.util.show(dlg);
			}
			dojo.stopEvent(evt);
		},
		
		onOpenPane: function() {
			var singleChild = this.getChildren()[0];
			if (singleChild != null && singleChild.load != null) {
				singleChild.load();
			}
		},
		
		onClosePane: function() {
		},
		
		destroy: function() {
			dojo.forEach(this.handlers, dojo.disconnect);
			this.inherited("destroy", arguments);
		}
	}
);

}

if(!dojo._hasResource["widgets.CategoryTreeTitlePane"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.CategoryTreeTitlePane"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.CategoryTreeTitlePane");




dojo.declare(
	"widgets.CategoryTreeTitlePane",
	[dijit.TitlePane],
	{
		imgBasePath: EDR.config.imageBaseDir,
		settingsPaneId: "",
		sortWidget: null,
		handlers: [],
		
		title_tooltip: "",
		icon_tooltip: "",
		icon_alt: "",
		
		postCreate: function() {
			this.inherited(arguments);
			this.modifyTemplate();
		},
		
		startup: function() {
			this.inherited(arguments);
			var categoryTree = dijit.byId(EDR.prefix+"categoryTree");
			this.handlers.push(dojo.connect(this.sortWidget, "onChange", categoryTree, categoryTree.onSortOrderChanged));
		},
		
		resize: function() {
			this.inherited(arguments);
			this.layout();
		},
			
		layout: function() {
			var labelWidth = dojo.marginBox(this.titleNode).w;
			var sortWidth = dojo.marginBox(this.sortWidget.domNode).w;
			var width = dojo.contentBox(this.titleBarNode).w - (labelWidth + sortWidth);
			if (width < 0) {				
				dojo.style(this.titleNode, "position", dojo.isIE <= 7 ? "absolute" : "relative");
				dojo.style(this.titleNode, "top", "-3000px");
			} else {
				dojo.style(this.titleNode, "position", dojo.isIE <= 7 ? "absolute" : "relative");
				dojo.style(this.titleNode, "top", dojo.isIE <= 7 ? "3px" : "0px");
			}
		},
		
		modifyTemplate: function() {
			var label = dojo.create("LABEL", {innerHTML:"", style:"display:none;", "for":"sortCategory"}, this.titleBarNode);
			var sortDiv = dojo.create("DIV", {}, this.titleBarNode);			
			var sortWidget = new dojox.form.DropDownSelect({
					id:"sortCategory", options:[],
					title:EDR.messages.analytics_categorytree_sort_tooltip,
				 	style: this.isLeftToRight() ? "position:absolute;top:0px;right:3px;" : "position:absolute;top:0px;left:3px;"
			}, sortDiv);
			
			var td = sortWidget.containerNode.parentNode;
			var labelContainer = dojo.create("DIV", {
				style:"overflow:hidden;float:right;max-width:100px;"
			}, td);
			labelContainer.appendChild(td.firstChild);
			labelContainer.appendChild(td.firstChild);
			labelContainer.appendChild(td.firstChild);
			if (dojo.isIE <= 7) { // hack for IE. Why style is not applied by dojo.create only in IE7...
				dojo.style(labelContainer, "overflow", "hidden");
				dojo.style(labelContainer, "float", "right");
				dojo.style(labelContainer, "maxWidth", "100px");				
			}
			
			dojo.forEach(sortWidget.domNode.getElementsByTagName("TD"), function(td) {
				dojo.style(td, "border", "none");
				dojo.style(td, "background", "none");
				dojo.style(td, "paddingLeft", "0px");
				dojo.style(td, "paddingRight", "0px");
			});
			sortWidget.addOption({value: "none", label: EDR.messages.analytics_categorytree_sort_none});
			sortWidget.addOption({value: "ascending", label: EDR.messages.analytics_categorytree_sort_ascending});
			sortWidget.addOption({value: "descending", label: EDR.messages.analytics_categorytree_sort_descending});
			this.sortWidget = sortWidget;
			this.titleNode.title = this.title_tooltip;
			var src = this.imgBasePath + "edit_display_srch_16.png";
			dojo.style(this.arrowNode, "display", "none");
		},
		
		destroy: function() {
			dojo.forEach(this.handlers, dojo.disconnect);
			this.inherited("destroy", arguments);
		}
	}
);

}

if(!dojo._hasResource["widgets.SaveSearch"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.SaveSearch"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.SaveSearch");





dojo.declare(
	"widgets.SaveSearch", [dijit._Widget, dijit._Templated],
	{				
		prefix: EDR.prefix,
		widgetsInTemplate: true,
		templateString:"<div style=\"width:315px;\">\n\t<form dojoAttachPoint=\"saveSearchForm\" onSubmit=\"return false;\">\n\t\t<div><label for=\"${prefix}saveSearchName\">${messages_saveSearch_name_show}:</label></div>\n\t\t<div style=\"margin-bottom:5px;\">\n\t\t\t<input type=\"text\" name=\"saveSearchName\" style=\"width:100%;\" id=\"${prefix}saveSearchName\" dojoAttachPoint=\"saveSearchName\"/>\n\t\t</div>\n\t\t<div><label for=\"${prefix}saveSearchQueryText\">${messages_saveSearch_query_show}:</label></div>\n\t\t<div style=\"margin-bottom:5px;\">\n\t\t\t<textarea rows=\"4\" name=\"saveSearchQuery\" id=\"${prefix}saveSearchQueryText\" dojoAttachPoint=\"saveSearchQueryText\"style=\"width:100%;\"></textarea>\n\t\t</div>\t\n\t\t<div><label for=\"${prefix}saveSearchDescription\">${messages_saveSearch_description_show}:</label></div>\n\t\t<div style=\"margin-bottom:5px;\">\n\t\t\t<textarea rows=\"5\"  name=\"saveSearchDescription\" id=\"${prefix}saveSearchDescription\" dojoAttachPoint=\"saveSearchDescription\" style=\"width:100%;\"></textarea>\n\t\t</div>\n\t</form>\n</div>\n",
		dialog: null,
		saveOptionChk: null,
		mode: "save", // save | edit
		url: "",
		timeout: 10000,
		handlers: [],
		
		messages_saveSearch_name_show: EDR.messages.saveSearch_name_show,
		messages_saveSearch_query_show: EDR.messages.saveSearch_query_show,
		messages_saveSearch_description_show: EDR.messages.saveSearch_description_show,
		
		postCreate: function() {
			this.inherited("postCreate", arguments);
		},
		
		startup: function() {
			this.inherited(arguments);
			this.dialog = dijit.byId(EDR.prefix+"saveSearchDialog");
//			this.saveOptionChk = this._supportingWidgets[0];
			this.handlers.push(dojo.connect(this.dialog.okButtonNode, "onClick", this, "onSave"));
//			handlers.push(dojo.connect(this.dialog.cancelButtonNode, "onClick", this, "onCancel"));
		},
		
		onSave: function() {
			if (this.mode == "save") this.save();
		},
/*		
		onCancel: function() {
		},
*/		
		save: function() {
			var params = this.getFormValues();
			if (!this.validate(params)) return;
			
			this.preSave();						
			
			var self = this;
			var args = 	{ 
				url: this.url,
				successCallback: function(response, ioArgs) {
					self.saved();
				},
				afterErrorHandlerCallback: dojo.hitch(this, this.loadErrorHandler),
				content: params,
				timeout: this.timeout,
				showProgress: false
			};
			EDR.ajax.Request.post(args);
		},
				
		preSave: function() {
		},
		
		postSave: function() {
		},
		
		saved: function() {
			dojo.publish("querySaved", [{}]);
			this.dialog.cancelFunction();
		},
		
		loadErrorHandler: function() {
		},
				
		getFormValues: function() {
			var params = dojo.formToObject(this.saveSearchForm);
//			params["saveSearchOptions"] = this.saveOptionChk.checked;
			return params;
		},
		
		validate: function(params) {
			var errors = "";
			if (params.saveSearchName == null || params.saveSearchName.length == 0) {
				errors += EDR.messages.error_savesearch_noname + "</br></br>";
			}
			if (params.saveSearchQuery == null || params.saveSearchQuery.length == 0) {
				errors += EDR.messages.error_savesearch_noquery + "</br></br>";
			}
			if (errors != "") {
				EDR.util.alert(errors);
				return false;
			}			
			return true;
		},
		
		setQuery: function(query) {
			this.mode = "save";
			var now = new Date();
			this.saveSearchName.value = "search_" + Math.floor(now / 1000);
			this.saveSearchQueryText.value = query;
			this.saveSearchDescription.value = "";
		},
		
		setValues: function(name, query, description) {
			this.mode = "edit";
			this.saveSearchName.value = name
			this.saveSearchQueryText.value = query;
			this.saveSearchDescription.value = description;
		},
		
		destroy: function() {
			dojo.forEach(this.handlers, dojo.disconnect);
			this.inherited("destroy", arguments);
		}
	}
);

}

if(!dojo._hasResource["widgets.ExportSearch"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.ExportSearch"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.ExportSearch");






dojo.declare(
	"widgets.ExportSearch", [dijit._Widget, dijit._Templated],
	{				
		prefix: EDR.prefix,
		widgetsInTemplate: true,
		templateString:"<div style=\"width:315px;\" class=\"ExportSearchDialog\">\n\t<form dojoAttachPoint=\"exportSearchForm\" onSubmit=\"return false;\">\n\t\t<div><label for=\"${prefix}exportSearchName\">${message_export_dialog_nameLabel}:</label></div>\n\t\t<div style=\"margin-bottom:5px;\">\n\t\t\t<input type=\"text\" name=\"exportId\" style=\"width:100%;\" id=\"${prefix}exportSearchName\" dojoAttachPoint=\"exportSearchName\"/>\n\t\t</div>\n\t\t<div style=\"margin-bottom:5px;\">\n\t\t\t<label for=\"${prefix}exportContentSource\">${message_export_dialog_contentLabel}:</label><br/>\n\t\t\t<select id=\"${prefix}exportContentSourceSelect\" name=\"contentSource\" style=\"width:100%;\" title=\"${message_export_dialog_contentSource}\">\n\t\t\t</select>\n\t\t</div>\n\t\t<div style=\"margin-bottom:5px;\" role=\"radiogroup\">\n\t\t\t<label>${message_export_dialog_schedulableLabel}:</label>&nbsp;\n\t\t\t<input id=\"${prefix}eScheduleYes\" type=\"radio\" name=\"schedulable\" value=\"true\">&nbsp;<label for=\"${prefix}eScheduleYes\">${message_yes}</label>\n\t\t\t<input id=\"${prefix}eScheduleNo\" type=\"radio\" name=\"schedulable\" value=\"false\" checked=\"\">&nbsp;<label for=\"${prefix}eScheduleNo\">${message_no}</label>\n\t\t</div>\n\t\t<div style=\"margin-bottom:5px;\">\n\t\t\t<label for=\"${prefix}exportDescription\">${message_export_dialog_descriptionLabel}:</label><br/>\n\t\t\t<textarea id=\"${prefix}exportDescription\" dojoAttachPoint=\"description\" name=\"description\" rows=\"6\" cols=\"56\"></textarea>\n\t\t</div>\n\t</form>\n\t<div dojoAttachPoint=\"messageDiv\" style=\"width:100%;height:100%;\">\n\t</div>\n</div>\n",
		dialog: null,
		url: "",
		timeout: 60000,
		handlers: [],
		
		message_export_dialog_nameLabel: EDR.messages.export_dialog_nameLabel,
		message_export_dialog_contentLabel: EDR.messages.export_dialog_contentLabel,
		message_export_dialog_contentSource: EDR.messages.export_dialog_contentSource,
		message_export_dialog_descriptionLabel: EDR.messages.export_dialog_descriptionLabel,
		message_export_dialog_schedulableLabel: EDR.messages.export_dialog_schedulableLabel,
		message_yes: EDR.messages.label_schedulable_yes,
		message_no: EDR.messages.label_schedulable_no,
		
		_storeCacheEnabled: null,
		_storeCacheDisabled: null,

		startup: function() {
			this.inherited(arguments);
			this.dialog = dijit.byId(EDR.prefix+"exportSearchDialog");
			this.handlers.push(dojo.connect(this.dialog.okButtonNode, "onClick", this, "doExport"));
			this._storeCacheEnabled = new dojo.data.ItemFileReadStore({data:
			{
				identifier: "name",
				items: [
				        	{name: "cache", label: EDR.messages.export_content_cache},
				        	{name: "none", label: EDR.messages.export_content_none},
				        	{name: "index", label: EDR.messages.export_content_index}
				        ]
			}
		});
			this._storeCacheDisabled = new dojo.data.ItemFileReadStore({data:
			{
				identifier: "name",
				items: [
				        	{name: "none", label: EDR.messages.export_content_none}
				        ]
			}
		}); 
			this.contentSourceSelect = new dijit.form.FilteringSelect({
				name: "contentSource",
				store: this._storeCacheEnabled,
				labelAttr: "label",
				searchAttr: "label",
				value: "none"
			}, dojo.byId("exportContentSourceSelect"));
		},
		
		onExport: function() {
		},
	
		doExport: function() {
			this.dialog.okButtonNode.setDisabled(true);
			
			var params = this.getFormValues();
			//if (!this.validate(params)) return;
			
			this.preExport();
			
			var self = this;
			var args = 	{ 
				url: this.url,
				successCallback: function(response, ioArgs) {
					var json = null;
					try {
						json = dojo.fromJson(response);
						self.saved(json);
						self.postExport();
					} catch (e) {
			        	self.loadErrorHandler(response, ioArgs);
			        	return;
					}					
				},
				afterErrorHandlerCallback: dojo.hitch(this, this.loadErrorHandler),
				content: params,
				timeout: this.timeout,
				showProgress: false
			};
			EDR.ajax.Request.post(args);
		},
				
		preExport: function() {
			EDR.ajax.Loading.setIsLoading(this.domNode.parentNode);
		},
		
		postExport: function() {
			EDR.ajax.Loading.clearIsLoading(this.domNode.parentNode);
		},
		
		saved: function(json) {			
			this.dialog.cancelButtonNode.setLabel(EDR.messages.K0001I_COMMON_CLOSE);			
			var result = json.result;
			var requestId = json.requestId;	
			
			var content = "";		
			if(result == "success") {
				content = EDR.messages.prompt_export.replace("{0}", requestId);
			} else {
				content = "Export failed."; 
			}
			dojo.style(this.exportSearchForm, "display", "none");
			dojo.style(this.messageDiv, "display", "block");
			this.messageDiv.innerHTML = content;	
		},
		
		changeOptionsState: function(docCacheEnabled) {
			if(docCacheEnabled) {
				this.contentSourceSelect.attr("store", this._storeCacheEnabled);
			} else {
				this.contentSourceSelect.attr("store", this._storeCacheDisabled);
			}
		},
		
		loadErrorHandler: function() {
			this.dialog.okButtonNode.setDisabled(false);
			this.dialog.cancelButtonNode.setLabel(EDR.messages.K0001I_COMMON_CANCEL);
			EDR.ajax.Loading.clearIsLoading(this.domNode.parentNode);			
		},
				
		getFormValues: function() {
			var params = dojo.formToObject(this.exportSearchForm);
//			params["saveSearchOptions"] = this.saveOptionChk.checked;
			return params;
		},
		
		validate: function(params) {
		},
		
		setName: function() {
			var now = new Date();
			this.exportSearchName.value = "results_" + Math.floor(now / 1000);
		},
		
		clear: function() {
			dojo.style(this.exportSearchForm, "display", "block");
			dojo.style(this.messageDiv, "display", "none");
			this.dialog.okButtonNode.setDisabled(false);
			this.dialog.cancelButtonNode.setLabel(EDR.messages.K0001I_COMMON_CANCEL);
			this.description.value = "";		
			this.setName();	
		},

		destroy: function() {
			dojo.forEach(this.handlers, dojo.disconnect);
			this.inherited("destroy", arguments);
		}
	}
);

}

if(!dojo._hasResource["widgets.SavedSearch"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.SavedSearch"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.SavedSearch");




dojo.declare(
	"widgets.SavedSearch", [dijit._Widget, dijit._Templated],
	{				
		widgetsInTemplate: true,
		templateString:"<div style=\"overflow:hidden;\">\n\t<div dojoAttachPoint=\"queryContainer\"\n\t\tstyle=\"position:absolute;left:5px;right:5px;top:10px;bottom:5px;overflow-x:hidden;overflow-y:auto;\">\n\t</div>\n\t<span dojoAttachPoint=\"hiddenSpan\"\n\t\tstyle=\"${fontStyle}visibility:hidden;position:absolute;\"></span>\n</div>\n",
		slideTabContent: null,
		resultBottomBar: null,
		count: 0,
		contentWidth: 370,
		itemLabelWidth: 330,
//		fontStyle: "font-weight:bold;font-style:italic;font-size:12px;",
		fontStyle: "font-size:13px;",
		
		imgBasePath: EDR.config.imageBaseDir,
		url: "",
		submitUrl: "",
		timeout: 10000,
		handlers: [],
		isOpen: false,
		messages_advancedSearch_noResult: EDR.messages.advancedSearch_noResult,
		
		postCreate: function() {
			this.inherited("postCreate", arguments);
		},
		
		startup: function() {
			this.editUrl = EDR.contextPath + "/preferences?action=editSearchQuery";
			this.deleteUrl = EDR.contextPath + "/preferences?action=deleteSearchQuery";
			
			this.inherited(arguments);
			this.slideTabContent = dijit.byId(EDR.prefix+"savedSearchTab");
			this.resultsBottomBar = dijit.byId(EDR.prefix+"horizontalSearchPanes").resultBottomBar;
			dojo.subscribe("querySaved", this, "onQuerySaved");
			dojo.subscribe("afterSlideTabOpened", this, "onOpen");
			dojo.subscribe("afterSlideTabClosed", this, "onClose");
		},
		
		onOpen: function(event) {
			if (event.contentId == (EDR.prefix+"savedSearchTab")) {
				this.isOpen = true;
				this.load();
			}
		},
		
		onClose: function(event) {
			if (event.contentId == (EDR.prefix+"savedSearchTab")) {
				this.isOpen = false;
				this.resultsBottomBar.revertMessage();
				this.clear();
			}
			this.updateTitle();
		},
		
		onQuerySaved: function(event) {
			if (this.isOpen) {
				this.load();
			} else {
				this.countup();
			}
		},
		
		onSavedQuerySelected: function(evt, item) {
			if (item.id == null || item.id.length == 0) return;
			dijit.byId(EDR.prefix+"searchManager").submitSavedSearch({ savedSearchId: item.id });
			//dijit.byId(EDR.prefix+"savedSearchTab").close();
		},
		
		onSavedQueryEdit: function(evt, item) {
			if (evt.type != "click" && evt.keyCode != dojo.keys.ENTER) return;

			dojo.stopEvent(evt);
			
			var dialog = dijit.byId(EDR.prefix+"saveSearchDialog");
			dialog.attr("title", EDR.messages.editSearch_title);
			dialog.okButtonNode.setLabel(EDR.messages.button_edit);
			dialog.okButtonNode.titleNode.title = EDR.messages.button_edit;
			
			var dialogContent = dijit.byId(EDR.prefix+"saveSearchContent");
			dialogContent.setValues(item.name, item.query, item.description);
			
			var connects = [];
			connects.push(dojo.connect(dialog.okButtonNode, "onClick", this, dojo.hitch(this, function() {				
				var params = dialogContent.getFormValues();
				params.saveSearchId = item.id; 
				if (!dialogContent.validate(params)) return;
				
				dojo.forEach(connects, dojo.disconnect);
				this.editSavedSearch(params);
				EDR.dialog.util.hide(dialog);
			})));
			connects.push(dojo.connect(dialog.cancelButtonNode, "onClick", this, function() {
				dojo.forEach(connects, dojo.disconnect);
			}));
			EDR.dialog.util.show(dialog);
		},
		
		onSavedQueryDelete: function(evt, item) {
			if (evt.type != "click" && evt.keyCode != dojo.keys.ENTER) return;

			dojo.stopEvent(evt);
			this.deleteSavedSearch(item);
		},
		
		load: function() {
			this.preLoad();					
			var self = this;
			var args = 	{ 
				url: this.url,
				successCallback: function(response, ioArgs) {
					var json = null;
					try {
						json = dojo.fromJson(response);
					} catch (e) {
			        	self.loadErrorHandler(response, ioArgs);
			        	return;
					}
					self.clear();
					self.loadJson(json);	
					self.postLoad();
				},
				errorCallback: dojo.hitch(this, this.loadErrorHandler),
				timeout: this.timeout,
				showProgress: false
			};
			EDR.ajax.Request.post(args);
		},
				
		editSavedSearch: function(params) {
			this.preLoad();					
			var self = this;
			
			var args = 	{ 
				url: this.editUrl,
				successCallback: function(response, ioArgs) {
					var json = null;
					try {
						json = dojo.fromJson(response);
					} catch (e) {
			        	self.loadErrorHandler(response, ioArgs);
			        	return;
					}
					self.clear();
					self.loadJson(json);	
					self.postLoad();					
				},
				errorCallback: self.loadErrorHandler,
				timeout: this.timeout,
				content: params,
				showProgress: false
			};
			EDR.ajax.Request.post(args);
		},

		deleteSavedSearch: function(item) {
			this.preLoad();					
			var self = this;
			var params = {saveSearchId:item.id};
			var args = 	{ 
				url: this.deleteUrl,
				successCallback: function(response, ioArgs) {
					var json = null;
					try {
						json = dojo.fromJson(response);
					} catch (e) {
			        	self.loadErrorHandler(response, ioArgs);
			        	return;
					}
					self.clear();
					self.loadJson(json);	
					self.postLoad();					
				},
				errorCallback: self.loadErrorHandler,
				timeout: this.timeout,
				content: params,
				showProgress: false
			};
			EDR.ajax.Request.post(args);
		},
		
		preLoad: function() {
			EDR.ajax.Loading.setIsLoading(this.domNode);
		},
		
		postLoad: function() {
			EDR.ajax.Loading.clearIsLoading(this.domNode);
		},
		
		loadJson: function(json) {
			this.count = json.length;
			this.updateTitle();
			if(this.count==0){
				var itemDiv = dojo.create("DIV", {
					innerHTML: this.messages_advancedSearch_noResult,
					style: "width:100%;height:20px;" + this.fontStyle
				}, this.queryContainer);
			}else{
				for (var i=0; i<json.length; i++) {
					this.buildSavedItem(json[i], this.queryContainer);
				}
			}
		},
		
		loadErrorHandler: function() {
			EDR.ajax.Loading.clearIsLoading(this.domNode);
		},
		
		countup: function() {
			this.count++;
			this.updateTitle();
		},
		
		updateTitle: function() {
			var title = EDR.messages.tabs_savedSearch;
			var count = "<span style='font-weight:normal;font-size:10px;position:relative;top:-1px;'>" + 
								"<bdo dir='ltr'>(" + this.count + ")</bdo>" +
							"</span>";
			if (this.isLeftToRight()) {
				title = title + "&nbsp;" + count;
			} else {
				title = count + "&nbsp;" + title;
			}
			dijit.byId(EDR.prefix+"savedSearchTab").titleNode.innerHTML = title;
		},
		
		buildSavedItem: function(item, parent) {
			var itemDiv = dojo.create("DIV", {
				innerHTML: this.buildSavedItemHtml(item),
				title: item.name,
				style: "width:100%;height:20px;" + this.fontStyle
			}, parent);
			itemDiv.item = item;
			
			var buttons = itemDiv.getElementsByTagName("A");
			this.handlers.push(dojo.connect(buttons[1], "onclick", this, function(evt) {
				this.onSavedQueryEdit(evt, itemDiv.item);
			}));
			this.handlers.push(dojo.connect(buttons[1], "onkeypress", this, function(evt) {
				this.onSavedQueryEdit(evt, itemDiv.item);
			}));
			this.handlers.push(dojo.connect(buttons[2], "onclick", this, function(evt) {
				this.onSavedQueryDelete(evt, itemDiv.item);
			}));
			this.handlers.push(dojo.connect(buttons[2], "onkeypress", this, function(evt) {
				this.onSavedQueryDelete(evt, itemDiv.item);
			}));
			
			this.handlers.push(dojo.connect(itemDiv, "onclick", this, function(evt) {
				this.onSavedQuerySelected(evt, itemDiv.item);
			}));
			this.handlers.push(dojo.connect(itemDiv, "onmouseover", this, function() {
				var item = itemDiv.item;
				this.resultsBottomBar.showMessage("Query: " + item.query + "  /  Description: " + item.description);
				itemDiv.style.backgroundImage = "url('" + this.imgBasePath + "bg-savesearch.png')";
				itemDiv.style.cursor = "pointer";
			}));
			this.handlers.push(dojo.connect(itemDiv, "onmouseout", this, function() {
				itemDiv.style.backgroundImage = "none";
				itemDiv.style.cursor = "auto";
			}));
			return itemDiv;
		},
		
		buildSavedItemHtml: function(item) {
			var html = "";
			html += "<div style=\"width:"+this.contentWidth+"px\">";
			html += 	"<div tabindex=\"0\"style=\"width:"+this.itemLabelWidth+"px;float:left;\"><a href=\"javascript:;\">" + this._getTruncatedLabel(item, this.itemLabelWidth) + "</a></div>";
			html += 	"<div>";
			html += 		"<a href=\"javascript:;\">";
			html += 			"<img";
			html +=					  " src=\"" + this.imgBasePath + "edit23.png\"";
			html +=					  " alt=\"" + EDR.messages.editSearch_title + "\"";
			html +=					  " title=\"" + EDR.messages.editSearch_title + "\"";
			html +=					  " style=\"padding-left:3px;width:15px;height:15px;\"/>";
			html +=			"</a>";
			html += 		"<a href=\"javascript:;\">";
			html +=				"<img";
			html +=					  " src=\"" + this.imgBasePath + "delete23.png\"";
			html +=					  " alt=\"" + EDR.messages.deleteSavedSearch_title + "\"";
			html +=					  " title=\"" + EDR.messages.deleteSavedSearch_title + "\"";
			html +=					  " style=\"padding-left:3px;width:15px;height:15px;\"/>";
			html +=			"</a>";
			html += 	"</div>";
			html += "</div>"
			return html;
		},
		
		clear: function() {
			dojo.empty(this.queryContainer);
		},
		
		destroy: function() {
			dojo.forEach(this.handlers, dojo.disconnect);
			this.inherited("destroy", arguments);
		},
		
		_getTruncatedLabel: function(item, width) {
			var label = item.name + ""/*hack: object2string*/; 
			if (this._getStringExtent(label) < width) {
				return label;
			} else {
				var ellipse = "...";
				var labelWidth = width - this._getStringExtent(ellipse);
				if (labelWidth > 0) { 	
					for (var i=0; i<label.length; i++) {
						var s = label.slice(0, i);
						if (labelWidth < this._getStringExtent(s) && i > 0) {
							return label.slice(0, i-1) + ellipse;
						}
					}				
				}
				return ellipse;
			}
		},
		
		_getStringExtent: function(str) {
			this.hiddenSpan.innerHTML = str;
			var size = this.hiddenSpan.offsetWidth;
			this.hiddenSpan.innerHTML = "";
			return size;
		},
		
		_getDummyJson: function() {
			return [
				{name:"saved search1", description:"aaaaaaaaaaaaaaaaaaaaaaaa", query:"query this"},
				{name:"saved search1", description:"aaaaaaaaaaaaaaaaaaaaaaaa", query:"query this"},
				{name:"saved search1", description:"aaaaaaaaaaaaaaaaaaaaaaaa", query:"query this"},
				{name:"saveeeeeeeeaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaeeeeeeeeeeeeeeeeeeeeeeeeeed search1", description:"aaaaaaaaaaaaaaaaaaaaaaaa", query:"query this"},
				{name:"saved search1", description:"aaaaaaaaaaaaaaaaaaaaaaaa", query:"query this"},
				{name:"saved search1", description:"aaaaaaaaaaaaaaaaaaaaaaaa", query:"query this"},
				{name:"saved search1", description:"aaaaaaaaaaaaaaaaaaaaaaaa", query:"query this"},
				{name:"saved search1", description:"aaaaaaaaaaaaaaaaaaaaaaaa", query:"query this"},
				{name:"saved seaaa22222222222222222222222aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaarch1", description:"aaaaaaaaaaaaaaaaaaaaaaaa", query:"query this"},
				{name:"saved search1", description:"aaaaaaaaaaaaaaaaaaaaaaaa", query:"query this"},
				{name:"saved search1", description:"aaaaaaaaaaaaaaaaaaaaaaaa", query:"query this"},
				{name:"saved search1", description:"aaaaaaaaaaaaaaaaaaaaaaaa", query:"query this"},
				{name:"saved search1", description:"aaaaaaaaaaaaaaaaaaaaaaaa", query:"query this"},
				{name:"saved search1", description:"aaaaaaaaaaaaaaaaaaaaaaaa", query:"query this"},
				{name:"saved search1", description:"aaaaaaaaaaaaaaaaaaaaaaaa", query:"query this"},
				{name:"saved search1", description:"aaaaaaaaaaaaaaaaaaaaaaaa", query:"query this"},
				{name:"saved search1", description:"aaaaaaaaaaaaaaaaaaaaaaaa", query:"query this"},
				{name:"saved search1", description:"aaaaaaaaaaaaaaaaaaaaaaaa", query:"query this"},
				{name:"saved search1", description:"aaaaaaaaaaaaaaaaaaaaaaaa", query:"query this"},
				{name:"saved search1", description:"aaaaaaaaaaaaaaaaaaaaaaaa", query:"query this"}
			];
		}
	}
);

}

if(!dojo._hasResource["widgets.PreviewContent"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.PreviewContent"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.PreviewContent");






dojo.declare(
	"widgets.PreviewContent", [dijit._Widget, dijit._Templated],
	{				
		widgetsInTemplate: true,
		templateString:"<div style=\"width:800px;height:510px;\">\t\n\t<!-- main toolbar -->\n\t<div dojoType=\"widgets.Toolbar\">\n\t\t<div style=\"\">\n\t\t\t<div dojoType=\"dijit.form.Button\"\n\t\t\t\ticonClass=\"previousHighlightButton\" \n\t\t   \t\talt=\"${messages_tooltip_preview_previous}\"\n\t\t   \t\ttitle=\"${messages_tooltip_preview_previous}\"></div>\t\t\t\t\t\t\n\t\t\t<div dojoType=\"dijit.form.Button\"\n\t\t\t\ticonClass=\"nextHighlightButtonIcon\" \n\t\t   \t\talt=\"${messages_tooltip_preview_next}\"\n\t\t   \t\ttitle=\"${messages_tooltip_preview_next}\"></div>\t\t\t\t\t\t\n\t\t</div>\n\t\t<div class=\"previewDialogTitleMessage\">\n\t\t\t<div>\n\t\t\t\t<span>${messages_preview_document_title}&nbsp;</span><span dojoAttachPoint=\"documentTitle\"></span>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<span>${messages_preview_document_date}&nbsp;</span><span dojoAttachPoint=\"documentDate\"></span>\n\t\t\t</div>\n\t\t</div>\n\t\t<span dojoAttachPoint=\"hiddenSpan\" style=\"${fontStyle}visibility:hidden;position:absolute;\"></span>\n\t</div>\t\n\t<div dojoAttachPoint=\"previewBody\" style=\"overflow:auto;position:absolute;left:5px;right:5px;top:40px;bottom:5px;\">\n\t</div>\n\t\n</div>\n",
		dialog: null,
		
		documentId: "",
		
		url: "",
		timeout: 10000,
		handlers: [],
		
		highlightList: [],
		currentHighlightSpan:null,
		highlightIndex: null,
		
		//trancate for long title
		fontStyle: "font-size:13px;",
		limitWidthForTitle: 300,
		
		messages_tooltip_preview_previous: EDR.messages.tooltip_preview_previous,
		messages_tooltip_preview_next: EDR.messages.tooltip_preview_next,
		messages_preview_document_title :EDR.messages.preview_document_title,
		messages_preview_document_date :EDR.messages.preview_document_date,
		
		postCreate: function() {
			this.inherited("postCreate", arguments);
			this.handlers.push(dojo.connect(this._supportingWidgets[1], "onClick", this, function() {
				this.previousHighlight();
			}));
			this.handlers.push(dojo.connect(this._supportingWidgets[2], "onClick", this, function() {
				this.nextHighlight();
			}));		
		},
		
		startup: function() {
			this.inherited(arguments);
			this.dialog = dijit.byId(EDR.prefix+"previewDialog");

			this.handlers.push(dojo.connect(this.dialog.okButtonNode, "onClick", this, function() {
				this.dialog.cancelFunction();
			}));
		},
				
		loadErrorHandler: function() {
		},
		
		setDocumentParams: function(params, fullQuery) {
			this.documentId = params.documentID;
			this.collectionId = params.collectionID;
			this.documentTitle.innerHTML = this._getTruncatedLabel(params.title,this.limitWidthForTitle);
			this.documentTitle.title = params.title;
			this.documentDate.innerHTML = params.date;
			this.description = params.description;
			this.previewBody.innerHTML = "";
			this.preLoad();
			dojo.xhrPost({
						url: EDR.contextPath + "/preview?action=loadPreview",
						content: {"did": this.documentId, "cid": this.collectionId, "query": fullQuery},
						load: dojo.hitch(this, "_onLoad"),
						error: dojo.hitch(this, "_onError"),
						timeout: dojo.hitch(this, "_onTimeout")
					});
		},
		
		_onLoad: function(response, ioArgs) {
			this.postLoad();
			if(response!=null){
				this.previewBody.innerHTML = response;
				this.previewBody.scrollTop = 0;
				this.clearHighlight();
				this.setHighlightList();
			}
		},
		
		setHighlightList: function(){
			var spans = this.previewBody.getElementsByTagName("span");
			var length = spans.length;
			if(length>0){
				for(var i=0;i<length;i++){
					if(spans[i].className=="OFHighlightTerm1"||spans[i].className=="OFHighlightTerm2"||spans[i].className=="OFHighlightTerm3"||spans[i].className=="OFHighlightTerm4"||spans[i].className=="OFHighlightTerm5"){
						this.highlightList.push(spans[i]);
					}
				}
			}			
		},
		
		_onError: function(response, ioArgs) {
			this.previewBody.innerHTML = EDR.messages.preview_prompt_documentNotAvailable+"<br /><br />" +this.description;
		},
		
		_onTimeout: function(response, ioArgs) {
			this.previewBody.innerHTML = EDR.messages.preview_prompt_documentNotAvailable+"<br /><br />" +this.description;
		},
		
		previousHighlight: function(){
			if(!(this.highlightList==null||this.highlightList.length==0)){
				if(this.currentHighlightSpan!=null){
					this.removeHighlight(this.currentHighlightSpan);
				}
				var length = this.highlightList.length
				if(this.highlightIndex==null){
					this.highlightIndex = length-1;
				}else{
					this.highlightIndex--;
				}
				if(this.highlightIndex<0){
					this.highlightIndex = length-1;
				}
				this.buildHighlightSpan();
			}
		},

		nextHighlight: function(){
			if(!(this.highlightList==null||this.highlightList.length==0)){
				if(this.currentHighlightSpan!=null){
					this.removeHighlight(this.currentHighlightSpan);
				}
				var length = this.highlightList.length
				if(this.highlightIndex==null){
					this.highlightIndex = 0;
				}else{
					this.highlightIndex++;	
				}		
				if(this.highlightIndex>length-1){
					this.highlightIndex = 0;
				}
				this.buildHighlightSpan();
			}
		},
		
		buildHighlightSpan: function(){
			this.currentHighlightSpan = this.highlightList[this.highlightIndex];
			dojo.addClass(this.highlightList[this.highlightIndex],"selectedOFHighlightTerm");
			dojo.attr(this.currentHighlightSpan,"tabindex",0);
			this.currentHighlightSpan.focus();
		},
		
		removeHighlight: function(span){
			dojo.removeAttr(span,"tabindex");
			dojo.removeClass(span,"selectedOFHighlightTerm");
		},
		
		clear: function(){
			this.clearHighlight();
		},
		
		clearHighlight: function(){
			this.highlightIndex = null;
			this.highlightList = [];
			this.currentHighlightSpan = null;
		},

		preLoad: function() {
			EDR.ajax.Loading.setIsLoading(this.domNode);
		},
		
		postLoad: function() {
			EDR.ajax.Loading.clearIsLoading(this.domNode);
		},
		
		_getTruncatedLabel: function(item, width) {
			var label = item + ""/*hack: object2string*/; 
			if (this._getStringExtent(label) < width) {
				return label;
			} else {
				var ellipse = "...";
				var labelWidth = width - this._getStringExtent(ellipse);
				if (labelWidth > 0) { 	
					for (var i=0; i<label.length; i++) {
						var s = label.slice(0, i);
						if (labelWidth < this._getStringExtent(s) && i > 0) {
							return label.slice(0, i-1) + ellipse;
						}
			}
		}
				return ellipse;
			}
		},
		
		_getStringExtent: function(str) {
			this.hiddenSpan.innerHTML = str;
			var size = this.hiddenSpan.offsetWidth;
			this.hiddenSpan.innerHTML = "";
			return size;
		},
				
		destroy: function() {
			dojo.forEach(this.handlers, dojo.disconnect);
			this.inherited("destroy", arguments);
		}
	}
);

}

if(!dojo._hasResource["widgets.customize.Popup"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.customize.Popup"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.customize.Popup");




dojo.declare(
"widgets.customize.Popup",
[dijit._Widget, dijit._Templated],
{
	widgetsInTemplate: true,
	templateString:"<div class=\"dijitDialog customDialog_portlet CustomizerPopup\" style=\"position: absolute; right: 30px; bottom: 30px;\">\n\t\t\n\t<div class=\"customDialog_header\" dojoAttachPoint=\"titleBar\" waiRole=\"dialog\">\n\n\t\t<div class=\"customDialog_top\">\n\t\t\t<div class=\"customDialog_left\"></div>\n\t\t\t<div class=\"customDialog_middle\" dojoAttachPoint=\"titleNode\">\n\t\t\t\t<div class=\"customDialog_title\" dojoAttachPoint=\"titleTextNode\" style=\"color:white;\">${messages_customizer_popup_label}</div>\t\t\t\t\n\t\t\t</div>\n\t\t</div>\n\n\t\t<div class=\"customDialog_bottom\">\n\t\t\t<div class=\"customDialog_left\"></div>\n\t\t \t<div class=\"customDialog_middle\"></div>\n\t\t</div>\n\t\n\t</div>\n\t\n\t<div class=\"customDialog_contentOuter\" dojoAttachPoint=\"containerOuter\">\n\n\t\t<div style=\"background-color: #FDE8D7; opacity: 0.8; width: 480px;height: 56px;\">\n\t\t\t<div>\n\t\t\t\t<span dojoType=\"widgets.Button\" type=\"button\" style=\"\" dojoAttachEvent=\"onClick: onOpenClick\" title=\"${messages_customizer_popup_button_open}\">${messages_customizer_popup_button_open}</span>\n\t\t\t\t<span dojoType=\"widgets.Button\" type=\"button\" style=\"\" dojoAttachEvent=\"onClick: onRevertClick\" title=\"${messages_customizer_popup_button_revert}\">${messages_customizer_popup_button_revert}</span>\n\t\t\t\t<span dojoType=\"widgets.Button\" type=\"button\" style=\"\" dojoAttachPoint=\"saveButton\" dojoAttachEvent=\"onClick: onSaveClick\" title=\"${customizer_popup_button_save}\">${customizer_popup_button_save}</span>\n\t\t\t\t<span dojoType=\"widgets.Button\" type=\"button\" style=\"\" dojoAttachEvent=\"onClick: onCancelClick\" title=\"${customizer_popup_button_exit}\">${customizer_popup_button_exit}</span>\t\t\t\t\n\t\t\t</div>\n\t\t</div>\n\t\t\n\t</div>\n\t\n\t<div class=\"customDialog_footer\" dojoAttachPoint=\"altFooterNode\">\t\n\t\t<div class=\"customDialog_left\"></div>\n\t\t<div class=\"customDialog_middle\"></div>\n\t</div>\t\n\t\n</div>\n",
	
	messages_customizer_popup_label: EDR.messages.customizer_popup_label,
	messages_customizer_popup_button_open: EDR.messages.customizer_popup_button_open,
	messages_customizer_popup_button_revert: EDR.messages.customizer_popup_button_revert,
	customizer_popup_button_save: EDR.messages.customizer_popup_button_save,
	customizer_popup_button_exit: EDR.messages.customizer_popup_button_exit,
	
	postCreate: function() {
		this.inherited(arguments);
		if(this.isLeftToRight()) {
			dojo.addClass(this.domNode, "widgetsLtr");
		}
	},	
	
	isLeftToRight: function() {
		var dir = this.attr("dir");
		if(dir) {
			return dir == "ltr";
		} else {
			return dojo._isBodyLtr();	
		}
	},
	
	onOpenClick: function(evt) {
		EDR.dialog.util.showById(EDR.prefix+"searchCustomizer");
		return false;
	},
	
	onRevertClick: function(evt) {
		window.location.reload();
	},
	
	onCancelClick: function(evt) {
//		window.location = "logout.jsp";
		window.close();
	},
	
	onSaveClick: function(evt) {
		var saveButton = this.saveButton;
		var manager = dijit.byId(EDR.prefix+"searchCustomizerWindow");
		
		saveButton.setDisabled(true);
		manager.saveConfig(dojo.hitch(this, "_onSaveComplete"));
	},
	
	_onSaveComplete: function() {
		this.saveButton.setDisabled(false);
	},
	
	__dummy__: ''
});
		

}

if(!dojo._hasResource["widgets.customize.Dialog"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.customize.Dialog"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.customize.Dialog");



dojo.declare(
"widgets.customize.Dialog",
widgets.customDialog,
{
	initialize: function() {
		dojo.forEach(this.getChildren(), function(child) {
			child.initialize();
		}, this);
	},
	
	isLeftToRight: function() {
		var dir = this.attr("dir");
		if(dir) {
			return dir == "ltr";
		} else {
			return dojo._isBodyLtr();	
		}
	}
});


}

if(!dojo._hasResource["widgets.customize._ConfigPane"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.customize._ConfigPane"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.customize._ConfigPane");

dojo.declare(
"widgets.customize._ConfigPane",
null,
{

	initialize: function(json) {
		var trs = dojo.query("tr", this.domNode);
		trs.forEach(function(tr) {
			var key = dojo.attr(tr, "configkey");

			if(key){

				var messagekey = dojo.attr(tr, "messagekey");
				var configtype = dojo.attr(tr, "configtype");
				if(!messagekey) {
					messagekey = key;
				}
				var value = json[key];
				if(typeof(value) == "undefined") {
					value = "";
				}
		
				var td = dojo.query("> td", tr);
				var inputs = dojo.query("input", tr);
				
				td[0].innerHTML = EDR.messages[messagekey.replace(/\./g, "_")];
				
				if(configtype == "bool") {
					var divs = dojo.query("> div", td[1]);
					if(divs && divs[0]) {
						var checkbox = dijit.byNode(divs[0]);
						checkbox.attr("value", value.toLowerCase() == "true");
					}
				}else if(configtype == "yesno"){
					var divs = dojo.query("> div", td[1]);
					if(divs && divs[0]) {
						var checkbox = dijit.byNode(divs[0]);
						checkbox.attr("value", value.toLowerCase() == "yes");
					}		
				}else if(configtype == "select"){
					var divs = dojo.query("> div", td[1]);
					if(divs && divs[0]) {
						var select = dijit.byNode(divs[0]);
						try {
							select.setValue(value);	
						} catch(e) {
						}
					}
				} else if(configtype == "numberlist") {
					var firstComma = value.indexOf(',');
					var defaultValue = value.substring(0, firstComma);
					var restStr = value.substring(firstComma + 1); 
					if(inputs[0]) {
						inputs[0].value = defaultValue;
					}
					if(inputs[1]) {
						inputs[1].value = restStr;
					}
				} else {
					if(inputs[0]) {
						inputs[0].value = value;
					}				
				}
			}
			
		}, this);
	},
	
	collectData: function(data) {
		if(!data || !data["names"] || !data["values"]) {
			data = { "names": [], "values": [] };
		}
		return this.collectDataFromNode(data, this.domNode);;
	},
	
	collectDataFromNode: function(data, node){
		var trs = dojo.query("tr", node);
		trs.forEach(function(tr) {
			
			var key = dojo.attr(tr, "configkey");
			var configtype = dojo.attr(tr, "configtype");
			data.names.push(key);
			var tds = dojo.query("> td", tr);
			var value;
			if(configtype == "bool") {
				var divs = dojo.query("> div", tds[1]);
				if(divs && divs[0]) {
					var checkbox = dijit.byNode(divs[0]);
					value = checkbox.attr("value");
					if(value == "on") {
						value = true;
					}
//					console.debug("value:", value);
				}
			} else if(configtype == "yesno"){
				var divs = dojo.query("> div", tds[1]);
				if(divs && divs[0]) {
					var checkbox = dijit.byNode(divs[0]);
					value = checkbox.attr("value");
					value = (!value) ? "No" : "Yes";
				}
			} else if(configtype == "select") {
				var divs = dojo.query("> div", tds[1]);
				if(divs && divs[0]) {
					var select = dijit.byNode(divs[0]);
					value = select.getValue();
				}				
			} else if(configtype == "numberlist") {
				var inputs = dojo.query("input", tr);
				if(inputs[0] && inputs[1]) {
					if (inputs[0].value != "" && inputs[1].value != "") {
						value = inputs[0].value + "," + inputs[1].value;
					} else if (inputs[0].value != "") {
						value = inputs[0].value;
					} else {
						value = inputs[1].value
					}
				}				
			} else {
				var inputs = dojo.query("input", tr);
				if(inputs[1]){
					value = inputs[1].value;
				}else if(inputs[0]) {
					value = inputs[0].value;
				} else {
					var select = dojo.query("select", tr);
					value = select.value;
				}
			}
			
			data.values.push(value);
		}, this);
		
		return data;
	}
	
});

}

if(!dojo._hasResource["widgets.customize.ScreenSettings"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.customize.ScreenSettings"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.customize.ScreenSettings");






dojo.declare(
"widgets.customize.ScreenSettings",
[dijit._Widget, dijit._Templated, widgets.customize._ConfigPane],
{
	widgetsInTemplate: true,
	templateString:"<div class=\"SearchApplicationCustomizePane ScreenSettingsPane\">\n<div>${messages_customizer_screen_section1}:\n<table>\n\t<tbody>\n\t\t<tr configkey=\"banner.file\" messagekey=\"banner\"><td></td><td><input dojoAttachPoint=\"input_config_banner_file\" type=\"text\" value=\"\" class=\"dijitComboBox\" dojoAttachEvent=\"onchange:_onBannerChange\" /></td></tr>\n\t\t<tr configkey=\"displayedApplicationName\" messagekey=\"prompt.displayed.application.name\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" dojoAttachEvent=\"onchange:_onDisplayNameChange\" /></td></tr>\n\t\t<tr configkey=\"search.backgroundImage\" messagekey=\"backgroundImageName\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" dojoAttachEvent=\"onchange:_onBackgroundChange\" /></td></tr>\n\t\t<tr configkey=\"bannerLeft.backgroundImage\" messagekey=\"bannerLeft\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" dojoAttachEvent=\"onchange:_onBannerLeftChange\" /></td></tr>\n\t\t<tr configkey=\"bannerBody.backgroundImage\" messagekey=\"bannerImageName\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" dojoAttachEvent=\"onchange:_onBannerCenterChange\" /></td></tr>\n\t\t<tr configkey=\"bannerRight.backgroundImage\" messagekey=\"bannerRight\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" dojoAttachEvent=\"onchange:_onBannerRightChange\" /></td></tr>\n\t</tbody>\n</table>\n</div>\n<hr />\n<div>\n${messages_customizer_screen_section2}:\n<table>\n\t<tbody>\n\t\t<tr configkey=\"link.preferences.show\" configtype=\"bool\"><td></td><td><input dojoType=\"dijit.form.CheckBox\" value=\"\" dojoAttachEvent=\"onClick: _onShowChange\" /></td></tr>\n\t\t<tr configkey=\"link.myProfile.show\" configtype=\"bool\"><td></td><td><input dojoType=\"dijit.form.CheckBox\" value=\"\" dojoAttachEvent=\"onClick: _onShowChange\" /></td></tr>\n\t\t<tr configkey=\"link.help.show\" configtype=\"bool\"><td></td><td><input dojoType=\"dijit.form.CheckBox\" value=\"\" dojoAttachEvent=\"onClick: _onShowChange\" /></td></tr>\n\t\t<tr configkey=\"link.about.show\" configtype=\"bool\"><td></td><td><input dojoType=\"dijit.form.CheckBox\" value=\"\" dojoAttachEvent=\"onClick: _onShowChange\" /></td></tr>\n\t\t<tr dojoAttachPoint=\"logoffElement\" configkey=\"link.logOff.show\" configtype=\"bool\"><td></td><td><input dojoType=\"dijit.form.CheckBox\" value=\"\" dojoAttachEvent=\"onClick: _onShowChange\" /></td></tr>\n\t</tbody>\n</table>\n</div>\n<!-- <hr />\n<div>\n${messages_customizer_screen_section3}:\n<table>\n\t<tbody>\n\t\t<tr configkey=\"field.defaultIcon\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" /></td></tr>\n\t</tbody>\n</table>\n<table style=\"margin-top: 1em; margin-left: 3em;\">\n\t<thead>\n\t\t<tr><th>${messages_fieldName}</th><th>${messages_fieldImage}</th><th>&nbsp;</th></tr>\n\t</thead>\n\t<tbody dojoAttachPoint=\"fieldImageBody\">\n\t</tbody>\n</table>\n<button dojoType=\"dijit.form.Button\" dojoAttachEvent=\"onClick: _addFieldRow\">${messages_button_addRow}</button>\n</div> -->\n</div>\n",

	messages_fieldName: EDR.messages.fieldName,
	messages_fieldImage: EDR.messages.fieldImage,
//	messages_fieldImageToShow: EDR.messages.fieldImageToShow,
	messages_button_addRow: EDR.messages.button_addRow,
	messages_customizer_screen_section1: EDR.messages.customizer_screen_section1,
	messages_customizer_screen_section2: EDR.messages.customizer_screen_section2,
	messages_customizer_screen_section3: EDR.messages.customizer_screen_section3,

	config_field_icon_from: EDR.config.field_icon_from,
	
	postCreate: function() {
		this.inherited(arguments);
		var banner = dijit.byId(EDR.prefix+"bannerId");
		dojo.style(this.logoffElement,"display",(banner.isLoggedIn ? "" : "none"));
	},
	
	initialize: function(json) {
		this.inherited(arguments);
		
/*		var tbody = this.fieldImageBody;		
		for(var name in json) {
			var result = name.match(/field\.icon\.(.*)/);
			if(result) {
				var fieldname = result[1];
				var tr = dojo.create("tr", null, tbody);
				var td = dojo.create("td", null, tr);
				var input1 = dojo.create("input", {type:"text", className:"dijitComboBox", value: fieldname}, td);
				var td2 = dojo.create("td", null, tr);
				var input2 = dojo.create("input", {type:"text", className:"dijitComboBox", value: json[name]}, td2);
				var td3 = dojo.create("td", null, tr);
				var a = dojo.create("a", {"href": "javascript:;"}, td3);
				var img = dojo.create("img", {src: EDR.contextPath + "/images/delete.gif"}, a);
				a.onclick = function(evt) {
					var node = this;
					var td = node.parentNode;
					var tr = td.parentNode;
					var tbody = tr.parentNode;
					tbody.removeChild(tr);
					dojo.stopEvent(evt)
				}
			}
		}
		
		this._addFieldRow();*/
	},
	
	_onBannerChange: function(evt) {
		var file = this.input_config_banner_file.value;
		var img = dojo.query("div.BannerLogo > img")[0];
		img.src = file;
	},
	
	_onDisplayNameChange: function(evt) {
		var target = evt.target;
		var displayName = target.value;
		var titles = dojo.query("div.BannerProductName");
		titles.attr("innerHTML", displayName);
	},
	
	_onBackgroundChange: function(evt) {
		var target = evt.target;
		var image = target.value;
		dojo.style(dojo.body(), "backgroundImage", "url('"+image +"')");
	},
	
	_onBannerLeftChange: function(evt) {
		var target = evt.target;
		var image = target.value;
		var divs = dojo.query("div.Banner .BannerLeft");
		divs.style("backgroundImage", "url('"+image +"')");		
	},	
	
	_onBannerCenterChange: function(evt) {
		var target = evt.target;
		var image = target.value;
		var divs = dojo.query("div.BannerGroup .BannerCenter");
		divs.style("backgroundImage", "url('"+image +"')");		
	},
	
	_onBannerRightChange: function(evt) {
		var target = evt.target;
		var image = target.value;
		var divs = dojo.query("div.Banner .BannerGroup");
		divs.style("backgroundImage", "url('"+image +"')");		
	},		
	
	_onShowChange: function(evt) {
		var input = evt.target;
		var div = input.parentNode;
		var tr = div.parentNode.parentNode;
		var configkey = dojo.attr(tr, "configkey");
		
		this._changeShowState(configkey);
	},
	
	_changeShowState: function(configkey, state) {
		var postfix = configkey.match(/link\.(.*)\.show/)[1];
		var node1 = dojo.byId(EDR.prefix + "link_" + postfix);
		var node2 = dojo.byId(EDR.prefix + "separator_" + postfix);
		if(node1) {
			dojo.toggleClass(node1, "dijitHidden");
		}
		if(node2) {
			dojo.toggleClass(node2, "dijitHidden");	
		}
	},
	
	_addFieldRow: function() {
		var tbody = this.fieldImageBody;
		
		var tr = dojo.create("tr", null, tbody);
		var td = dojo.create("td", null, tr);
		var input1 = dojo.create("input", {type:"text", className:"dijitComboBox", value: ""}, td);
		var td2 = dojo.create("td", null, tr);
		var input2 = dojo.create("input", {type:"text", className:"dijitComboBox", value: ""}, td2);
		var td3 = dojo.create("td", null, tr);
		var a = dojo.create("a", {"href": "javascript:;"}, td3);
		var img = dojo.create("img", {src: EDR.contextPath + "/images/delete.gif"}, a);
		a.onclick = function(evt) {
			var node = this;
			var td = node.parentNode;
			var tr = td.parentNode;
			var tbody = tr.parentNode;
			tbody.removeChild(tr);
			dojo.stopEvent(evt)
		}

	},

	__dummy__ : ''
});

}

if(!dojo._hasResource["widgets.customize.ServerSettings"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.customize.ServerSettings"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.customize.ServerSettings");







dojo.declare(
"widgets.customize.ServerSettings",
[dijit._Widget, dijit._Templated, widgets.customize._ConfigPane],
{
	widgetsInTemplate: true,
	templateString:"<div class=\"SearchApplicationCustomizePane ServerSettingsPane\">\n<div>${messages_customizer_server_section1}:\n<table>\n\t<tbody>\n\t\t<tr configkey=\"hostname\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" /></td></tr>\n\t\t<tr configkey=\"port\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" /></td></tr>\n\t\t<tr configkey=\"protocol\" configtype=\"select\"><td></td><td><select dojoType=\"dijit.form.FilteringSelect\"><option value=\"http\">${messages_protocol_http}</option><option value=\"https\">${messages_protocol_https}</option></select></td></tr>\n\t\t<!--  <tr configkey=\"username\" messagekey=\"customizer.text.imc.username.label\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" /></td></tr> -->\n\t\t<!--  <tr configkey=\"password\" messagekey=\"customizer.text.imc.password.label\"><td></td><td><input type=\"password\" value=\"\" class=\"dijitComboBox\" /></td></tr> -->\n\t\t<tr configkey=\"applicationName\" messagekey=\"prompt.application.name\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" /></td></tr>\n\t\t<tr configkey=\"trustStore\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" /></td></tr>\n\t\t<tr configkey=\"trustPassword\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" /></td></tr>\n\t\t<tr configkey=\"logging.level\" configtype=\"select\" messagekey=\"prompt.loggingLevel\"><td></td><td><select dojoType=\"dijit.form.FilteringSelect\"><option value=\"SEVERE\">${messages_prompt_loggingLevel_severe}</option><option value=\"INFO\">${messages_prompt_loggingLevel_info}</option><option value=\"FINE\">${messages_prompt_loggingLevel_fine}</option><option value=\"ALL\">${messages_prompt_loggingLevel_all}</option></select></td></tr>\n\t\t<tr configkey=\"timeout\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" /></td></tr>\n\t\t<tr configkey=\"customizerDisabled\" configtype=\"bool\" messagekey=\"customizer.no.palette\"><td>Customizer disabled</td><td><input dojoType=\"dijit.form.CheckBox\" value=\"\" /></td></tr>\n\t\t\n\t</tbody>\n</table>\n</div>\n<!-- \n<hr />\n<div>\n${messages_customizer_server_section2}:\n<table>\n\t<tbody>\n\t\t<tr configkey=\"showMessage.error\" configtype=\"bool\"><td></td><td style=\"width: 180px;\"><input dojoType=\"dijit.form.CheckBox\" value=\"\" /></td></tr>\n\t\t<tr configkey=\"showMessage.warning\" configtype=\"bool\"><td></td><td><input dojoType=\"dijit.form.CheckBox\" value=\"\" /></td></tr>\n\t\t<tr configkey=\"showMessage.info\" configtype=\"bool\"><td></td><td><input dojoType=\"dijit.form.CheckBox\" value=\"\" /></td></tr>\n\t\t<tr configkey=\"showMessage.success\" configtype=\"bool\"><td></td><td><input dojoType=\"dijit.form.CheckBox\" value=\"\" /></td></tr>\n\t</tbody>\n</table>\n</div>\n -->\n</div>\n",
	
	messages_protocol_http: EDR.messages.protocol_http,
	messages_protocol_https: EDR.messages.protocol_https,
	messages_prompt_loggingLevel_severe: EDR.messages.prompt_loggingLevel_severe,
	messages_prompt_loggingLevel_info: EDR.messages.prompt_loggingLevel_info, 
	messages_prompt_loggingLevel_fine: EDR.messages.prompt_loggingLevel_fine, 
	messages_prompt_loggingLevel_all: EDR.messages.prompt_loggingLevel_all, 
	messages_customizer_server_section1: EDR.messages.customizer_server_section1,
	messages_customizer_server_section2: EDR.messages.customizer_server_section2,
	
	postCreate: function() {
	},
	
	onShow: function() {
	},
	
	__dummy__: null	
});

}

if(!dojo._hasResource["widgets.customize.QueryOptions"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.customize.QueryOptions"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.customize.QueryOptions");







dojo.declare(
"widgets.customize.QueryOptions",
[dijit._Widget, dijit._Templated, widgets.customize._ConfigPane],
{
	widgetsInTemplate: true,
	templateString:"<div class=\"SearchApplicationCustomizePane QueryOptionsPane\">\n<div style=\"width:98%;padding:5px;\">\n<div style=\"width:48%;float:left;\">\n${messages_customizer_query_section1}:\n<table>\n\t<tbody>\n\t\t<tr configkey=\"preferences.spellCorrections\" messagekey=\"prompt.advanced.spellCorrections\" configtype=\"yesno\"><td></td><td><input dojoType=\"dijit.form.CheckBox\" value=\"\" /></td></tr>\n<!-- \t<tr configkey=\"builtQueryString.show\" configtype=\"bool\"><td></td><td><input dojoType=\"dijit.form.CheckBox\" value=\"\" /></td></tr> -->\n\t\t<tr configkey=\"extraQueryData.show\" configtype=\"bool\"><td></td><td><input dojoType=\"dijit.form.CheckBox\" value=\"\" /></td></tr>\n<!--\t\t<tr configkey=\"refineResults.show\" configtype=\"bool\"><td></td><td><input dojoType=\"dijit.form.CheckBox\" value=\"\" /></td></tr> -->\n<!-- \t\t<tr configkey=\"preferences.defaultCollections\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" /></td></tr> -->\n\t\t<tr configkey=\"preferences.nearDuplicateDetection\" messagekey=\"prompt.advanced.nearDuplicateDetection\" configtype=\"yesno\"><td></td><td><input dojoType=\"dijit.form.CheckBox\" value=\"\" /></td></tr>\n\t\t<tr configkey=\"preferences.summaryLength\" messagekey=\"prompt.advanced.summaryLength\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" /></td></tr>\n\t</tbody>\n</table>\n</div>\n<div style=\"width:48%;float:left;\">\n<br />\n<table>\n\t<tbody>\n\t\t<tr configkey=\"preferences.summaryLength.level1\" messagekey=\"prompt.advanced.summaryLength.level1\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" /></td></tr>\n\t\t<tr configkey=\"preferences.summaryLength.level2\" messagekey=\"prompt.advanced.summaryLength.level2\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" /></td></tr>\n\t\t<tr configkey=\"preferences.summaryLength.level3\" messagekey=\"prompt.advanced.summaryLength.level3\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" /></td></tr>\n\t\t<tr configkey=\"preferences.summaryLength.level4\" messagekey=\"prompt.advanced.summaryLength.level4\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" /></td></tr>\n\t\t<tr configkey=\"preferences.summaryLength.level5\" messagekey=\"prompt.advanced.summaryLength.level5\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" /></td></tr>\n\t</tbody>\n</table>\n</div>\n</div>\n<hr style=\"width:100%; clear: both;\"/>\n<div>${messages_customizer_query_typeAhead_section}:\n<table>\n\t<tbody>\n\t\t<tr configkey=\"typeAhead.search.numberOfResults\" messagekey=\"customizer.typeAhead.search.numberOfResults\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" /></td></tr>\n\t\t<tr configkey=\"typeAhead.search.mode\" messagekey=\"customizer.typeAhead.search.mode\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" /></td></tr>\n\t\t<tr configkey=\"typeAhead.facet.numberOfResults\" messagekey=\"customizer.typeAhead.facet.numberOfResults\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" /></td></tr>\n\t\t<tr configkey=\"typeAhead.documentlabel.numberOfResults\" messagekey=\"customizer.typeAhead.category.numberOfResults\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" /></td></tr>\n\t</tbody>\n</table>\n</div>\n<hr style=\"width:100%; clear: both;\"/>\n<div>\n${messages_customizer_query_section2}:\n<table>\n\t<thead>\n\t\t<tr><th>${messages_filterBy_fileType_name}</th><th>${messages_filterBy_fileType_extensions}</th></tr>\n\t</thead>\n\t<tbody dojoAttachPoint=\"fileTypeFilterBody\">\n\t</tbody>\n</table>\n<div dojoType=\"widgets.Button\"  dojoAttachEvent=\"onClick: _addFileTypeRow\">${messages_button_addRow}</div>\n</div>\n<!-- <hr />\n<div>\n${messages_customizer_query_section3}:\n<table>\n\t<thead>\n\t\t<tr><th>${messages_filterBy_custom_name}</th><th>${messages_filterBy_custom_value}</th></tr>\n\t</thead>\n\t<tbody dojoAttachPoint=\"customFilterBody\">\n\t</tbody>\n</table>\n<button dojoType=\"dijit.form.Button\" dojoAttachEvent=\"onClick: _addCustomFilterRow\">${messages_button_addRow}</button>\n</div> -->\n</div>\n",
	
	messages_filterBy_fileType_name: EDR.messages.filterBy_fileType_name,
	messages_filterBy_fileType_extensions: EDR.messages.filterBy_fileType_extensions,
	messages_filterBy_custom_name: EDR.messages.filterBy_custom_name,
	messages_filterBy_custom_value: EDR.messages.filterBy_custom_value,
	messages_button_addRow: EDR.messages.button_addRow,
	messages_customizer_query_section1: EDR.messages.customizer_query_section1,
	messages_customizer_query_section2: EDR.messages.customizer_query_section2,
	messages_customizer_query_section3: EDR.messages.customizer_query_section3,
	messages_customizer_query_typeAhead_section: EDR.messages.customizer_query_typeAhead_section,
	
	initialize: function(json) {
		this.inherited(arguments);
		
		var tbody = this.fileTypeFilterBody;
//		var tbody2 = this.customFilterBody;
		
		for(var key in json) {
			if(key.indexOf("documentType.") == 0) {
				var ext = key.substring(13);
				var tr = dojo.create("tr", {configkey:key}, tbody);
				var td1 = dojo.create("td", null, tr);
				var input1 = dojo.create("input", {"value": ext, "className": "dijitComboBox", "style":"width: 5em;"}, td1);		
				input1.onchange = function(evt){
					var node = this;
					var td = node.parentNode;
					var tr = td.parentNode;
					dojo.attr(tr,"configkey","documentType."+node.value);
				}
				var td2 = dojo.create("td", null, tr);
				var input2 = dojo.create("input", {"value": json[key], className: "dijitComboBox", "style": "width: 280px;"}, td2);				
				var td3 = dojo.create("td", null, tr);
				var a = dojo.create("a", {"href": "javascript:;"}, td3);
				var img = dojo.create("img", {src: EDR.contextPath + "/images/delete.gif", alt:EDR.messages.common_delete, title:EDR.messages.common_delete}, a);
				a.onclick = function(evt) {
					var node = this;
					var td = node.parentNode;
					var tr = td.parentNode;
					var tbody = tr.parentNode;
					tbody.removeChild(tr);
					dojo.stopEvent(evt);
				}
			}/* else if(key.indexOf("filterCustom.") == 0) {
				var labelStr = key.substring(13);

				var tr = dojo.create("tr", {configkey:key}, tbody2);
				var td1 = dojo.create("td", null, tr);
				var input1 = dojo.create("input", {"value": labelStr, "className": "dijitComboBox"}, td1);				
				input1.onchange = function(evt){
					var node = this;
					var td = node.parentNode;
					var tr = td.parentNode;
					dojo.attr(tr,"configkey","filterCustom."+node.value);
				}
				var td2 = dojo.create("td", null, tr);
				var input2 = dojo.create("input", {"value": json[key], className: "dijitComboBox", "style": "width: 280px;"}, td2);				
				var td3 = dojo.create("td", null, tr);
				var a = dojo.create("a", {"href": "javascript:;"}, td3);
				var img = dojo.create("img", {src: EDR.contextPath + "/images/delete.gif", alt:EDR.messages.common_delete, title:EDR.messages.common_delete}, a);
				a.onclick = function(evt) {
					var node = this;
					var td = node.parentNode;
					var tr = td.parentNode;
					var tbody = tr.parentNode;
					tbody.removeChild(tr);
					dojo.stopEvent(evt);
				}
			}*/
		}
		this._addFileTypeRow();
//		this._addCustomFilterRow();
	},
	
	_addFileTypeRow: function() {
		var tbody = this.fileTypeFilterBody;
		
		var tr = dojo.create("tr", null, tbody);
		var td = dojo.create("td", null, tr);
		var input1 = dojo.create("input", {type:"text", className:"dijitComboBox", value: "", "style":"width: 5em;"}, td);
		input1.onchange = function(evt){
			var node = this;
			var td = node.parentNode;
			var tr = td.parentNode;
			dojo.attr(tr,"configkey","documentType."+node.value);
		}
		var td2 = dojo.create("td", null, tr);
		var input2 = dojo.create("input", {type:"text", className:"dijitComboBox", value: "", "style": "width: 280px;"}, td2);
		var td3 = dojo.create("td", null, tr);
		var a = dojo.create("a", {"href": "javascript:;"}, td3);
		var img = dojo.create("img", {src: EDR.contextPath + "/images/delete.gif", alt:EDR.messages.common_delete, title:EDR.messages.common_delete}, a);
		a.onclick = function(evt) {
			var node = this;
			var td = node.parentNode;
			var tr = td.parentNode;
			var tbody = tr.parentNode;
			tbody.removeChild(tr);
			dojo.stopEvent(evt)
		}

	},
	
	_addCustomFilterRow: function() {
		var tbody = this.customFilterBody;
		
		var tr = dojo.create("tr", null, tbody);
		var td = dojo.create("td", null, tr);
		var input1 = dojo.create("input", {type:"text", className:"dijitComboBox", value: ""}, td);
		input1.onchange = function(evt){
			var node = this;
			var td = node.parentNode;
			var tr = td.parentNode;
			dojo.attr(tr,"configkey","filterCustom."+node.value);
		}
		var td2 = dojo.create("td", null, tr);
		var input2 = dojo.create("input", {type:"text", className:"dijitComboBox", value: "", style: "width: 280px;"}, td2);
		var td3 = dojo.create("td", null, tr);
		var a = dojo.create("a", {"href": "javascript:;"}, td3);
		var img = dojo.create("img", {src: EDR.contextPath + "/images/delete.gif", alt:EDR.messages.common_delete, title:EDR.messages.common_delete}, a);
		a.onclick = function(evt) {
			var node = this;
			var td = node.parentNode;
			var tr = td.parentNode;
			var tbody = tr.parentNode;
			tbody.removeChild(tr);
			dojo.stopEvent(evt)
		}

	},	
	
	__dummy__: null	
});

}

if(!dojo._hasResource["widgets.customize.Results"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.customize.Results"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.customize.Results");







dojo.declare(
"widgets.customize.Results",
[dijit._Widget, dijit._Templated, widgets.customize._ConfigPane],
{
	widgetsInTemplate: true,
	templateString:"<div class=\"SearchApplicationCustomizePane ResultsPane\">\n<div>${messages_customizer_results_section1}:\n<table>\n\t<tbody>\n<!-- \t<tr configkey=\"numberSearchResultsReturned.show\" configtype=\"bool\"><td></td><td><input dojoType=\"dijit.form.CheckBox\" value=\"\" /></td></tr> -->\n<!--\t<tr configkey=\"showDetails.show\" configtype=\"bool\"><td></td><td><input dojoType=\"dijit.form.CheckBox\" value=\"\" /></td></tr> -->\n<!-- \t<tr configkey=\"showDetailsImage.show\" configtype=\"bool\"><td></td><td><input dojoType=\"dijit.form.CheckBox\" value=\"\" /></td></tr> -->\n\t\t<tr configkey=\"preferences.siteCollapsing\" messagekey=\"prompt.advanced.siteCollapsing\" configtype=\"yesno\"><td></td><td><input dojoType=\"dijit.form.CheckBox\" value=\"\" /></td></tr>\n<!-- \t<tr configkey=\"preferences.extendedHighlighting\" configtype=\"bool\"><td></td><td><input dojoType=\"dijit.form.CheckBox\" value=\"\" /></td></tr> -->\n\t\t<tr configkey=\"preferences.resultsRange\" messagekey=\"customizer.prompt.advanced.numRequestedResults\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" /></td></tr>\n\t\t<tr configkey=\"date.fields\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" /></td></tr>\t\t\t\t\n\t\t<tr configkey=\"preferences.resultColumns\" messagekey=\"preferences.resultsColumns\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" dojoAttachPoint=\"resultsColumns\" dojoAttachEvent=\"onchange: onResultsColumnsChange\"/></td></tr>\t\t\t\t\n\t</tbody>\n</table>\n</div>\n<hr />\n<div>${messages_titles}:\n<table>\n\t<tbody>\n\t\t<tr configkey=\"titles.clean\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" /></td></tr>\n\t\t<tr configkey=\"titles.truncatePrefix\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" /></td></tr>\n\t</tbody>\n</table>\n</div>\n<hr />\n<div>${messages_clientViewer}:\n<table>\n\t<tbody>\n\t\t<tr configkey=\"clientViewer.show\" configtype=\"bool\"><td></td><td><input dojoType=\"dijit.form.CheckBox\" value=\"\" /></td></tr>\n\t\t<tr configkey=\"client.notes.icon\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" /></td></tr>\n\t\t<tr configkey=\"client.dominodoc.icon\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" /></td></tr>\n\t</tbody>\n</table>\n</div>\n<!-- <hr />\n<div>${messages_fields}:\n<table>\n\t<thead>\n\t\t<tr><th>${messages_fieldProtocol}</th><th>${messages_fieldShow}</th></tr>\n\t</thead>\n\t<tbody dojoAttachPoint=\"fieldProtocolBody\">\n\t</tbody>\n</table>\n<button dojoType=\"dijit.form.Button\" dojoAttachEvent=\"onClick: _addFieldRow\">${messages_button_addRow}</button>\n</div> -->\n\n</div>\n",
	
	messages_fieldProtocol: EDR.messages.fieldProtocol,
	messages_fieldShow: EDR.messages.fieldShow,
	messages_fields: EDR.messages.fields,
	messages_titles: EDR.messages.titles,
	messages_clientViewer: EDR.messages.clientViewer,
	messages_button_addRow: EDR.messages.button_addRow,
	messages_customizer_results_section1: EDR.messages.customizer_results_section1,

	initialize: function(json) {
		this.inherited(arguments);
	
/*		var tbody = this.fieldProtocolBody;

		var names = [];
		for(var name in json) {
			var regexp = new RegExp("fields\.(.*)");
			var result = regexp.exec(name);
			if(result) {
				var fieldname = result[1];
				names.push(fieldname);
			}
		}
		names.sort();
		for(var i=0; i<names.length; ++i) {
			var tr = dojo.create("tr", {configkey:"fields."+names[i]}, tbody);
			var td = dojo.create("td", null, tr);
			var input1 = dojo.create("input", {type:"text", className:"dijitComboBox", value: names[i]}, td);
			input1.onchange = function(evt){
				var node = this;
				var td = node.parentNode;
				var tr = td.parentNode;
				dojo.attr(tr,"configkey","fields."+node.value);
			}
			var td2 = dojo.create("td", null, tr);
			var input2 = dojo.create("input", {type:"text", className:"dijitComboBox", value: json["fields."+names[i]], style: "width: 280px;"}, td2);
			var td3 = dojo.create("td", null, tr);
			var a = dojo.create("a", {"href": "javascript:;"}, td3);
			var img = dojo.create("img", {src: EDR.contextPath + "/images/delete.gif", alt:EDR.messages.common_delete, title:EDR.messages.common_delete}, a);
			a.onclick = function(evt) {
				var node = this;
				var td = node.parentNode;
				var tr = td.parentNode;
				var tbody = tr.parentNode;
				tbody.removeChild(tr);
				dojo.stopEvent(evt)
			}			
		}
		
		this._addFieldRow();*/
	},
	
	_addFieldRow: function(evt) {
		var tbody = this.fieldProtocolBody;
		
		var tr = dojo.create("tr", null, tbody);
		var td = dojo.create("td", null, tr);
		var input1 = dojo.create("input", {type:"text", className:"dijitComboBox", value: ""}, td);
		input1.onchange = function(evt){
			var node = this;
			var td = node.parentNode;
			var tr = td.parentNode;
			dojo.attr(tr,"configkey","fields."+node.value);
		}
		var td2 = dojo.create("td", null, tr);
		var input2 = dojo.create("input", {type:"text", className:"dijitComboBox", value: "", style: "width: 280px;"}, td2);
		var td3 = dojo.create("td", null, tr);
		var a = dojo.create("a", {"href": "javascript:;"}, td3);
		var img = dojo.create("img", {src: EDR.contextPath + "/images/delete.gif", alt:EDR.messages.common_delete}, a);
		a.onclick = function(evt) {
			var node = this;
			var td = node.parentNode;
			var tr = td.parentNode;
			var tbody = tr.parentNode;
			tbody.removeChild(tr);
			dojo.stopEvent(evt);
		};
	},
	
	onResultsColumnsChange: function(evt) {
		var columnDefsStr =  this.resultsColumns.value;
		if(columnDefsStr != null) {
			var columnDefs = columnDefsStr.split(",");
			columnDefs = dojo.filter(columnDefs, function(elem){ return !(elem.length == 0 || elem[0] == '$'); });
			var manager = dijit.byId(EDR.prefix+"searchManager");
			manager.setColumnDefs(columnDefs);
			dojo.publish("headerColumnsChanged");
		}
	},
	
	__dummy__: null	
});

}

if(!dojo._hasResource["widgets.customize.Images"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.customize.Images"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.customize.Images");







dojo.declare(
"widgets.customize.Images",
[dijit._Widget, dijit._Templated, widgets.customize._ConfigPane],
{
	widgetsInTemplate: true,
	templateString:"<div class=\"SearchApplicationCustomizePane ImagesPane\">\n<div>${messages_documentSourceImage_label}:\n\t<table>\n\t\t<thead>\n\t\t\t<tr><th>${messages_documentSourceName}</th><th>${messages_documentSourceImage}</th></tr>\n\t\t</thead>\n\t\t<tbody dojoAttachPoint=\"sourceImageBody\">\n\t\t</tbody>\n\t</table>\t\n</div>\t\n</div>\n",

	messages_documentSourceName: EDR.messages.documentSourceName,
	messages_documentSourceImage: EDR.messages.documentSourceImage,
	messages_documentSourceImage_label: EDR.messages.documentSourceImage_label,
	
	initialize: function(json) {
		var tbody = this.sourceImageBody;
		var names = [];
		for(var name in json) {
			var regexp = new RegExp("documentSource\.(.*)\.icon");
			var result = regexp.exec(name);
			if(result) {
				var fieldname = result[1];
				names.push(fieldname);
			}
		}
		names.sort();
		for(var i=0; i<names.length; ++i) {
			var tr = dojo.create("tr", {configkey:"documentSource."+names[i]+".icon"}, tbody);
			var td = dojo.create("td", {innerHTML: names[i]}, tr);
			var td2 = dojo.create("td", null, tr);
			var input2 = dojo.create("input", {type:"text", className:"dijitComboBox", value: json["documentSource."+names[i]+".icon"]}, td2);
		}
	},
	
	__dummy__: null	
});

}

if(!dojo._hasResource["widgets.customize._ChartsPane"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.customize._ChartsPane"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.customize._ChartsPane");








dojo.declare(
"widgets.customize._ChartsPane",
[dijit._Widget, dijit._Templated, widgets.customize._ConfigPane],
{
	chartType: "",
	handlers: [],
	json: null,
	
	constructor: function() {
		this.chartType = "";
		this.handlers = [];
	},
	
	postCreate: function() {
		this.inherited(arguments);
	},
	
	initialize: function(json) {
		this.inherited(arguments);
		this.json=json;
		this.buildCharts(json);
	},
	
	buildCharts: function(json){
		var chartType = this.chartType;
		var chartsDiv = this[chartType+"Body"];
		var chartPropertiesArray = this[chartType+"PropertiesArray"];
		for(var i=1;i<100;i++){
			var titleKey = json[chartType+i+".titleKey"];
			var secondDiv = dojo.create("div",{innerHTML:((titleKey!=undefined)?titleKey+"&nbsp;":""),chartNumber:i}, chartsDiv);
			this.buildButtons(secondDiv);
			var tbl = dojo.create("table", null, secondDiv);
			var tbody = dojo.create("tbody", null, tbl);
			var propLength = chartPropertiesArray.length;
			for(var j=0;j<propLength;j++){
				this.buildChartForm(j, chartPropertiesArray, chartType, tbody, json[chartType+i+"."+chartPropertiesArray[j]]);
			}
			if(!this.hasNext(json, i, chartType)){
				break;
			}
			var hr = dojo.create("hr",null,secondDiv);	
		}
	},
	
	buildChartForm: function(i, chartPropertiesArray, chartType, tbody, itemValue){
		var itemLabel = EDR.messages[chartType+"_"+chartPropertiesArray[i].replace(/\./g, "_")];
		var tr = dojo.create("tr", null, tbody);
		var td = dojo.create("td", {innerHTML:itemLabel}, tr);
		var td2 = dojo.create("td", {name:chartPropertiesArray[i]}, tr);
		var widgetDiv = dojo.create("div", null,td2);
		if((itemValue=="true") ||(itemValue=="false")){
			var checkboxWidget = new dijit.form.CheckBox({value: itemValue,checked:((itemValue=="true")?true:false)},widgetDiv);				
			this.handlers.push(dojo.connect(td2,"onclick",this, "_showItems"));
		}else{
			var input2 = dojo.create("input", {type:"text",className:"dijitComboBox",value:itemValue!=undefined?itemValue:""},widgetDiv);
		}		
	},
	
	buildButtons: function(div){
		var buttonArray = ["up","down","delete"];
		var altArray = [EDR.messages.preferences_resultsColumns_moveBefore,EDR.messages.preferences_resultsColumns_moveAfter,EDR.messages.common_delete];
		for(var i=0; i < buttonArray.length; i++){
			var outer = dojo.create("span",{style:{marginRight:"4px"}},div);
			var button = dojo.create("a", {href: "javascript:;", innerHTML: "<img src='"+EDR.contextPath + "/images/"+buttonArray[i]+".gif' alt='"+ altArray[i] +"' title='"+altArray[i]+"' />"}, outer);
			this._connectHandlers(button, buttonArray[i]);
		}
	},
	
	hasNext: function(json, i, chartType){
		return ((json[chartType+(i+1)+".enable"]!=null)&&(json[chartType+(i+1)+".enable"]!=""));
	},
	
	_connectHandlers: function(elm, operation){
		var self = this;
		self.handlers.push(dojo.connect(elm,"onclick",self,function(evt) {
			self["_"+operation](elm);
		}));
	},
	
	onShow: function() {
	},
	
	_showItems: function(e){
		if(e.target.value=="true"){
			e.target.value="false";
		}else{
			e.target.value="true"
		}
	},
	
	addChartsBlock: function(){
		var chartType = this.chartType;
		var chartsDiv = this[chartType+"Body"];
		var chartPropertiesArray = this[chartType+"PropertiesArray"];
		var chartDefaultValues = this[chartType+"DefaultValues"];
		var secondDiv = dojo.create("div",{innerHTML:EDR.messages[chartType+"_createNewChart"]+"&nbsp;",chartNumber:(chartsDiv.childNodes.length+1)},chartsDiv);
		var previousBlock = secondDiv.previousSibling;
		if(previousBlock!=null){
			var hr = dojo.create("hr",null,previousBlock);
		}
		this.buildButtons(secondDiv);
		var tbl = dojo.create("table", null, secondDiv);
		var tbody = dojo.create("tbody", null, tbl);
		var propLength = chartPropertiesArray.length;
		for(var j=0;j<propLength;j++){
			this.buildChartForm(j, chartPropertiesArray, chartType, tbody, chartDefaultValues[j]);
		}
	},
	
	_exchangeBlock: function(block, refBlock,position){
		var temp = block.getAttribute("chartNumber");
		block.setAttribute("chartNumber",refBlock.getAttribute("chartNumber"));
		refBlock.setAttribute("chartNumber",temp);		
		dojo.place(block, refBlock, position);
	},
	
	_up: function(elm){
		var targetBlock = elm.parentNode.parentNode;
		if(targetBlock.getAttribute("chartNumber")!="1"){
			var refBlock = targetBlock.previousSibling;
			if(!targetBlock.nextSibling){
				var hr = dojo.create("hr",null,targetBlock);
				refBlock.removeChild(refBlock.lastChild);
			}
			this._exchangeBlock(targetBlock,refBlock,"before");
		}
	},
	
	_down: function(elm){
		var targetBlock = elm.parentNode.parentNode;
		if(targetBlock.nextSibling){
			var refBlock = targetBlock.nextSibling;
			if(!refBlock.nextSibling){
				var hr = dojo.create("hr",null,refBlock);
				targetBlock.removeChild(targetBlock.lastChild);
			}
			this._exchangeBlock(targetBlock,refBlock,"after");
		}
	},
	
	_delete: function(elm){
		var targetBlock = elm.parentNode.parentNode;
		var chartsDiv = targetBlock.parentNode;
		var targetChartNumber = targetBlock.getAttribute("chartNumber");
		if((targetBlock.nextSibling==null)&&(targetBlock.previousSibling!=null)){
			//for hr element
			targetBlock.previousSibling.removeChild(targetBlock.previousSibling.lastChild);
		}
		chartsDiv.removeChild(targetBlock);
		var childLength = chartsDiv.childNodes.length;
		for(var i = targetChartNumber; i<=childLength; i++){
			chartsDiv.childNodes[i-1].setAttribute("chartNumber",i);
		}
		dojo.disconnect(elm);
	},
	
	collectData: function(data) {
		if(!data || !data["names"] || !data["values"]) {
			data = { "names": [], "values": [] };
		}
		data = this.collectDataFromNode(data, this.configNode);
		data = this.collectChartsData(data, this.chartType);
		return data;
	},
	
	collectChartsData: function(data, chartType){
		var trs = dojo.query("tr", this[chartType+"Body"]);
		var chartNumber;
		
		trs.forEach(function(tr) {
			chartNumber = tr.parentNode.parentNode.parentNode.getAttribute("chartNumber");
			var td = tr.childNodes[1];
			data.names.push(chartType+chartNumber+"."+td.getAttribute("name"));
			
			var inputObj = td.firstChild.firstChild;
			data.values.push(inputObj.value);
		}, this);
		if(chartNumber==undefined){
			chartNumber=0;
		}
		return data;
	},
	
	destroy: function() {
		dojo.forEach(this.handlers, dojo.disconnect);
		this.inherited("destroy", arguments);
	},
	
	__dummy__: null	
});

}

if(!dojo._hasResource["widgets.customize.TopResultCharts"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.customize.TopResultCharts"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.customize.TopResultCharts");








dojo.declare(
"widgets.customize.TopResultCharts",
[widgets.customize._ChartsPane],
{
	widgetsInTemplate: true,
	templateString:"<div class=\"SearchApplicationCustomizePane TopResultChartsPane\" >\n\t<div style=\"width:98%;padding:5px;\">\n\t\t<div style=\"width:48%;float:left;\">\n\t\t\t<div>${messages_customizer_charts_topResults_header}:</div>\n\t\t\t<div dojoAttachPoint=\"addTopResultChartsButtonId\"></div>\n\t\t\t<div dojoAttachPoint=\"topResultsChartsBody\"></div>\n\t\t</div>\n\t\t<div style=\"width:48%;float:left;\">\n\t\t\t<div dojoAttachPoint=\"configNode\">\n\t\t\t\t<table>\n\t\t\t\t\t<tbody>\n\t\t\t\t\t\t<tr configkey=\"topResult.resultSize\" messagekey=\"topResult.resultSize\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" /></td></tr>\n\t\t\t\t\t</tbody>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</div>\n",

	topResultsChartsPropertiesArray : ["enable","titleKey","canUserChangeFieldName","fieldName",
	"fieldValueSeparator","maxValues.expanded","sortKey","sortOrder","open"],
	topResultsChartsDefaultValues:["true","","true","","","15", "frequency","descending","true"],
	
	messages_customizer_charts_topResults_header : EDR.messages.customizer_charts_topResults_header,
	
	constructor: function() {
		this.chartType = "topResultsCharts";
	},
	
	postCreate: function() {
		this.inherited(arguments);
	},
	
	initialize: function(json) {
		this.inherited(arguments);
		var addTopResultsChartsButton = new dijit.form.Button({label: EDR.messages.customizer_charts_topResults_button_label},this.addTopResultChartsButtonId);
    	this.handlers.push(dojo.connect(addTopResultsChartsButton,"onClick", this, "addChartsBlock"));
	},
	
	__dummy__: null	
});

}

if(!dojo._hasResource["widgets.customize.FacetCharts"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.customize.FacetCharts"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.customize.FacetCharts");








dojo.declare(
"widgets.customize.FacetCharts",
[widgets.customize._ChartsPane],
{
	widgetsInTemplate: true,
	templateString:"<div class=\"SearchApplicationCustomizePane facetChartsPane\" >\n\t<div style=\"width:98%;padding:5px;\">\n\t\t<div style=\"width:48%;float:left;\">\n\t\t\t<div>${messages_customizer_charts_facet_header}:</div>\n\t\t\t<div dojoAttachPoint=\"addFacetChartsButtonId\"></div>\n\t\t\t<div dojoAttachPoint=\"facetChartsBody\"></div>\n\t\t</div>\n\t\t<div style=\"width:48%;float:left;\">\n\t\t\t<div dojoAttachPoint=\"configNode\">\n\t\t\t\t<div>${messages_customizer_charts_facet_section1}:\n\t\t\t\t\t<table>\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr configkey=\"facetTree.enable\" messagekey=\"facetTree.enable\" configtype=\"bool\"><td></td><td><input dojoType=\"dijit.form.CheckBox\" value=\"\" /></td></tr>\n\t\t\t\t\t\t\t<tr configkey=\"facetTree.titleKey\" messagekey=\"facetTree.titleKey\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" /></td></tr>\n\t\t\t\t\t\t\t<tr configkey=\"facetTree.maxValues.default\" messagekey=\"facetTree.maxValues.default\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" /></td></tr>\n\t\t\t\t\t\t\t<tr configkey=\"facetTree.maxValues.all\" messagekey=\"facetTree.maxValues.all\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" /></td></tr>\n\t\t\t\t\t\t\t<tr configkey=\"facetTree.open\" messagekey=\"facetTree.open\" configtype=\"bool\"><td></td><td><input dojoType=\"dijit.form.CheckBox\" value=\"\" /></td></tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\t\t\t\t</div>\n\t\t\t\t<br />\n\t\t\t\t<div>${messages_customizer_charts_facet_section2}:\n\t\t\t\t\t<table>\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<tr configkey=\"documentLabelTree.enable\" messagekey=\"documentLabelTree.enable\" configtype=\"bool\"><td></td><td><input dojoType=\"dijit.form.CheckBox\" value=\"\" /></td></tr>\n\t\t\t\t\t\t\t<tr configkey=\"documentLabelTree.titleKey\" messagekey=\"documentLabelTree.titleKey\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" /></td></tr>\n\t\t\t\t\t\t\t<tr configkey=\"documentLabelTree.maxValues.default\" messagekey=\"documentLabelTree.maxValues.default\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" /></td></tr>\n\t\t\t\t\t\t\t<tr configkey=\"documentLabelTree.maxValues.all\" messagekey=\"documentLabelTree.maxValues.all\"><td></td><td><input type=\"text\" value=\"\" class=\"dijitComboBox\" /></td></tr>\n\t\t\t\t\t\t\t<tr configkey=\"documentLabelTree.open\" messagekey=\"documentLabelTree.open\" configtype=\"bool\"><td></td><td><input dojoType=\"dijit.form.CheckBox\" value=\"\" /></td></tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\t\t\t\t\t\n\t\t\t\t</div>\t\t\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</div>\n",

	facetChartsPropertiesArray : ["enable","titleKey","canUserChangeFacetName","facetName","maxValues.all","open"],
	facetChartsDefaultValues:["true","","true","","500","true"],

	messages_customizer_charts_facet_section1: EDR.messages.customizer_charts_facet_section1,
	messages_customizer_charts_facet_section2: EDR.messages.customizer_charts_facet_section2,
	messages_customizer_charts_facet_header : EDR.messages.customizer_charts_facet_header,
	
	constructor: function() {
		this.chartType = "facetCharts";
	},
	
	postCreate: function() {
		this.inherited(arguments);
	},
	
	initialize: function(json) {
		this.inherited(arguments);
    	var addFacetChartsButton = new dijit.form.Button({label: EDR.messages.customizer_charts_facet_button_label},this.addFacetChartsButtonId);
    	this.handlers.push(dojo.connect(addFacetChartsButton,"onClick", this, "addChartsBlock"));
	},
	
	__dummy__: null	
});

}

if(!dojo._hasResource["widgets.customize.TabWindow"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.customize.TabWindow"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.customize.TabWindow");



/*
 * widgets.customize.TabWindow
 * This class manages sub config pages.
 */
dojo.declare(
"widgets.customize.TabWindow",
widgets.TabWindow,
{
	testData: "",
	
	_configJson: null,
	
	_onDialogShow: function() {
	},
	
	initialize: function() {
		this._loadConfig();
		this._initializeConfigPanes();
	},
	
	_onDialogOk: function() {
	},
	
	_loadConfig: function() {
		var args = {
			url: "customize",
			handleAs: "json",
			load: dojo.hitch(this, "_onConfigLoad"),
			error: dojo.hitch(this, "_onConfigError"),
			timeout: dojo.hitch(this, "_onConfigTimeout")
		};
		if(this.testData) {
			args.url = this.testData;
		}
		dojo.xhrGet(args);
	},
	
	saveConfig: function(loadFunction, errorFunction, timeoutFunction) {
		var data = {};
		var children = this.getChildren();
		for(i=0; i<children.length; i++) {
			data = children[i].collectData(data);
		}
		var json = {};
		for(var i=0; i<data.names.length; i++) {
			json[data.names[i]] = data.values[i]; 
		}
		
		var args = {
				url: "customize",
				handleAs: "json",
				content: json,
				load: (loadFunction ? loadFunction : dojo.hitch(this, "_onConfigSave")),
				error: (errorFunction ? errorFunction : dojo.hitch(this, "_onConfigSaveError")),
				timeout: (timeoutFunction ? timeoutFunction : dojo.hitch(this, "_onConfigSaveTimeout"))				
			};
			dojo.xhrPost(args);		
	},
	
	_onConfigLoad: function(data) {
		var json = {};
		for(var i=0; i<data.names.length; i++) {
			json[data.names[i]] = data.values[i];
		}
		this._configJson = json;
		var children = this.getChildren();
		for(var i=0; i<children.length; i++) {
			var child = children[i];
			child.initialize(this._configJson);
		}
	},
	_onConfigError: function(data) {
		
	},
	_onConfigTimeout: function(data) {
		
	},
	
	_onConfigSave: function(data) {
	},
	_onConfigSaveError: function(data) {
	},
	_onConfigSaveTimeout: function(data) {
	},		
	
	_initializeConfigPanes: function() {
		
	},
	
	__dummy__: null
});

}

if(!dojo._hasResource["widgets.layout.BorderContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.layout.BorderContainer"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.layout.BorderContainer");



dojo.declare(
"widgets.layout.BorderContainer",
dijit.layout.BorderContainer,
{
	layout: function() {
		var parentNode = this.domNode.parentNode;
		var tablist = dojo.byId(EDR.prefix+"horizontalSearchPanes_tablist");
		
		var parentHeight = dojo.contentBox(parentNode).h;
		var tablistHeight = tablist?dojo.marginBox(tablist).h:0;
		var searchpane = dijit.byId(EDR.prefix+"horizontalSearchPanes");
		var toolbarHeight = 0;
		if(searchpane.resultToolbar){
			toolbarHeight = dojo.marginBox(searchpane.resultToolbar.domNode).h;
		}
		var bottomBarHeight = 0;
		if(searchpane.resultBottomBar){
			bottomBarHeight = dojo.marginBox(searchpane.resultBottomBar.domNode).h;
		}
		var height = parentHeight - tablistHeight - toolbarHeight - bottomBarHeight - 1;
		
		if(height < 0) {
			height = 0;
		}
		this.domNode.style.height = height + "px";
		
		this.inherited(arguments);
		
		var searchManager = dijit.byId(EDR.prefix+"searchManager");
		if(searchManager) {
			if (!searchManager.needNarrowResults())
				dojo.style(searchpane.centerContentPane.domNode,"left","0px");
		}
	},
	
	resize: function(){
		this.inherited(arguments);
		var resultsHeader = dijit.byId(EDR.prefix+"resultsHeader");
		var resultsBody = dojo.byId(EDR.prefix+"resultsBodyContainer");
		if((resultsHeader!=null)&&(resultsBody!=null)){
			var resultsHeaderHeight = dojo.marginBox(resultsHeader.domNode).h;
			var resultsPaneHeight = dojo.marginBox(dijit.byId(EDR.prefix+"horizontalSearchPanes").centerContentPane.domNode).h;
			dojo.marginBox(resultsBody,{h:(resultsPaneHeight-resultsHeaderHeight)});
		}
	}
});

}

if(!dojo._hasResource["widgets.CategoryTree"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.CategoryTree"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.CategoryTree");







dojo.declare(
	"widgets.CategoryTree", [widgets.FacetBase, dijit._Templated],
	{	
		prefix: EDR.prefix,
		widgetsInTemplate: true,
		templateString:"<div class=\"refinement\">\n\t<div dojoAttachPoint=\"facetTreeContainer\" style=\"overflow:hidden; padding:5px;\">\n\t\t<label for=\"${prefix}categoryTreeFilter\">${message_filter}:</label><br/>\n\t\t<input type=\"text\" style=\"width:150px;height:16px;\" title=\"${message_tooltip_filter}\"\n\t\t\tdojoAttachPoint=\"filterInput\" dojoAttachEvent=\"onkeyup: onFilterChanged\" id=\"${prefix}categoryTreeFilter\"></input>\n\t\t<div dojoType=\"widgets.Button\" title=\"${message_tooltip_clear}\" label=\"${message_clear}\"\n\t\t\tdojoAttachPoint=\"clearBtn\" dojoAttachEvent=\"onClick: onFilterClearClicked\"></div>\n\t\t<form dojoAttachPoint=\"facetForm\" style=\"overflow:hidden;\" onSubmit=\"return false;\">\n\t\t</form>\n\t</div>\n\t<div dojoAttachPoint=\"buttonContainer\" style=\"padding-top:7px;padding-left:5px;\">\n\t\t<form dojoAttachPoint=\"facetSearchForm\" onSubmit=\"return false;\">\n\t\t\t<div style=\"padding-left:2px;padding-bottom:4px;\">\n\t\t\t\t<label for=\"${prefix}categoryTreeSearchType\">${message_searchtype}:</label><br/>\n\t\t\t\t<select id=\"${prefix}categoryTreeSearchType\" name=\"searchType\" style=\"width:90%\" title=\"${message_tooltip_searchtype}\" dojoAttachPoint=\"searchType\" dojoAttachEvent=\"onchange: onSearchTypeChanged\">\n\t\t\t\t\t<option value=\"keywordSearch\">${message_keywordsearch}</option>\n\t\t\t\t\t<option value=\"facetSearch\">${message_subfacetsearch}</option>\n\t\t\t\t</select>\n\t\t\t</div>\n\t\t\t<div style=\"padding-left:2px;padding-bottom:4px;\">\n\t\t\t\t<label for=\"${prefix}searchFacetPath\">${message_facetpath}:</label><br/>\n\t\t\t\t<input dojoAttachPoint=\"pathInput\" title=\"${message_tooltip_facetpath}\" readonly=\"\" id=\"${prefix}searchFacetPath\" style=\"width:90%\" title=\"${message_facetpath}\" name=\"pathValue\"></input>\n\t\t\t</div>\n\t\t\t<div style=\"padding-left:2px;padding-bottom:4px;\">\n\t\t\t\t<label for=\"${prefix}searchFacetKeyword\">${message_keyword}:</label><br/>\n\t\t\t\t<input dojoAttachPoint=\"keywordInput\" title=\"${message_tooltip_keyword}\" id=\"${prefix}searchFacetKeyword\" style=\"width:90%\" title=\"${message_keyword}\" name=\"keywordValue\"></input>\n\t\t\t</div>\n\t\t\t<div style=\"padding-left:2px;padding-bottom:2px;\" role=\"radiogroup\">\n\t\t\t\t<div style=\"overflow:left;\">\n\t\t\t\t\t<input id=\"${prefix}categoryNewSearch\" dojoType=\"dijit.form.RadioButton\" title=\"${message_newsearch}\" name=\"queryType\"/>\n\t\t\t\t\t<label for=\"${prefix}categoryNewSearch\">${message_newsearch}</label>\n\t\t\t\t</div>\n\t\t\t\t<div style=\"overflow:left;\">\n\t\t\t\t\t<input id=\"${prefix}categoryRefineSearch\" dojoType=\"dijit.form.RadioButton\" title=\"${message_addsearch}\" checked=\"true\" name=\"queryType\"/>\n\t\t\t\t\t<label for=\"${prefix}categoryRefineSearch\">${message_addsearch}</label>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div dojoType=\"widgets.Button\" style=\"height:20px;\" label=\"${message_search}\" disabled=\"true\"\n\t\t\t\t\tdojoAttachPoint=\"categorySearchBtn\" dojoAttachEvent=\"onClick: onSearchButtonClicked\"></div>\n\t\t</form>\n\t</div>\t\n</div>\n",
		url: "",
		url2: "",
		timeout: 10000,
		
		showSelectionIcons: false,
		
		horizontalIcon: "column_d16.png",
		horizontalSelectedIcon: "column16.png",
		horizontalFacetImg: null,
		horizontalFacetLabel: null,
		horizontalFacetId: null,
		horizontalHasSubfacets: false,
		
		verticalIcon: "row_d16.png",
		verticalSelectedIcon: "row16.png",
		verticalFacetImg: null,
		verticalFacetLabel: null,
		verticalFacetId: null,
		verticalHasSubfacets: false,
		
		loaded: false,
		filterJson: null,
		json: null,
		
		sortType: "none",
		
		filterValue: "",
		prevFilterValue: "",
		filterEnabled: false,
				
		filterTimer: null,
		filterDuration: 500,
		treeItemWidth: 250,
		indentWidth: 15,
		defaultSize: 0,
		maxSize: 0,

		postCreate: function() {
			this.inherited("postCreate", arguments);
			dijit.setWaiRole(this.facetForm, "tree");
			
			dojo.subscribe("collectionChanged", this, "forceReload");
			dojo.subscribe("refresh", this, "refresh");
			dojo.subscribe("reset", this, "reset");
			dojo.subscribe("tabChanged", this, "onTabChanged");
			dojo.subscribe("verticalFacetChanged", this, "onFacetSearchStateChanged");
		},
		
		startup: function() {
			this.inherited(arguments);
			this._setTreeItemWidth();
			if (dojo.isIE <= 7) {
				this.clearBtn.adjustButtonWidth();
				this.categorySearchBtn.adjustButtonWidth();
				dojo.style(this.clearBtn.domNode, "position", "relative");
				dojo.style(this.clearBtn.domNode, "top", "4px");
			}
		},
		
		resize: function() {		
			this.layout();
		},
		
		layout: function() {
			this._setTreeItemWidth();
			
			dojo.forEach(dojo.query("div.refinement-group-ica", this.domNode), dojo.hitch(this, function(elem) {
				this._setRefGroupWidth(elem, elem.level);
			}));
			dojo.forEach(dojo.query("div.label-ica", this.domNode), dojo.hitch(this, function(elem) {
				this._setLabelWidth(elem, elem.level);
			}));
		},
				
		load: function() {
			var args = 	{ 
				url: this.url,
				showProgress: false,
				successCallback: dojo.hitch(this, function(response, ioArgs) {
					var json = null;
					try {
						json = dojo.fromJson(response);
					} catch (e) {
			        	this.loadErrorHandler(response, ioArgs);
			        	return;
					}
					this.clear();
					this.json = json;
					this.loadJson(json);	
					var activeTabId = dijit.byId(EDR.prefix+"horizontalSearchPanes").activeTabId;
					if (activeTabId != null && dijit.byId(activeTabId) != null && dijit.byId(activeTabId).hasHorizontalFacet) {
						this.enableSelectionIcons(true);
					}					
					this.postLoad();		
				}),
				afterErrorHandlerCallback: dojo.hitch(this, function(response, ioArgs) {
					this.loadErrorHandler(response, ioArgs);
				}),
				timeout: this.timeout
			};			
			this.preLoad();					
			EDR.ajax.Request.post(args);
		},
		
		loadFilteredCategories: function(filter) {
			var args = 	{ 
				url: this.url2,
				content: {
					filter: filter
				},
				showProgress: false,
				successCallback: dojo.hitch(this, function(response, ioArgs) {
					var json = null;
					try {
						json = dojo.fromJson(response);
					} catch (e) {
			        	this.loadErrorHandler(response, ioArgs);
			        	return;
					}
					this.clear();
					this.loadJson(json);	
					this.filterJson = json;
					this.postLoad();		
				}),
				afterErrorHandlerCallback: dojo.hitch(this, function(response, ioArgs) {
					this.loadErrorHandler(response, ioArgs);
				}),
				timeout: this.timeout
			};			
			this.preLoad();					
			EDR.ajax.Request.post(args);
		},
		
		loadChildren: function(parent, parentId, level, afterChildrenLoaded) {
			var args = 	{ 
				url: this.url,
				content: {
					parentId: parentId
				},
				showProgress: false,
				successCallback: dojo.hitch(this, function(response, ioArgs) {
					var json = null;
					try {
						json = dojo.fromJson(response);
					} catch (e) {
			        	this.loadErrorHandler(response, ioArgs);
			        	return;
					}
					this.loadJson(json, parent, level);	
					afterChildrenLoaded(json);					
				}),
				afterErrorHandlerCallback: dojo.hitch(this, function(response, ioArgs) {
					this.loadErrorHandler(response, ioArgs);
				}),
				timeout: this.timeout
			};			
			EDR.ajax.Request.post(args);
		},
		
		loadJson: function(json, parent, level) {
			this.loaded = true;
			if (json == null) json = [];
			if (json.length == 0 && parent == null) {
				this.facetForm.innerHTML = "<div style='padding:5px'></div>";
			} else {
				if (parent == null) {
					parent = this.facetForm;
					level = 0;
				}
				dojo.empty(parent);
				this.buildFacetGroups(json, parent, level);	
			}
		},
		
		isVisible: function() {
			return true;
		},
		
		refresh: function() {
			if (this.isVisible() && !this.loaded) this.load();
		},
		
		forceReload: function() {
			this.onFilterClearClicked();
			this.unselectAll();
		},
		
		unselectAll: function() {
			this.horizontalFacetImg = null;
			this.verticalFacetImg = null;
			this.horizontalFacetLabel = null;
			this.verticalFacetLabel = null;
			this.horizontalFacetId = null;
			this.verticalFacetId = null;
			
			dojo.publish("verticalFacetChanged", [{
				horizontalFacetLabel: "",
				horizontalFacetId: "",
				horizontalHasSubfacets: true,
				verticalFacetLabel: "",
				verticalFacetId: "",
				verticalHasSubfacets: true
			}]);
			dojo.publish("horizontalFacetChanged", [{
				horizontalFacetLabel: "",
				horizontalFacetId: "",
				horizontalHasSubfacets: true,
				verticalFacetLabel: "",
				verticalFacetId: "",
				verticalHasSubfacets: true
			}]);
			
			this.load();
		},
		
		clear: function() {
			dojo.forEach(this.handlers, dojo.disconnect);
			dojo.empty(this.facetForm);			
//			this.showSelectionIcons = false;
			this.horizontalFacetImg = null;
			this.verticalFacetImg = null;
		},
		
		reset: function() {			
			this.inherited(arguments);
		},
				
		loadErrorHandler: function(response) {},		
	
		preLoad: function() {
			this.filterInput.setAttribute("readonly", "");
			EDR.ajax.Loading.setIsLoading(this.domNode);
		},
	
		postLoad: function() {
			this.filterInput.removeAttribute("readonly");
			EDR.ajax.Loading.clearIsLoading(this.domNode);
		},
		
		loadErrorHandler: function(response) {
			this.filterInput.removeAttribute("readonly");
			EDR.ajax.Loading.clearIsLoading(this.domNode);
		},

		onFilterChanged: function(evt) {
			if (evt.keyCode == dojo.keys.TAB) return;
			
			if (this.filterTimer != null) {
				clearTimeout(this.filterTimer);
				this.filterTimer = null;
			}

		 	var filter = this.filterInput.value;
			if (this.prevFilterValue == filter) return;
			
		 	this.filterTimer = setTimeout(dojo.hitch(this, function() {
				this.prevFilterValue = filter;
		 		if (filter != null && filter.length != 0) {
					this.filterEnabled = true;
					this.filterValue = filter;
		 			this.loadFilteredCategories(filter);
		 		} else {
					this.filterEnabled = false;
					this.clear();
				 	this.loadJson(this.json);		 	
		 		}
		    }), this.filterDuration);
		},	
		
		onFilterClearClicked: function(evt) {
			this.filterEnabled = false;
		 	this.filterInput.value = "";
		 	this.prevFilterValue = "";
			this.clear();
		 	this.loadJson(this.json);		 	
		},
		
		onSortOrderChanged: function(value) {
			this.sortType = value;
			this.clear();
			if (this.filterEnabled) {
				this.loadJson(this.filterJson);
			} else {
				this.loadJson(this.json);
			}
		},
		
		onFacetClicked: function(evt) {
			if (evt.type != "click" && evt.keyCode != dojo.keys.ENTER && evt.charCode != dojo.keys.SPACE
				&& evt.keyCode != dojo.keys.LEFT_ARROW && evt.keyCode != dojo.keys.RIGHT_ARROW) return;
			
			var refTitle = evt.currentTarget.parentNode;
			var facetId = refTitle.facet.id;
			
			if (evt.type == "click" || (evt.keyCode === dojo.keys.ENTER || evt.charCode == dojo.keys.SPACE)) {
				if (facetId != this.verticalFacetId /*&& facetId != this.horizontalFacetId */) {
					var evt = { 
						currentTarget: refTitle.childNodes[1].childNodes[2],
						type: "click"
					};
					this.verticalFacetSelected(evt);
				}
			} else if (evt.keyCode == dojo.keys.RIGHT_ARROW) {
				if (refTitle.facet.hasChildren && !refTitle.facet.open) {
					var evt = { type: "click", currentTarget: refTitle.childNodes[1].firstChild };
					this.toggleFacetEventHandler(evt, false);					
				}
			} else if (evt.keyCode == dojo.keys.LEFT_ARROW) {
				if (refTitle.facet.hasChildren && refTitle.facet.open) {
					var evt = { type: "click", currentTarget: refTitle.childNodes[1].firstChild };
					this.toggleFacetEventHandler(evt, false);					
				}
			}
		},
		
		onTabChanged: function(evt) {
			var activeTabId = evt.activeTabId;
			var activeTabWidget = dijit.byId(activeTabId);
			this.enableSelectionIcons(activeTabWidget != null && activeTabWidget.hasHorizontalFacet);
		},
		
		onSearchButtonClicked: function(evt) {						
			var values = dojo.formToObject(this.facetSearchForm);
			var query = "";
			if (values.searchType == "keywordSearch") {
				if (values.keywordValue == null || values.keywordValue.length == 0) {
					EDR.util.alert(EDR.messages.analytics_categorytree_nokeyword);
					return;
				} else {
					query = "/\"keyword" + this.verticalFacetId + "\"/\"" + this._normalizeFacetValue(values.keywordValue) + "\"";
				}
			} else {			
				if (values.pathValue == null || values.pathValue.length == 0) {
					EDR.util.alert(EDR.messages.analytics_categorytree_nopath);
					return;
				} else {
					var paths = values.pathValue.split(".");
					if (paths == null || paths.length <= 1) {
						EDR.util.alert(EDR.messages.analytics_categorytree_nopath);
					}
					paths.pop();
					query = "/\"subcategory" + paths.join(".") + "\"/\"" + values.pathValue + "\"";
				}
			}
			if (query != null && query.length != 0) {
				var params = {keywords: query};
				var searchType = dijit.byId(EDR.prefix+"categoryRefineSearch").checked ?  "refineSearch" : "search";
				dijit.byId(EDR.prefix+"searchManager").submitSearch(null, searchType, params);
			}
		},
		
		onSearchTypeChanged: function(evt) {
			if (this.searchType.value == "keywordSearch") {
				this.keywordInput.removeAttribute("disabled");
			} else {
				this.keywordInput.setAttribute("disabled", "");
			}
		},
		
		onFacetSearchStateChanged: function(evt) {
			if (this.verticalFacetId == null || this.verticalFacetId.length == 0) {
				this.categorySearchBtn.setDisabled(true);
				this.pathInput.value = "";
			} else {
				this.categorySearchBtn.setDisabled(false);
				this.pathInput.value = this.verticalFacetId;
			}
		},
		
		enableSelectionIcons: function(enabled) {
			if (this.showSelectionIcons == enabled) return;
			dojo.forEach(dojo.query("img.vertical-category-img", this.domNode), dojo.hitch(this, function(elem) {
				dojo.style(elem, "visibility", enabled ? "visible" : "hidden");
				elem.parentNode.tabIndex = enabled ? "0" : "-1";
			}));
			dojo.forEach(dojo.query("img.horizontal-category-img", this.domNode), dojo.hitch(this, function(elem) {
				dojo.style(elem, "visibility", enabled ? "visible" : "hidden");
				elem.parentNode.tabIndex = enabled ? "0" : "-1";
			}));
			if (this.horizontalFacetImg != null) {
				var refTitle = this.horizontalFacetImg.parentNode.parentNode.parentNode;
				this.toggleSelectionClass(refTitle, enabled);
			}
			this.showSelectionIcons = enabled;
		},
		
		toggleSelectionClass: function(refTitle, selected) {
			if (selected) {
				dojo.addClass(refTitle.childNodes[0], "refinement-title-top-selected");
				dojo.addClass(refTitle, "refinement-title-ica-selected");
				dojo.addClass(refTitle.childNodes[2], "refinement-title-bottom-selected");
				dojo.removeClass(refTitle.childNodes[0], "refinement-title-top");
				dojo.removeClass(refTitle, "refinement-title-ica");
				dojo.removeClass(refTitle.childNodes[2], "refinement-title-bottom");
			} else {
				dojo.addClass(refTitle.childNodes[0], "refinement-title-top");
				dojo.addClass(refTitle, "refinement-title-ica");
				dojo.addClass(refTitle.childNodes[2], "refinement-title-bottom");
				dojo.removeClass(refTitle.childNodes[0], "refinement-title-top-selected");
				dojo.removeClass(refTitle, "refinement-title-ica-selected");
				dojo.removeClass(refTitle.childNodes[2], "refinement-title-bottom-selected");
			}
		},
		
		toggleFacetEventHandler: function(evt, force) { // evt.currentTarget == arrowContainer
			if (evt != null && evt.stopPropagation) evt.stopPropagation();
			if (evt.type != "click" && evt.keyCode != dojo.keys.ENTER && evt.charCode != dojo.keys.SPACE) return;
//			if (dojo.isIE) evt.currentTarget = evt.currentTarget.parentNode;

			var refTitle = evt.currentTarget.parentNode.parentNode;					
			var arrowImg = evt.currentTarget.firstChild;
			var label = evt.currentTarget.nextSibling;
			var refGroupList = refTitle.nextSibling;
			var level = refTitle.level + 1;
			var facetJson = refTitle.facet;

			if (refGroupList.style.display == 'none') {			
				facetJson.open = true;
				if (refGroupList.firstChild == null || force) {
					dojo.empty(refGroupList); // clear existing sub facet containers
					if (facetJson.facets != null && facetJson.facets.length != 0) {
						this.loadJson(facetJson.facets, refGroupList, level);	
						arrowImg.src = this.imgBasePath + "arrow_down8.png";
						setTimeout(function() {dojo.fx.wipeIn({node: refGroupList, duration: 300}).play();}, 0);
					} else {
						this.loadChildren(refGroupList, refTitle.facet.id, level, dojo.hitch(this, function(json) {
							facetJson.facets = json;
							arrowImg.src = this.imgBasePath + "arrow_down8.png";
							setTimeout(function() {dojo.fx.wipeIn({node: refGroupList, duration: 300}).play();}, 0);
						}));
					}
				} else {
					arrowImg.src = this.imgBasePath + "arrow_down8.png";
					setTimeout(function() {dojo.fx.wipeIn({node: refGroupList, duration: 300}).play();}, 0);
				}
				dijit.setWaiState(label, "expanded", "true");
			} else {
				arrowImg.src = this.imgBasePath + (this.isLeftToRight() ? "arrow_right8.png" : "arrow_left8.png");
				setTimeout(function() {dojo.fx.wipeOut({node: refGroupList, duration: 300}).play();}, 0);
				facetJson.open = false;
				dijit.setWaiState(label, "expanded", "false");
			}
		},
				
		verticalFacetSelected: function(evt) {
			if (evt != null && evt.stopPropagation) evt.stopPropagation();
			if (evt.type != "click" && evt.keyCode != dojo.keys.ENTER && evt.charCode != dojo.keys.SPACE) return;
//			if (dojo.isIE) evt.currentTarget = evt.currentTarget.parentNode;
			
			var refTitle = evt.currentTarget.parentNode.parentNode;;
			var img = evt.currentTarget.firstChild;
			var label = evt.currentTarget.previousSibling;
			var facetId = refTitle.facet.id;
			var facetLabel = refTitle.facet.label;
			var hasSubfacets = refTitle.facet.hasChildren;
			if (img.src.lastIndexOf(this.verticalSelectedIcon) == -1) {
			
				this.toggleSelectionClass(refTitle, true);		
				img.src = this.imgBasePath + this.verticalSelectedIcon;
				
				if (this.verticalFacetImg != null) {
					var prevLabel = this.verticalFacetImg.parentNode.previousSibling;
					this.toggleSelectionClass(this.verticalFacetImg.parentNode.parentNode.parentNode, false);
					this.verticalFacetImg.src = this.imgBasePath + this.verticalIcon;
					dijit.setWaiState(prevLabel, "selected", "false");			
				}
				
				this.verticalFacetLabel = facetLabel;
				this.verticalFacetId = facetId;
				this.verticalFacetImg = img;
				this.verticalHasSubfacets = hasSubfacets;
				dijit.setWaiState(label, "selected", "false");			
				
				dojo.publish("verticalFacetChanged", [{
					horizontalFacetLabel: this.horizontalFacetLabel,
					horizontalFacetId: this.horizontalFacetId,
					horizontalHasSubfacets: this.horizontalHasSubfacets,
					verticalFacetLabel: this.verticalFacetLabel,
					verticalFacetId: this.verticalFacetId,
					verticalHasSubfacets: this.verticalHasSubfacets
				}]);
			}
			return false;
		},

		setVerticalFacetId: function(vid) {
			this.verticalFacetId = vid;

			dojo.publish("verticalFacetChanged", [{
				horizontalFacetLabel: this.horizontalFacetLabel,
				horizontalFacetId: this.horizontalFacetId,
				horizontalHasSubfacets: this.horizontalHasSubfacets,
				verticalFacetLabel: this.verticalFacetLabel,
				verticalFacetId: this.verticalFacetId,
				verticalHasSubfacets: this.verticalHasSubfacets
			}]);
		},
		
		setHorizontalFacetId: function(hid) {
			this.horizontalFacetId = hid;
			
			dojo.publish("horizontalFacetChanged", [{
				horizontalFacetLabel: this.horizontalFacetLabel,
				horizontalFacetId: this.horizontalFacetId,
				horizontalHasSubfacets: this.horizontalHasSubfacets,
				verticalFacetLabel: this.verticalFacetLabel,
				verticalFacetId: this.verticalFacetId,
				verticalHasSubfacets: this.verticalHasSubfacets
			}]);
		},
		
		horizontalFacetSelected: function(evt) {
			if (evt != null && evt.stopPropagation) evt.stopPropagation();
			if (evt.type != "click" && evt.keyCode != dojo.keys.ENTER && evt.charCode != dojo.keys.SPACE) return;
//			if (dojo.isIE) evt.currentTarget = evt.currentTarget.parentNode;
			
			var refTitle = evt.currentTarget.parentNode.parentNode;;
			var img = evt.currentTarget.firstChild;
			var label = evt.currentTarget.previousSibling.previousSibling;
			var facetId = refTitle.facet.id;
			var facetLabel = refTitle.facet.label;
			var hasSubfacets = refTitle.facet.hasChildren;
			if (img.src.lastIndexOf(this.horizontalSelectedIcon) == -1) {
			
				this.toggleSelectionClass(refTitle, true);		
				img.src = this.imgBasePath + this.horizontalSelectedIcon;
				
				if (this.horizontalFacetImg != null) {
					var prevLabel = this.horizontalFacetImg.parentNode.previousSibling.previousSibling;
					this.horizontalFacetImg.src = this.imgBasePath + this.horizontalIcon;
					this.toggleSelectionClass(this.horizontalFacetImg.parentNode.parentNode.parentNode, false);
					dijit.setWaiState(prevLabel, "selected", "false");			
				}
				
				this.horizontalFacetLabel = facetLabel;
				this.horizontalFacetId = facetId;
				this.horizontalFacetImg = img;
				this.horizontalHasSubfacets = hasSubfacets;
				dijit.setWaiState(label, "selected", "true");
				
				dojo.publish("horizontalFacetChanged", [{
					horizontalFacetLabel: this.horizontalFacetLabel,
					horizontalFacetId: this.horizontalFacetId,
					horizontalHasSubfacets: this.horizontalHasSubfacets,
					verticalFacetLabel: this.verticalFacetLabel,
					verticalFacetId: this.verticalFacetId,
					verticalHasSubfacets: this.verticalHasSubfacets
				}]);
			}
			return false;
		},
		
		applyFacetFilter: function(filterValue) {
			if (filterValue == null || filterValue.length == 0) {
				dojo.forEach(dojo.query("div.refinement-group-ica", this.domNode), dojo.hitch(this, function(elem) {
					dojo.style(elem, "display", "block");
				}));
			} else {
				var regexp = dojo.data.util.filter.patternToRegExp("*" + filterValue + "*", true);			
				dojo.forEach(dojo.query("div.refinement-group-ica", this.domNode), dojo.hitch(this, function(elem) {
					var refTitle = elem.firstChild;
					var facetLabel = refTitle.facet.label;
					if (facetLabel.match(regexp)) {
						dojo.style(elem, "display", "block");
					} else {
						dojo.style(elem, "display", "none");
					}
				}));
			}
		},
		
		buildFacetGroups: function(facets, parent, level) {
			var self = this;
			if (parent == null) parent = this.facetForm;
			if (facets == null) return;
			
			var _facets = facets.concat([]);
			if (this.sortType == "ascending") {
				_facets.sort(function(a,b) { return a.label > b.label; });
			} else if (this.sortType == "descending") {
				_facets.sort(function(a,b) { return a.label < b.label; });
			}
			for (var i=0; i<_facets.length; i++) {
				parent.appendChild(this.buildFacetGroupElem(_facets[i], level));				
			}
		},
				
		buildFacetGroupElem: function(facet, level) {
			var refGroup = dojo.doc.createElement("DIV");
			refGroup.level = level;
			dojo.addClass(refGroup, "refinement-group-ica");
			this._setRefGroupWidth(refGroup, level);
			dojo.style(refGroup, "position", "relative");

			var refTitle = dojo.doc.createElement("DIV");
//			refTitle.setAttribute("tabIndex", 0);
			refTitle.title = dojo.string.substitute(EDR.messages.tooltip_facet_mine, [facet.label]);
			dojo.addClass(refTitle, "refinement-title-ica");
			refTitle.facet = facet;
			refTitle.level = level;

//			this.handlers.push(dojo.connect(refTitle, "onclick", this, this.onFacetClicked));
//			this.handlers.push(dojo.connect(refTitle, "onkeypress", this, this.onFacetClicked));
			
			var contentTop = dojo.doc.createElement("DIV");
			dojo.addClass(contentTop, "refinement-title-top");
			contentTop.innerHTML = "<div></div>";
			
			var contentBody = this.buildFacetGroupContentElem(facet, level);
			
			var contentBottom = dojo.doc.createElement("DIV");
			dojo.addClass(contentBottom, "refinement-title-bottom");
			contentBottom.innerHTML = "<div></div>";
			
			var refGroupList = dojo.doc.createElement("DIV");
			refGroupList.style.display = 'none';
			if (this.filterEnabled) {
				refGroupList.innerHTML = "<div></div>"; // dummy to prevent load children facets when filter is enabled
			}
						
			refTitle.appendChild(contentTop);
			refTitle.appendChild(contentBody);
			refTitle.appendChild(contentBottom);
			
			refGroup.appendChild(refTitle);
			refGroup.appendChild(refGroupList);
			
			if (facet.id == this.verticalFacetId) {
				var evt = { type: "click", currentTarget: contentBody.childNodes[2] };
				this.verticalFacetSelected(evt);
			} else if (this.showSelectionIcons && facet.id == this.horizontalFacetId) {
				var evt = { type: "click", currentTarget: contentBody.childNodes[3] };
				this.horizontalFacetSelected(evt);
			}
			if (facet.hasChildren && facet.facets != null && facet.facets.length != 0 && facet.open == true) {
				// this is filtered category tree case. Forcefully expand children
				var evt = { type: "click", currentTarget: contentBody.firstChild };
				this.toggleFacetEventHandler(evt, true);
			}
			
			return refGroup;
		},
		
		buildFacetGroupContentElem: function(facet, level) {
			var contentBody = dojo.doc.createElement("DIV");
			this.handlers.push(dojo.connect(contentBody, "onclick", this, this.onFacetClicked));
			this.handlers.push(dojo.connect(contentBody, "onkeypress", this, this.onFacetClicked));
			
			dojo.addClass(contentBody, "refinement-title-body-ica");
//			dojo.style(contentBody, "paddingLeft", this.indentWidth * level + "px");
//			dojo.style(contentBody, "paddingLeft", "3px");

//			var arrowLink = dojo.create("A", {href:"javascript:;"}, contentBody);			
			var arrowContainer = dojo.create("DIV", {className: "arrow-container"}, contentBody);

//			var arrowImg = dojo.create("IMG", {className: "arrow-img", src: this.imgBasePath + "arrow_right8.png"}, arrowLink);
			var arrowImg = dojo.create("IMG", {className: "arrow-img",
				src: this.imgBasePath + (this.isLeftToRight() ? "arrow_right8.png" : "arrow_left8.png")}, arrowContainer);
			
			if (facet.hasChildren) {
//				this.handlers.push(dojo.connect(arrowLink, "onclick", this, this.toggleFacetEventHandler));
//				this.handlers.push(dojo.connect(arrowLink, "onkeypress", this, this.toggleFacetEventHandler));
				this.handlers.push(dojo.connect(arrowContainer, "onclick", this, this.toggleFacetEventHandler));
				this.handlers.push(dojo.connect(arrowContainer, "onkeypress", this, this.toggleFacetEventHandler));
				//dojo.attr(arrowContainer, "tabIndex", "0");				
				dojo.attr(arrowContainer, "title", EDR.messages.tooltip_facet_expandcollapse);				
				dojo.attr(arrowImg, "alt", EDR.messages.tooltip_facet_expandcollapse);				
			} else {
				//dojo.attr(arrowContainer, "tabIndex", "-1");				
				dojo.style(arrowImg, "visibility", "hidden");
			}
						
			var label = dojo.doc.createElement("DIV");
			dojo.addClass(label, "label-ica");
			this._setLabelWidth(label, level);
//			dojo.style(label, this.isLeftToRight() ? "paddingLeft" : "paddingRight", "0px");
//			dojo.style(label, "float", this.isLeftToRight() ? "left" : "right");
			if (facet.match) dojo.style(label, "fontWeight", "bold");
			label.level = level;
			label.innerHTML = facet.label;			
			label.tabIndex = 0;
			dijit.setWaiRole(label, "treeitem");
			dijit.setWaiState(label, "expanded", "false");
			dijit.setWaiState(label, "selected", "false");			
			
			contentBody.appendChild(label);

			var vfacetLink = dojo.create("A", {href:"javascript:;"}, contentBody);
			var vfacetImg = dojo.create("IMG", {src:this.imgBasePath + this.verticalIcon, className:"vertical-category-img"}, vfacetLink);
			dojo.attr(vfacetImg, "title", EDR.messages.tooltip_2d_facet1);
			dojo.attr(vfacetImg, "alt", EDR.messages.tooltip_2d_facet1);
			this.handlers.push(dojo.connect(vfacetLink, "onclick", this, this.verticalFacetSelected));
			this.handlers.push(dojo.connect(vfacetLink, "onkeypress", this, this.verticalFacetSelected));
			
			var hfacetLink = dojo.create("A", {href:"javascript:;"}, contentBody);
			var hfacetImg = dojo.create("IMG", {src:this.imgBasePath + this.horizontalIcon, className:"horizontal-category-img"}, hfacetLink);
			dojo.attr(hfacetImg, "title", EDR.messages.tooltip_2d_facet2);
			dojo.attr(hfacetImg, "alt", EDR.messages.tooltip_2d_facet2);
			this.handlers.push(dojo.connect(hfacetLink, "onclick", this, this.horizontalFacetSelected));
			this.handlers.push(dojo.connect(hfacetLink, "onkeypress", this, this.horizontalFacetSelected));

			// show/hide 2dmap icons
			dojo.style(vfacetImg, "visibility", this.showSelectionIcons ? "visible" : "hidden");
			vfacetLink.tabIndex = this.showSelectionIcons ? "0" : "-1";
			dojo.style(hfacetImg, "visibility", this.showSelectionIcons ? "visible" : "hidden");
			hfacetLink.tabIndex = this.showSelectionIcons ? "0" : "-1";
			
			return contentBody;
		},
		
		_setTreeItemWidth: function() {
			this.treeItemWidth = dojo.contentBox(this.domNode).w - 5;
			if (this.treeItemWidth < 100) this.treeItemWidth = 100;
		},
		
		_setRefGroupWidth: function(refGroup, level) {
			dojo.style(refGroup, "width", (this.treeItemWidth - (this.indentWidth * level + 25)) + "px");
			if (level == 0) {
				dojo.style(refGroup, this.isLeftToRight() ? "left" : "right", 0 + "px");
			} else {
				dojo.style(refGroup, this.isLeftToRight() ? "left" : "right", this.indentWidth + "px");
			}
		},
		
		_setLabelWidth: function(label, level) {
			dojo.style(label, "width", this.treeItemWidth - (92 + level * this.indentWidth)+ "px");
		},
		
		_normalizeFacetValue: function(value) {
			var ret = "";
			for (var i=0; i<value.length; i++) {
				var c = value.charAt(i);
				if (c == '"') {
					ret += '\\"';
				} else if (c == '\\') {
					ret += '\\\\';
				} else {
					ret += c;
				}
			}
			return ret;
		},
		
		// messages
		message_filter: EDR.messages.facetsearch_filter,
		message_title: EDR.messages.facetsearch_dialog_title,
		message_facetlabel: EDR.messages.facetsearch_dialog_facetLabel,
		message_facetpath: EDR.messages.facetsearch_dialog_facetPath,
		message_keyword: EDR.messages.facetsearch_dialog_keyword,
		message_searchtype: EDR.messages.facetsearch_dialog_search_type,
		message_keywordsearch: EDR.messages.facetsearch_dialog_search_keyword,
		message_subfacetsearch: EDR.messages.facetsearch_dialog_search_subfacet,
		message_search: EDR.messages.button_search,
		message_cancel: EDR.messages.K0001I_COMMON_CANCEL,
		message_addsearch: EDR.messages.searchpane_addsearch,
		message_newsearch: EDR.messages.searchpane_newsearch,
		message_clear: EDR.messages.button_clear,
		message_tooltip_filter: EDR.messages.analytics_categorytree_filter_tooltip,
		message_tooltip_clear: EDR.messages.analytics_categorytree_clear_tooltip,
		message_tooltip_searchtype: EDR.messages.analytics_categorytree_searchtype_tooltip,
		message_tooltip_facetpath: EDR.messages.analytics_categorytree_facetpath_tooltip,
		message_tooltip_keyword: EDR.messages.analytics_categorytree_keyword_tooltip		
	}
);

}

if(!dojo._hasResource["widgets.layout.TabWindow"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.layout.TabWindow"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.layout.TabWindow");












// for Search/TextAnalytics basic layout using TabContainer and BorderLayout
dojo.declare(
"widgets.layout.TabWindow",
widgets.TabWindow,
{
	
	_childLoading: false,
	
	widgetsInTemplate: true,
	templateString: null,
	templateString:"<div class=\"dijitTabContainer\">\n\t<div dojoAttachPoint=\"tablistNode\"></div>\n\t<div dojoAttachPoint=\"tablistSpacer\" class=\"dijitTabSpacer ${baseClass}-spacer\"></div>\n\t\t\t<div dojoAttachPoint=\"resultToolbar\" dojoType=\"widgets.ResultToolbar\" class=\"email-toolbar-cp\" collectionsCount=\"1\"></div>\n\t\t\t<div dojoAttachPoint=\"resultBottomBar\" dojoType=\"widgets.ResultBottomBar\"></div>\n\n\t<div dojoAttachPoint=\"resultsBodyContainer\" dojoType=\"widgets.layout.BorderContainer\" dojoAttachPoint=\"clientArea\" style=\"width: 100%;\" gutters=\"false\">\n\t\t<div dojoAttachPoint=\"leftContentPane\" dojoType=\"dijit.layout.ContentPane\" region=\"leading\" splitter=\"true\" style=\"background-color: white; width: 265px;\">\n\t\t\t<div dojoAttachPoint=\"leftContainerNode\" style=\"width:100%;height:100%;padding:0px;\"></div>\n\t\t</div>\n\t\t<div dojoAttachPoint=\"centerContentPane\" dojoType=\"dijit.layout.ContentPane\" region=\"center\" style=\"overflow: hidden;\">\n\t\t\t<div class=\"${baseClass}-container\" dojoAttachPoint=\"containerNode\" style=\"overflow-x:auto; overflow-y: hidden; position: relative; width: 100%; height: 100%; padding: 0px;\"></div>\t\t\n\t\t</div>\n\t</div>\n</div>\n",
	_borderContainer: null,
	_isResultDisplay:false,
	
	handlers: [],
	
	startup: function() {
		this.inherited(arguments);
		
		// call startup functions for widgets which are under left pane
		dojo.forEach(dijit.findWidgets(this.leftContainerNode), function(widget) {
			if (widget.startup) widget.startup();
		});
	},
	
	// override
	_fillContent: function(source) {
		var leftPane = this.leftContainerNode;
		var rightPane = this.containerNode;
		if (source && leftPane && rightPane) {
			dojo.forEach(dojo.query("> DIV", source), function(div) {
				var dest = null;
				if (div.id == (EDR.prefix+"tabWindowLeftChildrenContainer")) {
					dest = leftPane;
				} else if (div.id == (EDR.prefix+"tabWindowRightChildrenContainer")) {
					dest = rightPane;
				}
				if (dest != null) {
					while(div.hasChildNodes()) {
						dest.appendChild(div.firstChild);
					}
				}
			});
		}
	},
	
	_hideChild: function(widget) {
		if (!this.transitioning) return;
		if (widget.onTabHide) widget.onTabHide();
		var button = this.tablist.pane2button[widget];
		if (button != null && dojo.hasClass(button.innerDiv, "tabActiveMiddle")) {
			this.toggleTabStyle(button);		
		}
		
		dojo.style(widget.domNode, "display", "none");
		
		if(widget["onHide"]) {
			widget.onHide();
			widget.isVisible = false;
		}
	},
	
	selectChild: function() {
//		if(this._childLoading) return;
		this.inherited(arguments);
	},
	
	_transition: function(){
		var tmp = this._containerContentBox;
		this._containerContentBox = dojo.contentBox(this.containerNode);
		this.inherited(arguments);
		this._containerContentBox = tmp;
	},
	
	_showChild: function(widget) {
		if (!this.transitioning) return;			
		this.activeTabId = widget.id;

		if (widget.onTabShow) widget.onTabShow();
		var button = this.tablist.pane2button[widget];
		if (button != null && dojo.hasClass(button.innerDiv, "tabInactiveMiddle")) {
			this.toggleTabStyle(button);
		}
		
		dojo.removeClass(widget.domNode, "dijitHidden");
		dojo.style(widget.domNode, "display", "block");
		
		if(widget["onShow"]) {
			widget.isVisible = true;
			widget.onShow();
		}
		
		//change Help URL
		var a = this.resultToolbar.eachTabHelp;
		a.onclick= dojo.hitch(this, function() {
			EDR.viewHelp(this._getHelpURL(widget.id)+".htm?noframes=true");	
		});
		if(!(this.activeTabId == (EDR.prefix+"documentViewId"))){
			this.containerNode.style.overflowX = "hidden";		
		}else{
			this.containerNode.style.overflowX = "auto";
			//adjust height of result's body when seleceted tab changed to document view
			this._borderContainer.resize();
		}
		dojo.publish("tabChanged", [{activeTabId:this.activeTabId}]);
	},
	
	postCreate: function() {
		this.inherited(arguments);		
//		this._borderContainer = this._supportingWidgets[0];		
		this._borderContainer = this._supportingWidgets[2];
		dojo.addOnLoad(dojo.hitch(this, "resize"));		
		
		dojo.style(this.tablist.domNode, "position", "relative");
		if(this.isLeftToRight()) {
			dojo.style(this.tablist.domNode, "left", "3px");	
		} else {
			dojo.style(this.tablist.domNode, "right", "3px");
		}
		
		this.hideResultDisplay();
		dojo.subscribe("postLoad", this, "applyChanges");
      dojo.subscribe("collectionChanged", this, "collectionChanged");
		
		var splitterPosition = this.isLeftToRight() ? "left" : "right"; 
		this.handlers.push(dojo.connect(this._borderContainer.getSplitter(splitterPosition), "_startDrag", this, "hideFlashPane"));
		this.handlers.push(dojo.connect(this._borderContainer.getSplitter(splitterPosition), "_stopDrag", this, "showFlashPane"));
	},
	
	hideFlashPane: function(){
		if(this.activeTabId != (EDR.prefix+"documentViewId")){
			widgets.analytics.hideAnalyticsPane();
			var container = dijit.byId(this.activeTabId).domNode;
			if(!EDR.isNoflash) {
				this.setIsLoading(container);
			}
		}else{
			//for resizing document pane
			this.layout();
		}
	},
	
	showFlashPane: function(){
		if(this.activeTabId != (EDR.prefix+"documentViewId")){
			var container = dijit.byId(this.activeTabId).domNode;
			if(!EDR.isNoflash) {
				this.clearIsLoading(container);
			}
			
//			widgets.analytics.showAnalyticsPane();
		}
		this.layout();
	},
	
    setIsLoading: function(div) {
       var targetDiv = div
       var loadingOverlay = dojo.query("div[class='resizingBackground']", targetDiv)[0];            
       if (!loadingOverlay) { // no overlay present
         // render an overlay to make the target div appear disabled.        
         var overlay = document.createElement("div");
         var pos = dojo.coords(targetDiv);
	     overlay.className = "resizingBackground";
	     overlay.style.position = "absolute";
	     overlay.style.left = pos.l;
	     overlay.style.top = pos.t;
	     overlay.style.width = pos.w + "px";
	     overlay.style.height = pos.h + "px";
	     overlay.style.zIndex = 100;
	     targetDiv.appendChild(overlay);
	     var busy = document.createElement("div");
	     busy.style.position = "absolute";
	     busy.style.left = (pos.w/2 - 25) + "px";
	     var heightOffset = pos.h == 0 ? 50 : pos.h;
	     busy.style.top = (heightOffset/2 - 10) + "px";
	     busy.innerHTML = EDR.messages.splash_resizing + "<img src=\""+EDR.config.imageBaseDir+"/status_indicator_20_slow.gif\" alt=\""+EDR.messages.splash_resizing+"\"/>";
	     busy.zIndex = 200;
	     overlay.appendChild(busy);
	     return overlay;
	   }
	   return loadingOverlay;
    },
    
    clearIsLoading: function(div) {      
      var targetDiv = div
      var loadingOverlay = dojo.query("div[class='resizeingBackground']", targetDiv)[0];
      if (loadingOverlay) {        
        targetDiv.removeChild(loadingOverlay);
      }
    },
	
	layout: function() {
		this._borderContainer.resize();
		
		var width = this._contentBox.w;
		dojo.style(this.tablist.domNode, "width", (width - 6) + "px");
		dojo.style(this.tablist.rightEdgeWindowDiv, "left", (width - 3) + "px");		
				
		var selected = this.selectedChildWidget;
		if(selected) {	
			dojo.style(selected.domNode, "width", "100%");
			dojo.style(selected.domNode, "height", "100%");
			if(selected.resize) {
				selected.resize();
			}
		}	
		// call startup functions for widgets which are under left pane
		dojo.forEach(dijit.findWidgets(this.leftContainerNode), function(widget) {
			if (widget.resize) widget.resize();
		});
		if(dojo.isIE <= 7) {
			this._borderContainer.resize();
			dojo.forEach(dijit.findWidgets(this.leftContainerNode), function(widget) {
				if (widget.resize) widget.resize();
			});
		}
		
		//for resizing outerWidth in document pane 
		var resultsHeaderTable = dijit.byId(EDR.prefix+"resultsHeader").searchResultsHeaderTable;
		if((this.activeTabId == (EDR.prefix+"documentViewId"))&&(dojo.contentBox(resultsHeaderTable).w>dojo.contentBox(dojo.byId(EDR.prefix+"documentViewId")).w)){
			dojo.contentBox(dojo.byId(EDR.prefix+"documentViewId"),{w:dojo.contentBox(resultsHeaderTable).w});
		}
	},
	
	hideResultDisplay: function(){
	   dojo.style(this.leftContainerNode, "visibility", "hidden");
		dojo.style(this._borderContainer.domNode,"visibility","hidden");
	},
	
	showResultDisplay: function(){
      dojo.style(this.leftContainerNode, "visibility", "visible");
		dojo.style(this._borderContainer.domNode,"visibility","visible");
	},
	
	applyChanges: function(){
		if(!this._isResultDisplay){
			this.showResultDisplay();
			this._isResultDisplay=true;
		}
	},
	
	collectionChanged: function() {
      if (EDR.isTextAnalyticsEnabled) return;
      this.hideResultDisplay();
      this._isResultDisplay=false;
	},
	
	_getHelpURL: function(activeWidgetId){
		if(activeWidgetId==(EDR.prefix+"documentViewId"))
			return "iiysutmdoc";
		else if(activeWidgetId==(EDR.prefix+"categoryViewId"))
			return "iiysutmfacet";
		else if(activeWidgetId==(EDR.prefix+"timeSeriesViewId"))
			return "iiysutmtime";
		else if(activeWidgetId==(EDR.prefix+"topicViewId"))
			return "iiysutmtopic";
		else if(activeWidgetId==(EDR.prefix+"deltaViewId"))
			return "iiysutmtrend";
		else if(activeWidgetId==(EDR.prefix+"twoDMapViewId"))
			return "iiysutm2dmap";
		else
			return "";
	},
	
	destroy: function() {
		dojo.forEach(this.handlers, dojo.disconnect);
		this.inherited("destroy", arguments);
	},
		
	__dummy__ : null
});

}

if(!dojo._hasResource["widgets.layout.DocumentsPane"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.layout.DocumentsPane"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.layout.DocumentsPane");



dojo.declare(
"widgets.layout.DocumentsPane",		
dijit.layout.ContentPane,
{
	activeIconPath: "",
	
	onShow: function() {
		var children = this.getChildren();
		for(var i=0; i<children.length; i++) {
			children[i].isVisible = true;
		}
		dijit.byId(EDR.prefix+"horizontalSearchPanes").resultToolbar.showDocumentButtons();
		dijit.byId(EDR.prefix+"resultsBody").refresh();
	},
	
	onHide: function() {
		dijit.byId(EDR.prefix+"horizontalSearchPanes").resultToolbar.hideDocumentButtons();
		var children = this.getChildren();
		for(var i=0; i<children.length; i++) {
			children[i].isVisible = false;
		}		
	},
	
	resize: function() {
		dijit.byId(EDR.prefix+"resultsHeader")._onResized();
		dijit.byId(EDR.prefix+"resultsBody")._onResized();
	}
});

}

if(!dojo._hasResource["widgets.FacetTypeAhead"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["widgets.FacetTypeAhead"] = true;
//*********************** ES COPYRIGHT START  *********************************
// @copyright(disclaimer)
// 
// Licensed Materials - Property of IBM
// 5724-Z21
// (C) Copyright IBM Corp. 2003, 2012
// 
// US Government Users Restricted Rights
// Use, duplication or disclosure restricted by GSA ADP Schedule
// Contract with IBM Corp.
// 
// DISCLAIMER OF WARRANTIES :
// 
// Permission is granted to copy and modify this Sample code, and to
// distribute modified versions provided that both the copyright
// notice, and this permission notice and warranty disclaimer appear
// in all copies and modified versions.
// 
// THIS SAMPLE CODE IS LICENSED TO YOU "AS-IS".
// IBM  AND ITS SUPPLIERS AND LICENSORS  DISCLAIM
// ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, IN SUCH SAMPLE CODE,
// INCLUDING THE WARRANTY OF NON-INFRINGEMENT AND THE IMPLIED WARRANTIES
// OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
// WILL IBM OR ITS LICENSORS OR SUPPLIERS BE LIABLE FOR ANY DAMAGES ARISING
// OUT OF THE USE OF  OR INABILITY TO USE THE SAMPLE CODE, DISTRIBUTION OF
// THE SAMPLE CODE, OR COMBINATION OF THE SAMPLE CODE WITH ANY OTHER CODE.
// IN NO EVENT SHALL IBM OR ITS LICENSORS AND SUPPLIERS BE LIABLE FOR ANY
// LOST REVENUE, LOST PROFITS OR DATA, OR FOR DIRECT, INDIRECT, SPECIAL,
// CONSEQUENTIAL,INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS
// OF THE THEORY OF LIABILITY, EVEN IF IBM OR ITS LICENSORS OR SUPPLIERS
// HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// 
// @endCopyright
//*********************** ES COPYRIGHT END  ***********************************
dojo.provide("widgets.FacetTypeAhead");
dojo.provide("widgets.TypeAhead");

dojo.declare(
	"widgets.FacetTypeAhead", [widgets.TypeAhead],
	{				
		maxSize: 15,
		
		getLoadParams: function(e, keyword) {
			var facetName = e.target.facetName;
			var facetPath = e.target.facetPath;
			var facetId = e.target.facetId;
			return {
				"facetFilter": keyword,
				"facetName": facetName,
				"facetPath": facetPath,
				"facetId": facetId, 
				"maxSize": this.maxSize
			};			
		}
	}
);

}

	
dojo.i18n._preloadLocalizations("dojo.nls.dojo", ["ROOT","ar","ca","cs","da","de","de-de","el","en","en-gb","en-us","es","es-es","fi","fi-fi","fr","fr-fr","he","he-il","hu","it","it-it","ja","ja-jp","ko","ko-kr","nl","nl-nl","no","pl","pt","pt-br","pt-pt","ru","sk","sl","sv","th","tr","xx","zh","zh-cn","zh-tw"]);


	if(dojo.config.afterOnLoad && dojo.isBrowser){
		//Dojo is being added to the page after page load, so just trigger
		//the init sequence after a timeout. Using a timeout so the rest of this
		//script gets evaluated properly. This work needs to happen after the
		//dojo.config.require work done in dojo._base.
		window.setTimeout(dojo._loadInit, 1000);
	}

})();

